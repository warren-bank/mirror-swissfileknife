<html><body>
<font face="verdana" size=2>

<font size=3><b>the way of sfk - command line text file processing</b></font>
<p>
<b>how to speed up your working process by use of the command shell, a set of batchfiles, and the swiss file knife.</b>
<p>
sfk is not just a tool, but an implementation of <i>working process principles</i>, namely:
<p>
<lu>
<li><a href="#realtime-search">realtime search and analysis of ASCII text files (usually sourcecode).</a>
<li><a href="#power-editing">power editing trough cluster files, trial and backup development.</a>
<li><a href="#dynamic-patching">dynamic source patching (how to make local changes permanent without ever checking in).</a>
<li><a href="#batch-files">structuring work by batchfiles.</a>
</lu>
<p>
which will be discussed here in a short overview. furthermore, this document contains
<p>
<lu>
<li><a href="#grep">sfk grep, detab, filter, run examples.</a>
<li><a href="#general-syntax">sfk general command syntax.</a>
<li><a href="#run-syntax">sfk run syntax.</a>
<li><a href="#patch-syntax">sfk patch syntax.</a>
<li><a href="#ftp">sfk instant ftp server.</a>
<li><a href="#win-ux">windows vs. linux syntax differences.</a>
</lu>
<p>
but first of all, let's talk about the command line principle, which is a prerequisite for using sfk efficiently.

<p>
<b>01: the shell-based working process</b>
<p>
The average developer is using some kind of integrated development environment (IDE). An IDE provides many comfortable features for <i>basic</i> tasks, and can be sufficient for small projects; but as soon as you need to <i>automatize</i> a couple of steps, especially massive file operations, it's getting complicated - if not impossible.
<p>
Therefore I will now talk about the <b>Windows (XP/NT/2K) Command Shell</b> (more about Unix shells later). If you shiver just by hearing this term, your only contact with the shell so far was probably this:
<p>
<font face="courier">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start Menu -> Run -> cmd.exe
</font>
<p>
By default, you get an uncomfortable, inefficient shell, about 80x25 characters, wide font, and without some important mouse support for text marking and insertion. Furthermore, just to open the shell via "Start Menu" is ways too complicated. So let's do some configuration:
<p>
<lu>
<li>create a shell desktop icon for immediate access. to do so, open Start Menu -> Programs -> Accessories, then right mouse button over the Command Prompt icon, select "copy". now left-click onto some empty space on the desktop, select "paste". a new icon appears.
<li>right-click on this icon, select the properties.
<li>layout: set screen buffer size: width 120, height 3000. this means, whatever text is listed, the shell will allow you to view the last 3000 lines, so no important outputs will get lost.
<li>layout: select window size: width 120, height 25. this tells how much of the buffer is displayed by default, it can be changed afterwards by resizing the window.
<li>options: activate QuickEdit Mode (and Insert Mode), if not done already. this essential option allows you to mark text in the shell eighter by free selection (keeping left button pressed) or by double-click (selecting a whole word), to copy this into clipboard by right button, and to insert clipboard content by right button (if nothing is marked up in the shell).
<li>font: select a more compact font size, I recommend "7x12".
<li>now select the Shortcut tab. extend the Target expression to<p>
<font face="courier">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%SystemRoot%\system32\cmd.exe /K c:\batch\init.bat
</font>
<p>which tells the shell to always run init.bat on startup.
<li>finally, close the shell properties, and create a directory and file "c:\batch\init.bat" with this content:<p>
<font face="courier">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set PATH=%PATH%;c:\batch
</font>
</lu>

<p>
<b>the efficient shell: first contact</b>
<p>
now double-click on the new icon. a shell window opens. at first, learn how to move quickly: few people may have noticed, but <b>command auto-completion</b> by pressing the TAB key has become a standard with the windows command shell. to enter the directory C:\batch, type this:
<p>
<font face="courier">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C:&nbsp;&nbsp;&nbsp;(+ENTER KEY)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd \&nbsp;&nbsp;&nbsp;(+ENTER KEY)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd ba
</font>
<p>and do NOT press ENTER after "ba", but simply press the TAB key. your command should be autocompleted to:
<p>
<font face="courier">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd batch
</font>
<p>and then you can press ENTER. if there happens to be another dir starting with "ba", e.g. "baba", you may get "cd baba" at first. don't mind, just press TAB again - sooner or later, "cd batch" will be listed.
<p>now, this isn't highly spectacular yet, but once you try to walk into a directory like
<p>
<font face="courier">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D:\work100\TheProject\BaseLib\CoreDriver\include\
</font>
<p>
it is a huge difference if you try to type the <i>whole</i> expression (including approx 3. typos and retries), or if you simply type:
<p>
<font face="courier">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd wo(TABKEY)\th(TABKEY)\ba(TABKEY)\(TABKEY)\(TABKEY)
</font>
<p>
note that you're not even required to type any word at all - for the last two parts of above expression, I just typed \ and then TABKEY already. this way, the shell simply lists the first directory (or file) available.
<p>
if your <b>window has no auto-completion</b>, you may be using an older Win2K, in which this feature is available, but not active by default. to activate, say
<p>
<font face="courier">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regedit<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;search HKEY_CURRENT_USER\Software\Microsoft\Command Processor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set CompletionChar to value 9<br>
</font>
<p>
from now, every new shell opened supports autocompletion. And about the unix users: well, most unix shells support autocompletion by default, and have a comfortable working layout, so there should be no configuration effort.
<p>
now, what do we have?
<p>
<lu>
<li>a shell in which we can navigate nearly as quick as in explorer.
<li>but we can also run every command-line tool instantly, just by typing it's name. of course we have to copy the tool into C:\batch first, or alternatively, we may extend the PATH in C:\batch\init.bat to include the tool.
<li>and we can extend our working environment anytime, by the creation of new batch files in C:\batch.
</lu>
<p>
First of all, download sfk, and copy <b>sfk.exe</b> and <b>sview.exe</b> (in case of windows) to C:\batch.
<p>
And from now on, <b>stay in the shell</b>. Whatever follows now, I expect that you have permanent command line access.

<a name="realtime-search">
<p>
<b>02: realtime search and analysis of sourcecode.</b> &nbsp;&nbsp;&nbsp; <a href="#top">back to top</a>
<p>
If you're working with thousands of source files, you often have to lookup something. This process is sped up massively by the creation of "snapfiles", for example:
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font face="courier"><b>sfk snapto=all-src.cpp -dir TheProject -file .c .h .cpp .hpp .xml</b></font>
<p>
This command collects all source files from the directory tree "TheProject" into one large text file, "all-src.cpp". Now you can load this file into your favourite text editor, and perform high-speed lookups accross all content, with less than 5 seconds per lookup on a current machine (Pentium IV etc.).
<p>
This principle can be optimized into <b>pingpong reverse tracking</b>:
<p>
<lu>
<li>you open the same snapfile in two windows (e.g. with the commercial text editor UltraEdit, use the command "Duplicate Window")
<li>then you arrange both windows parallel on the screen (UltraEdit: tile vertical)
<li>now, start searching something in the left window. once you're in a source spot of interest, you may want to lookup something else, e.g. a method name which is called from there.
<li>now simply change to the right window, and do your next search. this way you keep one eye on the original spot, and one on the next.
<li>now you may want to research a third term. ok, you only have two windows, so change back to the left, and search there again.
<li>therefore it's called ping-pong: you change between a left and right window, step by step proceeding through a huge source base.
<li>this principle is efficient with a snapfile only. if you were loading each local sourcefile one by one, you would soon end up with hundreths (thousands?) of opened windows, loosing any overview.
</lu>
<p>
Searching through a codebase this way, using an editor, is already somewhat fast, but it can get even faster. If you're working under windows, sfk provides another tool, called the <i>snap viewer</i>. On the command line, say
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font face="courier"><b>sview all-src.cpp</b></font>
<p>
The snapfile is loaded and displayed as read-only in a window. Now,
<p>
<lu>
<li>type whatever word you like - it is searched instantly, and sview jumps to the first hit automatically. To browse through all hits, use <i>mouse wheel down</i> or <i>SHIFT+CursorDown</i>.
<li>if you left-click on a word, it is SelectedAndSearched automatically. this can be very irritating for the unexperienced user - but remember, <i>snapview is optimized for searching</i>, and nothing else.
<li>if you right-click on a word, another view window is opened, and again the word is searched for instantly.
<li>sfk snapview displays a maximum of three viewers side by side.
<li>if you create further view windows (always by right mouse button), a new line of windows is started from the left.
<li>for all further howto's, press F8 in snapview, and read the help text.
</lu>
<p>
sfk snapview is optimized for <i>realtime searching</i> in huge snapfiles. case-insensitive lookups over 3 million lines of code take about 1.5 seconds on current machines (e.g., Pentium IV with 1 GB of RAM), case-sensitive lookups about 500 msec.

<a name="power-editing">
<p>
<b>03: power editing through cluster files.</b> &nbsp;&nbsp;&nbsp; <a href="#top">back to top</a>
<p>

"If I jam all those files together into a snapshot... why can't I change these contents directly in the snapshot?". An intriguing question indeed. To make this possible, sfk would have to
<p>
<lu>
<li>scan the snapshot file permanently for changes.
<li>isolate changes, write them back to the target files.
<li>scan all target files as well for changes, and if there are, re-integrate them into the snapshot.
</lu>
<p>
we cannot really do this with a huge snapshot containing the contents of thousands of files. the system would break down if we check a thousand files for a change each second... but in a smaller scale, it is possible. sfk calls this a <b>clusterfile</b>.
<p>
to create a clusterfile, first think a moment which files you actually need in there for editing. select a file tree with a maximum of 200 files approx., then don't use snapto, but:
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font face="courier"><b>sfk syncto=100-edit.cpp -dir TheProject/FooLib/CoreDriver -file .hpp .cpp</b></font>
<p>
why is it called syncto? sfk collects all source files from the mentioned directory into 100-edit.cpp, and then it doesn't exit, but continues to run in <i>sync mode</i>. in this mode, sfk does exactly what was mentioned above: check both the cluster (100-edit.cpp) as well as all target files for changes, and sync them either "down" (from cluster to targets) or "up" (from targets into cluster, if targets were changed directly).
<p>
now load the cluster into your favourite editor, have some really <b>global changes</b>, and select <i>save</i>. you will notice a short information popup listing all targets concerned by your change. the target contents are updated automatically. it's the same as if you were selecting a function like "replace in files" from a text editor, recursively in a file tree.
<p>
<b>up-syncing</b>
<p>
but what happens if you load one of the target files directly in your editor, change and save it?
<p>
<lu>
<li>sfk will detect the change, for example, in CoreLib.hpp.
<li>it loads CoreLib.hpp into memory, re-integrates the content, and writes a new 100-edit.cpp to disk.
<li>your text editor should now auto-detect that 100-edit.cpp was changed, and offer you to reload the file.
</lu>
<p>
<b>NOTE:</b> cluster editing should be used ONLY if your text editor is able of autodetecting changes in text files, and offers you to reload such files automatically!
<p>
you also get a short popup info from sfk, saying "RELOAD CLUSTER NOW".

<p>
<b>trial and backup development</b>
<p>
let's say, you integrated a new, cool feature into 100-edit.cpp, and it's working fine. before you integrate the next feature, make a save point of your work this way:
<p>
<lu>
<li>end sfk syncmode by pressing ESCAPE (or CTRL+C on unix).
<li>copy 100-edit.cpp 110-next.cpp
<li>sfk syncto=110-next.cpp
</lu>
<p>
this way, you create a new revision of your codebase. sfk is synced onto this new revision. drop 100-edit.cpp from your editor, load 110-next.cpp instead, and continue working.
<p>
now, you may jump back and forth between these revisions any time by stopping sfk, and re-syncing onto the other one. for example, if you changed lots of stuff in 110-next.cpp, but want to check again how 100-edit.cpp behaved, then
<p>
<lu>
<li>end sfk syncmode by pressing ESCAPE.
<li>sfk syncto=100-edit.cpp
</lu>
<p>
sfk will automatically do a <i>down-sync</i> by default, which means all content of 100-next.cpp is written out into the target files. after your test of this version, jump forward again through
<p>
<lu>
<li>end sfk syncmode by pressing ESCAPE.
<li>sfk syncto=110-next.cpp
</lu>
<p>
and, again, all target file content will be overwritten by the new code.
<p>
this is what i call <i>trial and backup development</i> - having both massive, global changes, but also a very easy and transparent local backup system.
<p>
<b>line number mapping</b>
<p>
so far, so fast - you warp over your sources, and change them in realtime. great! but once you compile, you may have to cope with compile errors, for example:
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font face="courier">CoreLib.cpp(6300) : error C2065: 'nCnt' : undeclared identifier</font>
<p>
unfortunately, the line number 6300 is not the line number in the cluster, but in a local target file. it must be mapped. to do so, write yourself a short compile batch like this:
<p>
<font face="courier">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;make yoursys.mak &gt;err.txt 2&gt;&amp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sfk mapto=110-next.cpp &lt;err.txt<br>
</font>
<p>
sfk will read the compiler's error messages from err.txt, parse through it, and whatever looks like a filename and line number is mapped into a cluster location, and listed.

<a name="dynamic-patching">
<p>
<b>04: dynamic source patching.</b> &nbsp;&nbsp;&nbsp; <a href="#top">back to top</a>
<p>

or: how to keep local changes, even across new codebases - without ever checking in.

<p>
the primary reason why you may need local, permanent code changes is <b>customizing the system</b> for your own needs. imagine your company is making a security software, and you are working on a component in this software which tries to read something from a file. now let's say, whenever you change anything in your code, you have to do this:
<p>
<ul>
<li>compile and link, start the system
<li>GUI appears, requiring authentication
<li>you enter some username and password
<li>from the software's menu system, you select File, Load Plugin, Certificate Manager
<li>a file requester pops up, you enter the name of some DLL
<li>the DLL is loaded and started
<li>another file requester pops up, you enter the name of a certificate file
<li>finally, your code is reached, and it tries to load the file.
</ul>
<p>
this whole process costs you about 60 seconds. even worse, it is boring and tiring, an extremely robotic, stupid task - but on every change in your code, you have to run through the whole process, again and again - 20 or 30 times a day.
<p>
if you're a real crack, you start thinking about <i>process optimization</i>. you investigate into the source, and soon you find the authentication module, with it's password check. with 3 lines of code, the check can be worked around. the same applies for the other stuff - with just a few lines of code, you manage to run the plugin loading and file selections fully automatically.
<p>
in other words, with a handfull of changes at the right places, your system runs fully automated to your point of interest. great!
<p>
of course you do <i>not</i> intend to check these changes in - they're <i>local optimization</i> just to improve <i>your</i> working process. and maybe you <i>cannot</i> check them in, even if you liked to, as you have no write access to these modules.
<p>
but a few days later, you may have to upgrade to a new codebase. you have to <i>sync</i> to the newest sources from the cvs depot, to get the latest features and fixes from your colleagues. and as you sync, your local changes get lost.
<p>
now, what do you do? on the new codebase, you insert your code optimizations again - from hand. you
<p>
<lu>
<li>open file by file
<li>search for a specific source line, or couple of lines. you do <i>not</i> jump to a <i>fixed line number</i>, because new code may have been inserted, and all line numbers are invalid now. instead, you <i>search for a source pattern</i>.
<li>then you replace it with a couple of other lines, a <i>replacement pattern</i>.
<li>then you save the file, and proceed to the next.
</lu>
<p>
and this is exactly what <b>sfk patch</b> does - fully automatized. instead of changing the target files directly, you write a patch script, or patch file. for example, c:\patch\comfort.hpp:
<br>
<table><tr><td width=50>&nbsp;</td><td>
<font face="courier" size="3"><pre>
:patch "working comfort optimization"

:info skip authentication, automatize plugin and cert file load

:root SecuFooBase

:file Base\Authentication\StartupManager.cpp
:from
   char szUser[100];
   char szPW[100];
   long lRC = showUserPWDialogue(szUser,100,szPW,100);
   if (lRC) { return 197; }
:to
   // [patch-id]
   char szUser[100];
   char szPW[100];
   // long lRC = showUserPWDialogue(szUser,100,szPW,100);
   // if (lRC) { return 197; }
   strcpy(szUser, "tester1");
   strcpy(szPW, "hello123");
:done

:file Base\GUIController\MainCore.cpp
:from
void CMainCore::showHelp()
:to
// [patch-id]
void autoRunFileLoad() {
   processUserMessage(eMsg_LoadPlugin, "d:\tmp\testplug.dll");
   processUserMessage(eMsg_Plugin+10 , "d:\tmp\testcert.x509");
}

void CMainCore::showHelp()
:from
   GUIMsg *pMsg;
   while (true) {
      pMsg = getNextUserInput();
:to
   autoRunFileLoad();

   GUIMsg *pMsg;
   while (true) {
      pMsg = getNextUserInput();
:done
</pre></font></td></tr></table>
<br>
In this example,
<p>
<ul>
<li>two files are loaded, StartupManager.cpp and MainCore.cpp
<li>in StartupManager, one code section is searched ("from" block) and replaced ("to" block).
<li>in MainCore, two code sections are replaced. for example, additional code is inserted in front of CMainCore::showHelp.
<li>be aware that every patched target file is marked with a string <b>[patch-id]</b>. if you write a patch file, you <b>must</b> insert this string in at least one "to" block. this way, sfk can identifiy already-patched files, and refuse to patch them again in case of user errors.
<li>the :root specifies a fixed directory from which the patch file must be called.
</ul>
<p>
Now, to actually patch the code, you have to
<ul>
<li>cd into the root directory:<p>
<b>cd SecuFooBase</b><p>
<li>then execute the patch file:<p>
<b>sfk patch c:\patch\comfort.hpp</b><p>
</ul>
<p>
Then sfk will load the patch file, load the target files, check if everything is OK, create backups of the targets, and actually apply the patch.
<p>
You may also <b>revoke</b> the patch anytime by saying:<br>
&nbsp;&nbsp;&nbsp;<b>sfk patch c:\patch\comfort.hpp -revoke</b>
<p>
And if you change the patchfile itself, i.e. you rework your patch, you may revoke and re-apply it in one step by saying:<br>
&nbsp;&nbsp;&nbsp;<b>sfk patch c:\patch\comfort.hpp -redo</b>
<p>
sfk patching is called <b>dynamic</b> because it adapts to changing codebases. for example, as long as the code line "void CMainCore::showHelp()" itself is not changed, the insertion of "autoRunFileLoad" will work, even if MainCore.cpp is completely reworked many times. patch tools using line numbers are not that flexible.
<p>
One word of <b>WARNING</b>: dynamic patching is a powerful mechanism - you can use it for all kinds of stuff, for example getting rid of tracing spam from other colleagues, or doing a total "source conversion", e.g. for improvements of the tracing system. But always take great care that you do <b>NOT CHECK IN PATCHED FILES</b>. It's also for your own security that every patched file contains the string <b>[patch-id]</b>. If you use patches regularly, always have a quick check that <b>[patch-id] appears nowhere in the source you're about to check in</b>.
<p>

<a name="batch-files">
<p>
<b>05: structuring work by batch files.</b> &nbsp;&nbsp;&nbsp; <a href="#top">back to top</a>
<p>
the following batch file examples should be placed within c:\batch.
<br>
<font face="courier" size="3"><pre>
<b>ec.bat</b> - edit command
notepad c:\batch\%1.bat

   usage example: to create another batch "jamsrc.bat",
   you now simply type "ec jamsrc". of course, replace "notepad"
   by your favourite text editor. (say "ec init" first, then extend
   the PATH to c:\program files\your editor, or whereever it's located).

<b>e.bat</b> - edit a file in the text editor
@echo off
"c:\program files\your favourite text editor\theEditor.exe" %1

   usage example: this is not so much a batch, but an <i>alias</i> -
   it reduces typing effort. for example, if I'm using UltraEdit,
   I never type "ultraedit mysource.cpp". I may use this command -
   running the editor - about 200 times a day, so it's inacceptable
   to always type more than 1 character for this essential function.
   instead, I say "e mysource.cpp". a trivial, primitive trick -
   but still not obvious for many people, therefore I'm mentioning it.

<b>jamsrc.bat</b> - collect contents of local source tree
sfk snapto=all-src.cpp -dir . !save_ -file .cpp .c .hpp .h .xml .cfg !all-head !all-src

   usage example: whereever you are within the source base,
   just type "jamsrc" to create a local source collection.

<b>setcur.bat</b> - set current working directory
set VCURRENT=proj%1

   usage example: structure your work by giving different code bases
   different numbers. e.g., the first codebase you get from cvs may be
   be called <b>100</b>, residing under the work directory <b>proj100</b>.
   a few days later, you fetch the latest sources in another new directory,
   <b>proj101</b>, and so on. this way you can quickly switch back and forth
   between proven code and fresh code.

<b>jamsrc2.bat</b> - collect contents of whole current working dir
@ECHO off
IF "%VCURRENT%"=="" goto xend
sfk snapto=C:\%VCURRENT%\all-src.cpp -dir C:\%VCURRENT% !\save_ -file .cpp .c .hpp .h .xml !all-head !all-src
dir C:\%VCURRENT% /S /B >C:\%VCURRENT%\lslr
:xend

   usage example: whereever you are within the source base,
   just type "jamsrc" to re-create the global source collection.
   this collection is then available under c:\proj100\all-src.cpp
   (if your current codebase number is 100.)

<b>vall.bat</b> - view whole content of working dir in sfk snapview
@ECHO off
IF "%VCURRENT%"=="" goto xend
sview C:\%VCURRENT%\all-src.cpp
:xend

   usage example: provided that you ran jamsrc2 at least once,
   type "vall" anytime to perform instant searches across everything.

<b>do-check-all.bat</b> - check if patches can be applied, or are still valid
@echo off
IF "%1"=="" goto err01
IF "%VCURRENT%"=="" goto xend
cd C:\%VCURRENT%
IF "%1"=="pre" (
sfk run "sfk patch $pfile -sim -qs" -quiet -norec c:\patch .hpp
) ELSE (
sfk run "sfk patch $pfile -verify -qs" -quiet -norec c:\patch .hpp
)
goto xend
:err01
echo supply pre or post
:xend

   usage example: this batch expects that all your patch files
   are located in c:\patch and have a file type ".hpp".

   if you say "do-check-all pre", all patches are checked against
   the codebase, and sfk tells if the source patterns match, i.e.
   if the patches might be inserted, if you liked to do so.
   so it's a pre-check before doing the actual patching.

   however, if you have patched the code already, and synced to
   a new cvs codebase, you may say "do-check-all post" anytime
   to check if the applied patches are still intact.

<b>do-patch-all.bat</b> - apply all patches to the codebase
@echo off
IF "%VCURRENT%"=="" goto xend
C:
cd \%VCURRENT%
echo === applying to codebase ===
sfk run "sfk patch -qs $pfile" -quiet -norec c:\patch .hpp
:xend

   usage example: whenever you get a new codebase from cvs,
   you want to apply all your patches from c:\patch to it.
   let's say the new codebase is proj110, then you say

      setcur 110
      do-check-all pre
      do-patch-all

<b>do-revoke-all.bat</b> - undo all patches
@echo off
IF "%VCURRENT%"=="" goto xend
C:
cd \%VCURRENT%
echo === revoking all patches ===
sfk run "sfk patch -revoke -qs $pfile" -quiet -norec c:\patch .hpp
:xend

   usage example: you may have traced and analyzed the code enough
   by the aid of self-written patches - and now you actually want
   to change and check-in some code parts, which are within files
   also changed by patching. then you must first revoke the patches,
   before you can checkout for edit.

<b>erw.bat</b> - edit as read-write
@echo off
attrib -R %1
notepad %1

   usage example: whenever you check out from cvs, the stuff is
   read-only by default. so, if you want to apply some quick local changes,
   you have to "attrib -R" so often that it makes sense to provide
   this within another small batch. so simply say "erw foobar.cpp"
   to edit foorbar.cpp, even if it's readonly.

</pre></font>

<p>

<a name="grep">
<p>
<b>06: sfk text processing primitives.</b> &nbsp;&nbsp;&nbsp; <a href="#top">back to top</a>
<p>
<font face="courier" size="3"><pre>
<b>examples: search for a string in all files of a dir tree</b>

   sfk grep mystring
   sfk grep mystring -dir . -file .hpp .cpp

<b>examples: remove all tabs from source files</b>

   sfk detab=3 . .hpp .cpp
   sfk detab=4 -dir . -file .h .cpp

<b>example: filter all file paths containing FooSys but not CoreLib</b>

   sfk list | sfk filter -+FooSys -!CoreLib

<b>examples: run a command on all .cpp files of the dir tree</b>

   sfk run "mything.exe $pfile" -dir . -file .cpp
   sfk run "mything.exe $qfile" . .cpp

for the syntax of all commands, type "sfk" in the command shell.
now follows a dump of the current help text.

<hr> <a name="general-syntax">
usage:
   sfk snapto=outfile [-pure] [-prefix=str] [-norec] dir mask [mask2] [...]
       collect many files into one large text file.
       pure: don't insert filenames. prefix: insert str before every block.
       norec: do not recurse into subdirs. stat: show time stats at end.
       wrap=n: auto-wrap long lines near column n, e.g. -wrap=80
          sfk snapto=all-src.cpp -prefix=!$! . .cpp .hpp
          sfk snapto=all-src.cpp -prefix=!$! -dir src1 src2 -file .cpp .hpp .xml
   sfk syncto=dbfile dir mask [!mask2]
       gather files into one large editable clusterfile.
       changes in the cluster are written back to sourcefiles automatically.
       changes in the source files are synced into the cluster automatically.
          sfk syncto=cluster.cpp . .cpp .hpp
   sfk syncto=dbfile [-up]
       reuse an existing clusterfile.
       on start, by default, cluster diffs are written to the sourcefiles.
       on start, with -up, sourcefile diffs are written into the cluster.
          sfk syncto=cluster.cpp
   sfk syncto=dbfile -from=myconfig.sfk
       read command line parameters from config file, e.g.
          -dir
             foosys\bar1\include
             foosys\bar1\source
             !save_patch
          -file
             .cpp .hpp
   mapping of compiler error output line numbers:
       make yoursys.mak &amp;gt;err.txt 2&amp;gt;&amp;1
       sfk mapto=yourcluster.cpp [-nomix] [-cmd=...] &lt;err.txt
          nomix: list only the mapped output lines. cmd: on first mapped line,
          call supplied command, with clustername and line as parameters.

   sfk patch [...]
       dynamic source file patching. type "sfk patch" for help.

   sfk detab=tabsize dir mask [!mask2]
       replace tabs by spaces within file(s).
          sfk detab=3 . .cpp .hpp
          sfk detab=3 singleFileName.txt
   sfk scantab dir mask [!mask2]
       check if files contain tabs.
          sfk scantab -dir src1 src2 -file .cpp .hpp
   sfk lf-to-crlf or crlf-to-lf
       just like detab, for CRLF conversion
   sfk text-join-lines infile outfile
       for text with lines split by email reformatting.
   sfk stat [-minsize=mb] [dir] [-i]
       show directory size statistics in mbytes.
       minsize: list only dirs and files &gt;= minsize mbytes.
       -i: read list of files and directories from stdin.
          sfk stat -minsize=10m
          type dirlist.txt | sfk stat -quiet -i
   sfk list [-twinscan] dir [mask]
       plain listing of files within dir.
       twinscan: list only identical files, if any.
          sfk list -dir src1 -file .cpp -dir src2 -file .hpp
   sfk grep [-pat] pattern [pattern2] [-dir] [dir1] [mask1] ...
       very simple, case-insensitive pattern search for text files.
       only lines containing all patterns are listed.
          sfk grep mytext . .hpp
          sfk grep -pat text1 text2 -dir src1 src2 -file .cpp .hpp
   sfk bin-to-src [-pack] infile outfile
       create sourcefile containing a binary object
          sfk bin-to-src myimg.dat imgsrc.cpp
   sfk filter &lt;input &gt;output [-lnum] [-c] -+orpat [++andpat] [-!nopat] [...]
       filter lines from standard input, case-insensitive.
       -+   this pattern MAY be  part of a result line
       -+   this pattern MAY be start of a result line
       ++   this pattern MUST be  part of a result line
       +ls+ this pattern MUST be start of a result line
       -!   this pattern must NOT be  part of a result line
       -ls! this pattern must NOT be start of a result line
       -no-empty-lines removes all empty lines from stream
       -lnum preceed all result lines by input line number
       -c   compare case-sensitive (not default)
          anyprog | sfk filter -+mypat -!otherpat
   sfk addhead &lt;in &gt;out [-noblank] string1 string2 ...
   sfk addtail &lt;in &gt;out [-noblank] string1 string2 ...
       add string(s) at start or end of lines.
       with noblank specified, does not add blank char.

   sfk md5gento=outfile dir mask [mask2] [!mask3] [...]
   sfk md5gento=outfile -dir dir1 dir2 -file mask1 mask2 !mask3 [...]
       create list of md5 checksums over all files.
          sfk md5gento=md5.dat . *
   sfk md5check=infile [-skip=n] [-skip n]
       verify list of md5 checksums. to speed up verifys by spot checking,
       specify -skip=n: after every checked file, n files will be skipped.
          sfk md5check=md5.dat

   sfk run "your command $file [$relfile] [...]" [-quiet] [-sim]
       run self-defined command on files or directories.
       type "sfk run" for help.

   sfk freezeto=targetdir [-quiet] -dir src1 -copy|zip
       copy or freeze all or updated files from src to target,
       using the external commands xcopy and zip.
       !dirname excludes directory "dirname".
       option -quiet avoids listing every single zip or xcopy call.
       NOTE: as everything else, freezeto comes WITHOUT ANY WARRANTY.
       -&gt; Always have a manual check afterwards if your most important
          files are really contained within the backup archives!
       -&gt; Test read your backup media on different drives and machines!
       -&gt; Test restoring of your backups from time to time!

   sfk inst [...]
       instrument c++ source code with calls to micro tracing kernel.
       type "sfk inst" for help.

   sfk reflist [-abs] [-wide] -dir tdir -file .text -dir sdir -file .sext
       find file references and dependencies. "sfk reflist" for help.

   general option -norec avoids recursion into subdirectories.
   general option -quiet shows less output on some commands.

<hr> <a name="run-syntax">
sfk run "your command $file [$relfile] [...]" [-quiet] [-sim] [...]

    run a self-defined command on every file- or directory name.
    within your command string, you may specify:

       $quotfile    or $qfile  - insert filename with path and "" quotes.
       $purefile    or $pfile  - insert filename with path and NO quotes.
       $quotrelfile or $qrfile - insert relative filename without path.
       $quotbase    or $qbase  - the relative base filename, without extension.
       $quotext     or $qext   - filename extension. foo.bar.txt has extension .txt.
       $quotpath    or $qpath  - the path (directory) without filename.
       also valid: $purerelfile, $prfile, $purebase, $pbase, $pureext, $pext,
                   $purepath, $ppath.

    if you supply only path expressions, only directories will be processed.
    option -ifiles allows processing of a filename  list from stdin.
    option -idirs  allows processing of a directory list from stdin.
    on stdin, '#' remark lines and empty lines are skipped.
    note that "sfk.exe &lt;list.txt" supports max. 4 KB for list.txt under windows.
    note that "type list.txt | sfk.exe" supports unlimited stream length.

    NOTE: always think a moment 1) if your filenames may contain BLANKS, and
          2) if and where to use quoted or non-quoted (pure) expressions.
          if you combine things, you may often have to use 'p'ure forms
          embraced by slightly complicated \" quotes like this:
             sfk run "ren \"$pbase.$pext\" \"$pbase-old.$pext\"" testfiles
          in any way, have a -sim run first to simulate what may happen.

       sfk run "attrib -R $qfile" -quiet testfiles\FooBank\BarDriver
       sfk run "&lt;img src=$quotfile&gt;" -dir . -file .jpg -sim &gt;index.html
       sfk run "xcopy $qpath \"G:\$ppath\" /S /H /I /R /K /Y /D" -dir sources
       type dirlist.txt | sfk run -idirs "xcopy \"x:\$ppath\" \"z:\$ppath\" /I /D"

<hr> <a name="patch-syntax">
usage: sfk patch [-revoke|-redo] yourpatchfile.cpp

without any options supplied, sfk patch
   - runs the patchfile.
   - makes backups of the specified target files.
   - patches the specified target files.

options supported:
   -revoke: undo all patches.
            this simply copies all backups back over the targets.
            NOTE: targets are TOUCHED afterwards (current date/time set)
                  to enforce proper recompile. use -keepdates to avoid.
   -redo  : undo all patches and then re-apply patches.
            best used whenever you change the patchfile itself,
            to have your changes updated in the target files.
   -exact-match: by default, leading whitespaces are ignored.
                 use this option enforce exact 1:1 line matching.
   -keep-dates: by default, revoked files get touched.
                use this option enforce original file date.
   -sim   : simulate what the patch would do, don't change anything.
   -qs    : quick summary, just tell a one-line status.
   -stats : show statistics of select-replace usage.
   -verify: check if an applied patch is still intact.

patchfile rules:
- patches are executed extactly in the order as given in the file.
- each FROM/TO statement is executed exactly ONCE.
- if ANY of the FROM/TO statements doesn't match the input,
  the whole file is NOT patched.
- if ANY of the FROM/TO statements doesn't match the input,
  the whole file is NOT patched.
- in the first TO for a new target file, include the word [patch-id]
  by using a comment in the target file's syntax, e.g. in C++: // [patch-id]
  this marks the file as being patched -&gt; sfk will not patch it again.

it is recommended that your patchfiles have the ending .cpp
to enable syntax highlighting with most text editors.

patchfile example, containing all supported patchfile commands:

:patch "fix method types for local use"
:info auto-adapt return types

:root foosrc

:file include\Foobar.hpp
:from 
    bool                  isAvailable               ( UInt8 );
:to
    UInt8                 isAvailable               ( UInt8 ); // [patch-id]
:from 
    UInt16                getAppType                ( UInt8 );
:to
    UInt32                getAppType                ( UInt8 );
:done

:# this is a remark, allowed only outside :file blocks.
:file include\Another.cpp
:select-replace /lineSelectPattern/from/to/
:select-replace /MY_TRACE(/\n"/"/
:set only-lf-output
:from 
    bool                  existsFile                ( UInt8 );
:to
    // [patch-id]
    UInt8                 existsFile                ( UInt8 );
:done

:mkdir sources
:create sources\MyOwnFix.hpp
#define OTHER_SYMBOL MY_OWN_SYMBOL
:done

:skip-begin
this is outcommented stuff. the skip-end is optional.
:skip-end
</pre></font>
<hr> <a name="ftp">
<br>
<b>SFK instant ftp server, and client </b> &nbsp;&nbsp;&nbsp; <a href="#top">back to top</a>
<p>
Why an ftp server? because
<ul>
<li>far too often, connecting two machines is a configuration nightmare, and ftp is the only thing working.
<li>to exchange files with other colleagues, sometimes ftp is even easier then a temporary exchange folder on the network.
</ul>
<p>
Anyway, just say "sfk ftpserv" on one machine, e.g. yourpc, and you have an instant ftp server - no installation, no configuration, no nothing. Then, on the other machine, say "ftp yourpc". You get instant read access to the directory where sfk ftpserv is running in.
<p>
FTP is a slightly complicated protocol, creating an extra connection for every file transfer. This mechanism may fail sometimes, due to firewall problems. In this case, using "sfk ftp yourpc" may help: the sfk client is detecting an sfk server, and uses an easier transfer protocol. Furthermore, a different port may be specified.
<p>
For example, I actually need sfk ftp everytime I want to compile the linux version of sfk. my linux is running on the same machine as windows, under vmware; from linux, I can ping to my host system, and I can even connect to the IP address using ftp. But with a normal ftp client, I can NOT transfer any files. All data connections are blocked due to reasons (windows service pack, network config, firewall...) I will <i>not</i> invest any further time to find out. Instead, I use "sfk ftp ipnumber get src.zip", and after compilation, I say "sfk ftp ipnumber put sfk-linux" to write the result back to the host.
<p>
SFK ftpserv is very simple, and only <b>one user can connect at a time</b>. I.e. if you're connecting with two clients to the same server, you will be blocked until the 1st connection times out. If you need more power, download and install a full ftp server like filezilla.
<p>
<font face="courier" size="3"><pre>
sfk ftpserv [-h[elp]] [-port=nport] [-rw] [-maxsize=n]

   creates an instant ftp server to enable easy file transfer.
   * the CURRENT DIRECTORY is made accessible, without subdirs.
   * any kind of directory traversal (.., / etc.) is blocked.
   * just ONE CLIENT (browser etc.) can connect at a time.
   * after 30 seconds of inactivity, the connection is closed.
   port: use other port than default, e.g. -port=30199.
   rw  : allow read+write access. default is readonly.
   maxsize: increment size limit per file write to n mbytes.

   NOTE: be aware that ANYONE may connect to your server.
         with -rw specified, ANYONE may also write large files.
         if this is a problem, do NOT use sfk ftpserv, but download
         and install a full-scale ftp server like filezilla.

   if you login to the server using a regular ftp client, but you cannot
   transfer any files, it's usually a firewall vs. ftp protocol problem.
   in this case, the sfk ftp client may help. type "sfk ftp" for info.

sfk ftp host[:port] put|get filename

   simple anonymous ftp client. if connected to sfk server,
   this uses sfk/sft protocol, requiring fewer connections.

      sfk ftp farpc put test.zip
         send test.zip to farpc

      sfk ftp 192.168.1.99:30199 get test.zip
         receive test.zip from 192.168.1.99 port 30199

      sfk ftp hostname
         enter interactive mode, supporting commands:
            dir, get filename, put filename.

</pre></font>

<hr> <a name="win-ux">
<p>
<b>sfk windows vs. sfk linux: syntax differences</b>
<p>
the syntax of all commands listed above is for the windows version of sfk. under linux (and all other unix systems), the bash is making problems with several characters, especially ! and $.
<p>
therefore, sfk linux uses these replacements:
<p>
<ul>
<li>the exclusion-char ! is replaced by :
<li>the run pattern identifier $ is replaced by #
</ul>
<p>
for the correct unix syntax of all commands, type "sfk" under linux.

<p>
<a href="#top">back to top</a>
<br>&nbsp;<br>

</font>
</body></html>
