
sfk: working practices by examples
==================================

this is a more detailed addition to readme.txt.


use case 01: adding features to project FooBank
-----------------------------------------------

imagine FooBank is checked into some cvs. you're working locally
within some dir "work100", and just checked out the project into there.
so you have the files:

   work100\BaseLib\Trace\include\Trace.hpp
   work100\FooBank\BarDriver\include\BarBottle.hpp
   work100\FooBank\BarDriver\include\BarDriver.hpp
   work100\FooBank\BarDriver\include\BarGlass.hpp
   work100\FooBank\BarDriver\include\BarMug.hpp
   work100\FooBank\BarDriver\source\BarBottle.cpp
   work100\FooBank\BarDriver\source\BarDriver.cpp
   work100\FooBank\BarDriver\source\BarGlass.cpp
   work100\FooBank\BarDriver\source\BarMug.cpp
   work100\FooBank\DB\include\DBController.hpp
   work100\FooBank\DB\source\DBController.cpp
   work100\FooBank\GUI\include\FooGUI.hpp
   work100\FooBank\GUI\source\FooGUI.cpp
   
now you want to rework all files of BarDriver, with a massive change
concerning all files. as an example, you want to derive all classes
from bar driver from some new "BarObject". of course you also create
a new file "BarObject.". step by step:

01 check out / open for edit the whole BarDriver tree from cvs.
02 cd work100
03 sfk syncto=100-bar-from-depot.cpp -dir FooBank\BarDriver -file .hpp .cpp

   what you now hold in 100-bar-from-depot is a COPY FROM CVS.
   save this point so that you may jump back later. to do so,

04 exit sfk by pressing ESCAPE
05 copy 100-bar-from-depot.cpp 110-bar-add-barobject.cpp

   and why do we prefix all filenames by a number? to speed up working
   through command line autocomplete. let's say your editor is "edit",
   then you type this
   
      edit 110{TAB}
   
   and this is instantly expanded to 
   
      edit 110-bar-add-barobject.cpp
   
06 by the way, have you fully configured your Windows Command Line environment?
   depending on the system you're using (Win2K, WinXP) autocomplete may not
   be active. to activate it manually, use
   
      regedit
         HKEY_CURRENT_USER\Software\Microsoft\Command Processor
            => set CompletionChar to value 9
   
   furthermore, set the layout of your command prompt like this:

      properties
         Edit Options
            QuickEdit Mode ACTIVE
            Insert Mode ACTIVE
   
      properties
         layout
            screen buffer size
               width: 160
               height: 3000
            window size
               width: 160
               height: 31
   
   now you have a power shell with 3000 lines of scrollback - essential
   for effective working. i also recommend a 7 x 12 raster font.
   
   anyway, we did copy a source snapshot, and will now start editing.
   in the following, replace "edit" by your favourite editor command.

   first restart sfk syncing, but now on the new file:

07 sfk syncto=110-bar-add-barobject.cpp

08 open another command shell, place the sfk shell to the top of screen.
   so you always have two shells:
   -  in the upper you see sfk status infos
   -  in the lower, you're editing and compiling.

09 edit 110-bar-add-barobject.cpp

   you now see the cluster. it contains this index:

   :# ----- 8 target files -----
   :edit FooBank\BarDriver\include\BarBottle.hpp
   :edit FooBank\BarDriver\include\BarDriver.hpp
   :edit FooBank\BarDriver\include\BarGlass.hpp
   :edit FooBank\BarDriver\include\BarMug.hpp
   :edit FooBank\BarDriver\source\BarBottle.cpp
   :edit FooBank\BarDriver\source\BarDriver.cpp
   :edit FooBank\BarDriver\source\BarGlass.cpp
   :edit FooBank\BarDriver\source\BarMug.cpp
   :# ----- target index end -----

10 you may now go through the cluster source and apply global changes
   of this kind

      from: class BarBottle
      to  : class BarBottle : public BarObject

   as soon as you select SAVE within your editor, sfk auto-syncs
   your changes into all the above listed files.

   now, the class BarObject itself is still missing.
   create 2 new files

      FooBank\BarDriver\include\BarObject.hpp
      FooBank\BarDriver\source\BarObject.cpp

   with some code in it. to add these to the cluster,

11 expand the above index section in the editor this way:

   :# ----- 8 target files -----
   :edit FooBank\BarDriver\include\BarBottle.hpp
   :edit FooBank\BarDriver\include\BarDriver.hpp
   :edit FooBank\BarDriver\include\BarGlass.hpp
   :edit FooBank\BarDriver\include\BarMug.hpp
   :edit FooBank\BarDriver\source\BarBottle.cpp
   :edit FooBank\BarDriver\source\BarDriver.cpp
   :edit FooBank\BarDriver\source\BarGlass.cpp
   :edit FooBank\BarDriver\source\BarMug.cpp
   :edit FooBank\BarDriver\include\BarObject.hpp
   :edit FooBank\BarDriver\source\BarObject.cpp 
   :# ----- target index end -----

   as you see, new files are always added at the end.
   select SAVE in your editor - sfk will integrate
   the new files into the cluster, and ask you to reload it:

12 to reload the cluster, you may have to click into any
   window not being the editor (or the desktop, or the editor's
   iconified window in the task bar), and then again
   on the editor window. at least with ultraedit, you're now 
   asked automatically if the editor may reload the cluster.

13 now go the end of the cluster - you see contents were added.
 
   exceptions: if you do NOT a request to reload the cluster,
   something went wrong, e.g. a typo in the index section.
   then have a look into the sfk shell area. files it cannot load
   are simply ignored until the index section is fixed by you.

14 compile your code. you may get an error like

      BarGlass.cpp line 15: wrong syntax

   now, if you want to jump to that line directly, you cannot
   do this within the cluster - line numbers are different there.

   so what to do? you may edit barglass.cpp directly

15 edit FooBank\BarDriver\source\BarGlass.cpp

   and apply some changes, then select SAVE in your editor.
   -  sfk will autodetect that BarGlass.cpp was changed.
   -  the file is reintegrated into the cluster.
   -  you get a request to reload the cluster.

   as long as you're changing just and only BarGlass.cpp,
   simply ignore the cluster reload requests (maybe drop
   the cluster temporarily from your editor).

   as soon as BarGlass.cpp fully compiles, reload the cluster
   and continue working there.

   in general,
   -  editing the cluster is best for massive global changes.
   -  but when it comes to compiling, you may be better off
      by editing the target files directly.

15.2 automatic line number mapping

   since sfk 1.0.2, you may also have your compiler output
   parsed directly and error line numbers mapped to the cluster.
   to do so, write a batch, e.g. do-compile.bat:

      make FooBank.make 1>err.txt 2>&1
      sfk mapto=110-bar-add-barobject.cpp <err.txt

   this will
      -  write the compiler stdout and stderr to err.txt
         (depending on your compiler, just stderr "2>err.txt"
         might be sufficient)
      -  then, sfk reads from err.txt and
         -  searches for filenames and nearby numbers
         -  searches for matching filenames in the cluster
         -  re-calculates the line numbers
         -  dumps the input (err.txt) mixed with the mapping results
            to the console. you may also tell sfk to dump only
            the mapping results by specifying -nomix.

15.3 automatically jump into the editor, to the first error

   since sfk 1.0.3, you may add another option to "mapto",
   telling sfk to execute a command with the first identified error.

      make FooBank.make 1>err.txt 2>&1
      sfk mapto=110-bar-add-barobject.cpp -cmd=c:\tools\jumpline.ahk <err.txt

   this will run the script "jumpline.ahk" with two parameters,
   the cluster name 110-bar-add-barobject.cpp and the line number of the 
   first error identified in the compiler output.

   now, if you download and install the AutoHotkey GUI automation tool,
   and provide a script "c:\tools\jumpline.ahk" with this content:

      nErrFile = %1%
      nErrLine = %2%
      IfWinExist,YourEditor
      {
         WinActivate,YourEditor,,2
         WinWaitActive,YourEditor,,2
         WinMenuSelectItem,YourEditor,,Search,Goto Line
         WinWaitActive,Goto,,2
         Send,%nErrLine%{ENTER}
         WinWaitActive,YourEditor,,2
         Send,{HOME}{UP}+{DOWN}+{DOWN}+{DOWN}
      }

   then the following will happen automatically:
   on the first compile error encountered,

      -  the window of your editor is activated.
      -  the menu command "Search / Goto Line" is selected.
      -  the line number is entered.
      -  three lines of context are marked.

   of course you have to adapt the script to the name
   and menu structure of your favourite text editor.

   now, back to the working process. feature completed, what next?
   if you don't want to check in yet, create a savepoint:

16 copy 110-bar-add-barobject.cpp 120-bar-next.cpp

   now continue adding the next code.
   if this code turns out to work fatally wrong, jump back
   to the 110 cluster this way:

17 jumping back to 110-bar-add-barobject.cpp

   -  exit sfk by pressing ESCAPE

   -  you may not want to work on 110 directly, as you don't want
      to modify this savepoint. so make a copy from it, e.g.

      copy 110-bar-add-barobject.cpp 130-bar-retry.cpp

   -  then re-sync to this through

         sfk syncto=130-bar-retry.cpp

      with this syntax, sfk automatically
         -  loads 130-bar-retry.cpp
         -  writes all contents to the targets without
            considering any file dates (forced DOWN SYNC)
         -  of course all target files must still be writeable
            to allow this.



use case 02: power handling huge parallel codebases
---------------------------------------------------

imagine a project BigBank is checked into cvs, with more than 10,000
source files. you have five versions of it on your local PC under:

   d:\work150\BigBank\...
   d:\work151\BigBank\...
   d:\work152\BigBank\...
   d:\work160\BigBank\...
   d:\work170\BigBank\...

and you want to be able to jump between these versions anytime.
in the following examples, you keep all your batch files in O:\batch
and of course have O:\batch in your PATH.


   setting up base batches

10 create a file O:\batch\setcurbank.bat

      @echo off
      echo >O:\batch\setcur.bat set VCURRENT=work%1\BigBank
      call O:\tools\bin\setcur.bat

   create a file O:\batch\cdcur.bat

      @echo off
      IF "%VCURRENT%"=="" goto xend
      d:
      cd \%VCURRENT%
      :xend

   now, to select a specific codebase, e.g. 152, you say

      setcurbank 152
      cdcur

   and afterwards, e.g. after opening new shells, just

      setcur
      cdcur

   in both cases you're landing within d:\work152\BigBank

  

20 setting up source collector batches

   create a file O:\batch\jamsrc2.bat

      @ECHO off
      IF "%VCURRENT%"=="" goto xend
      sfk snapto=D:\%VCURRENT%\all-src.cpp -dir D:\%VCURRENT% !\save_patch\ -file .cpp .c .hpp .h .xml
      dir D:\%VCURRENT% /S /B >D:\%VCURRENT%\lslr
      :xend

   create a file O:\batch\jamsrc.bat

      @ECHO off
      IF "%VCURRENT%"=="" goto xend
      sfk snapto=all-src.cpp -dir . !save_patch\ -file .cpp .c .hpp .h .xml
      :xend

   create a file O:\batch\eall.bat

      @echo off
      IF EXIST D:\%VCURRENT%\all-src.cpp (
         edit D:\%VCURRENT%\all-src.cpp
      ) ELSE (
         echo "you forgot to jamsrc2"
      )

21 (re)creating the global snapfile

   now, no matter where you are within the file work152 file tree,
   just say

      jamsrc2

   and a GLOBAL snapfile containing ALL 10,000 source files of the project
   will be created. on a pentium IV system, this may take between 30 sec
   and a few minutes. when this is done,

22 loading the global snapfile
   just type

      eall

   and your editor loads the global snapfile of your current codebase
   (takes about 5 sec for a 100 mbyte file using ultraedit).

23 creating a local snapfile

   often, you only want an overview of sources within a local path.
   e.g. you're within BigBank\CoreDriver\HAL and want to read
   through all files from this point on.
   then just say

      jamsrc

   and a local snapfile under HAL\ is created. then

      edit all-src.cpp

   and there you have it.


24 search for class declarations in the global snapfile

   create a file O:\batch\getclass.bat

      @IF "%VCURRENT%"=="" goto xend
      sfk filter -lnum -c <D:\%VCURRENT%\all-src.cpp "+ls+class " ++%1 "-!;"
      :xend

   then, whenever you need to lookup a class you haven't heard of before,
   type for example

      getclass CVirtualCurrencyLayer

   and you will get a listing of line-numbers and class names.
   an experienced developer will quickly identify the relevant line.
   now,
   -  in the shell, mark the relevant line number through double-click;
      (requires Edit Mode active, see use case 01, point 05)
   -  enter your editor
   -  select GO TO LINE NUMBER
   -  press SHIFT+INSERT

   this way you quickly jump to any class declaration, even in codebases
   with millions of lines.



use case 03: backups, creating durable archives
-----------------------------------------------

creating backups that make sense is not at all simple.
let's say,

-  you have between 6 and 8 GBytes of data to backup.
   the only existing media for this are DVD or streamer.
   you probably have no streamer, so you're forced to use DVD.

-  you want to place all your data onto a single DVD.
   this would require compression to fit into 4 GBytes.

-  you heave read many reports that DVD's in general are unreliable
   and not at all a good medium for long-lasting archives.
   but again, you have nothing else...

   -> so you'll be forced to check your DVD backups from time to time
      to see if they are still readable.

now about the compression point:

-  if you simply zip everything into a single large archive,
   you may get the required compression. but if, some day,
   just one single byte of the dvd fails to read, the whole
   zip archive might be lost. so the risk of a single,
   large super-archive is too high.

-  if you don't zip anything at all, just copy your thousands
   of files as they are onto DVD, it's of course the safest way.
   but:

   -  you loose all compression.

   -  if you try to READ the archive DVD, you will notice
      that copying the whole DVD back onto your harddrive 
      may take 6 to 10 hours (!) simply because reading
      many small files from DVD takes much, much longer
      than reading some larger files (slow access times
      versus bulk transfer times). and do you want to wait
      6 hours to verify a DVD if it's still readable?

sfk "freezeto" tries to solve this problem by a technique i call
"decentralized compression".

for example, your daily working data comprises these dirs:

   D:\development
   D:\pictures
   D:\audio
   D:\mail
   D:\accounting

to create an sfk durable archive from this, you need

   -  a "mirror" directory, ideally on a different partition,
      and this ideally on a different physical disk,
      for performance reasons. in the following example,
      i take a mirror directory:

         Z:\zmirrord

      which must have as much empty space as all data from D:

   -  the command XCOPY.EXE must be in your path.

   -  the command ZIP.EXE must be in your path.
      ZIP.EXE is provided by the InfoZIP group on sourceforge.net.

   -  the tool UNZIP.EXE must be in a well-defined location.
      in the following example, we expect it is located under

         C:\tools\unzip.exe

   -  the tool SFK.EXE must be in a well-defined location.
      in the following example, we expect it is located under

         C:\tools\sfk.exe

now create an sfk command script.
create a file C:\batch\mirror-d-to-z.sfk

   -dir development  -zip
   -dir pictures     -zip
   -dir audio        -zip
   -dir mail         -zip
   -dir accounting   -zip

create a file C:\batch\do-mirror-d-to-z.bat
 
   D:
   cd \
   mkdir Z:\zmirrord
   sfk freezeto=Z:\zmirrord -from=C:\batch\mirror-d-to-z.sfk

the "02-tools" stuff will be explained later.
if you run this batch now,

1. sfk scans through all directory trees listed in the .sfk script
   and transfers the data to the target dir ( Z:\zmirrord\ )

2. within the target dir, for every single SUB-directory,
   sfk creates a zip.
   example: if your pictures directory looks like

      pictures\home\
      pictures\winter\
      pictures\summer\
      pictures\holiday\usa\

   then sfk doesn't simply create one "pictures.zip", but

      pictures\home\01-arc.zip
      pictures\winter\01-arc.zip
      pictures\summer\01-arc.zip
      pictures\holiday\usa\01-arc.zip

   and that's what i call "decentralized compression".
   so you end up with hundreds of middle-sized zip files -
   a compromise between data safety and DVD access speed,
   including full compression.

3. of course, just zipping is not enough. how do you get the data
   out of all those zip's later if you need the backup?

   take a closer look - sfk also created some files within Z:\mirrord\ :

      01-content.txt    - plain listing of all original filenames
      03-md5-arc.txt    - checksums of all zip archives
      04-verify-arc.bat - batch for zip archive verification
      05-unpack-arc.bat - batch for extracting the zip archives
      06-md5-org.txt    - checksums of all original files
      07-verify-org.bat - batch for original file verification
      08-dir-times.txt  - sfk internal timestamps

   and the batch "05-unpack-arc.bat" does the job of re-creating
   all files later if you need the backup.

   NOTE: this batch strictly requires the tool "02-tools\unzip.exe"
   so please verify that your batch (do-mirror-d-to-z) really
   created Z:\zmirrord\02-tools\unzip.exe

   if so, you may

4. burn the whole content of Z:\zmirrord\ to DVD.
   make sure the directory name "zmirrord" is NOT included on the DVD,
   i.e. the DVD root directory should look like

      01-content.txt
      03-md5-arc.txt
      04-verify-arc.bat
      05-unpack-arc.bat
      06-md5-org.txt
      07-verify-org.bat
      08-dir-times.txt
      development
      pictures   
      audio      
      mail       
      accounting 
      
5. RESTORING AN ARCHIVE

   for example, if your D: drive crashes, replace the harddisk, then

   -  copy the whole backup DVD content onto D:\

   -  run 05-unpack-arc.bat

      and wait. after a while, your files will be recreated.
   
      DISCLAIMER: please NOTE that neither i nor the creators of
      the ZIP/UNZIP tools can take any warranty whatsoever that
      really ALL your files are exactly recreated as they were.
      some complicated file systems, attributes and access rights
      may always create problems! Therefore I recommend that you 
      practice the RESTORE process at least once, to see if, 
      in the worst case, you have a high probability of getting
      your data back.

   -  as i'm writing this, i notice that after restoring the files,
      you also end up with all those 01-arc.zip's still located
      within the hard disk directories. as a workaround,

      how to delete the 01-arc's after use:
      -  copy 05-unpack-arc.bat 09-del-arc.bat
      -  edit 09-del-arc.bat
      -  global replace "02-tools\unzip" by "del"
      -  run 09-del-arc.bat

6. VERIFYING AN ARCHIVE WITHOUT RESTORING

   from time to time, approx. once a year, you MUST run a verify
   over your most important DVD archives, simply because through
   aging processes, you can never be sure if your DVDs are still alive.

   with an sfk durable archive, this is easy:

   -  insert the DVD into a DVD drive, for example drive E:

   -  open the command shell, say

         E:
         cd \
         04-verify-arc.bat

      this batch strictly expects 02-tools\sfk to be located on the
      DVD as well, therefore this is copied within do-mirror-d-to-z.bat.

      now, just wait and see ... sfk reads all files on the DVD,
      and compares their checksums with those stored in 03-md5-arc.txt.
      such a verify may take between 1 and 2 hours. still a long time,
      but still far better than anything else.

7. MY BACKUP PROGRAM CAN DO BETTER ...

   most probably you're using some very comfortable backup software already,
   but remember:

   -  can it produce decentralized compressed archives,
      or may a single unreadable sector of the DVD lead
      to a loss of the whole DVD content?

   -  is the backup software itself stored on the DVD?
      or is it complicated to restore a backup on a different PC?

   -  will this software still be available in 20 years?
      or how long do you expect your archives to live?
      the only de-compression tool used by sfk is unzip.exe
      from the InfoZIP group, which is available in 
      multi-platform sourcecode. so the probability is very high
      that this tool will be available on every computer,
      even within decades. by the way, I recommend that you
      download the InfoZIP packages from sourceforge, and extend
      the above batch (do-mirror-d-to-z) by copying the whole
      package contents (unzipped, of course) onto the DVD as well.


use case 04: delete a list of directories
-----------------------------------------

   e.g. you have directories

      tmp1
      tmp2
      tmp5
      tmp20
      tmp24

   and want to deltree them all, you may say

      dir tmp* /B | sfk addhead rmdir /S /Q >x.bat

   creating an intermediate batch with the content:

      rmdir /S /Q tmp1
      rmdir /S /Q tmp2
      rmdir /S /Q tmp5
      rmdir /S /Q tmp20
      rmdir /S /Q tmp24

   now run x.bat and the selected directory trees are deleted.

