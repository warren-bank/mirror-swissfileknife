/*
   The Swiss File Knife Command Line Multi Function Tool.
   StahlWorks Art & Technology, http://stahlworks.com/

   known issues:
   -  not every option can be specified everywhere.
   -  patch, inst: option -keep-dates only works
      with Win32 yet (uses xcopy command).
   -  unix handling of files >2GB and timestamps >2038
      is not yet tested and may require further adaptions.
   -  ntfs handling of links is not yet tested.
   -  german umlauts not supported in grep.
   -  getFileMD5NoCache should determine disk sector size
      and adjust read buffer accordingly.
   -  todo: numtoab8: top bit check.
   -  64 bit systems with g++: sizeof(long) == 8 may lead
      to problems in code assuming 32 bit sizes.

   NOTE:
      -  fread is mapped  to safefread
      -  fwrite is mapped to safefwrite
      to work around the Windows 60 MB I/O bug.

   1.5.8
   -  SYNTAX CHANGE: sfk detab: by default, the command
           now runs in SIMULATION mode if files are selected. 
           add -yes to really (re)write files.
   -  add: filter: -context, -precon, -postcon to list
           context lines around search hits. up to 100
           pre context lines can be listed. performance
           may slow down significantly with this option.
   -  add: sfk inst: option -witheol to instrument also
           "{" brackets at the end of line.
   -  add: support for logical color names like err,time
           with filter command. added color help text
           reference to filter command.
   -  chg: sfk text-join-lines renamed to sfk joinlines,
           but old name is still supported.
   -  chg: help text improvements.
   -  chg: sfk now prints a warning when using an unknown
           color name in sfk filter.
   -  chg: sfk copy: now showing a progress percentage
           only if there is more than 0% of progress.
   -  fix: sfk alias: crash if file cannot be written.
   -  fix: detab: empty text lines were stripped when
           using a command chain like "detab=n +toclip".
   internal:
   -  chg: execFilter cleanup.

   1.5.7
   -  chg: BEHAVIOUR CHANGE: sfk tail: now internally
           uses "seek" instead of "stat" to determine
           the current file size, as "stat" often fails
           to reflect file size changes in realtime.
           use option "-altsize" for old behaviour.
   -  add: sfk list, sfk help select: examples for
           exclusion of files and sub folders.
   -  add: sfk ftp and other network client commands:
           automatic expansion of target ip number,
           e.g. sfk ftp 23 == sfk ftp 192.168.1.23
           if the current host ip is 192.168.1.x.
   -  add: sfk sft, alias for sfk ftp using port 2121.
   -  add: sfk sftserv, alias for sfk ftpserv w/port 2121.
           sft means simple file transfer protocol,
           which cannot be used on port 21 on systems
           like windows 7.
   -  add: sfk webrequest: send a plain HTTP request
           and show the reply text with headers.
   -  add: sfk webserv: now also handles HEAD requests,
           so sfk wget to an sfk webserver no longer
           produces error messages.
   -  add: sfk list ... +sft support (ftp on port 2121).
   -  fix: sfk list mydir .1.cpp did not list .1.cpp files
           and list mydir !.1.cpp did not exclude them
           due to incomplete file extension comparison.

   1.5.6
   Revision 2:
   -  add: option -textfiles to process only text files.
   -  add: option -binfiles  to process only binary files.
   Initial Revision:
   -  CHG: SYNTAX CHANGE: if you are using negative
           directory selection masks starting with "."
           like in this example:
              sfk list -dir mytree !.svn
           then sfk will now exclude directories
           like in file masks: dir names ending with 
           the given extension will be excluded.
   -  chg: RETURN CODE CHANGE: sfk md5check:
           if some files to check do not exist sfk
           no longer returns code 0, but code 2 or 3.
   -  add: sfk filter -within ... -replace ...
           to replace phrases only in parts of lines.
   -  add: sfk if, conditional command execution based
           on the return code of a previous chain command.
   -  add: sfk call, call a sub function in a script.
   -  add: sfk copy, an incremental file copy and
           synchronization command.
   -  add: sfk wget, download http:// content from web.
   -  add: simple http:// url support for some commands
           like filter.
   -  add: simple anonymous ftp:// url support for some
           commands like list.
   -  add: sfk chars, print character codes of a word.
   -  add: sfk ascii, alias for sfk help ascii.
   -  add: sfk ownip(s), sfk ip to list the ip address(es)
           of the current machine.
   -  add: sfk ftpserv linux, mac: own IP information.
   -  add: sfk udpdump: dump incoming UDP packets.
   -  add: user defined zip file extension support:
           set an environment variable like
              export SFK_ZIP_EXT=".foo .bar .myext"
           to define a list of up to 30 file extensions
           that should be treated as zip files.
   -  add: sfk larc, alias for sfk list -arc.
   -  fix: file selection negative dir masks like in
             sfk list -dir mytree !.svn
           were ignored because they started with ".".
           now such masks correctly exclude dir names
           ending with the given extension.
   -  fix: md5check: now returns rc 2 or 3 if some files
           to check are not found. see help for details.
   -  fix: sfk copy: dirs where only time was copied
           were not listed in time color, and not listed
           at all in simu mode.
   -  chg: sfk getcwd: now passes dir name as file object
           to following chain commands.
   -  chg: code redundancy cleanup, more definitions
           moved into sfkbase.hpp.
   internal:
   -  chg: ftp deep directory processing, yet inactive.
   -  chg: unified use of netErrno().

   1.5.5
   -  add: sfk filter -form "$count" or "$(count+n)" 
           to insert the output line numer with an
           optional offset that is added.
   -  add: sfk filter -form "$()" format with brackets
           to work around parameter collisions
           within sfk scripts.
   -  add: apple mac experimental binary build.
           define MAC_OS_X whenever compiling on mac.
           define MAC_OS_X_PPC or MAC_OS_X_I686 to have
           the cpu type included in the version info.
   -  add: sfk ftpserv: now showing own ip under windows.
   -  add: sfk make-random-file -text: text file contents
           are now more randomly with varying line lengths.
   -  add: sfk loop help text, and listing in main help.
   -  add: sfk md5: option -verbose to list execution time.
   -  add: sfk md5: performance improvement.
   -  add: sfk filter: help section "common errors."
   -  add: sfk treesize, an alias for sfk stat.
   -  add: better error output on network errors.
   -  add: sfk ftpserv, ftp client help text solution
           on windows 7 connection blockings.
   -  chg: changed SFK_IO_BLOCK_SIZE to 10 MB,
           which is still far below the Windows 60 MB limit.
   -  fix: sfk ftpserv: now produces a speaking error
           if user connects with http protocol.
   -  fix: -fileset using "names with blanks" did't work.
           now such names can be used with double quotes.
   -  fix: sfk list -withdirs/-justdirs -dir a -file b :
           the file mask was ignored, the command always
           listed all directories. now, IF file masks are
           given, then list only the names of directories
           containing at least one matching file.
   -  fix: sfk list -withdirs -since ... : did list all
           directories ignoring the -since option.
   -  fix: sfk windows: list on UNC paths' root dir failed,
           e.g. sfk list \\anyhost\rootdir
           now using GetFileAttributesEx in that case.
   -  fix: sfk split: failed on ext2 partitions,
           and probably with all network files,
           due to windows bug on file read blocks > 60 MB.
           now ALL fread/fwrite calls are mapped to calls
           that use smaller blocks for I/O.
   -  fix: some root directories on mounted filesystems were
           skipped due to wrong interpretation as duplicates,
           as they had the same inode number. now the st_dev
           number is also taken for file identification.
   -  fix: additional buffer safety in ProgressInfo output.
   -  fix: now blocking some signals like SIGPIPE that stopped
           a linux sfk server if the client closed connection.
   -  fix: missing shutdown on socketclose may have lead
           to missing data at the end of some tcp connections.
   internal:
   -  add: sfk filter -within ... -replace _from_to_
           to change text only in a part of a line.
   -  add: sfk filesys, infos on filesystem.
   -  fix: rework of coi auto delete refcnt uses.
   -  fix: sfk filter: option -binary did nothing.

   1.5.4
   -  chg: SYNTAX CHANGE: sfk stat under windows:
           hidden files are now INCLUDED by default,
           to make sure the real size usage is always
           listed, esp. with dirs like "application data".
           use option -nohidden for old behaviour.
   -  add: sfk dir, alias for "sfk list -stat", also
           listing the number of skipped hidden files.
   -  add: sfk find: sfk ftext, alias for find -text.
   -  add: sfk httpserv, an instant http server 
           for easy file download and upload.
   -  add: sfk linelen: tell the length of a string
           or of the longest/shortest line of text.
   -  add: sfk filter: unified syntax, accept -! AND -:
           as well as -ls: and -le: on all platforms.
   -  add: sfk filter: unified syntax, accept -uform
           to use # instead of $ on all platforms.
   -  add: sfk ftpserv: dir listing now contains flags
           for dir entries, and text/binary information.
   -  add: sfk ftpserv: alternative default port 2121.
           often on (linux) machines port 21 is occupied
           by some complicated no-use ftp, and/or the
           user has no admin rights to use port 21.
           in that case, sfk ftpserv switches to 2121.
   -  add: sfk ftp/ftpserv: sft protocol 102, with time stamps,
           new transfer sequence and checksum after content.
           client and server fall back to 101 if there is a peer
           using the old protocol. complete rework of help text.
   -  add: sfk ftp: use with command chaining, experimental
           upload/download only of changed files.
   -  add: sfk ftpserv: option -deep to allow sfk ftp
           clients to put and get files with full path,
           e.g. sfk ftp myhost get the/sub/dir/doc.txt
           required directories are created on demand.
   -  add: sfk ftpserv, sfk ftp: option -pw to require
           simple password authentication.
   -  add: sfk ftpserv, sfk ftp: option -run to execute
           any command or script on the server side.
           requires authentication (option -pw on both
           sides) to enforce basic security.
   -  add: sfk ftp: support for put of chained filenames,
           e.g. sfk list mydir .txt +ftp myhost put
   -  add: sfk stat: option -flat to show the no. of
           files and bytes per folder w/o subfolders.
   -  add: sfk stat: can now also list sizes in (k)bytes.
   -  add: sfk stat: alias "statn" == "stat -minsize=n".
   -  add: sfk stat: option -sum for just the summary.
   -  add: tcpdump: example on how to connect via proxies.
   -  add: sfk help firefox, sfk samp firefox for infos
           and an example on ffox extension development.
   -  add: tcpdump -flat: if reply contains binary,
           now also hex dumping first 1000 bytes of that.
   -  add: sfk inst: support for blocks starting with
           whitespace "   {" instead of just "{".
   -  add: sfk ftpserv -help: info about the "passive"
           command on some ftp clients.
   -  add: SFK_CONFIG now also supports quiet, quiet=2.
   -  add: sfk inst: rework of help text.
   -  add: sfk alias: better help text and examples,
           especially for linux.
   -  add: experimental compile support under mac os x.
   -  add: run: help example for video image extraction.
   -  chg: sfk ftp(serv): by default, less verbose output.
           specify -verbose for the old behaviour.
   -  fix: ftpserv, httpserv, tcpdump: port was blocked
           when re-running the server.
   -  fix: sfk color black: produced invisible text under
           windows with black or white shell background.
   -  fix: md5: wrong calculation on 64-bit g++ systems,
           reason was the insane sizeof(long) == 8.
   -  fix: sfk ftp -quiet ... dir didn't list anything.
   -  fix: setting of file times under windows.
   -  fix: sfk samp javagui produced too much output.
   -  fix: linux: better support for files > 2 GB,
           changed several 32bit stat() calls to 64.
   internal:
   -  add: execJam: webrc in meta infos.
   -  chg: sft102: optional block mode with different
           command sequence.
   -  chg: bGlblQuiet changed to cs.quiet.

   1.5.3
   Revision 3:
   -  add: list: improved help text.
   -  add: sfk samp javahex, javagui.
   -  add: sfk batch as a shortcut for sfk samp sfkcmd
           under windows, or sfk samp sfkbash under linux.
   -  fix: list -quiet -stat: quiet blocked stat output.
   Initial Revision:
   -  opt: READ PERFORMANCE OPTIMIZATION: reading lines
           from text files should now be >= 5 times faster.
   -  add: xe: read support for .tar, .gz, .bz2, .tar.gz and
           .tar.bzip2 files, including nested archives,
           under the same restrictions as zip files
           (e.g. must fit completely into memory).
   -  add: complete content listing of nested .tar, .tar.gz
           and .tar.bzip2 archives (also in base/xd).
   -  add: reflist: now accepts option -memlimit.
   -  chg: option -wrap can now be used locally on comands.
   -  fix: listing of tar archive content times.
   -  fix: sfk filter -rep crashed on stream text if the
           replacements incremented the text length.
   -  fix: md5check: always told 0 kb/sec statistic.
   internal:
   -  add: option -rewrap to force plain text rewrapping.

   1.5.2
   Revision 2:
   -  fix: sfk find, strings: joined isolated words taken
           from binaries if the first one was ended by CR.
   -  fix: sfk echo: missing flush on terminal output.
   Revision 1:
   -  add: sfk help opt now lists all recognized
           zip file extensions.
   -  add: sfk samp javaimg, php, phpimg.
   -  add: .xpi now also recognized as a zip archive.
   -  add: sfk list -before, can be combined with -since.
   -  add: sfk patch -anyroot.
   -  add: sfk runloop -steps=n relative range processing.
   -  add: sfk list -usectime to use or list file creation time
           instead of modification time.
   -  add: sfk label -prefix=s to change the allowed input
           parameter name prefixes from "$" to something else.
   -  add: sfk list -qarc to explicitely list only the first
           level of zip file contents, without nested zips.
   -  chg: sfk list -arc now lists zip contents as deep as
           possible, including nested zips, also under base/xd.
   -  chg: option -xd no longer required under base/xd,
           supply only -arc to activate zip processing.
   -  chg: snapto: prefix length limited to 40 chars.
   -  fix: sfk list -qarc with .zip file mask produced nothing.
   -  fix: sfk find ... +view failed on some file contents
           to display correctly.
   -  fix: sfk echo produced unwanted blank lines.
   -  fix: sfk replace, sfk hexfind: didn't find all occurrences
           of search expression if first character was uppercase.
   -  fix: dir link to itself within a dir lead to
           nested processing with error messages.
           such direct links are now skipped.
   -  fix: dir names like foo.zip where treated as zip files.
   -  fix: reworked help text of sfk help xe.
   -  fix: internal: script parm escapes did not work.
   -  fix: internal: readStat() no longer calls status(),
           i.e. readStat() is now the lowest level above FS.
   -  fix: internal: status() now only returns nClStatus.

   1.5.1
   Revision 2:
   -  chg: only for sfk base -xdemo or sfk xe:
           -arc is no longer default with any command,
           esp. snapto, find, filter, hexfind,
           as shallow processing is often sufficient.
           user must specify -arc explicitely.
   -  add: option -hidden now listed explicitely
           in the help of snapto, find, filter, stat.
   -  chg: further small reworks of help text.
   Revision 1:
   -  fix: negative path mask was ignored with path of
           zip file entries.
   -  fix: sfk script: script parameters that looked like
           general options, e.g. "-yes", were interpreted
           instead of being passed to the script.
   -  add: sfk script: option -literal to also allow
           script parameters starting with "+".
   Initial Release:
   -  chg: SYNTAX CHANGE: output of "list -zip" changed:
           - under windows, zip entries are now listed using
             "\" back slashes, to be consistent with the
             general file naming format.
           - within-zip paths are now separated by double
             slash (no longer single slash) from the zip
             file name, to allow easy automatic separation
             of those path portions.
           examples:
             old format: "foo.zip\sub/bar.txt"
             new format: "foo.zip\\sub\bar.txt"
   -  chg: SYNTAX CHANGE: "sfk ver" is now "sfk ver -own",
           to print the version of sfk itself.
   -  chg: SYNTAX CHANGE: "sfk ... +select" (select used
           down in a command chain) now ignores any input
           from previous commands, allowing to run many
           independent selects in the same chain, like
           "sfk sel mydir +sel otherdir +sel thirddir".
           to use chain input, say "+list" instead.
   -  chg: SYNTAX CHANGE: list -zip is now list -arc for
           archive content listing. -zip is still accepted.
   -  add: linux: block of repeated processing of dir contents
           caused by symbolic links. new option "-showskip"
           to tell verbosely about blocked repetitions.
           new option "-allowdups" to disable detection.
   -  add: sfk replace: help text now tells clearly that
           subdir processing is default.
   -  add: sfk deltree, a short for del -withdirs -hidden.
   -  add: sfk md5: output chaining support.
   -  add: sfk cd, sfk getcwd, sfk mkdir.
   -  add: sfk sort to sort chain text.
   -  add: sfk count -same to count identical lines.
   -  add: head, tail now also accept chain text.
   -  add: filter: -unique option, remove duplicate lines.
   -  add: sfk ask, to search all help text for words.
   -  add: sfk dumphelp, to dump all help text.
   -  add: sfk help opt extended, -verbose added.
   -  add: strings: output chaining support.
   -  add: sfk hexfind, replace: option -reldist to tell
           relative distance between hits.
   -  add: sfk version: print versions of any binary
           containing a well formatted version string.
           support for output chaining.
   -  add: filter: block inclusion and exclusion through
           options -inc, -cut, -addmark.
   -  add: hex, dec: support for input/output chaining.
   -  add: filter: help text more detailed on -where.
   -  add: option -sub as the opposite of -nosub.
   -  add: sfk ftp: option -quiet for less output.
   -  add: sfk view -i to display text stream from stdin.
   -  add: version string now supports fixlevel and info.
   -  chg: sfk del -withdirs thedir now also deletes empty
           directories if no files were deleted within.
   -  fix: chain commands before +then tried to pass data
           to subsequent commands, instead of dumping their
           output to terminal, esp. sfk echo ... +then.
   -  fix: +del within a chain no longer assumes dir "."
           on insufficient chain input.
   -  fix: sfk hexfind -nodump produced "cannot load" errors
           when processing zip file contents.
   -  fix: superfluous linefeed after diverse command output.
   -  fix: sfk echo: added superfluous linefeed after output.
   -  fix: snapto of text with :file: lines produced errors,
           such lines are now escaped with a prefix character.
   -  fix: sfk filter -cnt (short for -count) didn't work.
   -  fix: wrong message on -dir x if x is non-existent.
   -  fix: sfk script: with more than 1 script in the 
           same script file, +end of first was ignored.
   -  fix: hexfind, replace without replace expression:
           wrong highlighting of found expression.
   -  fix: sfk replace with variable length patterns:
           missing close on multiple file processing.
   -  fix: sfk list -sincedir c:\ d:\ didnt' work.
   -  fix: sfk list c:\ produced "c:\\" names
   -  fix: find -nosub: showed wrong "scan" info of dirs.
           also improved scan status display of files.
   internal:
   Revision 2:
   -  chg: bGlblHiddenFiles to cs.hidden
   Initial Release:
   -  add: precachezip: snap direct processing.
   -  add: precachezip now also loads the dir list,
           so direct processing can easily exclude
           already processed entries from the list.
   -  add: chaining: commands may now accept both data
           and filenames, selecting by the given input.
   -  add: StringMap now also accepts NULL values.
   -  add: timeFromString now supporting 26 char format.
   -  add: md5 can now be used in a script, but it does
           not yet support input chaining.
   -  chg: memory leak checks are now skipped if sfk
           is stopped by pressing escape.
   -  chg: cs.subdirs can now be used command local.
   -  fix: no longer autocompleting with "." if no dir
           given on commands detab, remcr, addcr.
   -  fix: processDirParms: script keywors like "+end"
           skipped autocomplete of dir parms.
   -  fix: writeable mode not set in coi::fillfrom.
   -  chg: general file processing code rework.
   -  mod: toclip: passing chain text to clipboard
   -  mod: filter from stdin, from file, from chain
   -  mod: myfgets: removed stringpipe support

   1.5.0
   -  add: snapto: now includes modification time and size
           information per file header, by default.
           use option -nometa for the old behaviour.
   -  add: bin-to-src -pack: added check to ensure output
           buffer is not filled beyond supplied size.
   -  add: bin-to-src: option -append.
   -  add: echo: relaxed syntax, accepting ---===--- etc.
   -  fix: stat: wrong statistical output when supplying
           filesets with more than one root directory.
   -  fix: script: "+then othercommand" did not reset
           the chain data.
   -  fix: internal: missing "file not found" in loadfile().
   -  fix: internal: /W3 warnings partial cleanup.

   1.4.9
   -  fix: sfk split, replace, addcr, remcr:
           writing large files onto network drives failed.
           the windows implementation of the C function
           fwrite(p,1,nsize,f) fails on network drives
           if nsize > 60 MB, returning "0" written bytes.
   -  fix: addcr, remcr: incomplete error handling.
   -  fix: replace: wrong help text concerning case search.
   -  add: replace: better info about sfk filter -replace.
   -  add: general option -exterr to display extended
           error information on file processing errors.
   -  fix: internal: changed ALL fwrite to myfwrite.
           myfwrite currently limited to 5 MB blocksize.
           extended all fwrite error outputs by perrinfo.

   1.4.8
   -  chg: SYNTAX CHANGE: sfk replace and hexfind:
           now searches CASE-INSENSITIVE by default for
           all TEXT (not binary) patterns supplied.
           this way, replace and hexfind behave the same
           as functions "sfk find" and "sfk filter".
           sfk replace and hexfind will be slower now,
           especially on large files.
           specify option -case for old behaviour.
   -  fix: sfk scripts: any "+command" can now be used
           after "sfk label labelname".
   -  add: find: -text -count to count no. of matching
           lines within text files (not binary files).
   -  add: hexfind: support for output chaining to filter.
   -  fix: addcr, remcr, synctext, detab, script
           and some other commands may have crashed
           with large input files due to out of memory.
   -  add: partcopy: optional endoffset i/o start+length.
   -  add: command chaining: sfk cmd1 +then cmd2 runs two
           independent commands, NOT passing data to cmd2.
   -  add: options -waitonerror, -waitonend to wait for
           user input on every error or at program end.
   -  fix: filter -form -write: did not save changed output,
           as lines processed only by -form were not counted
           as a change.
   -  fix: unknown command (syntax error) did not return rc 9.
   -  add: case-insensitive search with hexfind and replace.
   -  add: sfk pause - wait until user presses enter.
   -  add: the first command may now also be started with +,
           to make sfk scripts look more consistent.
   -  fix: hextobin ... +another command now possible, e.g.
           sfk fromclip +hextobin c:\tmp\tmp1.dat +hexdump
   -  chg: hexfind, replace: print blank after filename.
   -  fix: internal: loadFile, loadBinaryFile now all using
           num instead of long for size values.
   -  add: internal: getKeyPress() may now filter down or up.
   -  fix: internal: ProgressInfo ctr: memset to clear all.
   -  add: internal: load(Binary)File: clean tolerance area.
   -  fix: internal: load(Bianry)File: ignored out of memory
           conditions, therefore may have lead to crash
           on all commands that used it.

   1.4.7
   -  add: sfk pathfind: if path contains entries with
           trailing slashes, now strips the slashes.
   -  fix: -wrapbin may have triggered normal -wrap,
           sometimes with default column number (80).
   -  add: dupfind -diffdirs option.
   -  fix: fromclip can now be used in sfk scripts
           in a command like sfk label ... +fromclip.
   -  fix: chaining: commands after +toclip were ignored.
   -  fix: sfk select ... +snapto counted files twice.
   -  add: hextobin: now also accepts input with 0x format.
   -  fix: internal: minor code cleanup.
   -  add: filter: option -snap to interpret snapfiles,
           and list subfile names contained therein.
   -  add: filter: option -verbose to show filenames.
   -  fix: dupfind: with multiple input dirs and chaining,
           wrong directory was passed with filenames.

   1.4.6
   -  fix: replace didn't work with last byte of file.
   -  add: sfk sel ... +stat now tells no. of bytes used.
   -  fix: sfk fromclip +filter ... -join +toclip crashed.
   -  fix: "sfk echo mydir | sfk stat -i" produced errors.
   -  add: rep help now tells about filt -rep wildcards.
   -  add: dupfind help: added "sfk dupfind ."
   -  add: sfk filter -srep = sfk filter -spat -rep
   -  add: internal: snapto callback for filenames.

   1.4.5
   -  add: partcopy, copy parts of binary files.
   -  add: hexdump: -offlen option to dump file parts.
   -  fix: hexfind: search within files > 2GB.
   -  fix: hexfind: seek error message now w/o write text.
   -  fix: size parameters: now accepting 64 bit 'b' value.
   -  add: size parameters: 'b' is now optional.
   -  add: size parameters: with no postfix given,
           sfk now assumes a byte size.
   -  add: support for 0x hex values on some size and
           offset string parameters.
   -  add: internal: myfseek with 64 bit support.
   -  fix: internal: numFromSizeStr now using atonum.
   -  fix: internal: skipDirFileColl no longer set by
           default w/in walkAllTrees, blocked freezeto.
   -  fix: internal: freezeto didn't work since 1.4.3.

   1.4.4
   -  add: sfk join: option -force to overwrite output
           files without asking back.
   -  add: sfk replace: support for source / target
           replacements with differing length.
   -  chg: sfk replace: relaxed syntax, now supporting
           options directly before single filename.
   -  fix: run using $relfile: a:foo.txt was not reduced
           to foo.txt under windows.
   -  fix: internal: copy -load: now uses shadow file
           if source has unreadable attributes.
   -  fix: sfk env now also listed in main help.
   -  add: internal: sfk ... +sfk or +then to flush chain.
   -  add: internal: resetAllFileSets() to flush also SFL.

   1.4.3
   -  fix: now flushing terminal output on some commands
           like stat, allowing tail -f on redirected output.
   -  add: sfk env, dump and search environment variables.
   -  add: internal: -slow, -dirdelay=n, -filedelay=n
   -  fix: no longer stopping dir tree processing on
           unreadable files or dirs. now trying to process
           as much as possible. global rework of RC handling.
   -  add: option -stoponerr[or] to activate old behaviour,
           which is to stop dir tree processing on error.
   -  add: "n errors occurred" informal message at program
           end in case of errors.
   -  add: option -rcfromerr[or] to override rc on any
           skipped errors.
   -  add: sfk errortest, to experiment with shell return
           code influencing options.
   -  fix: sfk run "echo test" -yes +filter no longer
           produces a ":file ?" line.
   -  fix: internal: execJamFile: stop on non-zero rc
           from dumpJamLine in text mode.

   1.4.2
   -  add: option -nosub[directories], the same as -norec 
           but easier to remember. -norec will be kept.
   -  add: sfk list -zip now also lists contents of
           .ear .war .aar files.
   -  add: sfk script, run commands from a script file.
   -  add: sfk samp bash, short bash script example.
   -  add: sfk samp sfk, sfkcmd, sfkbash script examples.
   -  fix: sfk rep: memory leak msg on parameter errors,
           and improved error message.
   -  chg: output of some hexadecimal numbers changed
           from lowercase to uppercase.
   -  add: sfk hex, dec to convert numbers.
   -  fix: script: +loop failed with -from.

   1.4.1
   -  fix: sfk list now fully skips unicode filenames,
           and does not stop dir tree processing.
   -  add: run commands without any token are now blocked
           only if there is pending chain input data,
           which indicates a user error.
   -  opt: alias: if no parameters are specified by user,
           all (and even more than 10) parameters are
           now passed to the created command.
   -  fix: echo: % within echo string created problems.
   -  fix: find, filter: output on windows console did
           not display characters with accent correctly.
   -  fix: sfk list now skips unicode directory names.
   -  opt: internal: more blocks covered by USE_SFK_BASE.
   -  add: internal: +tee, +toterm, +tofile.
   -  add: internal: script, create script files.
   -  add: internal: samp sfk, script file examples.
   -  fix: internal: reset of temporary command data
           now done per chain cycle.
   -  fix: internal: oprintf convert text only on printf,
           not when passing it further in the chain.
   -  fix: internal: copy mydir c: target dir checks.
   -  fix: internal: verify -cleanup now rewrites filedb.
   -  chg: internal: filedb: pathsum removed.
   -  chg: internal: filedb: V10 with variable metalen.
   -  fix: internal: freeze: glblErrorLog lacked reset.
   -  fix: internal: sync: no source is older message
           if it's due to dst jump.

   1.4.0
   -  add: sfk filefind command, an easy filename finder
           for the current directory tree. can be typed
           as "sfk ff" or even just "sfk :".
   -  add: sfk sel -sincedir ... +run "$qsince ..." is now
           supported. if a command produces -since reference
           names, then they are passed through to the next.
   -  add: sfk run: if there is chain filename input,
           auto-append $file to command if not present.
   -  add: sfk ... +fview can now be typed as ... +fv
   -  opt: performance improvement by rework of memtracing.
   -  opt: color text output: no action (escape sequence
           etc.) when changing from color to same color.
   -  add: sfk sleep n, delay execution for n milliseconds.
   -  add: sfk make-random-file to produce test data.
   -  add: sfk sample, create instant java or cpp code.
   -  add: skip of non-existent files on many functions.
   -  add: missing +view in main help text for linux.
   -  add: tcpdump: autodetect of http protocol,
           and autoselect of shorter timeout,
           if no timeout is set by user explicitely.
   -  fix: internal: handling of execSingleFile rc,
           stop processing only on rc >= 9.
   -  fix: internal: isAbsolutePath now considers two-
           and single char paths as well (e.g. C: and \)
   -  add: internal: chain: root dir info per file.
   -  add: internal: chain: reference per file.
   -  add: internal: class Coi replacing filename.
   -  fix: internal: perr now doing mtkerr as well.
   -  fix: internal: pwarn now using szErrBuf.
   -  fix: internal: perr, pwarn auto-append LF.
   -  fix: internal: help opt: missing parm on printf.

   1.3.9
   -  add: sfk ... +view command:
           Depeche View for Linux integration using WINE.
           requires Depeche View 1.2.0 or higher, and
           the linux WINE package being installed.
   -  add: sfk ... +view -verbose tells absolute path
           of target dview executable, if it is called
           dview, dview.bat or dview.exe.
   -  add: sfk view: option -noback, -nowine, -nolinux.
   -  fix: sfk color: cyan and magenta were swapped.
   -  fix: find -names mydir foo >tmp1.txt produced nothing
   -  fix: sfk find -names testfiles foo +... produced nothing
   -  fix: sfk list -late -time testfiles produced nothing
   -  fix: sfk list -big -size testfiles produced nothing

   1.3.8
   -  add: linux: general option -nofollow to avoid recursing
           into directory links. this option works only with
           up-to-date linux variants like ubuntu.
   -  fix: list -sort -size did not sort by name.
   -  add: set SFK_COLORS=link:... to change color
           of symbolic link names.
   -  add: -nowarn, -noerr, -nonote
   
   1.3.7
   -  SYNTAX CHANGE:
           sfk list -twinscan replaced by sfk dupfind.
   -  add: dupfind, find and list duplicate files,
           including command chaining support.
   -  opt: dupfind search performance improved massively
           compared to list -twinscan.
   -  add: dupfind: -minsize, input chain support.
   -  add: ftpserv: options -timeout, -quiet.
   -  add: tcpdump: informal message on very small timeout.
   -  add: md5check: post-command chaining support, e.g.
           sfk md5check x.md5 +echo "all done"
   -  add: bin-to-src: java source code generation.
   -  chg: internal: bGlblError renamed to nGlblError.

   1.3.6
   -  fix: reflist: missing linefeeds on chained output
           of zero-ref records.
   -  fix: deplist: missing linefeed on single source.
   -  chg: reflist: can now be stopped by ESC (windows).
   -  chg: reflist, deplist: see also in help text.
   -  add: reflist help: more examples.
   -  fix: filter -lshigh error message.

   1.3.5
   -  SYNTAX CHANGE:
           reflist: source dir is now listed first.
           option -abs renamed to -path.
           option -base renamed to -noext.
   -  add: list -sort[rev] to sort filenames alphabetically.
   -  fix: filter: missing return code on line hits.
   -  add: find: return code support, rc help text.
   -  add: option -showrc to print rc on program end.
   -  add: scantabs, hexfind, replace: rc support.
   -  chg: md5check: now returns rc 1 if there is just
           a checksum mismatch, and >1 on severe errors.
   -  add: sfk deplist, list dependencies of files.
   -  chg: optimization of reflist, deplist (memory use).
   -  add: internal: StringTable: support for NULL entries.
   -  fix: internal: ProgressInfo clear, lastDumpTime.
   -  fix: missing error message on rep -to.
   -  fix: internal: mystricmp return value lacking tolower.
   -  chg: internal: list now using ProgressInfo.
   -  fix: internal: eKeepAdd missing on setStatus calls.
   -  fix: list u:\ was reduced to list u: (removing slash)
   -  add: internal: SFKMainStat, -exectime.
   -  chg: reflist, deplist help text.
   -  fix: internal: execRefProcSrc now stores relative src
           names if -relnames specified, for complete deplist.

   1.3.4
   -  fix: "filter x.txt -count -write" didn't work.
   -  add: improved error message on replace user errors.
   -  chg: rework of replace help text.
   -  fix: filter -rep _..._\n_ produced wrong colors.
   -  add: filter -where, -lswhere, -lewhere.
   -  chg: filter -highlight: eased restrictions where
           it can be used (before/after replace etc.)
   -  add: filter -highlight def[ault] color support.
   -  add: view: transparent parameter passing to dview,
           allowing, for example, to set -area or -id.
   -  add: rework of reflist command, esp. output format.

   1.3.3
   -  SYNTAX CHANGE:
           replace: now accepts filename as first parm.
           sfk rep singleFile -pat /src/dst/ [...] [-yes]
           - otherwise -pat must be specified.
   -  SYNTAX CHANGE:
           run: when used in a command chain, run now
           inserts ":file " name records into output text.
           use option -nofile[names] to disable this.
   -  add: filter: -lsrep, -lerep, -lshigh, -lehigh
           to replace or highlight at line start or end.
   -  chg: run: rework of status output.
   -  add: run: option -printcmd, -stoprc=n.
   -  add: +view: snapfile format creation, -wrap option.
   -  fix: list ... +run ... +run used wrong command string.
   -  fix: run ... +run didn't pass filenames.
   -  fix: -to and run used same string buffer,
           renderOutMask now expects target buffer.
   -  add: run: redirect 2> only if not done by user.
   -  fix: view: do not run dview if no input available.
   -  add: view: option -noshl to disable syntax highlighting.
   -  SYNTAX CHANGE:
           hexdump: -nohead no longer used,
           say -nofilenames to not list filenames.
   -  chg: internal: -nofile[names] now sets
           cs.nonames instead of cs.nohead.

   1.3.2
   SYNTAX CHANGE:
      -  filter -sep ... -form $col1\t$col2 :
         AND
      -  replace /foobar/foo\x00ar/ -file tmp.txt :
         support for slash patterns:
         \t   is now interpreted and replaced by TAB.
         \xnn is now interpreted and replaced by any
              char with hexcode nn.
         \\   is replaced by slash \ itself.
         replace supports also \x00 replacements,
         without the need to use -binary option.
      -  find mydir pat1 pat2 pat3 :
         patterns starting with - or + must now be prefixed
         by backslash, e.g. sfk find mydir \-mypat .
   SYNTAX CHANGE:
      -  filter -form without previous -sep no longer
         assumes -sep " \t" but packs the whole line into
         column 1 without splitting it.
   SYNTAX CHANGE:
      -  md5 filename now also echoes the filename.
         say -nonames to list md5 sum only.
   SYNTAX CHANGE:
      -  option -nocode renamed to -nocconv.
      -  "sfk stat" now lists help text instead of listing
         the local directory contents. list local dir
         by saying "sfk stat .".
   -  add: filter -rep supporting * and ?.
   -  add: \n \r \xnn support in several format strings.
   -  add: wildcard support for filter patterns -+ etc.
   -  add: filter -highlight color pattern.
   -  add: -bright and -dark color control.
   -  add: filter -no-blank-lines
   -  add: +hextobin chain command.
   -  add: +view, +fview chain commands.
   -  chg: patch: now accepts any number of blanks
           after most commands, e.g. ":mkdir   thedir"
   -  add: -to output filemask for some commands.
   -  add: head, tail.
   -  fix: -dir or -file w/o further parm now issues error.
   -  add: windows: auto detection of black or white shell
           backgrounds, auto select of optimized colors.
   -  add: sfk where x now automatically searches through
           all exentions (.bat etc) listed in PATHEXT.
   -  add: general option -cconv to activate codepage
           conversion of terminal output on windows.
   -  add: "alias name" now lists alias "name".
   -  add: alias -list chaining support.
   -  add: list -since: most recent file info.
   -  add: filter -join +toclip, addToCurrentLine.
   -  add: fromclip, toclip chaining.
   -  add: run output chaining via tmp files.
   -  fix: run -idirs didn't work with linux.
   -  add: option -literal to disable slash patterns.
   -  add: hexfind, alias of replace.
   -  add: sleep msec.
   -  add: filter -pat.
   -  add: delete, to remove files (not dirs).
   -  add: find: autodetect of binary or text.
           may be overridden by -text or -binary.
   -  add: find: now also accepts single filename.
   -  fix: verfy status output.
   -  chg: internal: filter code rework, modularized.
   -  chg: internal: pszGlblJamPrefix no longer dynamic.
   -  add: command chaining support.
   -  add: internal: phrase.
   -  fix: process directory entries even with -norec.
   -  fix: disable fileExists check in walkFileList,
           to enable more flexible +run of file lists.
   -  fix: copy: verifyFile rc check.
   -  add: internal: -keepstale=n.
   -  chg: internal: command statistics in cs.
   -  add: -[block]sep -form now issuing error message.
   -  fix: now removing cleaned-up stale files from metadb.
   -  fix: syntest now using own text buffer.
   -  add: internal: encode-perc, decode-perc
   -  add: internal: command name aliasing.
   -  add: internal: beep.
   -  add: internal: ftpserv -run.
   -  fix: filter ... +filter -form "$col1 $col1":
           npats of 1st filter wasn't set correctly.
   -  fix: chain.indata read index reset.
   -  add: internal: tail -follow -lines=n with filtering.
   -  add: internal: copy: size statistics.
   -  add: internal: syncver -clean.
   -  fix: sync -save: metadb update on stale del.
   -  chg: internal: remapping of color code attributes.
   -  fix: copy to \\netdrive don't try to create root.

   1.3.1
   -  fix: md5gento= didn't work with "=" specified.
   -  fix: md5check= didn't work with "=" specified.
   -  fix: md5check progress indicator.
   -  chg: SYNTAX CHANGE:
           command "syncto" renamed to "synctext".
           command "mapto" renamed to "maptext".
   -  add: filter -cnt now using prefix color.
   -  fix: memory leak in addcrlf on error situations.
   -  fix: sfk help ascii for windows now (trying to)
           display Ansi characters correctly w/in console.
   -  fix: windows: listing of filenames with umlauts.
   -  add: option -nocode to disable codepage conversions.
   -  add: filter: -wrap or -wrap=ncols for output.
   -  fix: auto-calculated -wrap columns is now shell
           columns minus 2 (instead of whole columns).
   -  add: list: option -quot to add double quotes.
   -  fix: unwanted cycle() on info.setstatus leading
           to wrong colored time sync output.
   -  fix: detection of -sep -form without separators.
   -  fix: missing cleanup of half written file produced
           by ctrl+c during copy.
   -  add: set SFK_CONFIG=columns:n to manually define
           the console output width.
   -  fix: -tracesel now also lists -sincedir decisions.
   -  add: -flist option to process file name lists.
   yet internal/alpha:
   -  add: automated interface syntax tests.
   -  add: scantab with indent statistics.
   -  chg: copy, sync: verify now done in separate pass.
   -  add: copy: retry loop for failed verifies.
   -  add: sync: stale safety, keep trashfiles <30 days.
   -  add: sync: -signto, -checksigns.
   -  add: sync: -save, -load. syncver.
   -  fix: sync: rewrite write protected files.
   -  add: sincedir: ref dir check, -incref support.
   -  fix: sync: cleanup: dont list non-empty dirs as del.

   1.3.0
   -  add: sfk help options.
   -  add: md5gento: -rel option for relativized filenames.
   -  add: echo function, print colored text onto terminal.
   -  add: tcpdump, create hexdump of a tcp connection.
   -  add: path mask support, -dir with wildcards.
   -  add: support for "*" filename wildcard, or another
           char under linux, which can be changed through
           export SFK_CONFIG=wildstar:c
   -  add: improved wildcard support with ftp functions.
   -  add: "?" wildcard support on filename masks.
   -  chg: "%" is now default for linux wildcard char.
   -  add: progress info for md5gento, md5check.
   -  add: more detailed help on list command.
   -  add: filter -joinlines.
   -  add: -wrap, -wrapbin options with auto-calc columns.
   -  add: hexdump: autoselect of -wide by shell columns.
   -  chg: list -sincedir now also lists time differences.
           new option -sincechg behaves like old -sincedir.
   -  chg: default windows colors now compatible both to
           white and black shell backgrounds.
   -  chg: default warn color now magenta under windows.
   -  add: set SFK_COLORS=theme:black
   -  fix: -sincedir foo bar: foo and bar were mixed up
           internally in comparison, therefore newer files
           of "foo" may not have been listed.
   -  fix: filestat::differs: didn't return timestate.
   -  fix: file time and attribute comparison,
           mask windows attributes for comparison.
   -  fix: check nAttribs for non-zero before setting.
   -  chg: internal: using myfread/write to update info.
   -  fix: joinPath, getCurrentRoot now check for ':'.
   -  fix: avoid attribute cloning from dir ending with colon.
   -  fix: relativization of paths by relToCopySrc.
   -  chg: fileExists() no longer using fopen.
   -  chg: differs() now using seconds for wft.
   -  add: internal: filter -en/decode-url.
   -  add: internal: pszGlblPreRoot support, used by copy.
   -  add: -quiet support for tcpdump.
   -  add: internal: -view support on several commands.
   -  fix: -view: -dir tmp1 -dir tmp2 -file .txt:
           now inserting "-file *" implicitely for tmp1.
   -  add: internal: -tracesel, -tracedir, -tracefiles.

   1.2.9
   -  chg: SYNTAX CHANGE: just typing "sfk list" no longer lists
           the current directory, but shows the help text.
           type "sfk list ." now to list the current dir,
           or specify any option, e.g. "sfk list -late".
   -  add: options -sincedir, -sinceadd, -sincediff, -relnames,
           to be used with list and run.
   -  add: sfk md5 multi file and verify support.
   -  add: sfk replace, to replace patterns in binary files.
   -  add: sfk list -sincedir now supports -pure.
   -  add: more help text examples for list and run.
   -  add: option -names for find/grep, to list just filenames.
   -  fix: some error messages lacked linefeed.
   -  add: internal: file attribute writing with linux.
   -  add: internal: sfk copy -since now leaves out empty dirs.

   1.2.8
   -  add: sfk alias - reduce typing effort by aliases.
   -  add: sfk mkcmd - remember working dir in alias batch.
   -  fix: sfk ftpclient mget didn't work.
   -  chg: internal: -sincedir: check also content.

   1.2.7
   -  add: list: -late, -old, -big, -small, -since, -sort.
   -  fix: internal: sfk -html: color sometimes not reset.
   -  add: internal: file time info functionality.
   -  fix: -quiet made no sense with sfk list.
   -  fix: linux: getFileStat: 64 bit support.
   -  add: highlight of hidden dirs.
   -  add: filter -count, -cnt output line counter.
           -lnum may now be specified as postfix option.
   -  fix: fromclip: text contained too many CR's.

   1.2.6
   -  chg: SYNTAX CHANGE ON RUN COMMAND:
           by default, run is now always in SIMULATION MODE.
           to have to add "-yes" to really execute.
   -  add: runloop, hexdump, split, join.
   -  chg: rework of setGeneralOption. general options
           may now accept additional parameters.
   -  chg: renamed addcrlf to addcr, remcrlf to remcr.
           old command names still supported inofficially.
   -  add: addcrlf: support for malformed files containing
           only CR instead of LF. these are now also converted
           into crlf output.
   -  add: internal: -sincedir general option.

   1.2.5
   -  add: sfk md5check/md5gento syntax extended,
           the "=" is no longer needed but still supported.
   -  add: filter -rep xsrcxdst: both src and dst now
           support format strings with \t and \xnn.
   -  add: filter -sep: support for hex values \xnn.
   -  fix: windows text color: background was changed.
           now masking SetConsoleTextAttribute correctly.
   -  fix: unexpected error messages by ftp transfer from server
           to client. removed ack verify at server, as error msges
           at client are sufficient.

   1.2.4
   -  fix: ftp: file receive by normal ftp: division by zero
           during output of intermediate size.

   1.2.3
   -  fix: ftp: timeouts after transfer of long files,
           due to wrong sequence of reply and md5 check.
   -  fix: ftp: now issuing error on sender side on non-ok reply.
   -  fix: filter -sep "\t" -form now working.
   -  opt: ftp: now issuing error on foo*bar names on mput, mget.
   -  add: sfk list -zip: now listing both .zip and .jar contents.
   -  add: (windows) toclip, fromclip.

   1.2.2
   -  fix: ftp error handling improved. testing and
           skipping unwritable files before transfer.
   -  fix: unix compatibility during tree walking.
   -  fix: deblank now also deblanks directories.
   -  add: sft101 with skip records to improve flushing.
   -  fix: ftpserv always said "igoring path" on dir.
   -  fix: ftp client: better parsing of "-" lines esp. with dir.
   -  add: mget, mput in case of SFT.
   -  add: ftp: client and server tell each other supported sft.
   -  fix: ftpserv: escape key recognition.

   1.2.0
   -  fix: bin to text: dynamic nMinWord adaption. by default,
           short words accepted, but whenever binary appears,
           it's incremented to at least 3 chars.
   -  fix: help text: md5gento: wildcard removed.
   -  fix: find/grep: multi-pattern hits across two soft-wrapped
           lines are also detected now, listing both lines.
           hard-wrapped lines (ending with LF) are not included.
   -  add: line prefix color, used with find, for slash symbols
           marking combined soft-wrapped lines.
   -  fix: find -text now also produces colored output,
           and supports -c option for case-sensitive search.
   -  chg: rework of sfk patch -example help text.
   -  fix: binary to text conversion: missing word flush on CR.
   -  fix: ditto: CR may produce a blank only in jamfile mode.

   1.1.9
   -  fix: help text, sfk snapto examples.
   -  fix: replacement for faulty windows fgets. now text files
           can be read including "EOF" 0x1A char, and 0x00.
           changed on grep, test, snapto, filter.
   -  fix: strings, snapto with -umlauts option: better detection
           of printable characters (by sfkisprint).
   -  add: sfk help ascii help text: how to list windows umlauts.
   -  chg: infocounter now uses second steps i/o checkBytes.
   -  add: bGlblEscape check in walkAllFiles.
   -  add: better parameter error checking on run command.
   -  add: -all option as workaround for "*" under unix.
   -  add: enforcing specific sequence of -file parameters:
           1. global wildcards "-all" or "*"
           2. then positive file patterns, e.g. starting with "."
           3. then negative file patterns, starting with "!" or ":"
           added parameter error checks.
   -  add: implicite add of "*" if first -file parm is negative mask.
   -  fix: snapto: also include binaries by name pattern.
   -  fix: grep -text again using fgets, stopping at NULL bytes.

   1.1.8
   -  chg: sfk find now requires directory as first parameter,
           if using short syntax. this way, find is more in line
           with all other commands, and also more flexible.
   -  add: (internal, experimental) checkdisk.
   -  add: (internal, experimental) copy.
   -  add: findPathLocation: include current dir on windows.
   -  fix: sfk filter test.txt -rep //x/ crashed.
   -  fix: ftpserv: always told 15 sec timeout although it's 30.
   -  fix: rc was not promoted in walkFiles(), preventing stops
           in case of errors.
   -  chg: sfk grep renamed to sfk find, which is a bit clearer.
           but the alias "sfk grep" will always be accepted as well.
   -  add: general option "-include .ext1 .ext2" to force inclusion
           of specific binary files on some commands. this is global,
           and can be specified in front of other dir and file options.
   -  add: option -wrapbin=nn which specifies at which column binary
           to text conversions are wrapped.
   -  add: [internal] -any option, followed by a list of files or dirs.
   -  add: calls to processDirParms: rc check everywhere.
   -  chg: internal autocomplete now is a 2-bit mask.
   -  add: third form of file set: list of specific file names.
           support for mixing specific files and dir trees.
           if mixed, specific files include binary support.
   -  add: PreFileFlank support, meaning that optionally,
           -file may be specified in front of -dir.
   -  chg: cleanup, maxlinelen moved to sfkbase.

   1.1.7
   -  fix: all colors, also on help, now off by default on unix,
           otherwise a shell with black background becomes unusable.
   -  fix: filter -format: do not issue error on non-existing columns.
   -  add: filter: detection of wrong option sequence, with error msg.
   -  add: filter: options -le+ and -le! for line end selection.
   -  add: bin-to-src: added name prefix for better integration.
   -  add: unix: SFK_COLORS now accepts a "def:" default color.
   -  fix: patch: on -nopid now also no backup of patchfile.
   -  add: list: -zip also lists zipfile contents.
   -  fix: grep on binaries lost some chars, added nword count.
   -  add: messagebox function (windows only).
   -  add: grep and filter: -verbose support, yet experimental.
   -  add: bin-to-src now uses decimal array by default, reducing
           size of code. added option -hex for old format.
   -  fix: StringTable resetEntries missing nClArraySize.
   -  fix: Array, LongTable, NumTable reset: missing sizes.
   -  add: help ascii, help shell.

   1.1.6
   -  add: accept general options before any command.
   -  add: some example documentation.
   -  opt: global code rework, added perr and pwarn.
   -  fix: grep: last record of (binary) files ignored.
   -  fix: md5check: -skip n didn't work (-skip=n did).
   -  add: color command to change terminal text color.
   -  add: filter: text processing option -form.
   -  add: grep: windows: now with coloured highlighting of result
           filenames and text hits. sfk help colors for color config.
   -  add: filter: windows: color highlighting of hits.
   -  opt: mystrstri speed improved.
   -  ren: syncto: option -stest renamed to -stop.
   -  fix: mapto: now also counts notes-begin section.
   -  add: sfk grep: now also processing binary files.
           to switch to old behaviour, use grep -text.
   -  add: (internal) freezeto: stale archive list.
   -  add: micro tracing kernel: file logging support.
   -  add: patch: -nopid support to apply permanent patches.
   -  fix: unix colors by default for help text only.
   -  add: reflist: internal option -case, for autotest.
   -  add: patch: output buffer extended to 50000 lines.
   -  add: patch: help text rework, template generation.
   -  fix: mystrncmp: added end of string check.

   1.1.5
   -  fix: stat: sizes >4GB truncated in listing.
   -  rem: freezeto no longer listed as official function
           until intense long-run tests are done.
   -  fix: freezeto: enforcing unzip 5.52. older unzips
           have problems when used with ntfs.
   -  fix: freezeto: count info msgs not as errors.

   1.1.3
   -  add: filter: pattern replacement using -rep _src_dst_.
   -  fix: filter: options beginning with + not recognized.
   -  fix: many options can now be specified more flexible.
   -  add: ftpserv: support for mget/mput * by clients.
   -  chg: ftpserv: client timeout now 30 seconds.
   -  add: (internal) sfk test function, for selftest.
   -  chg: new order of command listing in help.
   -  fix: filter: -ls! and -ls+ now also case-insensitive.
   -  add: inter-platform regression test, see scripts/ dir.

   1.1.2
   -  add: linux: run: using # instead of $ due to bash.
   -  add: linux: all: using : instead of ! due to bash.
      in general, sfk for linux is still alpha.
   -  fix: freezeto: wrong warning that files are not
      contained in archive if starting with ./
   -  add: sfk simple tcp file server, get, put.
   -  add: sfk md5 for quick single file check.
   -  fix: patch: changed error message on pattern mismatch,
      now telling the real from block number.
   -  add: sfk filter may now also read from file i/o stdin.
   -  add: sfk deblank, replace blanks in filenames.
   -  add: simple ftp server, ftp client.
   -  fix: md5check linux path char compatibility.
   -  fix: linux: patch function, inst function port.

   1.1.1
   -  fix: massive linux reworks. no longer following
      symbolic links. some functions unusable so far
      now have at least alpha status.
   -  chg: complete rework of mirrorto backup function,
      which is now renamed to "freezeto", as it is
      primarily intended to create zipped archives.
      -  chg: per-dir zip names changed from 01-arc.zip
         to 01-arc-part.zip for better uniqueness.
         If you used mirrorto previously, cleanup your
         archive tree directories before next use!
      -  add: checksums of copied files now also included
         in md5-arc.txt, to ensure everything's covered
         in verification batch.
      -  fix: freezeto: 09-freeze-log contained only last error,
         now appending all zip messages by double ">".
      -  add: freezeto: local zip header scan while building
         checksums, to verify that files were really added.
   -  add: sfk list: options -time, -size, -size=digits.
   -  fix: now really using 64 bit timestamps with msvc,
      which requires the latest visual compiler.
      added compiler version check, and 32 bit warning.
   -  fix: minor: cleanup of parameter handling.
   -  fix: compile: variable scope in execDirFreeze
*/

// NOTE: if you change the source and create your own derivate,
// fill in the following infos before releasing your version of sfk.
#define SFK_BRANCH   ""
#define SFK_VERSION  "1.5.8"  // ver_ and check the _PRE definition
#define SFK_FIXPACK  ""
#ifndef SFK_PROVIDER
#define SFK_PROVIDER "unknown"
#endif

// in case of linking problems concerning libsocket etc.,
// you may out-comment this to compile without tcp support:
#ifndef USE_SFK_BASE
 #define WITH_TCP
 #define SFK_FTP_TIMEOUT "30" // seconds, as string
#endif // USE_SFK_BASE

#define USE_SFT_UPDATE

#define SFK_CCDIRTIME // copy over created dir time

// should you get problems with fsetpos/fgetpos compile,
// activate this to disable zip/jar file content listing:
// #define NO_ZIP_LIST

#ifdef _WIN32
 #define VER_STR_OS "windows-any"
 #define _WIN32_WINNT 0x0400 // for copyFileEx
#else
 #ifdef MAC_OS_X
  #ifdef MAC_OS_X_PPC
   #define VER_STR_OS "mac-osx-ppc"
  #endif
  #ifdef MAC_OS_X_I686
   #define VER_STR_OS "mac-osx-i686"
  #endif
  #ifndef VER_STR_OS
   #define VER_STR_OS "mac-osx"
  #endif
 #else
  #ifdef SFK_LIB5
   #define VER_STR_OS "linux-lib5"
  #else
   #define VER_STR_OS "linux-lib6"
  #endif
 #endif
#endif

// SFK_PRE_RELEASE?
// #define SFK_VERTYPE "Pre"

#define VER_DAT_STR "date=" __DATE__

#define  MTKTRACE_CODE
#include "sfkbase.hpp"

#ifdef VFILEBASE
#endif // VFILEBASE

#ifdef USE_SFK_BASE
 #define NO_VER_STR
#endif

#ifndef NO_VER_STR
// binary version tag, is also parsed in version command.
// $version:vernum,shortid,full name,type$\0"
 #ifndef SFK_VERTYPE
  #define SFK_VERTYPE "Base" // version type
 #endif
 #ifndef SFK_VERTEXT
  #define SFK_VERTEXT "/OSE" // open source edition
 #endif
static const char *pszGlblVersion =
   "$version:vernum=" SFK_VERSION ",name=sfk,title=Swiss File Knife,info=-,os=" VER_STR_OS ",type=" SFK_VERTYPE SFK_VERTEXT ",fix=" SFK_FIXPACK "," VER_DAT_STR "$\0";
static const char *pszGlblVerType = SFK_VERTYPE;
#endif

#define SFK_BOTH_RUNCHARS
// #define SFK_STRICT_MATCH

#ifndef USE_SFK_BASE
 #define WITH_FN_INST
#endif // USE_SFK_BASE

#ifndef USE_SFK_BASE
 #ifdef WINFULL
  #define SFK_MEMTRACE
 #endif
#endif

#ifdef _WIN32
 #ifdef SFK_MEMTRACE
  #include "memdeb.cpp"
 #endif
#endif

#ifdef WINCE
 // #include "sfkwince.cpp"
#endif

#if defined(_WIN32) && defined(SFK_WINPOPUP_SUPPORT)
 #include "winpop.cpp"
#endif

void initWildCards() {
   #ifndef _WIN32
   char c = '%'; // linux wildcard default
   char *pszWC = getenv("SFK_CONFIG");
   if (pszWC) pszWC  = strstr(pszWC, "wildstar:");
   if (pszWC) pszWC += strlen("wildstar:");
   if (pszWC) c = *pszWC;
   memset(glblWildStr    , 0, sizeof(glblWildStr));
   memset(glblWildInfoStr, 0, sizeof(glblWildInfoStr));
   glblWildStr[0]     = c;
   glblWildChar       = c;
   glblWildInfoStr[0] = c;
   #endif
}

bool isWildChar(char c) {
   #ifdef _WIN32
   return (c == glblWildChar);
   #else
   return (c == '*' || c == glblWildChar);
   #endif
}
bool isWildStr(char *p) {
   if (strlen(p) != 1) return false;
   return isWildChar(p[0]);
}

void setTextColor(long n, bool bStdErr=0);
long perr(const char *pszFormat, ...);
long pwarn(const char *pszFormat, ...);
long pinf(const char *pszFormat, ...);

// ========== 64 bit abstraction layer begin ==========

char *numtostr(num n, int nDigits, char *pszBuf, int nRadix)
{
   static char szBuf[100];
   if (!pszBuf)
        pszBuf = szBuf;

   #ifdef _WIN32
   if (nRadix == 10)
      sprintf(pszBuf, "%0*I64d", nDigits, n);
   else
      sprintf(pszBuf, "%0*I64X", nDigits, n);
   return pszBuf;
   #else
   if (nRadix == 10)
      sprintf(pszBuf, "%0*lld", nDigits, n);
   else
      sprintf(pszBuf, "%0*llX", nDigits, n);
   return pszBuf;
   #endif
}

char *numtoa_blank(num n, int nDigits)
{
   static char szBuf2[100];
   #ifdef _WIN32
   sprintf(szBuf2, "% *I64d", nDigits, n);
   return szBuf2;
   #else
   sprintf(szBuf2, "% *lld", nDigits, n);
   return szBuf2;
   #endif
}

char *numtoa(num n, int nDigits, char *pszBuf) {
   return numtostr(n, nDigits, pszBuf, 10);
}

char *numtohex(num n, int nDigits, char *pszBuf) {
   return numtostr(n, nDigits, pszBuf, 0x10);
}

num atonum(char *psz)
{
   #ifdef _WIN32
   return _atoi64(psz);
   #else
   return atoll(psz);
   #endif
}

// atonum with support for decimal and 0x hex values
num myatonum(char *psz)
{
   if (!strncmp(psz, "0x", 2)) {
      #ifdef _WIN32
      return _strtoui64(psz+2, 0, 0x10);
      #else
      return strtoull(psz+2, 0, 0x10);
      #endif
   } else {
      return atonum(psz);
   }
}

mytime_t getSystemTime()
{
   static mytime_t stSysTime = 0;
   #ifdef SFK_W64
   return _time64(&stSysTime);
   #else
   return time(&stSysTime);
   #endif
}

// ========== 64 bit abstraction layer end ============

// ====== SFK primitive function library begin ========

char *ownIPList(int &rhowmany, ulong nPort=0, const char *psep=" or ");

// all closesocket calls are redirected to:
void myclosesocket(SOCKET hsock, bool bread, bool bwrite)
{
   int nmode = 0;

   if (bread  && !bwrite)
      nmode = SHUT_RD;     // no more receptions
   else
   if (!bread && bwrite)
      nmode = SHUT_WR;     // no more transmissions
   else
   if (bread  && bwrite)
      nmode = SHUT_RDWR;   // no more transfers at all

   // signal the tcp stack that transmission stops,
   // so the receiver side may receive remaining data.
   shutdown(hsock, nmode);

   #ifdef _WIN32
   closesocket(hsock);
   #else
   close(hsock);
   #endif
}

// just close on a socket is not enough.
// myclosesocket also does the shutdown().
#define closesocket myclosesocket

num getCurrentTime()
{
   #ifdef _WIN32
   return (num)GetTickCount();
   #else
   struct timeval tv;
   gettimeofday(&tv, NULL);
   return ((num)tv.tv_sec) * 1000 + ((num)tv.tv_usec) / 1000;
   #endif
}

// copies a maximum of nMaxDst MINUS ONE chars,
// AND adds a zero terminator at pszDst (within nMaxDst range!).
// to use this like strncpy, always add +1 to nMaxDst.
// NOTE: if nMaxDst == 0, NO zero terminator is added.
void mystrcopy(char *pszDst, char *pszSrc, long nMaxDst) {
   if (nMaxDst < 2) {
      if (nMaxDst >= 1)
         pszDst[0] = '\0';
      return;
   }
   long nLen = strlen(pszSrc);
   if (nLen > nMaxDst-1)
      nLen = nMaxDst-1;
   memcpy(pszDst, pszSrc, nLen);
   pszDst[nLen] = '\0';
}
#define strcopy(dst,src) mystrcopy(dst,src,sizeof(dst)-10)

uchar *mymemdup(char *psz, long nlen)
{
   uchar *p = new uchar[nlen+2];
   if (!p) return p;
   memcpy(p, psz, nlen);
   p[nlen] = '\0'; // tolerance
   return p;
}

// remove blanks from right side of a string
void myrtrim(char *pszBuf) {
   long nlen = strlen(pszBuf);
   while (nlen > 0 && pszBuf[nlen-1] == ' ') {
      pszBuf[nlen-1] = '\0';
      nlen--;
   }
}

void skipUntil(char **pp, char *pdelim) {
   char *p = *pp;
   while (*p && !strchr(pdelim, *p))
      p++;
   *pp = p;
}

void skipOver(char **pp, char *pdelim) {
   char *p = *pp;
   while (*p && strchr(pdelim, *p))
      p++;
   *pp = p;
}

void skipToWhite(char **pp) { skipUntil(pp, " \t\r\n"); }
void skipWhite(char **pp)   { skipOver(pp, " \t\r\n");  }

long prepareTCP()
{
   static bool bDone = 0;
   if (!bDone)
   {
      bDone = 1;
      #ifdef _WIN32
      WORD wVersionRequested = MAKEWORD(1,1);
      WSADATA wsaData;
      if (WSAStartup(wVersionRequested, &wsaData)!=0)
         return 9+perr("WSAStartup failed\n");
      #endif
   }
   return 0;
}

char *ownIPList(int &rhowmany, ulong nPort, const char *psep)
{
   prepareTCP();

   static char szIPListBuf[200];
   szIPListBuf[0] = '\0';

   char szPortStr[50];
   szPortStr[0] = '\0';
   if (nPort > 0)
      sprintf(szPortStr, ":%lu", nPort);

   #ifdef _WIN32

   char *pownip = "";
   struct in_addr addr;

   hostent *pinfo = gethostbyname(""); // fails under linux
   if (pinfo) {
      memcpy(&addr,pinfo->h_addr_list[0],sizeof(struct in_addr));
      pownip = inet_ntoa(addr);
      strcopy(szIPListBuf, pownip);
      strcat(szIPListBuf, szPortStr); // if any
      rhowmany = 1;
   }

   #else

   // linux: list all existing interface IPV4 addresses
   struct ifaddrs *pAdrObj = NULL;
   char szAdrBuf[200]; mclear(szAdrBuf);
   getifaddrs(&pAdrObj);
   const char *pprefix = "";
   int ndone = 0;
   while (pAdrObj != NULL) {
     if (pAdrObj->ifa_addr->sa_family==AF_INET && strcmp(pAdrObj->ifa_name, "lo0")) {
       void *pIPData = &((struct sockaddr_in *)pAdrObj->ifa_addr)->sin_addr;
       const char *pszIP = inet_ntop(AF_INET, pIPData, szAdrBuf, sizeof(szAdrBuf)-10);
       if (strcmp(pszIP, "127.0.0.1")) {
          int nlen = strlen(pszIP);
          int nrem = (int)sizeof(szIPListBuf) - (int)strlen(szIPListBuf);
          if (nlen < nrem - 10) {
             strcat(szIPListBuf, pprefix);
             strcat(szIPListBuf, pszIP);
             strcat(szIPListBuf, szPortStr); // if any
             pprefix = psep;
             ndone++;
          }
       }
     }
     pAdrObj = pAdrObj->ifa_next;
   }
   rhowmany = ndone;

   #endif

   return szIPListBuf;
}

// ====== SFK primitive function library end   ========

// ====== SFK trace mode crash handler begin ========

#ifdef WITH_TRACING

static void traceModeCrashHandler(int sig)
{
   static int crashRecursionCounter = 0;
   crashRecursionCounter++;
   if (crashRecursionCounter < 2)
   {
      crashRecursionCounter++;
      // dump stack trace to error log
      mtkDumpStackTrace(0);
      mtkDumpLastSteps(0);
   }
   printf("sfk exits due to segment violation.\n");
   exit(255);
}

#ifndef USE_SFK_BASE
void initCrashHandler()
{
   void (*pfhand)(int) = traceModeCrashHandler;
   sigset_t mask;
   sigemptyset(&mask);
#ifdef SIGSEGV
   signal (SIGSEGV, pfhand);
   sigaddset(&mask, SIGSEGV);
#else
   #error no_sigsegv_defined
#endif
#ifdef SIGFPE
   signal (SIGFPE, pfhand);
   sigaddset(&mask, SIGFPE);
#else
   #error no_sigfpe_defined
#endif
#ifdef SIGILL
   signal (SIGILL, pfhand);
   sigaddset(&mask, SIGILL);
#else
   #error no_sigill_defined
#endif
#ifdef SIGABRT
   signal (SIGABRT, pfhand);
   sigaddset(&mask, SIGABRT);
#else
   #error no_sigabrt_defined
#endif
   sigprocmask(SIG_UNBLOCK, &mask, 0);
}
#endif // USE_SFK_BASE

#endif

// ====== SFK trace mode crash handler end ========

static bool bGlblCurCmdSet = 0;
static char szGlblCurCmd[50];

class CommandScope {
public:
      CommandScope (char *pszcmd);
     ~CommandScope ( );
};

CommandScope::CommandScope(char *pszcmd) {
   strcopy(szGlblCurCmd, pszcmd);
   bGlblCurCmdSet = 1;
}

CommandScope::~CommandScope() {
   bGlblCurCmdSet = 0;
}

#ifdef VFILEBASE

const char *pGlblHttpUserAgent = 0;

static char szGlblUserAgent[100];

void setHTTPUserAgent(const char *psz)
   { pGlblHttpUserAgent = psz; }

char *getHTTPUserAgent() 
{

   if (pGlblHttpUserAgent)
      return (char*)pGlblHttpUserAgent;

   if (bGlblCurCmdSet)
      snprintf(szGlblUserAgent, sizeof(szGlblUserAgent)-10,
         "Swiss File Knife " SFK_VERSION " %s (" VER_STR_OS ")",
            szGlblCurCmd);
   else
      snprintf(szGlblUserAgent, sizeof(szGlblUserAgent)-10,
         "Swiss File Knife " SFK_VERSION " (" VER_STR_OS ")");

   // capialize os info
   char *pbra = strchr(szGlblUserAgent, '(');
   if (pbra) {
      pbra++;
      bool bfirst=1;
      while (*pbra) {
         char c = *pbra;
         if (isalpha(c) && bfirst)
            { bfirst=0; *pbra=toupper(c); }
         if (!isalpha(c)) bfirst=1;
         pbra++; 
      }
   }

   return szGlblUserAgent;
}

#endif // VFILEBASE

// fwrite on windows network drives may fail with blocks > 60 MB,
// therefore a single block write is limited to this size:
#define SFK_IO_BLOCK_SIZE 10000000 // about 10 MB

// optional callback tracing for hot spots
void (*pGlblTraceCallback)(char *pmsg) = 0;
static char szTraceBuf[1024+10];
void cbtrace(const char *pszFormat, ...)
{
   if (!pGlblTraceCallback) return;
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szTraceBuf, sizeof(szTraceBuf)-10, pszFormat, argList);
   szTraceBuf[sizeof(szTraceBuf)-10] = '\0';
   pGlblTraceCallback(szTraceBuf);
}

long getFileStat( // RC == 0 if exists anything
   char  *pszName,
   long   &rbIsDirectory,
   long   &rbCanRead,
   long   &rbCanWrite,
   num    &rlFileTime,
   num    &rlFileSize,
   num   *ppcatimes = 0, // optional: creation and access time
   void  *prawstat = 0,  // optional: create copy of stat structure
   long   nrawstatmax=0  // size of above buffer
 );

#define delstring(x) \
   if (x) {          \
      delete [] x;   \
      x = 0;         \
   }

// this also sets zero terminator at end of string,
// i.e. nmaxlen means including zero terminator.
void setattr(char *pdst, uchar uc, ulong nlen, ulong nmaxlen)
{
   if (nlen > nmaxlen) nlen = nmaxlen;
   if (nlen > 0) {
      memset(pdst, uc, nlen-1);
      pdst[nlen-1] = '\0';
   } else {
      pdst[0] = '\0';
   }
}

bool myisxdigit(char c) {
   if (c >= '0' && c <= '9') return 1;
   if (c >= 'a' && c <= 'f') return 1;
   if (c >= 'A' && c <= 'F') return 1;
   return 0;
}

long getTwoDigitHex(char *psz)
{
   char szHex[10];

   if (!*psz) return -1;
   szHex[0] = tolower(*psz++);
   if (!myisxdigit(szHex[0])) return -1;

   if (!*psz) return -1;
   szHex[1] = tolower(*psz++);
   if (!myisxdigit(szHex[1])) return -1;

   szHex[2] = '\0';

   return (long)strtoul(szHex,0,0x10);
}

void doSleep(long nmsec) 
{
   #ifdef _WIN32
   Sleep(nmsec);
   #else
   // sleep(1);
   const timespec ts = { nmsec / 1000, nmsec % 1000 * 1000000 };
   nanosleep(&ts, NULL);  
   #endif
}

enum eWalkTreeFuncs {
   eFunc_MD5Write = 1,
   eFunc_JamFile  = 2,  // fixed value
   eFunc_CallBack = 3,  // fixed value
   eFunc_Detab       ,
   eFunc_Entab       ,
   eFunc_JamIndex    ,
   eFunc_SnapAdd     ,
   eFunc_FileStat    ,
   eFunc_Grep        ,
   eFunc_Mirror      ,
   eFunc_Run         ,
   eFunc_FormConv    ,
   eFunc_Inst        ,
   eFunc_RefColSrc   ,  // collect reflist sources
   eFunc_RefColDst   ,  // collect reflist targets
   eFunc_Deblank     ,
   #ifdef WITH_TCP
   eFunc_FTPList     ,
   eFunc_FTPNList    ,
   eFunc_FTPLocList  ,
   #endif // WITH_TCP
   eFunc_Hexdump     ,
   eFunc_Copy        ,
   eFunc_Cleanup     ,
   eFunc_AliasList   ,
   eFunc_ReplaceFix  ,
   eFunc_ReplaceVar  ,
   eFunc_MetaUpd     ,
   eFunc_MetaCheck   ,
   eFunc_Scantab     ,
   eFunc_Filter      ,
   eFunc_Delete      ,
   eFunc_DupScan     ,
   eFunc_Version     ,
};

enum eConvTargetFormats {
   eConvFormat_LF     = 1,
   eConvFormat_CRLF   = 2
};

long nGlblShellRC = 0;

struct CommandStats 
{
public:
   CommandStats   ( );
   void reset     ( );

   long debug     ;
   long verbose   ;  // 0,1,2
   bool delStaleFiles      ;
   bool skipOwnMetaDir     ;
   bool blockAutoComplete  ;
   long tabSize   ;
   long tabsDone  ;
   long tabFiles  ;
   long scanTabs  ;
   bool scanIndent;
   long indentFilt;

   long files     ; // visible plus hidden
   long filesChg  ; // no. of files changed
   long noFiles   ; // fnames that failed to stat etc.
   long dirs      ; // visible plus hidden
   long filesCloned ; // no. of files with attributes copied
   long dirsCloned  ; // no. of dirs with attributes copied
   bool hidden    ; // include hidden files and dirs
   long numHiddenFiles ; // for list stats
   long numHiddenDirs  ; // for list stats
   long numHiddenFilesSkipped ;
   long numHiddenDirsSkipped  ;
   long binariesSkipped ;
   long addedFilesSkipped ; // on -sincedif
   long shadowsWritten ;
   long shadowFallbacks ;
   long filesDeleted ;
   long filesDeletedWP;
   long dirsDeleted  ;
   long dirsDeletedWP;
   long filesScanned ;
   long dirsScanned  ;
   long filesNewerInDst ;
   long filesStale ; // deletion candidate
   long lines    ;
   num  maxFileTime;
   ulong listForm;   // list -size etc.
   bool sim   ;      // just simulate command
   bool nohead;      // leave out some header, trailer info
   bool pure  ;      // extra info if -pure was specified
   bool dostat;      // copy: list just size statistics
   bool tailTail;    // running tail, not head
   long tailLines;   // head, tail
   bool tailFollow;  // head, tail
   char *tomask;     // output filename mask
   char *curcmd;     // current command
   bool rootrelname; // use filenames relative to root dir
   bool rootabsname; // force absolute names
   bool writeall;    // write all files, not only changed oned
   bool spat;        // enable slash patterns \t etc.
   bool wpat;        // support * and ?
   bool usecase;     // case-sensitive search or not
   bool nocase;      // optional: forced nocase on binary search
   long blankRunFiles;  // no. of filenames w/blanks passing run
   long wrongpcRunFiles;// no. of filenames w/wrong path chars
   long badNameForm;    // set by execRunFile on bad filename formats
   bool nocheck;     // do not perform any checks
   bool noinfo;      // do not tell infos
   bool nochain;     // disable command chains
   bool useJustNames;// create a list of filenames
   bool countMatchLines; // count no. of matching lines
   bool yes;
   bool force;
   bool syncFiles;   // sync files instead of copy
   bool syncOlder;   // with sync, copy older over newer files
   bool nonames;     // do NOT print/pass :file records
   char *runCmd;     // default: "" if not set.
   bool printcmd;    // run: print raw command
   long stoprc;      // run: stop on rc >= stoprc
   bool anymatches;  // find: found at least 1 matching line in 1 file
   bool showrc;      // print rc at program end
   bool deplist;     // deplist command selected
   long refsrccnt;   // reflist, deplist: no. of sources
   bool depsingle;   // process dependencies of a single file
   bool coldstnames; // reflist, deplist: execRefColSrc also collects DstNames
   bool refstripsrc; // strip source file contents from unused chars
   long listByTime;
   bool listByTimeAll;
   long listBySize;
   bool listBySizeAll;
   long listByName;
   bool listByNameAll;
   bool tellExecTime;
   long timeOutMSec;
   bool timeOutAutoSelect;
   num  selMinSize;  // consider only files >= so many bytes
   bool nowarn;      // disable all warning output
   bool noerr;       // disalbe all error output
   bool nonotes;     // disalbe all note output
   bool skipLinks;   // do not follow symbolic directory links
   bool traceFileFlags;
   bool fileMaskAndMatch;  // AND match of file mask parts
   bool pathMaskAndMatch;  // AND match of path mask parts
   bool incFNameInPath;    // include filename in path mask check
   bool verifyEarly;       // copy: verify directly after write
   bool verifyLate;        // copy: verify in a separate pass
   FILE *outfile;          // can be used by chain.print
   bool listTargets;       // force target name listing i/o src
   long idleMode;          // low prio processing, 0 (off) to 2
   long walkDirDelay;      // low prio file processing with delays
   long walkFileDelay;     // low prio file processing with delays
   long treeStopRC;        // stop tree processing on internal RC >= this
   bool stopTree(long nrc);   // tells if to stop on the supplied rc
   bool toldTreeStop;
   bool skipDirFileColl;   // optim: do not collect flist per dir.
   // cannot be set w/functions that strictly need those lists.
   bool rcFromError;       // change shell rc on skipped errors
   bool repDump;           // replace: create hexdump of hits
   bool repDumpHalve;      // replace: hexdump only source side
   bool withdirs;          // include directories in command
   bool justdirs;          // process only directories
   bool usesnap;           // interpret snapfile format and list titles
   bool usesnapfiltname;   // filter filenames as well
   long addsnapraw;        // snapto raw mode 1 or 2
   const char *addsnaplf;  // "\n" or "\r\n" depending on mode and OS
   ulong addsnapmeta;      // bit 0:time 1:size 2:encoding
   long stathilitelevel;   // stat command: highlight dirs <= this
   bool travelzips;        // traverse zipfile contents
   bool incbin;            // include binary files in processing
   bool reldist;           // hexfind: tell also relative distances
   #ifdef VFILEBASE
   bool shallowzips;       // list only first level of zips
   bool precachezip;
   bool extdomref;         // include external domain refs
   bool xelike;            // set xe default behaviour and help text
   bool cacheall;          // no direct processing of files
   bool cachestat;         // cache statistics at program end
   bool travelHttp;        // decided per command, esp. list
   #endif // VFILEBASE
   bool subdirs;           // process subdirs
   bool utf8dec;           // utf-8  detect and decode (not yet impl.)
   bool utf16dec;          // utf-16 detect and decode
   long utf16found;        // statistic for post-command info
   long utf16read;         // statistic for post-command info
   bool showdupdirs;       // linux: tell if dir link contents are skipped
   bool usecirclemap;      // linux: allow circle map, on by default
   num  sincetime;         // process only files modified since that time
   num  untiltime;         // process only files modified until that time
   bool usectime;          // use creation time instead of modification time
   char paramprefix[30];   // for user defined script input parameter names
   long wrapcol;           // if >0, auto-wrap lines in snapfile
   long wrapbincol;        // only on binary to text conversion
   bool rewrap;            // ignore linefeeds, rewrap all
   char listunit;          // stat output in 'b'ytes, 'k'bytes or default.
   bool flatdirstat;       // list no. of files per dir, not dir tree
   long flatfilecnt;       // global stats if flatdirstat is set
   long flatdircnt;        // "
   num  flatbytecnt;       // "
   bool statonlysum;       // sfk stat: quiet except summary
   long quiet;             // quiet mode
   bool ftpupdate;         // mput, mget: explicite -update
   bool ftpall;            // mput, mget: disable -update mode
   bool noclone;           // disable time stamp replication
   long fast;              // command dependent optimization
   bool noprog;            // no progress indicator
   bool test;              // filter: run in test mode
   bool copyLinks;         // copy symlinks     , windows only, untested
   bool copyNoBuf;         // copy w/o buffering, windows only, untested
   bool copyDecrypt;       // copy and decrypt  , windows only, untested
   bool intrun;            // sfk run -internal option
   bool textfiles;         // process only textfiles
   bool binaryfiles;       // process only binaryfiles
   bool packalnum;         // deblank: reduce filenames to alnum
   bool noipexpand;        // disallow ip number expansion
};

struct CommandStats gs; // global settings accross whole chain
struct CommandStats cs; // command local statistics or settings

bool infoAllowed() {
   if (cs.quiet)  return 0;
   if (cs.noinfo) return 0;
   return 1;
}

long quietMode() { return cs.quiet; }
long fastMode()  { return cs.fast;  }

#ifdef VFILEBASE
bool csExtDomRef() { return cs.extdomref; }
void setxelike(bool byes) { gs.xelike = cs.xelike = byes; }
bool httpTravel()  { return cs.travelHttp; }
#endif // VFILEBASE

void setArcTravel(bool bYesNo, bool bPreCache) 
{
   mtklog("setarctravel %d %d", bYesNo, bPreCache);
   gs.travelzips  = bYesNo;
   cs.travelzips  = bYesNo;
   #ifdef VFILEBASE
   cs.precachezip = bPreCache;
   #endif // VFILEBASE
}

bool getArcTravel( ) { return cs.travelzips; }

void setSubLoad(bool bYesNo) {
   mtklog("setsubload %d", bYesNo);
   gs.subdirs = bYesNo;
   cs.subdirs = bYesNo;
}

void setHiddenLoad(bool bYesNo) {
   mtklog("sethidload %d", bYesNo);
   gs.hidden = bYesNo;
   cs.hidden = bYesNo;
}

void setBinaryLoad(bool bYesNo) {
   mtklog("setbinload %d", bYesNo);
   gs.incbin = bYesNo;
   cs.incbin = bYesNo;
}

void setUTFLoad(bool bYesNo) {
   mtklog("setutfload %d", bYesNo);
   gs.utf16dec = bYesNo;
   cs.utf16dec = bYesNo;
}

long getWrapLoad(bool &rrewrap) {
   rrewrap = cs.rewrap;
   return cs.wrapcol; 
}
void setWrapLoad(long n, bool brewrap) { 
   cs.wrapcol = n;
   gs.wrapcol = n;
   cs.wrapbincol = (n >= 80) ? ((n * 90) / 100 - 10) : 80;
   gs.wrapbincol = cs.wrapbincol;
   cs.rewrap = brewrap;
   gs.rewrap = brewrap;
}

// tells if cur matches mask, including variations:
// if mask="-sep" then "-sep" and "-ssep" is allowed.
bool isxopt(char *pszcur, char *pszmask)
{
   char szBuf[100];
   if (pszmask[0] != '-') return 0;
   if (strlen(pszmask) > sizeof(szBuf)-10) return 0;

   // check for indirect hit: "-seps".
   // if so, auto-activate slash patterns for this command.
   sprintf(szBuf, "%ss", pszmask);
   if (!strncmp(pszcur, szBuf, strlen(szBuf))) {
      cs.spat = 1;
      return 1;
   }

   // check for direct hit: "-sep"
   if (!strncmp(pszcur, pszmask, strlen(pszmask))) return 1;

   // check for indirect hit: "-ssep"
   char *pszbase = pszmask+1;

   // if so, auto-activate slash patterns for this command.
   sprintf(szBuf, "-s%s", pszbase);
   if (!strncmp(pszcur, szBuf, strlen(szBuf))) {
      cs.spat = 1;
      return 1; 
   }

   // check for "-uform" to activate -upat syntax.
   sprintf(szBuf, "-u%s", pszbase);
   if (!strncmp(pszcur, szBuf, strlen(szBuf))) {
      glblNotChar = ':';
      glblRunChar = '#';
      return 1; 
   }

   return 0;
}

// tells if cur matches mask, without variations.
bool isopt(char *pszcur, char *pszmask) {
   if (!strncmp(pszcur, pszmask, strlen(pszmask))) return 1;
   return 0;
}

CommandStats::CommandStats() { reset(); }

void CommandStats::reset()
{ 
   memset(this, 0, sizeof(*this)); 
   wpat        =  1;
   runCmd      = "";
   treeStopRC  = 19; // NOT 9
   subdirs     =  1;
   utf8dec     =  0;
   utf16dec    =  0; // experimental, NOT yet default
   usecirclemap=  1;
   wrapbincol  = 80; // default
   addsnaplf   = "\n";
}

bool CommandStats::stopTree(long nrc) 
{
   long lRC = 0;
   long nShellRC = 0;
   if (nrc >= treeStopRC) {
      if (!toldTreeStop) {
         toldTreeStop = 1;
         #ifndef USE_SFK_BASE
         long pinf(const char *pszFormat, ...);
         pinf("directory tree processing stopped by error.\n");
         #endif // USE_SFK_BASE
      }
      lRC = 1;
      // on stop, always map fatal rc to shell rc
      if (nrc >= 9) nShellRC = 9;   // error occurred, processing stopped.
      else          nShellRC = nrc; // should not happen
   } else {
      // map masked rc to shell rc
      if (cs.rcFromError) {
         if (nrc >= 7) nShellRC = 7;   // error occurred, processing continued.
         else          nShellRC = nrc; // any other code below 7
      }
   }
   // build maximum shell rc, if any
   if (nShellRC > nGlblShellRC)
      nGlblShellRC = nShellRC;
   // continue or stop tree processing
   return lRC ? 1 : 0;
}

struct CommandPermamentStorage
{
public:
   CommandPermamentStorage ( );

   num  tailnsize;   // current file size of tail
   num  tailnpos;    // current read position of tail
   bool keeptmp;     // do not autodelete tmp files
   bool showtmp;     // verbosely list names of created tmpfiles
}
   cperm;

CommandPermamentStorage::CommandPermamentStorage() { memset(this, 0, sizeof(*this)); }

// a hostbyname with automatic extension of "22" to "192.168.1.22"
struct hostent *sfkhostbyname(const char *pstr, bool bsilent)
{
   char szExpBuf[100];

   char *psz = (char*)pstr;

   bool bdotfirst = 0;
   if (*psz == '.')
      { bdotfirst = 1; psz++; }
   char *ppart = psz;

   bool balldigit = 1;
   for (; *psz; psz++)
      if (!isdigit(*psz))
         { balldigit = 0; break; }
 
   if (!cs.noipexpand && balldigit)
   {
      // auto expand "22" or ".22" to "192.168.1.22"
      mclear(szExpBuf);
      int   nnum  = 0; // number of own ip's
      char *plist = ownIPList(nnum, 0, "\t");
      // copy first 3 segments of own ip, if any
      char *pseg  = strchr(plist, '.');
      if (pseg) pseg = strchr(pseg+1, '.');
      if (pseg) pseg = strchr(pseg+1, '.');
      if (pseg)
      {
         int nlen = (pseg - plist) + 1;
         memcpy(szExpBuf, plist, nlen);
         strcpy(szExpBuf+nlen, ppart);
         if (!bsilent && !cs.noinfo)
            pinf("[nopre] [using %s]\n", szExpBuf);
         pstr = szExpBuf;
      }
   }

   return gethostbyname(pstr);
}

// replace \\t and \\xnn by a single character,
// within a binary block that is not zero-terminated.
long shrinkFormTextBlock(char *psz, long &rLen)
{
   if (!cs.spat)
      return 0; // nothing to do

   // char *psz2 = psz;
   // printf("in : ");
   // for (long i=0; i<rLen; i++) printf("%02X ",psz2[i]);
   // printf("\n");

   long getTwoDigitHex(char *psz);
   long nRemain = rLen;
   while (nRemain > 0)
   {
      if (!strncmp(psz, "\\\\", 2)) {
         memmove(psz+1, psz+2, nRemain-2);
         *psz = '\\';
         nRemain -= 1;
         rLen    -= 1;
      }
      else
      if (!strncmp(psz, "\\t", 2)) {
         memmove(psz+1, psz+2, nRemain-2);
         *psz = '\t';
         nRemain -= 1;
         rLen    -= 1;
      }
      else
      if (!strncmp(psz, "\\q", 2)) {
         memmove(psz+1, psz+2, nRemain-2);
         *psz = '"';
         nRemain -= 1;
         rLen    -= 1;
      }
      else
      if (!strncmp(psz, "\\n", 2)) {
         memmove(psz+1, psz+2, nRemain-2);
         *psz = '\n';
         nRemain -= 1;
         rLen    -= 1;
      }
      else
      if (!strncmp(psz, "\\r", 2)) {
         memmove(psz+1, psz+2, nRemain-2);
         *psz = '\r';
         nRemain -= 1;
         rLen    -= 1;
      }
      else
      if (!strncmp(psz, "\\x", 2)) {
         long n = getTwoDigitHex(psz+2);
         if (n < 0) return 9;
         memmove(psz+1, psz+4, nRemain-4);
         *psz = (char)n;
         nRemain -= 3;
         rLen    -= 3;
      }
      psz++;
      nRemain--;
   }

   // printf("out: ");
   // for (long i=0; i<rLen; i++) printf("%02X ",psz2[i]);
   // printf("\n");

   return 0;
}

long nGlblFunc        = 0;
bool bGlblSyntaxTest  = 0;
bool bGlblCollectHelp = 0;
long nGlblActiveFileAgeLimit = 30; // days
long nGlblErrors   = 0;
long nGlblWarnings = 0;
long nGlblTraceSel = 0; // b0:dirs b1:files
bool bGlblMD5RelNames = 0;
bool bGlblHaveInteractiveConsole = 0;
bool bGlblEnableOPrintf = 1; // allow codepage conversion w/in oprintf
bool bGlblForceCConv = 0;    // enfore codepage conversion w/in oprintf
bool bGlblAllowGeneralPure = 0; // command dependent
bool bGlblPauseOnError = 0;  // pause after every error
bool bGlblPauseOnEnd   = 0;  // pause before program end
bool bGlblOldMD5 = 0;
char *pszGlblOutFile = 0;  // if set, some funcs will take care not to read this file
char *pszGlblSaveTo  = 0;  // if set, some funcs will save output files to this path
FILE *fGlblOut     = 0; // general use
FILE *fGlblCont    = 0; // freezeto: content list
FILE *fGlblMD5Arc  = 0;
FILE *fGlblMD5Org  = 0;
FILE *fGlblBatch   = 0;
FILE *fGlblTimes   = 0;

#ifdef VFILEBASE
   #include "sfknet.hpp"
#endif // VFILEBASE

unsigned char abBuf[MAX_ABBUF_SIZE+100];
char szLineBuf[MAX_LINE_LEN+10];
char szLineBuf2[MAX_LINE_LEN+10];
char szLineBuf3[MAX_LINE_LEN+10];
char szAttrBuf[MAX_LINE_LEN+10];
char szAttrBuf2[MAX_LINE_LEN+10];
char szAttrBuf3[MAX_LINE_LEN+10];
char szRefNameBuf[MAX_LINE_LEN+10];
char szRefNameBuf2[MAX_LINE_LEN+10];
char szOutNameBuf[MAX_LINE_LEN+10];
char szRunCmdBuf[MAX_LINE_LEN+10];
#define MAX_MATCH_BUF 500
char szMatchBuf[MAX_MATCH_BUF+10];  // strmatch word buffer
bool szMatchEsc[MAX_MATCH_BUF+10];  // strmatch escape flags
char *pszGlblPreRoot = 0;
char szGlblMixRoot[MAX_LINE_LEN+10];
bool bErrBufSet = 0;
char *pszGlblJamPrefix = ":file:";
char *pszGlblJamRoot = 0;
bool  bGlblJamPure = 0;
#define MAX_JAM_TARGETS 1000
char *apJamTargets[MAX_JAM_TARGETS];
num   alJamTargetTime[MAX_JAM_TARGETS];
num   nJamSnapTime = -1;
long  nJamTargets  = 0;
char *pszGlblRepSrc = 0;
char *pszGlblRepDst = 0;
char *pszGlblBlank =
   "                                                "
   "                                                ";
num  nGlblStartTime = 0;
num  nGlblListMinSize = 0; // in bytes
long nGlblListMode = 0;    // 1==stat 2==list
int  nGlblListDigits = 12;
bool bGlblEscape = 0;
char *pszGlblDstRoot = 0;
num nGlblBytes = 0;
char *pszGlblDirTimes = 0;
char *pszGlblTurn = "\\|/-";
long  nGlblTurnCnt = 0;
bool  bGlblQuoted     = 0; // list: add quotes around filenames
bool  bGlblNoRootDirFiles = 0; // list -dir +dirmask
ulong nGlblConvTarget = 0; // see eConvTargetFormats
#ifdef WITH_FN_INST
bool  bGlblInstRevoke = 0;
bool  bGlblInstRedo   = 0;
bool  bGlblInstEol    = 0;
char *pszGlblInstInc  = "";
char *pszGlblInstMac  = "";
static bool bGlblTouchOnRevoke = 1;
#endif
char *pszGlblSnapFileStamp    = ":snapfile sfk,1.1,lprefix=";
char *pszGlblClusterFileStamp = ":cluster sfk,1.0.7,prefix=:";
bool  bGlblRefRelCmp    = 1;
bool  bGlblRefBaseCmp   = 0;
bool  bGlblRefWideInfo  = 0;
long  nGlblRefMaxSrc    = 10;
bool  bGlblRefLimitReached = 0;
bool  bGlblStdInAny     = 0;  // all cmd except run: take list from stdin
bool  bGlblStdInFiles   = 0;  // run only: take filename list from stdin
bool  bGlblStdInDirs    = 0;  // run only: take directory list from stdin
long  nGlblMD5Skip      = 0;
bool  bGlblMirrorByDate = 0;  // inofficial, might be removed.
char *pszGlblXCopyCmd   = 0;
char *pszGlblZipCmd     = 0;
char *pszGlblUnzipCmd   = 0;
char *pszGlblSFKCmd     = 0;
long nGlblZipVersionHi  = 0;
long nGlblZipVersionLo  = 0;
long nGlblUnzipVersionHi = 0;
long nGlblUnzipVersionLo = 0;
long nGlblTCPMaxSizeMB   = 500;
// #ifdef WITH_TCP
SOCKET hGlblTCPOutSocket = 0;
bool bGlblFTPReadWrite   = 0;
bool bGlblFTPSetAttribs  = 0;
bool bGlblFTPListFlatTS  = 0; // server: send flat timestamp on list
bool bGlblFTPListAsHTML  = 0;
// #endif // WITH_TCP
bool bGlblBinGrep           = 0;
bool bGlblBinGrepAutoDetect = 1;
uchar nGlblBinTextBinRange  = 0xFF;
long nGlblDarkColBase    = 0;
long nGlblBrightColBase  = 1;
bool bGlblSysErrDetail   = 0;

// highlight=1 red=2 green=4 blue=8
#ifdef _WIN32
bool bGlblUseColor       =  1;
bool bGlblUseHelpColor   =  1;
// windows default safety colors for ANY background.
// will be changed automatically if black background is detected.
// help part
long nGlblHeadColor      =  5; // green
long nGlblExampColor     = 11; // purple (magenta)
// functional part
long nGlblFileColor      = 11; // purple
long nGlblLinkColor      = 12; // cyan
long nGlblHitColor       =  5; // green
long nGlblRepColor       =  7; // yellow
long nGlblErrColor       =  3; // red
long nGlblWarnColor      = 11; // purple
long nGlblPreColor       =  9; // bright blue
long nGlblTimeColor      =  9; // bright blue
long nGlblTraceIncColor  = 12; // cyan
long nGlblTraceExcColor  = 11; // purple
#else
bool bGlblUseColor       =  0;
bool bGlblUseHelpColor   =  0;
// unix default colors for white background
long nGlblFileColor      = 10; // purple
long nGlblLinkColor      = 12; // cyan
long nGlblHitColor       =  4; // green
long nGlblRepColor       =  8; // blue
long nGlblErrColor       =  2; // red
long nGlblWarnColor      =  2; // red
long nGlblPreColor       =  8; // blue
long nGlblHeadColor      =  4; // green
long nGlblExampColor     = 10; // purple
long nGlblDefColor       =  0; // default
long nGlblTimeColor      =  8; // blue
long nGlblTraceIncColor  = 12; // cyan
long nGlblTraceExcColor  = 11; // purple
#endif

bool bGlblGrepLineNum    = 0;
bool bGlblHtml           = 0;  // for html help creation
bool bGlblShortSyntax    = 0;
bool bGlblAnyUsed        = 0;
bool bGlblAllowAllPlusPosFile = 0;
char *pszGlblSinceDir    = 0;
bool bGlblSinceDirIncRef = 0;
long nGlblMissingRefDirs = 0;
long nGlblMatchingRefDirs= 0;
long nGlblSinceMode      = 0; // b0:add b1:dif
bool bGlblIgnoreTime     = 0;
bool bGlblIgnore3600     = 0;
bool bGlblHexdumpShowLE  = 0;
bool bGlblHexDumpWide    = 0;
long nGlblHexDumpForm    = 0;
num  nGlblHexDumpOff     = 0;
num  nGlblHexDumpLen     = 0;
char  *pszGlblCopySrc    = 0;
char  *pszGlblCopyDst    = 0;
uchar *pGlblWorkBuf      = 0;
num    nGlblWorkBufSize  = 0;
long   nGlblCopyStyle    = 2; // how filenames are dumped onto terminal
long   nGlblCopyShadows  = 0;
num   nGlblShadowSizeLimit = 0;
bool  bGlblUseCopyCache  = 0;
bool  bGlblShowSyncDiff  = 0;
bool  bGlblHavePlusDirMasks = 0; // deprecated
num   nGlblMemLimit      = 300 * 1048576;
char  *pGlblCurrentScript = 0; // while within a script command

#ifdef _WIN32
char *pszGlblAliasBatchHead = "@rem sfk alias batch";
#else
char *pszGlblAliasBatchHead = "# sfk alias batch";
#endif

long nGlblFzMisArcFiles = 0;
long nGlblFzConArcFiles = 0;
long nGlblFzConArchives = 0;
long nGlblFzMisCopFiles = 0;
long nGlblFzConCopFiles = 0;

void cleanupTmpCmdData();
void shutdownAllGlobalData();

// circular link processing blocker.
// used only in a vertical walkFiles() processing run,
// e.g. parameters -dir dir1 -file .cpp -dir dir1 -file .hpp
// will run walkFiles() twice, each time resetting this:
KeyMap glblCircleMap;

#ifndef USE_SFK_BASE
void resetStats()
{
   void resetFileCounter();
   void resetFileSet();

   // reset command statistics:
   // copy global settings into local command settings
   memcpy(&cs, &gs, sizeof(cs));
   resetFileCounter();

   // reset command settings
   cs.quiet    = 0;
   pszGlblSaveTo = 0;
   if (pszGlblSinceDir) { delete [] pszGlblSinceDir; pszGlblSinceDir=0; }

   // reset selected dirs and files
   resetFileSet();

   // reset all temporary command data
   cleanupTmpCmdData();

   // reset circular dependency blocker
   glblCircleMap.reset();
}
#endif // USE_SFK_BASE

class FileList;
class StringPipe;
class Coi;

long execDetab       (char *pszFile, char *pszOutFile);
long execEntab       (char *pszFile);
long execScantab     (char *pszFile);
long execDirMirror   (char *pszName, long  lLevel, FileList &oDirFiles, num &ntime1, num &ntime2);
long execFileMirror  (char *pszFile, num &ntime1, num &ntime2, long nDirFileCnt);
long execDirXCopy    (char *pszName, long  lLevel, FileList &oDirFiles, num &ntime1, num &ntime2);
long execFileXCopy   (char *pszFile, num &ntime1, num &ntime2, long nDirFileCnt);
long execDirFreeze   (char *pszName, long  lLevel, FileList &oDirFiles, num &ntime1, num &ntime2);
long execFileFreeze  (char *pszFile, num &ntime1, num &ntime2, long nDirFileCnt);
long getFileMD5      (char *pszFile, SFKMD5 &md5, bool bSilent=0, bool bInfoCycle=0);
long execFormConv    (char *pszFile, char *pszOutFile);
long execHexdump     (char *pszFile, uchar *pBuf, ulong nBufSize); // from file or buffer
long walkFiles       (Coi  *pcoi, long lLevel, long &nGlobFiles, FileList &oDirFiles, long &lDirs, num &lBytes, num &ntime1, num &ntime2);
long execSingleFile  (Coi  *pcoi, long lLevel, long &lGlobFiles, long nDirFileCnt, long &lDirs, num &lBytes, num &ntime1, num &ntime2);
long execSingleDir   (Coi  *pcoi, long lLevel, long &lGlobFiles, FileList &oDirFiles, long &lDirs, num &lBytes, num &ntime1, num &ntime2);
long execFileCopy    (Coi  *pcoi);
long execDirCopy     (char *pszSrc, FileList &oDirFiles);
long execFileCleanup (char *pszFile);
long execDirCleanup  (char *pszSrc, FileList &oDirFiles);
long timeFromString  (char *psz, num &nRetTime);
bool tryGetRelTime   (char *psz, num &nRetTime);
long execReplaceFix  (Coi *pcoi);
long execReplaceVar  (Coi *pcoi);
size_t myfread       (uchar *pBuf, size_t nBytes, FILE *fin , num nMaxInfo=0, num nCur=0, SFKMD5 *pmd5=0);
size_t myfwrite      (uchar *pBuf, size_t nBytes, FILE *fout, num nMaxInfo=0, num nCur=0, SFKMD5 *pmd5=0);
char *rootRelativeName(char *pszFileName, char *pszOptRoot);
char *relativeFilename(char *pszPath);
void myfgets_init    ( );
long myfgets         (char *pszOutBuf, long nOutBufLen, FILE *fin, bool *rpBinary=0, char *pAttrBuf=0);
long execFilter      (Coi *pcoi, FILE *fin = 0, StringPipe *pin = 0, long nMaxLines = -1, char *pszOutFile = 0);
long execDelFile     (char *pszName);
long execDelDir      (char *pszName, long lLevel, long &lGlobFiles, FileList &oDirFiles, long &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2);
long execVersion     (Coi *pcoi);

// set/provide a minimum info about the current I/O operation.
// if called multithreaded, this should not crash but in the
// worst case return only incomplete info strings.

class IOStatus {
public:
      IOStatus  ( );

      void   setInfo (char *pinfo);
      char  *getInfo (num &nagemsec, num &nbytes, num &nmaxbytes);

      num   countBytes  (num nbytes);
      void  setMaxBytes (num nbytes);
      void  resetBytes  ( );

private:
      char  szClStatus[200+20];
      num   nClSince;
      num   nClBytes;
      num   nClMaxBytes;
};
static IOStatus iostat;

IOStatus::IOStatus() {
   memset(this, 0, sizeof(*this));
}

void IOStatus::setInfo(char *pinfo) {
   memset(szClStatus, 0, sizeof(szClStatus));
   if (!pinfo) {
      nClSince = 0;
      return;
   }
   strncpy(szClStatus, pinfo, sizeof(szClStatus)-20);
   nClSince = getCurrentTime();
}

char *IOStatus::getInfo(num &nagemsec, num &nbytes, num &nmaxbytes) {
   if (!szClStatus[0]) return 0;
   if (nClSince > 0) {
      num nage  = getCurrentTime() - nClSince;
      nagemsec  = nage;
      nbytes    = nClBytes;
      nmaxbytes = nClMaxBytes;
   } else {
      nagemsec  = 0;
      nbytes    = 0;
      nmaxbytes = 0;
   }
   return szClStatus;
}

num IOStatus::countBytes(num nbytes) {
   nClBytes += nbytes;
   return nClBytes;
}

void IOStatus::setMaxBytes(num nbytes) {
   nClMaxBytes = nbytes;
}

void IOStatus::resetBytes() {
   nClBytes = 0; 
   nClMaxBytes = 0;
}

IOStatusPhase::IOStatusPhase(char *pinfo) {
   iostat.setInfo(pinfo);
}

IOStatusPhase::~IOStatusPhase( ) {
   // iostat.setInfo(0);
}

char *getIOStatus(num &nage, num &nbytes, num &nmaxbytes) {
   return iostat.getInfo(nage, nbytes, nmaxbytes); 
}
num   countIOBytes(num nbytes)   { return iostat.countBytes(nbytes); }
void  setIOStatMaxBytes(num n)   { iostat.setMaxBytes(n); }
void  resetIOBytes( )   { iostat.resetBytes(); }
void  resetIOStatus( )  { iostat.setInfo(0); iostat.resetBytes(); }

#ifndef _WIN32
char *readDirEntry(DIR *d) {
  struct dirent *e;
  e = readdir(d);
  return e == NULL ? (char *) NULL : e->d_name;
}
#endif

// extended skip functions, ignore line ends,
// handle quotes and escaped quotes:

void nextToken(char **pp, char &rclast, bool &rbnewline) 
{
   char *p = *pp;
   while (*p && ((*p == ' ') || (*p == '\t') || (*p == '\r') || (*p == '\n') || (*p == '#')) ) {
      // skip # only if it's first char of line
      if (*p == '#' && rclast != '\n')
         break;
      rclast = *p++;
      if (rclast == '\n')
         rbnewline = 1;
   }
   *pp = p;
}

void skipPastToken(char **pp, char &rclast)
{
   char *p = *pp;
   bool besc = 0;
   char cold = 0;
   while (*p) 
   {
      if (*p == '\"' && cold != '\\')
         besc ^= 0x1;
      if (!besc && ((*p == ' ') || (*p == '\t') || (*p == '\r') || (*p == '\n')) )
         break;
      rclast = cold = *p++;
   }
   *pp = p;
}

// strip quotes, transform inner quotes \" to normal quotes "
// uses: szLineBuf, szLineBuf2
long postProcessToken(char **pptok, StringTable &oDynaStrings, int argc, char *argv[], int iParmOffs, int nParm)
{
   char *ptok = *pptok;
   // strip outer quotes, if any
   if (*ptok == '\"') {
      long nlen = strlen(ptok);
      if (ptok[nlen-1] == '\"') {
         memmove(ptok, ptok+1, nlen-1);
         nlen -= 2;         // count both quotes
         ptok[nlen] = '\0'; // readjust terminator
      }
      else return 9; // missing end quote
   }
   // transform inner quotes, if any
   char *psz = ptok;
   while (*psz) {
      if (!strncmp(psz, "\\\"", 2)) {
         long nlen = strlen(psz);
         memmove(psz, psz+1, nlen-1);   // cut backslash
         psz[nlen-1] = '\0'; // new terminator
      }
      if (*psz) psz++;
   }

   // substitute parameters. accept both $1,$2,$3 and %1,%2,%3.
   strcopy(szLineBuf, ptok);
   char szName1[50],szName2[30];
   mclear(szName1);
   mclear(szName2);
   bool bDoneAny = 0;

   // accept "$" and "%" parameters, or user defined?
   bool buserpre = cs.paramprefix[0] ? 1 : 0;

   for (long iparm=0; iparm<9; iparm++)
   {
      char *pcur = szLineBuf;
      while (1)
      {
         long nlen1=0,nlen2=0;
         if (buserpre) {
            sprintf(szName1, "%.20s%ld" , cs.paramprefix, (int)(iparm+1));
            nlen1 = strlen(szName1);
         } else {
            sprintf(szName1, "$%ld" , (int)(iparm+1));
            sprintf(szName2, "%%%ld", (int)(iparm+1));
            nlen1 = strlen(szName1);
            nlen2 = strlen(szName2);
         }
         char *psz  = pcur;
         char clast = (char)-1, cesc = 0;
         long nlenx = 0;
         while (*psz) {
            if (!strncmp(psz, szName1, nlen1)) {
               nlenx = nlen1;
               // allow escapes only if not user defined
               if (!buserpre) cesc = '$';
               break; 
            }
            if (!buserpre && !strncmp(psz, szName2, nlen2))
               { nlenx = nlen2; cesc = '%'; break; }
            clast = *psz++;
         }
         if (!*psz) break;
         if (clast == cesc) {
            /*
               // do NOT replace parm, just unescape it:
               psz--;
               memmove(psz, psz+1, strlen(psz+1)+1); // WITH terminator
               pcur = psz+1;
               // remember we have to dup szLineBuf
               bDoneAny = 1;
               continue;
            */
         }
         // replace $param... by actual value
         char *pval = "";
         if (iparm < nParm) pval = argv[iParmOffs+iparm];
         long nleft = psz-pcur;
         memcpy(szLineBuf2, pcur, nleft);
         long nmid  = strlen(pval);
         memcpy(szLineBuf2+nleft, pval, nmid);
         char *prite= psz+nlenx;
         strcpy(szLineBuf2+nleft+nmid, prite);
         strcpy(pcur, szLineBuf2);
         // step pcur, may have to replace $1 many times
         pcur += nleft+nmid;
         // remember we have to dup szLineBuf
         bDoneAny = 1;
      }
   }
   // do we have to manage a copy of the token?
   if (bDoneAny) {
      if (!strlen(szLineBuf))
         // subst lead to an EMPTY token:
         return 1;
      if (oDynaStrings.addEntry(szLineBuf, -1, &ptok)) // is copied
         return 9+perr("outofmem");
      // ptok should now contain the copy
      if (!ptok) return 9+perr("internal #2310271958");
      // write back ptok, in case it was changed:
      *pptok = ptok;
   }
   return 0;
}

char *mystrrstr(char *psrc, char *ppat) 
{
   if (!psrc || !ppat) return 0;

   char c = *ppat;
   long nsrclen = strlen(psrc);
   long npatlen = strlen(ppat);
   if (npatlen > nsrclen) return 0;

   char *pcur = psrc + nsrclen - npatlen;
   while (pcur >= psrc) {
      if (*pcur == c && !strncmp(pcur, ppat, npatlen))
         return pcur;
      pcur--;
   }
   return 0;
}

char *mystrristr(char *psrc, char *ppat)
{
   if (!psrc || !ppat) return 0;

   char c = *ppat;
   long nsrclen = strlen(psrc);
   long npatlen = strlen(ppat);
   if (npatlen > nsrclen) return 0;

   char *pcur = psrc + nsrclen - npatlen;
   while (pcur >= psrc) {
      if (!mystrnicmp(pcur, ppat, npatlen))
         return pcur;
      pcur--;
   }
   return 0;
}

long   nGlblConsColumns    = 80;
bool   bGlblConsColumnsSet =  0;

long setWriteEnabled(char *pszFile)
{
   #ifdef _WIN32

   BOOL bok = 0;

   #ifdef WINFULL
   WIN32_FILE_ATTRIBUTE_DATA oinf;
   bok = GetFileAttributesEx(pszFile, GetFileExInfoStandard, &oinf);
   if (!bok) return 9;

   oinf.dwFileAttributes &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);
   bok = SetFileAttributes(pszFile, oinf.dwFileAttributes);
   #else
   ulong nattrib = GetFileAttributesA(pszFile);
   nattrib &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);
   SetFileAttributes(pszFile, nattrib);
   #endif

   if (!bok) return 9;

   #else

   struct stat64 buf;
   if (stat64(pszFile, &buf)) return 9;

   mode_t nmode = buf.st_mode | _S_IWRITE;
   if (chmod(pszFile, nmode)) return 9;
   
   #endif

   return 0;
}

FILE *pGlblOpenWriteFile   = 0;
char  szGlblOpenWriteName[MAX_LINE_LEN+10];

void beginFileWrite(char *pszName, FILE *p) {
   pGlblOpenWriteFile = p;
   strcopy(szGlblOpenWriteName, pszName);
}
void endFileWrite() {
   pGlblOpenWriteFile = 0;
   szGlblOpenWriteName[0] = 0;
}
void checkFileWrite() {
   if (pGlblOpenWriteFile)
      perr("unexpected: file left open for write: %s\n", szGlblOpenWriteName);
}
void cleanupFileWrite() {
   if (pGlblOpenWriteFile) {
      // close and remove incomplete (trash) file.
      // may not work here as this is called during interrupt.
      fclose(pGlblOpenWriteFile);
      remove(szGlblOpenWriteName);
   }
}
FILE *myfopen(char *pszName, char *pszMode) {
   FILE *f = fopen(pszName, pszMode);
   if (!f && !strcmp(pszMode, "wb") && fileExists(pszName)) {
      // file is probably write protected
      if (setWriteEnabled(pszName))
         return 0;
      // retry on write-enabled file
      f = fopen(pszName, pszMode);
   }
   if (f) {
      if (pGlblOpenWriteFile)
         pwarn("open for write on %s not registered\n", pszName);
      else
         beginFileWrite(pszName, f);
   }
   return f;
}
void myfclose(FILE *f) {
   if (f == pGlblOpenWriteFile)
      endFileWrite();
   fclose(f);
}

#ifdef _WIN32
HANDLE hGlblConsole     =  0;
WORD   nGlblConsAttrib  =  0;

#define CCMASK_FOREGROUND (FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE|FOREGROUND_INTENSITY)
#define CCMASK_BACKGROUND (BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE|BACKGROUND_INTENSITY)
#define CCMASK_FORE_BACK  (CCMASK_FOREGROUND|CCMASK_BACKGROUND)
#define CCMASK_NOT_FGCOL  (0xFFFF ^ CCMASK_FOREGROUND)

// need this to ensure that commands dumping colored output
// do never leave the shell in a non-std color.
BOOL WINAPI ctrlcHandler(DWORD type)
{
   if (type != CTRL_C_EVENT && type != CTRL_BREAK_EVENT)
      return 0;

   bGlblEscape = 1;
   setTextColor(-1);
   cleanupFileWrite();

   // printf("[user interrupt]\n");
   ExitProcess(8);
   return 1;
}
#else
// unix todo: ctrl+c handler to reset color
void ctrlcHandler(int sig_number)
{
   bGlblEscape = 1;
   setTextColor(-1, 0); // stdout
   setTextColor(-1, 1); // stderr
   cleanupFileWrite();

   // printf("[user interrupt]\n");
   exit(8);
}
#endif

void setColorScheme(char *psz1)
{
   char *psz2 = 0;
   if (!strncmp(psz1, "off", 3))
   {  bGlblUseColor = bGlblUseHelpColor = 0; }
   else
   if (!strncmp(psz1, "on", 2))
      bGlblUseColor = 1;

   if (strstr(psz1, "bright"))
      nGlblDarkColBase = 1;

   if (strstr(psz1, "dark"))
      nGlblBrightColBase = 0;

   if (strstr(psz1, "theme:black")) {
      // autoselect BRIGHT colors with black background.
      nGlblDarkColBase =  1;
      nGlblExampColor  =  7; // bright yellow
      nGlblFileColor   = 15; // bright white
      nGlblLinkColor   = 13; // bright cyan
      nGlblWarnColor   =  7; // bright yellow
   }

   if (strstr(psz1, "theme:white")) {
      // with white background, user may want to select
      // bright or dark colors case by case.
      nGlblHeadColor      =  4; // green
      nGlblExampColor     = 11; // purple
      nGlblFileColor      = 11; // purple
      nGlblLinkColor      = 12; // cyan
      nGlblHitColor       =  3; // green
      nGlblRepColor       =  6; // yellow
      nGlblErrColor       =  3; // red
      nGlblWarnColor      = 11; // purple
      nGlblPreColor       =  8; // blue
      nGlblTimeColor      =  8; // blue
      nGlblTraceIncColor  = 12; // dark magenta
      nGlblTraceExcColor  = 11; // purple
   }

   psz2 = strstr(psz1, "head:");  if (psz2) { nGlblHeadColor  = atol(psz2+5); }
   psz2 = strstr(psz1, "examp:"); if (psz2) { nGlblExampColor = atol(psz2+6); }
   psz2 = strstr(psz1, "file:");  if (psz2) { nGlblFileColor  = atol(psz2+5); }
   psz2 = strstr(psz1, "link:");  if (psz2) { nGlblLinkColor  = atol(psz2+5); }
   psz2 = strstr(psz1, "hit:");   if (psz2) { nGlblHitColor   = atol(psz2+4); }
   psz2 = strstr(psz1, "rep:");   if (psz2) { nGlblRepColor   = atol(psz2+4); }
   psz2 = strstr(psz1, "err:");   if (psz2) { nGlblErrColor   = atol(psz2+4); }
   psz2 = strstr(psz1, "warn:");  if (psz2) { nGlblWarnColor  = atol(psz2+5); }
   psz2 = strstr(psz1, "pre:");   if (psz2) { nGlblPreColor   = atol(psz2+4); }
   #ifndef _WIN32
   psz2 = strstr(psz1, "def:");   if (psz2) { nGlblDefColor   = atol(psz2+4); }
   #endif
   //                   0123456789
   psz2 = strstr(psz1, "time:");     if (psz2) { nGlblTimeColor     = atol(psz2+5); }
   psz2 = strstr(psz1, "traceinc:"); if (psz2) { nGlblTraceIncColor = atol(psz2+9); }
   psz2 = strstr(psz1, "traceexc:"); if (psz2) { nGlblTraceExcColor = atol(psz2+9); }
}

long nGlblCurColor = -1; // currently active color

void setTextColor(long n, bool bStdErr)
{
   if (n == nGlblCurColor) {
      mtklog("color: ignore %ld, is set already", n);
      return;
   }
   nGlblCurColor = n;

   if (bGlblHtml) 
   {
      static bool bAnySet = 0;
      static bool bIsBold = 0;
      ulong ncol = 0;
      if (bAnySet) { printf("</font>"); bAnySet=0; }
      if (bIsBold) { printf("</b>"); bIsBold=0; }
      if (n == -1)
         return;
      bAnySet=1;
      if (n == 1) { bIsBold=1; printf("<b>"); }
      if (n &  2) ncol |= (n&1) ? 0xFF0000 : 0x990000;
      if (n &  4) ncol |= (n&1) ? 0x00FF00 : 0x009900;
      if (n &  8) ncol |= (n&1) ? 0x0000FF : 0x000099;
      if (n & 16) { bIsBold=1; printf("<b>"); }
      printf("<font color=\"%06X\">", ncol);
      return;
   }

   if (!bGlblUseColor) {
      mtklog("color: ignore %ld, no colors used", n);
      return;
   }

   #ifdef _WIN32

   #ifdef WINFULL
   if (n == 0) {
      // FIX: n==0 produces invisible text both with a white
      //      or black background shell. a visible compromise:
      n = 14;
   }

   WORD nAttrib = 0;
   if (n & 1) nAttrib |= FOREGROUND_INTENSITY;
   if (n & 2) nAttrib |= FOREGROUND_RED;
   if (n & 4) nAttrib |= FOREGROUND_GREEN;
   if (n & 8) nAttrib |= FOREGROUND_BLUE;

   if (n == -1) {
      // default color: set all attribs as they were.
      SetConsoleTextAttribute(hGlblConsole, nGlblConsAttrib);
      mtklog("color: scta %lxh (is default)", nGlblConsAttrib);
   } else {
      // set new FOREGROUND text color, but make sure that
      // background color and anything else stays unchanged.
      ulong nval = (nGlblConsAttrib & CCMASK_NOT_FGCOL) | nAttrib;
      SetConsoleTextAttribute(hGlblConsole, nval);
      mtklog("color: scta %lxh (default=%lxh)", nval, nGlblConsAttrib);
   }
   #endif

   #else

   #define UXATTR_RESET     0
   #define UXATTR_BRIGHT    1
   #define UXATTR_DIM       2
   #define UXATTR_UNDERLINE 3
   #define UXATTR_BLINK     4
   #define UXATTR_REVERSE   7
   #define UXATTR_HIDDEN    8

   #define UXCOL_BLACK      0
   #define UXCOL_RED        1
   #define UXCOL_GREEN      2
   #define UXCOL_YELLOW     3
   #define UXCOL_BLUE       4
   #define UXCOL_MAGENTA    5
   #define UXCOL_CYAN       6
   #define UXCOL_WHITE      7

   FILE *fout = stdout;
   if (bStdErr)
         fout = stderr;

   if (n==-1) {
      // unix: have to use a user-defined default color
      n = nGlblDefColor;
   }

   int nAttr = (n & 1) ? UXATTR_BRIGHT : UXATTR_RESET;

   switch (n & 14) {
      case  2: n = UXCOL_RED;     break;
      case  4: n = UXCOL_GREEN;   break;
      case  6: n = UXCOL_YELLOW;  break;
      case  8: n = UXCOL_BLUE;    break;
      case 10: n = UXCOL_MAGENTA; break;
      case 12: n = UXCOL_CYAN;    break;
      case 14: n = UXCOL_WHITE;   break;
      default: n = UXCOL_BLACK;   break;
   }
   fprintf(fout, "%c[%d;%dm", 0x1B, nAttr, n+30);

   #endif
}

// windows-1250 to dos-850 ANSI Central European mapping table.
// some mappings are approximations.
uchar aMapAnsi1250ToOEM850[] = {
0x80,0x5F, 0x81,0x5F, 0x82,0x27, 0x83,0x9F, 0x84,0x22, 0x85,0x2E, 0x86,0xC5, 0x87,0xCE, 
0x88,0x5E, 0x89,0x25, 0x8A,0x53, 0x8B,0x3C, 0x8C,0x4F, 0x8D,0x5F, 0x8E,0x5A, 0x8F,0x5F, 
0x90,0x5F, 0x91,0x27, 0x92,0x27, 0x93,0x22, 0x94,0x22,            0x96,0x2D, 0x97,0x2D, // 0x95,0x07,
0x98,0x7E, 0x99,0x54, 0x9A,0x73, 0x9B,0x3E, 0x9C,0x6F, 0x9D,0x5F, 0x9E,0x7A, 0x9F,0x59, 
0xA0,0xFF, 0xA1,0xAD, 0xA2,0xBD, 0xA3,0x9C, 0xA4,0xCF, 0xA5,0xBE, 0xA6,0xDD, 0xA7,0xF5, 
0xA8,0xF9, 0xA9,0xB8, 0xAA,0xA6, 0xAB,0xAE, 0xAC,0xAA, 0xAD,0xF0, 0xAE,0xA9, 0xAF,0xEE, 
0xB0,0xF8, 0xB1,0xF1, 0xB2,0xFD, 0xB3,0xFC, 0xB4,0xEF, 0xB5,0xE6, 0xB6,0xF4, 0xB7,0xFA, 
0xB8,0xF7, 0xB9,0xFB, 0xBA,0xA7, 0xBB,0xAF, 0xBC,0xAC, 0xBD,0xAB, 0xBE,0xF3, 0xBF,0xA8, 
0xC0,0xB7, 0xC1,0xB5, 0xC2,0xB6, 0xC3,0xC7, 0xC4,0x8E, 0xC5,0x8F, 0xC6,0x92, 0xC7,0x80, 
0xC8,0xD4, 0xC9,0x90, 0xCA,0xD2, 0xCB,0xD3, 0xCC,0xDE, 0xCD,0xD6, 0xCE,0xD7, 0xCF,0xD8, 
0xD0,0xD1, 0xD1,0xA5, 0xD2,0xE3, 0xD3,0xE0, 0xD4,0xE2, 0xD5,0xE5, 0xD6,0x99, 0xD7,0x9E, 
0xD8,0x9D, 0xD9,0xEB, 0xDA,0xE9, 0xDB,0xEA, 0xDC,0x9A, 0xDD,0xED, 0xDE,0xE8, 0xDF,0xE1, 
0xE0,0x85, 0xE1,0xA0, 0xE2,0x83, 0xE3,0xC6, 0xE4,0x84, 0xE5,0x86, 0xE6,0x91, 0xE7,0x87, 
0xE8,0x8A, 0xE9,0x82, 0xEA,0x88, 0xEB,0x89, 0xEC,0x8D, 0xED,0xA1, 0xEE,0x8C, 0xEF,0x8B, 
0xF0,0xD0, 0xF1,0xA4, 0xF2,0x95, 0xF3,0xA2, 0xF4,0x93, 0xF5,0xE4, 0xF6,0x94, 0xF7,0xF6, 
0xF8,0x9B, 0xF9,0x97, 0xFA,0xA3, 0xFB,0x96, 0xFC,0x81, 0xFD,0xEC, 0xFE,0xE7, 0xFF,0x98, 
};

char ansiCharToOEM(char c) {
   long nentries = sizeof(aMapAnsi1250ToOEM850) / 2;
   for (long i=0; i<nentries; i++)
      if (aMapAnsi1250ToOEM850[i*2+0] == (uchar)c)
         return aMapAnsi1250ToOEM850[i*2+1];
   return c;
}

char oemCharToAnsi(char c) {
   if (((uchar)c) < 0x80) return c;
   long nentries = sizeof(aMapAnsi1250ToOEM850) / 2;
   for (long i=0; i<nentries; i++)
      if (aMapAnsi1250ToOEM850[i*2+1] == (uchar)c)
         return aMapAnsi1250ToOEM850[i*2+0];
   return c;
}

void ansiToDos(char *psz) { while (*psz) *psz++ = ansiCharToOEM(*psz); }
void dosToAnsi(char *psz) { while (*psz) *psz++ = oemCharToAnsi(*psz); }
void oprintf(char *pszFormat, ...);
void oprintf(StringPipe *pOutData, char *pszFormat, ...);

char szPrintBufMap[MAX_LINE_LEN+10];

void mystrcatf(char *pOut, long nOutMax, char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';
   char *psz = szPrintBufMap;

   if (nOutMax == 0) nOutMax = MAX_LINE_LEN;

   long nlen1 = strlen(pOut);
   long nrem1 = (nOutMax - nlen1) - 1; // including term.
   long nlen2 = strlen(psz);
   if (nlen2 > nrem1) nlen2 = nrem1;
   if (nlen2 > 0) {
      memcpy(pOut+nlen1, psz, nlen2);
      *(pOut+nlen1+nlen2) = '\0';
   }
}

void printHtml(char *pszText, int iTextLen)
{
   for (int i=0; i<iTextLen; i++) {
      char c = pszText[i];
      switch (c) {
         case '>': printf("&gt;"); break;
         case '<': printf("&lt;"); break;
         case '&': printf("&amp;"); break;
         default : putchar(c); break;
      }
   }
}

void printColorText(char *pszText, char *pszAttrib, bool bWithLF=1)
{
   // printf("pct.text: %s\n", pszText);
   // printf("pct.attr: %s\n", pszAttrib);

   long nTextLen = strlen(pszText);
   long nAttrLen = strlen(pszAttrib);

   // if insufficient attribs provided, use no color
   if (nAttrLen < nTextLen) {
      oprintf("%s%s", pszText, bWithLF ? "\n":"");
      return;
   }

   long i1=0,i2=0,i3=0;
   while (i1 < nTextLen)
   {
      // identify next phrase of same color
      uchar a1 = pszAttrib[i1];
      for (i2=1; i1+i2<nTextLen; i2++)
         if (pszAttrib[i1+i2] != a1)
            break;
      // dump next phrase with len i2.
      long d = nGlblDarkColBase;
      long b = nGlblBrightColBase;
      switch (a1) 
      {
         // sfk internal color codes. when extending this,
         // also adapt color mapping in the "view" command.

         case 'f': setTextColor(nGlblFileColor ); break;
         case 'l': setTextColor(nGlblLinkColor ); break;
         case 'h': setTextColor(nGlblHeadColor ); break;
         case 'i': setTextColor(nGlblHitColor  ); break;
         case 'a': setTextColor(nGlblRepColor  ); break;
         case 'x': setTextColor(nGlblExampColor); break;
         case 'e': setTextColor(nGlblErrColor  ); break;
         case 'w': setTextColor(nGlblWarnColor ); break;
         case 't': setTextColor(nGlblTimeColor ); break;
         case 'p': setTextColor(nGlblPreColor  ); break;

         // bright base colors
         case 'R': setTextColor(b+2 ); break;
         case 'G': setTextColor(b+4 ); break;
         case 'B': setTextColor(b+8 ); break;
         case 'Y': setTextColor(b+6 ); break;
         case 'C': setTextColor(b+12); break;
         case 'M': setTextColor(b+10); break;
         case 'V': setTextColor(b+14); break;

         // dark base colors
         case 'r': setTextColor(d+2 ); break;
         case 'g': setTextColor(d+4 ); break;
         case 'b': setTextColor(d+8 ); break;
         case 'y': setTextColor(d+6 ); break;
         case 'c': setTextColor(d+12); break;
         case 'm': setTextColor(d+10); break;
         case 'v': setTextColor(d+14); break;

         default : setTextColor(-1); break;
      }
      if (bGlblHtml)
         printHtml(pszText+i1, (int)i2);
      else
         oprintf("%.*s", (int)i2, pszText+i1);
      // step forward
      i1 += i2;
   }
   setTextColor(-1);
   if (bWithLF)
      putchar('\n');
}

char attribFromHumanColor(char *pszCol, char cDefault='i')
{
   // red -> dark red. Red or RED -> bright red.
   if (!mystricmp(pszCol, "red"))     return pszCol[0];
   if (!mystricmp(pszCol, "green"))   return pszCol[0];
   if (!mystricmp(pszCol, "blue"))    return pszCol[0];
   if (!mystricmp(pszCol, "yellow"))  return pszCol[0];
   if (!mystricmp(pszCol, "cyan"))    return pszCol[0];
   if (!mystricmp(pszCol, "magenta")) return pszCol[0];
   if (!mystricmp(pszCol, "def"))     return ' ';
   if (!mystricmp(pszCol, "default")) return ' ';
   if (!mystricmp(pszCol, "white"))   return (pszCol[0] == 'W') ? 'V':'v';

   // since 1.58 also supporting logical colors
   if (!mystricmp(pszCol, "err"))     return 'e';
   if (!mystricmp(pszCol, "warn"))    return 'w';
   if (!mystricmp(pszCol, "head"))    return 'h';
   if (!mystricmp(pszCol, "examp"))   return 'x';
   if (!mystricmp(pszCol, "file"))    return 'f';
   if (!mystricmp(pszCol, "hit"))     return 'i';
   if (!mystricmp(pszCol, "rep"))     return 'a';
   if (!mystricmp(pszCol, "pre"))     return 'p';
   if (!mystricmp(pszCol, "time"))    return 't';

   static bool btold = 0;
   if (!btold) 
   {
      btold = 1;
      pwarn("unsupported color name: %s (try \"sfk help color\")\n", pszCol);
   }

   return cDefault;
}

char szPrintBuf1[MAX_LINE_LEN+10];
char szPrintBuf2[MAX_LINE_LEN+10];
char szPrintAttr[MAX_LINE_LEN+10];

long printx(const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';
   char *pszSrc = szPrintBuf1;
   long iDst = 0;
   char nAttr = ' ';
   bool bResetOnLF = 0;
   while (*pszSrc && (iDst < sizeof(szPrintBuf2)-10)) 
   {
      if (!strncmp(pszSrc, "<help>", 6))  { pszSrc += 6; if (bGlblUseHelpColor) bGlblUseColor = 1; } else
      if (!strncmp(pszSrc, "<file>", 6))  { pszSrc += 6; nAttr = 'f'; } else
      if (!strncmp(pszSrc, "<head>", 6))  { pszSrc += 6; nAttr = 'h'; } else
      if (!strncmp(pszSrc, "<prefix>", 8)){ pszSrc += 8; nAttr = 'p'; } else
      if (!strncmp(pszSrc, "<examp>", 7)) { pszSrc += 7; nAttr = 'x'; } else
      if (!strncmp(pszSrc, "$$"    , 2))  {
         pszSrc += 2;
         szPrintBuf2[iDst] = '$';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "$"     , 1)) { pszSrc += 1; nAttr = 'h'; bResetOnLF = 1; } else
      if (!strncmp(pszSrc, "##"    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = '#';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (pszSrc[0] == '\\' && pszSrc[1] == glblWildChar) {
         pszSrc += 2;
         szPrintBuf2[iDst] = glblWildChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "#"     , 1)) { pszSrc += 1; nAttr = 'x'; bResetOnLF = 1; } else
      if (!strncmp(pszSrc, "<hit>" , 5)) { pszSrc += 5; nAttr = 'i'; } else
      if (!strncmp(pszSrc, "<rep>" , 5)) { pszSrc += 5; nAttr = 'a'; } else
      if (!strncmp(pszSrc, "<err>" , 5)) { pszSrc += 5; nAttr = 'e'; } else
      if (!strncmp(pszSrc, "<warn>", 6)) { pszSrc += 6; nAttr = 'w'; } else
      if (!strncmp(pszSrc, "<time>", 6)) { pszSrc += 6; nAttr = 't'; } else
      if (!strncmp(pszSrc, "<def>" , 5)) { pszSrc += 5; nAttr = ' '; } else

      if (!strncmp(pszSrc, "[["    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = '[';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "]]"    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = ']';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      // base colors are bright or dark depending on their first name char
      if (!mystrncmp(pszSrc, "[red]"    , 5)) { nAttr = pszSrc[1]; pszSrc += 5; } else
      if (!mystrncmp(pszSrc, "[green]"  , 7)) { nAttr = pszSrc[1]; pszSrc += 7; } else
      if (!mystrncmp(pszSrc, "[blue]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[yellow]" , 8)) { nAttr = pszSrc[1]; pszSrc += 8; } else
      if (!mystrncmp(pszSrc, "[cyan]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[magenta]", 9)) { nAttr = pszSrc[1]; pszSrc += 9; } else

      if (!strncmp(pszSrc, "[def]"    , 5)) { pszSrc += 5; nAttr = ' '; } else

      if (!strncmp(pszSrc, "[CR]"     , 4)) {
         pszSrc += 4;
         szPrintBuf2[iDst] = '\r';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "[LF]"     , 4)) {
         pszSrc += 4;
         szPrintBuf2[iDst] = '\n';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "<not>"    , 5)) {
         pszSrc += 5;
         szPrintBuf2[iDst] = glblNotChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<run>" , 5)) {
         pszSrc += 5;
         szPrintBuf2[iDst] = glblRunChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<wild>" , 6)) {
         pszSrc += 6;
         szPrintBuf2[iDst] = glblWildChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<sla>" , 5)) {
         pszSrc += 5;
         szPrintBuf2[iDst] = glblPathChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else {
         szPrintBuf2[iDst] = *pszSrc;
         szPrintAttr[iDst] = nAttr;
         if (*pszSrc == '\n' && bResetOnLF) {
            nAttr = ' ';
            szPrintAttr[iDst] = nAttr;
            bResetOnLF = 0;
         }
         pszSrc++;
         iDst++;
      }
   }
   szPrintBuf2[iDst] = '\0';
   if (bGlblCollectHelp) {
      long chainAddLine(char *pszText, char *pszAttr, bool bSplitByLF);
      chainAddLine(szPrintBuf2, szPrintAttr, 1);
   }
   else
      printColorText(szPrintBuf2, szPrintAttr, 0);
   return 0;
}

static char szErrBuf[MAX_LINE_LEN+10];

char *sfkLastError()
{
   if (bErrBufSet)
      return szErrBuf;
   else
      return "";
}

ListEntry::ListEntry( )  { pClNext = pClPrevious = 0; data = 0; }
ListEntry::~ListEntry( ) { pClNext = pClPrevious = 0; data = 0; }

List::List( )  { reset(); }
List::~List( ) { reset(); }

// NOTE: caller MUST FREE all list elements before reset()!
void List::reset( ) {
   pClFirst = pClLast = 0;
}

void List::add(ListEntry* pNew)
{
   if (!pClFirst)
   {
      // yet empty list:
      pClFirst = pClLast = pNew;
      pNew->pClNext = pNew->pClPrevious = 0;
      return;
   }

   // append node at end of list:
   pClLast->pClNext   = pNew;
    pNew->pClPrevious = pClLast;
    pNew->pClNext     = 0;
   pClLast            = pNew;
}

void List::addAsFirst(ListEntry* pNew)
{
   // yet empty list?
   if (!pClFirst)
   {
      pClFirst = pClLast = pNew;
      pNew->pClNext = pNew->pClPrevious = 0;
      return;
   }

   // make node new front of list:
   ListEntry *n2 = pClFirst;
   n2->pClPrevious      = pNew;
    pNew->pClPrevious   = 0;
    pNew->pClNext       = n2;
   pClFirst             = pNew;
}

void List::addAfter(ListEntry *pAfter, ListEntry *pNew)
{
   ListEntry *pNext = pAfter->pClNext;  // might be 0

   pAfter->pClNext   = pNew;
   pNew->pClPrevious = pAfter;
   pNew->pClNext     = pNext;

   if (pNext)
      pNext->pClPrevious = pNew;
   else
      pClLast  = pNew;
}

void List::remove(ListEntry* pRemove)
{
   ListEntry *pPrevious = pRemove->pClPrevious;  // might be 0
   ListEntry *pNext     = pRemove->pClNext;      // might be 0

   pRemove->pClNext = pRemove->pClPrevious = 0;

   if (!pPrevious)   // if 'pRemove' at start of list
   {
      if (pClFirst = pNext)      // new list start becomes pNext ...
         pNext->pClPrevious = 0; // ... and if pNext exists, adjust it,
      else
         pClLast  = 0;           // else list is empty.
   }
   else
   {
      // at least a 'pClPrevious' is given.
      if (pPrevious->pClNext = pNext)     // let pPrevious' 'pClNext' ptr bypass 'pRemove' ...
         pNext->pClPrevious = pPrevious;  // ... and if pNext exists, adjust it,
      else
         pClLast  = pPrevious;            // else set new listend.
   }
}

KeyMap::KeyMap( ) {
   mtklog("keymap ctr %p", this);
   wipe();
}

KeyMap::~KeyMap( ) {
   mtklog("keymap dtr %p", this);
   reset();
   wipe();
}

void KeyMap::wipe( ) {
   nClArrayAlloc = 0;
   nClArrayUsed = 0;
   apClKey  = 0;
   apClVal  = 0;
   bClCase  = 1;
   bClRev   = 0;
}

void KeyMap::reset( ) 
{
   for (long i=0; i<nClArrayUsed; i++)
      delete [] apClKey[i];
   if (apClKey) delete [] apClKey;
   if (apClVal) delete [] apClVal;
   wipe();
}

void KeyMap::setcase(bool bYesNo)    { bClCase = bYesNo; }
void KeyMap::setreverse(bool bYesNo) { bClRev = bYesNo;  }

long KeyMap::expand(long nSoMuch)
{__
   // expand the key array
   char **apTmp1 = new char*[nClArrayAlloc+nSoMuch];
   if (!apTmp1) return 9;
   if (apClKey) {
      memcpy(apTmp1, apClKey, nClArrayUsed*sizeof(char*));
      delete [] apClKey;
   }
   apClKey = apTmp1;

   // expand the value array
   void **apTmp2 = new void*[nClArrayAlloc+nSoMuch];
   if (!apTmp2) return 9;
   if (apClVal) {
      memcpy(apTmp2, apClVal, nClArrayUsed*sizeof(void*));
      delete [] apClVal;
   }
   apClVal = apTmp2;

   // set new alloc size
   nClArrayAlloc += nSoMuch;

   return 0;
}

// rc =0:found_and_index_set
// rc <0:insert_before_index
// rc >0:insert_after_index
int KeyMap::bfind(char *pkey, long &rindex)
{
   // binary search for key, or insert position
   ulong nbot=0,ndist=0,nhalf=0,imid=0;
   ulong ntop=nClArrayUsed; // exclusive
   char  *ptmp=0;
   int    ncmp=-1;   // if empty, insert before index 0

   while (1)
   {
      if (nbot > ntop) // shouldn't happen
         { perr(0, "int. 187281850"); ncmp=-1; break; }

      ndist = ntop - nbot;
      // mtklog("dist %ld bot %ld top %ld",ndist,nbot,ntop);
      if (ndist == 0) break; // nothing left
      nhalf = ndist >> 1;
      imid  = nbot + nhalf;
      ptmp  = apClKey[imid];
      ncmp  = bClCase ? strcmp(pkey, ptmp) : mystricmp(pkey, ptmp);
      if (bClRev) ncmp = 0 - ncmp;
      
      if (ncmp < 0) {
         // select lower half, if any
         // mtklog(" take lower %lxh %lxh %ld",nval,ntmp,imid);
         if (ntop == imid) break; // safety
         ntop = imid;
      }
      else
      if (ncmp > 0) {
         // select upper half, if any
         // mtklog(" take upper %lxh %lxh %ld",nval,ntmp,imid);
         if (nbot == imid+1) break; // required
         nbot = imid+1;
      } else {
         // straight match
         mtklog("%ld = indexof(%.20s) used=%lu",imid,pkey,nClArrayUsed);
         break; // found
      }
   }

   rindex = imid;
   return ncmp;
}

long KeyMap::put(char *pkey, void *pval)
{
   // assure space for insertion, incl. safety
   if (nClArrayUsed >= nClArrayAlloc-10) {
      if (nClArrayAlloc == 0) {
         if (expand(20)) return 9;
      } else {
         if (expand(nClArrayAlloc)) return 9;
      }
   }

   // search for key or insert position:
   long imid=0;
   int  nrc = bfind(pkey, imid);

   if (nrc) 
   {
      // no match, insert new entry:
      // if ncmp <= 0: before imid
      // if ncmp  > 0: after imid
      if (nrc > 0) imid++;
   
      // before imid as it is now
      ulong ntomove = nClArrayUsed - imid;
      memmove(&apClKey[imid+1], &apClKey[imid], sizeof(char*) * ntomove);
      memmove(&apClVal[imid+1], &apClVal[imid], sizeof(void*) * ntomove);
      apClKey[imid] = strdup(pkey); // is COPIED.
      nClArrayUsed++;
   }

   // target position is now imid.
   apClVal[imid] = pval;
   // if there was an old pval, it is replaced.

   return 0; // done
}

void *KeyMap::get(char *pkey, long *poutidx)
{
   long imid=0;
   int  nrc = bfind(pkey, imid);
   // even on miss return last comparison index
   // to allow caller to find nearby words.
   if (poutidx) *poutidx = imid;
   if (nrc) return 0;
   if (imid < 0 || imid >= nClArrayUsed)
      {  perr("int. 187281919"); return 0; }
   return apClVal[imid]; // if any
}

bool KeyMap::isset(char *pkey) {
   long imid=0;
   return bfind(pkey, imid) ? 0 : 1;
}

long KeyMap::remove(long imid)
{
   // remove entry at imid
   delete [] apClKey[imid];
   if (imid < nClArrayUsed) {
      ulong ntomove = nClArrayUsed - imid - 1;
      memmove(&apClKey[imid+0], &apClKey[imid+1], sizeof(char*) * ntomove);
      memmove(&apClVal[imid+0], &apClVal[imid+1], sizeof(void*) * ntomove);
   }
   nClArrayUsed--;
   return 0;
}

long KeyMap::remove(char *pkey) 
{
   long imid=0;
   int  nrc = bfind(pkey, imid);
   if (nrc) return 1; // no such key
   return remove(imid);
}

long KeyMap::size( ) {
   return nClArrayUsed;
}

void *KeyMap::iget(long nindex, char **ppkey)
{
   if (nindex < 0 || nindex >= nClArrayUsed)
      { if (ppkey) *ppkey = 0; return 0; }
   if (ppkey) *ppkey = apClKey[nindex];
   return apClVal[nindex];
}

// - - - keymap access with num keys: - -  -

// so far, the nums are simply converted into
// a hex string, prefixed by a non-printable 0x1.

inline void numToKey(num nkey, char *pbuf) {
   pbuf[0] = '\x01';
   pbuf[1] = '\0';
   numtohex(nkey, 16, pbuf+1);
}

long  KeyMap::put   (num nkey, void *pvalue) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return put(szBuf, pvalue);
}

void *KeyMap::get   (num nkey) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return get(szBuf);
}

bool  KeyMap::isset (num nkey) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return isset(szBuf);
}

long  KeyMap::remove(num nkey) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return remove(szBuf);
}

num hextonum(char *psz)
{
   #ifdef _WIN32
   return _strtoui64(psz, 0, 0x10);
   #else
   return strtoull(psz, 0, 0x10);
   #endif
}

void *KeyMap::iget  (long nindex, num *pkey) {
   char *pszkey = 0;
   void *pres = iget(nindex, &pszkey);
   if (pkey) {
      if (*pszkey == '\x01') {
         num nkey = hextonum(pszkey+1);
         *pkey = nkey;
      } else {
         perr("wrong keymap key for index %ld", nindex);
         *pkey = 0;
      }
   }
   return pres;
}

// - - - keymap access with num keys end - -  -

StringMap::StringMap( )  { 
   mtklog("strmap ctr %p", this);
}

StringMap::~StringMap( ) {
   mtklog("strmap dtr %p", this);
   reset(); 
}

void StringMap::reset( ) 
{__
   mtklog("strmap reset %p", this);
   for (long i=0; i<size(); i++)
      if (apClVal[i])
         delete [] (char*)apClVal[i];
   KeyMap::reset();
}

long StringMap::put(char *pkey, char *pvalin)
{__
   // COPY the input string, but also accept NULL.
   char *pcopy = pvalin ? strdup(pvalin) : 0;

   mtklog("strmap put this=%p %p key=%s",this,pcopy,pkey);

   // is the key is stored already?
   long imid=0;
   int  nrc = bfind(pkey, imid);
   if (!nrc)
   {
      // yes: if there is a value, delete it
      if (apClVal[imid])
         delete [] (char*)apClVal[imid];
      // and set new value, also accepting NULL.
      apClVal[imid] = pcopy;
      return 0;
   }

   // else add a copy
   return KeyMap::put(pkey, pcopy);
}

char *StringMap::get(char *pkey, char *pszOptDef)
{
   char *pres = (char*)KeyMap::get(pkey);
   if (!pres && pszOptDef) pres = pszOptDef;
   return pres;
}

long StringMap::remove(char *pkey) 
{
   long imid=0;
   int  nrc = bfind(pkey, imid);
   if (!nrc && apClVal[imid]) 
      delete [] (char*)apClVal[imid];
   return KeyMap::remove(pkey);
}

char *StringMap::iget(long nindex, char **ppkey)
{
   char *pkey = 0;
   char *pval = (char*)KeyMap::iget(nindex, &pkey);
   if (ppkey) *ppkey = pkey;
   return pval;
}

long StringMap::put(num nkey, char *pvalin) 
{__
   // pvalin is dup'ed in the called put()

   mtklog("strmap nput this=%p %lxh %p",this,(ulong)nkey,pvalin);

   char szBuf[100];
   szBuf[0] = '\0';
   numtohex(nkey, 16, szBuf);

   return StringMap::put(szBuf, pvalin);
}

char *StringMap::get(num nkey) 
{
   char szBuf[100];
   szBuf[0] = '\0';
   numtohex(nkey, 16, szBuf);
   return (char*)get(szBuf);
}

char *StringMap::iget(long nindex, num *pkey) 
{
   char *pszkey = 0;
   void *pres = iget(nindex, &pszkey);
   if (pkey) {
      num nkey = hextonum(pszkey);
      *pkey = nkey;
   }
   return (char*)pres;
}

long StringMap::remove(num nkey) 
{
   char szBuf[100];
   szBuf[0] = '\0';
   numtohex(nkey, 16, szBuf);

   long imid=0;
   int  nrc = bfind(szBuf, imid);
   if (!nrc && apClVal[imid]) 
      delete [] (char*)apClVal[imid];

   return 0;
}

AttribStringMap::AttribStringMap( )  { }
AttribStringMap::~AttribStringMap( ) { }

char *AttribStringMap::mixdup(char *ptext, char *pattr)
{__
   long nlen1 = strlen(ptext);
   long nlen2 = strlen(pattr);

   // mixed = TEXT + ZEROTERM + ATTR + ZEROTERM + MAGIC
   long nmix  = nlen1 + 1 + nlen2 + 1 + 1;

   char *pmix = new char[nmix];

   memcpy(pmix, ptext, nlen1);
   pmix[nlen1] = '\0';

   memcpy(pmix+nlen1+1, pattr, nlen2);
   pmix[nlen1+1+nlen2] = '\0';

   // to allow consistency checks:
   pmix[nlen1+1+nlen2+1] = (char)0xFF;

   return pmix;
}

long AttribStringMap::demix(char *pmixed, char **pptext, char **ppattr)
{__
   // mixed = TEXT + ZEROTERM + ATTR + ZEROTERM + MAGIC
   char *ptext  = pmixed;
   long nlen1   = strlen(ptext);
   char *pattr  = ptext + nlen1 + 1;
   long nlen2   = strlen(pattr);
   char *pmagic = pattr + nlen2 + 1;
   if (*pmagic != (char)0xFF)
      return 9+perr("color string failure, %p \"%.10s\" \"%.10s\" \"%.10s\"", pmixed, pmixed, ptext, pattr);
   *pptext = ptext;
   *ppattr = pattr;
   return 0;
}

long AttribStringMap::put(char *pkey, char *ptext, char *pattr) 
{__
   char *pmix = mixdup(ptext, pattr);
   // mtklog("asmap::put \"%s\" \"%s\" \"%s\"",pkey,ptext,pattr);
   // the string is dup'ed already,
   // place ptr straight into the keymap:
   return KeyMap::put(pkey, pmix);
}

long AttribStringMap::put(num nkey, char *ptext, char *pattr) 
{__
   char *pmix = mixdup(ptext, pattr);
   // mtklog("asmap::put %ld \"%s\" \"%s\"",(long)nkey,ptext,pattr);
   // the string is dup'ed already,
   // place ptr straight into the keymap:
   return KeyMap::put(nkey, pmix);
}

char *AttribStringMap::get(char *pkey, char **ppattr) 
{
   char *pmix = StringMap::get(pkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   *ppattr = pattr;
   return ptext;
}

char *AttribStringMap::iget(long nindex, char **ppkey, char **ppattr) 
{
   char *pkey = 0;
   char *pmix = StringMap::iget(nindex, &pkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   if (ppkey) *ppkey = pkey;
   *ppattr = pattr;
   return ptext;
}

char *AttribStringMap::get(num nkey, char **ppattr) 
{
   char *pmix = StringMap::get(nkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   *ppattr = pattr;
   return ptext;
}

char *AttribStringMap::iget(long nindex, num *pkey, char **ppattr) 
{
   num nkey = 0;
   char *pmix = StringMap::iget(nindex, &nkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   if (pkey) *pkey = nkey;
   *ppattr = pattr;
   return ptext;
}

long parseVersion(char *psz, long nmaxlen, StringMap &rmap)
{
   // expect input from a binary block:
   char szBuf[300];
   if (nmaxlen > sizeof(szBuf)-10)
       nmaxlen = sizeof(szBuf)-10;
   memcpy(szBuf, psz, nmaxlen);
   szBuf[nmaxlen] = '\0';

   char szVerID[50];
   sprintf(szVerID, "$%s:", "version");

   // $version:num=1.2.3,id=sfk,name=Swiss File Knife,type=base$\0"
   // 0123456789
   psz = szBuf;
   if (!strBegins(psz, szVerID)) return 9;
   psz += 9;

   char *atmp[10];
   memset(&atmp, 0, sizeof(atmp));

   // split comma separated string
   while (psz)
   {
      // nam=val,
      char *pnam = psz;

      while (*psz && *psz != '=' && *psz != '$') psz++;
      if (*psz != '=') break;
      *psz++ = '\0';

      char *pval = psz;

      while (*psz && *psz != ',' && *psz != '$') psz++;
      if (*psz == ',' || *psz == '$') {
         *psz++ = '\0';
         rmap.put(pnam, pval);
      }
      else break;
   }

   return 0;
}

#ifdef VFILENET
char *flatURLName(char *purl, char *pctype, char *pbuf, long nmaxbuf, ulong nmode, bool &rdefault)
{
   bool bpath2name = (nmode & 1) ? 1 : 0;
   bool bpath2path = (nmode & 2) ? 1 : 0;
   bool bwithdom   = (nmode & 4) ? 1 : 0;
   bool bskippath  = (!bpath2name && !bpath2path);

   *pbuf = '\0'; // safety

   char *prel    = purl;
   char *purlmax = purl + strlen(purl);
   char *pCacheDir = getDiskCachePath();

   char szNameBuf[SFK_MAX_PATH+10];

   // only normalize net filenames,
   // or net files from the cache dir.
   if (strBegins(prel, "http://")) prel += strlen("http://");
   else
   if (strBegins(prel, "ftp://"))  prel += strlen("ftp://");
   else
   if (strBegins(prel, pCacheDir)) 
   {
      prel += strlen(pCacheDir);
      if (*prel == glblPathChar) prel++;

      // rebuild url from cache name format
      char *psrc = prel;
      char *pdst = szNameBuf;
      char *pdstmax = pdst+sizeof(szNameBuf)-10;
      szNameBuf[0] = '\0';

      if (strBegins(psrc, "http/") || strBegins(psrc, "http\\"))
         { psrc += 5; strcat(pdst, "http://"); pdst += 7; }
      else
      if (strBegins(psrc, "ftp/") || strBegins(psrc, "ftp\\"))
         { psrc += 4; strcat(pdst, "ftp://"); pdst += 6; }

      while (*psrc && (pdst < pdstmax)) 
      {
         if (!strncmp(psrc, "%2F", 3))
            { psrc+=3; *pdst++ = '/'; continue; }
         if (*psrc == '\\')
            { psrc++; *pdst++ = '/'; continue; }
         *pdst++ = *psrc++;
      }
      *pdst = '\0';

      // printf("-> \"%s\"\n", szNameBuf);

      prel = szNameBuf;
   }
   else
      return 0;

   char *pdst = pbuf;
   long  nrem = nmaxbuf - 10;

   if (nrem <= 100) { perr("int. #9529106"); return 0; }

   if (bskippath) {
      // the/sub/doc.zip -> doc.zip
      // http://foo.com/ -> ""
      char *psz2 = strrchr(prel, '/');
      if (psz2) {
         prel = psz2+1;
         if (!*prel) {
            strcpy(pdst, "index.html");
            rdefault = 1;
            return pbuf;
         }
      }
   }
   else
   if (!bwithdom) {
      // foobar.com/path -> path
      char *psz2 = strchr(prel, '/');
      if (psz2) {
         prel = psz2+1;
         if (!*prel) {
            strcpy(pdst, "index.html");
            rdefault = 1;
            return pbuf;
         }
      }
   }

   // convert and add rest of url.
   // http: $-_.+!*'(),
   char szBuf[10];
   char *psrc = prel;
   char *pext1 = 0;
   char *pext2 = 0;
   char  clast = 0;
   bool  lm    = 0; // last char was minus
   while (*psrc && (nrem > 0))
   {
      char c = *psrc++;
      clast  = c;
      if (isalnum(c)) {
         *pdst++ = c; nrem--; lm=0;
         continue; 
      }
      if (!pext2) pext2 = psrc-1;
      switch (c) {
         case '.':
             pext1 = psrc-1; pext2 = 0;
         case '-': case '+': case '_':
            *pdst++ = c; nrem--; lm=0;
            continue;
         case '/':
            if (bpath2path) {
               *pdst++ = glblPathChar; nrem--; lm=0;
               continue;
            }
         default:
            if (!lm) {
               *pdst++ = '-'; nrem--; lm=1;
            }
            continue;
      }
      /*
      sprintf(szBuf, "%%%02X", (unsigned)c);
      *pdst++ = szBuf[0];
      *pdst++ = szBuf[1];
      *pdst++ = szBuf[2];
      nrem -= 3;
      */
   }

   // fix trailing slash
   if (clast == '/' && (nrem >= 12)) {
      strcpy(pdst, "index.html");
      pdst += strlen(pdst);
      pext1 = ".html";
      nrem -= 10;
      rdefault = 1;
   }

   *pdst = '\0';

   // reset extensions that make no sense
   // if (pext1) {
   //    if (pext1 && !strcmp(pext1, ".php"))   pext1 = 0;
   //    if (pext1 && !strcmp(pext1, ".asp"))   pext1 = 0;
   // }

   // create default extensions for well-known ctypes
   if (!pext1 && pctype) {
      if (strstr(pctype, "text"))   pext1 = ".txt";
      if (strstr(pctype, "html"))   pext1 = ".html";
      if (!pext1) pext1 = ".dat";
   }

   if (!pext1) pext1 = ".dat";

   // if extension is not at end of name, append it again
   if (pext1)
   {
      long nlen   = strlen(pext1);
      bool binurl = (pext1 >= purl && pext1 <= purlmax);
      if (binurl && pext2 && (pext2 > pext1))
         nlen = pext2 - pext1;
      if (nlen > 7) { pext1 = ".dat"; nlen = 4; }
      char *pcmp = pdst - nlen;
      if (pcmp < pbuf) pcmp = pbuf;
      if (nlen <= 7 && nlen < nrem && strncmp(pcmp, pext1, nlen))
      {
         memcpy(pdst, pext1, nlen);
         pdst[nlen] = '\0';
         nrem -= nlen;
      }
   }

   return pbuf;
}
#endif // VFILENET

// - - - - - Coi(Table) begin - - - - -

bool Coi::bClDebug = 0;

Coi::Coi(char *pszName, char *pszRootDir)
{
   memset(this, 0, sizeof(*this));

   if (!strncmp(pszName, glblDotSlash, 2))
      pszName += 2;

   #ifdef VFILEBASE
   bool strEnds(char *pszStr, char *pszPat);

   bool bexpdone = 0;

   if (strBegins(pszName, "http://") || strBegins(pszName, "ftp://"))
   {
      // auto-expand http://thehost to http://thehost/
      char *psz = strstr(pszName, "//");
      if (psz) {
         psz += 2;
         psz = strchr(psz, '/');
         if (!psz) {
            long nlen = strlen(pszName);
            pszClName = new char[nlen+4];
            strcpy(pszClName, pszName);
            strcat(pszClName, "/");
            bexpdone = 1;
         }
      }
   }

   if (!bexpdone)
   #endif // VFILEBASE
   pszClName   = strdup(pszName);

   pszClRoot   = pszRootDir ? strdup(pszRootDir) : 0;

   mtklog("coi ctr %p name %s proot %p", this, pszName, pszClRoot);
}

Coi::~Coi( )
{
   mtklog("coi dtr %p %s\n", this, pszClName);

   if (nClRefs > 0) {
      perr("url has %ld refs open, cannot dtr: %s", nClRefs, pszClName);
      return; // avoid instant crash
   }

   if (pdata) {
      // missing cleanup tolerance:
      if (data().pfile) {
         perr("missing close on %s",name());
         fclose(data().pfile);
      }
      // cleanup heavy data:
      delete pdata;
   }

   delstring(pszClName);
   delstring(pszClRoot);
   delstring(pszClRef);
   delstring(pszClExtStr);
   memset(this, 0, sizeof(*this));
}

Coi *Coi::copy( ) 
{
   Coi *pres = new Coi(name(), pszClRoot ? pszClRoot : 0);
   if (pszClRef) pres->setRef(pszClRef);
   if (pszClExtStr) pres->setExtStr(pszClExtStr);

   pres->nClStatus = nClStatus;
   pres->nClHave   = nClHave;
   pres->nClSize   = nClSize;
   pres->nClMTime  = nClMTime;
   pres->nClCTime  = nClCTime;
   pres->bClRead   = bClRead;
   pres->bClWrite  = bClWrite;
   pres->bClDir    = bClDir;
   pres->bClFSDir  = bClFSDir;
   pres->bClHidden = bClHidden;
   pres->bClLink   = bClLink;
   pres->bClBinary = bClBinary;
   pres->bClArc    = bClArc;
   pres->nClUCS    = nClUCS;

   return pres;
}

long Coi::incref(char *pTraceFrom)  {
   ++nClRefs;
   mtklog("inc-ref: cnt=%ld from %s on %p %s", nClRefs, pTraceFrom, this, name());
   return nClRefs; 
}

long Coi::decref( )  {
   nClRefs--;
   mtklog("dec-ref: cnt=%ld on %p %s", nClRefs, this, name());
   if (nClRefs < 0)
      pwarn("ref.cnt underflow (%ld): %s\n", name());
   return nClRefs;
}

long Coi::refcnt( )  { 
   return nClRefs;   
}

bool Coi::debug( ) { return cs.debug || bClDebug; }

void Coi::fillFrom(void *pfdatin) // SFKFindData ptr
{
   SFKFindData *pfdat = (SFKFindData *)pfdatin;

   bClDir    = (pfdat->attrib & 0x10) ? 1 : 0;

   bClHidden = (pfdat->attrib & 0x06) ? 1 : 0;
   #ifndef _WIN32
   bClLink   = pfdat->islink ? 1 : 0;
   #endif
   nClMTime  = pfdat->time_write;
   nClCTime  = pfdat->time_create;
   nClSize   = pfdat->size;

   // 0x01 of windows finddata.attrib is readonly
   bClWrite  = (pfdat->attrib & 0x01) ? 0 : 1;

   #ifndef _WIN32
   // linux specific and informal stuff
   rawmode   = pfdat->rawmode;
   rawtype   = pfdat->rawtype;
   rawnlnk   = pfdat->rawnlnk;
   if (pfdat->bhavenode) {
      nClINode  = pfdat->ninode;
      memcpy(&oClStDev, &pfdat->ostdev, sizeof(__dev_t));
      nClHave  |= COI_HAVE_NODE;
   }
   #endif

   // flag the status fields that have been copied
   nClHave  |= COI_HAVE_DIR;
   nClHave  |= COI_HAVE_HIDDEN;
   nClHave  |= COI_HAVE_LINK;
   nClHave  |= COI_HAVE_TIME;
   nClHave  |= COI_HAVE_SIZE;

   mtklog("coi::fillfrom done dir=%d %s", bClDir, name());

   // remember we don't need to readStat():
   nClStatus = 1; // meta infos now available
}

long Coi::status( ) {
   return (long)nClStatus; 
}

#ifndef _WIN32
bool  Coi::haveNode( )   { return (nClHave & COI_HAVE_NODE) ? 1 : 0; }
num   Coi::getNode( )    { return nClINode; }
bool  Coi::haveFileID( ) { return haveNode(); }

const char *pGlblHexChars = "0123456789ABCDEF";

char *Coi::getFileID( )  
{
   if (!haveNode()) return "";

   // decode binary stdev and inode into a hex string
   uchar *pdst   = (uchar*)szClFileID;
   uchar *pmax   = pdst + sizeof(szClFileID)-4;

   uchar *psrc    = (uchar*)&oClStDev;
   long  nsrcsize = sizeof(oClStDev);
   long  isrc     = 0;

   if (pdst + nsrcsize * 2 >= pmax) return "";
   for (isrc=0; isrc<nsrcsize; isrc++) {
      *pdst++ = pGlblHexChars[(*psrc >> 4) & 0x0F];
      *pdst++ = pGlblHexChars[(*psrc >> 0) & 0x0F];
      psrc++;
   }

   psrc = (uchar*)&nClINode;
   nsrcsize = sizeof(nClINode);

   if (pdst + nsrcsize * 2 >= pmax) return "";
   for (isrc=0; isrc<nsrcsize; isrc++) {
      *pdst++ = pGlblHexChars[(*psrc >> 4) & 0x0F];
      *pdst++ = pGlblHexChars[(*psrc >> 0) & 0x0F];
      psrc++;
   }

   *pdst = '\0';

   if (cs.debug) {
      printf("fileid=\"%s\" len=%ld for \"%s\"\n",szClFileID,(long)strlen(szClFileID),name());
   }

   return szClFileID;
}
#endif

CoiData::CoiData( ) {
   mtklog("coidata ctr %p",this);
   memset(this, 0, sizeof(*this));   
   #ifdef _WIN32
   otrav = -1;
   #endif
}

CoiData::~CoiData( ) 
{
   mtklog("coidata dtr %p", this);

   #ifdef VFILEBASE
   if (pClFtp) {
      mtklog("coidata dtr autoreleases ftp %p", pClFtp);
      releaseFtp();
      // do NOT delete, is managed by cache.
   }

   if (pClHeaders) {
      mtklog("coidata dtr autoreleases headers %p", pClHeaders);
      delete pClHeaders;
   }

   if (pClHttp) {
      mtklog("coidata dtr autoreleases http %p", pClHttp);
      releaseHttp();
      // do NOT delete, is managed by cache.
   }

   if (pelements) delete pelements;

   if (pClOrgName) delete [] pClOrgName;

   #endif // VFILEBASE

   if (src.data) delete [] src.data;

   if (rbuf.data) delete [] rbuf.data;

   if (prelsubname) delete [] prelsubname;

   if (bdiropen) perr("missing closeDir() after dir traversal, %p", this);

   if (pdirpat)  delete [] pdirpat;

   memset(this, 0, sizeof(*this));   
   #ifdef _WIN32
   otrav = -1;
   #endif
}

#ifdef VFILEBASE
// NOTE: whenever the list is changed,
//       adapt zzfind hashing of extensions.
#endif // VFILEBASE

char *arcExtList[] = 
{
   ".zip",".jar",".ear",".war",".aar",".xpi",
   #ifdef VFILEBASE
   #ifndef NO_TAR_SUPPORT
   // CONVENTION:
   //   on ambiguous extensions like .tar <-> .tar.gz,
   //   always list the LONGEST FIRST.
   ".tar.gz", ".tar", ".tgz",
   ".tar.bz2", ".tbz2",
   ".gz", ".bz2",
   // NOTE: .tbz not supported, as it is not clearly bzip2
   #endif
   #endif // VFILEBASE
   // up to 30 user defined ZIP archive extensions are supported:
   0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0  // EOD and some tolerance
};

class StartupEnvGrabber 
{
public:
   StartupEnvGrabber();

   char szZipExtBuf[200];
};

StartupEnvGrabber glblEnvGrabber;

StartupEnvGrabber::StartupEnvGrabber() 
{
   // set SFK_ZIP_EXT=".foo .bar .myext"
   char *psz1 = getenv("SFK_ZIP_EXT");
   if (psz1) 
   {
      // find insertion index in arcExtList
      int iins = 0;
      int imax = (sizeof(arcExtList) / sizeof(char*)) - 3;
      for (; arcExtList[iins] && (iins<imax); iins++);

      // copy and split user extension list
      strcopy(szZipExtBuf, psz1);
      psz1 = szZipExtBuf;
      char *psz2 = 0;
      bool bterminal = 0;
      while (!bterminal && psz1 && *psz1) 
      {
         psz1 = strchr(psz1, '.');
         if (!psz1) break;
         psz2 = psz1+1;
         while (*psz2 && isalnum(*psz2))
            psz2++;
         bterminal = *psz2 ? 0 : 1;
         *psz2++ = '\0';
         // still space left?
         if (iins >= imax-1) {
            fprintf(stderr, "Error: too many extensions in SFK_ZIP_EXT\n");
            break;
         }
         // add another extension
         arcExtList[iins++] = psz1;
         // step to next, if !bterminal
         psz1 = psz2;
      }
   }
}

bool endsWithArcExt(char *pname) 
{
   // find relevant end of input name:
   // filesys : e.g. .tar.bz2
   // http url: e.g. .tar.bz2?name=val&foo=bar

   // exclusive name end point (on terminator or '?'):
   char *pend = pname + strlen(pname);

   if (strBegins(pname, "http://")) {
      char *psz = strrchr(pname, '?');
      if (psz) pend = psz;
   }

   // netto length until end point
   long nnamlen = pend - pname;

   for (long i=0; arcExtList[i]; i++) 
   {
      char *ppatstr = arcExtList[i];
      long  npatlen = strlen(ppatstr);
      if (nnamlen < npatlen)
         continue;
      if (!mystrnicmp(pname + nnamlen - npatlen, ppatstr, npatlen))
         return 1;
   }

   return 0;
}

bool Coi::isDirOpen( ) {
   return data().bdiropen;
}

bool Coi::hasSize  ( ) { return (nClHave && COI_HAVE_SIZE) ? 1 : 0; }
bool Coi::hasTime  ( ) { return (nClHave && COI_HAVE_TIME) ? 1 : 0; }

void Coi::setSize  (num nSize) {
   nClSize  = nSize;
   nClHave |= COI_HAVE_SIZE;
}

void Coi::setTime(num nMTime, num nCTime) {
   nClMTime = nMTime;
   nClCTime = nCTime;
   nClHave |= COI_HAVE_TIME;
}

void Coi::setIsDir (bool bYesNo) {
   bClDir   = bYesNo;
   nClHave |= COI_HAVE_DIR;
}

num Coi::getSize( ) 
{__
   if (nClHave & COI_HAVE_SIZE) return nClSize;
   if (!status()) readStat();
   return (status() >= 9) ? -1 : nClSize;
}

num Coi::getTime( ) 
{__
   if (nClHave & COI_HAVE_TIME) {
      if (cs.usectime) return nClCTime;
      return nClMTime;
   }

   if (!status()) readStat();
   if (status() >= 9) return -1;

   if (cs.usectime) return nClCTime;
   return nClMTime;
}

long Coi::setExtStr(char *psz) {
   delstring(pszClExtStr);
   if (psz)
      if (!(pszClExtStr = strdup(psz)))
         return 9;
   return 0;
}

char *Coi::getExtStr( ) {
   return pszClExtStr;
}

long Coi::readStat( )
{__
   // NOTE: readStat cannot fetch "hidden" and "link" file info.
   //       such info seems to be available only via findFirstFile().

   // if filesystem meta infos already read,
   // or any error already occured, do nothing:
   if (nClStatus > 0) return nClStatus;

   #ifdef VFILEBASE
   // virtual files MUST be blocked from native FS access
   if (isNet() || isZipSubEntry())
   {
      // defensive information gathering:
      // if ANY infos exist, assume that the vfile meta info
      // have already been fetched in a different way,
      // so avoid expensive retrieval operations.
      if (nClHave) {
         nClStatus = 1;
         return 0;
      }

      // in case of Http, try an expensive header access:
      if (isHttp()) {
         if (data().getHttp(name())) return 9;
         HTTPClient *phttp = data().pClHttp;
         if (phttp->getFileHead(name(), this, "stat"))
            { nClStatus = 9; return 9; }
         // sets binary, size
         nClStatus = 1;
         return 0;
      }

      // in any case, block nativeFS access on virtuals:
      nClStatus = 1; // "sorry, we know nothing."
      return 0;
   }
   #endif // VFILEBASE

   long bIsDir    = 0;
   long bCanRead  = 1;
   long bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   num aExtTimes[2];
   memset(aExtTimes, 0, sizeof(aExtTimes));
   if (getFileStat(name(), bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize, aExtTimes))
   {
      mtklog("coi.stat failed: %s have=%lu", name(), nClHave);
      nClStatus = 9;
      return 9;
   }

   nClStatus = 1; // read metadata successfully

   nClSize  =       nFileSize;   nClHave |= COI_HAVE_SIZE;
   nClMTime =       nFileTime;   nClHave |= COI_HAVE_TIME;
   nClCTime =    aExtTimes[0];
   bClRead  = (bool)bCanRead;    nClHave |= COI_HAVE_READ;
   bClWrite = (bool)bCanWrite;   nClHave |= COI_HAVE_WRITE;
   bClDir   = (bool)bIsDir;      nClHave |= COI_HAVE_DIR;
   
   mtklog("coi.stat r=%d w=%d dir=%d %s", bClRead, bClWrite, bClDir, name());

   return 0;
}

bool Coi::isWriteable( ) 
{__
   #ifdef VFILEBASE
   // any virtual file?
   if (isNet()) return 0;
   if (isZipSubEntry() > 0) return 0;
   if (isTravelZip()) return 0;
   #endif // VFILEBASE

   mtklog("coi::iswriteable.1 %d %ld %s",bClWrite,nClStatus,name());

   // only physical files are writeable, so far.
   if (!nClStatus) readStat();
   if (bClDir) return 0;

   mtklog("coi::iswriteable.2 %d %ld %s",bClWrite,nClStatus,name());

   return bClWrite;
}

char *Coi::relName( ) 
{
   char *pszabs = name();

   // native file:
   char *prel = strrchr(pszabs, glblPathChar);
   if (prel) return prel+1;

   #ifdef _WIN32
   // c:thefile.txt
   prel = strrchr(pszabs, ':');
   if (prel) return prel+1;
   #endif

   return pszabs;
}

char *Coi::rootRelName( ) 
{__
   char *relName(char *pszRoot, char *pszAbs);
   if (pszClRoot) 
   {
      mtklog("coi.rootrelname: %s %.10s %.10s", relName(pszClRoot, pszClName), pszClRoot, pszClName);
      if (debug()) printf("coi.rootrelname: %s\n", relName(pszClRoot, pszClName));
      char *prel = relName(pszClRoot, pszClName);
      // special case: theroot.zip\\thesub.txt
      // then now holding: "\thesub.txt"
      if (*prel == glblPathChar) prel++;
      return prel;
   }
   if (debug()) printf("coi.rrname.noroot: %s\n", pszClName);
   return pszClName;
}

bool Coi::isAnyDir( ) 
{__
   if (bGlblSyntaxTest) {
      // if just simulating, check how the name looks
      if (!strcmp(name(), ".")) return 1;
      return strstr(name(), "dir") ? 1 : 0;
   }

   long n = 0;

   #ifdef VFILEBASE
   if (isTravelZip()) {
      bClDir = 1;
      mtklog("%d = isanydir(%s) by trvzip", bClDir, name());
      nClHave |= COI_HAVE_DIR;
      return bClDir;
   }
   if (n = isZipSubEntry()) {
      switch (n) {
         case 1: bClDir = 0; break; // file within zip
         case 2: bClDir = 1; break; // dir within zip (but not traversable)
      }
      mtklog("%d = isanydir(%s) by zipsub (%ld)", bClDir, name(), n);
      nClHave |= COI_HAVE_DIR;
      return bClDir;
   }
   #endif // VFILEBASE

   if (nClHave & COI_HAVE_DIR) {
      mtklog("%d = isanydir(%s) as stored", bClDir, name());
      return bClDir;
   }

   // dir status not yet determined
   bClDir = 0;

   #ifdef VFILEBASE
   if (isHttp()) {
      bClDir = rawIsHttpDir();
      mtklog("%d = isanydir(%s) by httpdir", bClDir, name());
   }
   else
   if (isFtp()) {
      bClDir = rawIsFtpDir();
      mtklog("%d = isanydir(%s) by ftpdir", bClDir, name());
   }
   else
   #endif // VFILEBASE
   {
      bClDir = rawIsDir();
      mtklog("%d = isanydir(%s) by fs", bClDir, name());
   }

   // avoid redundant high-effort reads of dir info
   nClHave |= COI_HAVE_DIR;

   return bClDir;
}  // Coi::isAnyDir

bool Coi::isTravelDir( ) 
{__
   if (bGlblSyntaxTest) {
      // if just simulating, check how the name looks
      if (!strcmp(name(), ".")) return 1;
      return strstr(name(), "dir") ? 1 : 0;
   }

   // make sure raw status is determined
   bool brawdir = isAnyDir();

   #ifdef VFILEBASE
   if (isTravelZip())   brawdir = 1;   // per definitionem
   else
   if (isZipSubEntry()) brawdir = 0;   // travel done otherwise
   #endif // VFILEBASE

   mtklog("%d = istravdir(%s)", brawdir, name());

   return brawdir;
}

num strHash(char *pstr) 
{
   SFKMD5 md5;
   md5.update((uchar*)pstr,strlen(pstr));
   unsigned char *pmd5 = md5.digest();
   num nsumlo=0, nsumhi=0;
   for (long i=0,b=64-8; i<8; i++) {
   // nsumhi = nsumhi | (((num)pmd5[0+i]&0xFF) << b);
      nsumlo = nsumlo | (((num)pmd5[8+i]&0xFF) << b);
      b -= 8;
   }
   return nsumlo;
}

bool Coi::rawIsDir( ) {
   if (!nClStatus)
      readStat();
   return bClDir;
}

// used so far only for http redirects
long Coi::setName(char *psz, char *pszOptRoot)
{
   #ifdef VFILEBASE
   if (pszClName && hasData() && !data().pClOrgName) 
   {
      // do not delete first name,
      // but refunction it as the org name.
      data().pClOrgName = pszClName;
      pszClName = 0;
   }
   #endif // VFILEBASE

   if (pszClName) delete [] pszClName;

   pszClName = strdup(psz);

   if (pszOptRoot) {
      if (pszClRoot) delete [] pszClRoot;
      pszClRoot = strdup(pszOptRoot);
   }

   return 0;
}

char  *Coi::name( ) { return pszClName; }

#ifdef VFILEBASE
char  *Coi::orgName( ) 
{
   if (hasData() && data().pClOrgName)
      return data().pClOrgName;
   return name();
}
#endif // VFILEBASE

char  *Coi::root(bool braw) {
   if (braw) return pszClRoot;
   return pszClRoot ? pszClRoot : (char*)""; 
}

char  *Coi::ref (bool braw) { 
   if (braw) return pszClRef;
   return pszClRef ? pszClRef : (char*)""; 
}

long  Coi::setRef(char *pszName) {
   delstring(pszClRef);
   if (pszName) 
      if (!(pszClRef = strdup(pszName)))
         return 9;
   return 0;
}

CoiData &Coi::data( )
{
   if (!pdata)
      pdata = new CoiData();
   return *pdata;
}

bool Coi::hasData( )    { return pdata ? 1 : 0; }

#ifdef VFILEBASE
bool Coi::isCached( )   { return bClInCache; }
bool Coi::hasContent( ) { return (pdata && pdata->src.data) ? 1 : 0; }
#endif // VFILEBASE

bool Coi::isFileOpen( ) {
   // the open flag itself is managed via pdata
   if (!pdata) return 0;
   return data().bfileopen;
}

void Coi::setContent(uchar *pdata, num nsize, num ntime)
{__
   num nOldSize = data().src.size;
   num nNewSize = nsize;

   if (data().src.data) {
      delete [] data().src.data;
      mclear(data().src);
   }

   if (pdata) {
      data().src.data = pdata;
      data().src.size = nsize;
      data().src.time = ntime;
   }

   #ifdef VFILEBASE
   // cache checks itself if coi is really cached
   glblVCache.tellByteSizeChange(this, nOldSize, nNewSize);
   #endif // VFILEBASE
}

long Coi::releaseContent( )
{__
   setContent(0,0); // free existing

   if (data().rbuf.data) {
      mtklog("coi releases rbuf: %s",name());
      delete [] data().rbuf.data;
      mclear(data().rbuf);
   }

   return 0;
}

long Coi::getContent(uchar **ppdata, num &rnSize)
{__
   if (!ppdata) return 9; // parameter error

   *ppdata = 0; // safety
   rnSize  = 0; // safety

   if (data().src.data) 
   {
      // was already loaded
      *ppdata = data().src.data;
      rnSize  = data().src.size;
      return 0;
   }

   #ifdef VFILEBASE
   // load file of known or unknown size?
   if (isNet())
   {
      // always expect unknown sizes from the net
      mtklog("loadownraw, expect unknown size: %s", name());
      uchar *pdata = 0;
      num    nsize = 0;
      long nrc = 0;
      if (nrc = loadOwnFileRaw(100 * 1000000, &pdata, nsize)) {
         mtklog("loadownraw failed, %ld", nrc);
         return 9;   // failed
      }
  
      mtklog("loadownraw ok, %ld bytes", (long)nsize);

      setContent(pdata, nsize);

      *ppdata = data().src.data;
      rnSize  = data().src.size;

      return 0;
   }
   #endif // VFILEBASE

   char *pszFile = name();

   num nFileSize = getSize();
   if (nFileSize < 0)
      return 9+perr("unable to read: %s", pszFile);

   num nFileTime = getTime();

   // if FileSize == 0, using a dummy buffer.

   num nTolerance = 100;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut)
      return 9+perr("out of memory: %s\n", pszFile);
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      perr("cannot read: %s\n", pszFile);
      delete [] pOut;
      return 9;
   }

   long nRead = myfread((uchar*)pOut, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      perr("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pOut;
      return 9;
   }

   // zero termination is always guaranteed.
   pOut[nFileSize] = '\0';

   setContent((uchar*)pOut, nFileSize, nFileTime);

   *ppdata = data().src.data;
   rnSize  = data().src.size;

   return 0;
}

bool Coi::existsFile(bool bOrDir)
{__
   char *pszName = name();

   #ifdef VFILEBASE
   if (isNet())         return 1; // assume it exists
   if (isZipSubEntry()) return 1; // assume it exists
   // .zip file: fall through
   #endif // VFILEBASE

   #ifdef _MSC_VER

   DWORD nAttrib = GetFileAttributes(pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (!bOrDir && (nAttrib & FILE_ATTRIBUTE_DIRECTORY))
      return 0; // is a dir, not a file

   #else

   // linux
   struct stat64 buf;
   if (stat64(pszName, &buf))
      return 0;
   if (!bOrDir && (buf.st_mode & _S_IFDIR))
      return 0; // is a dir, not a file

   #endif

   // we can get the attribs, and it's not a dir,
   // so expect that it is a file.
   return 1;
}

long Coi::open(char *pmode)
{__
   mtklog("coi-open %p %s %s %p",this,name(),pmode);

   // reset per-file statistics
   resetIOStatus();

   #ifdef VFILEBASE
   // in case of vfiles, make sure required inputs
   // are loaded, e.g. http://foo.zip//bar.zip//file.txt
   // RECURSION BLOCK: for now, we call provideInput
   // ONLY for zip sub entries. netFiles are expected
   // to be cached otherwise, but not through pinput.
   if (isZipSubEntry())
      if (provideInput(__LINE__))
         return 9;
   #endif // VFILEBASE

   // (re)init in case that readLine is used:
   if (data().rbuf.data) delete data().rbuf.data;
   memset(&data().rbuf, 0, sizeof(data().rbuf));

   // supported modes: "rb","r+b","wb"
   data().bwrite     = 0;
   data().szmode[0]  = '\0';
   data().ntotalread = 0;
   #ifdef VFILEBASE
   data().bstopread  = 0;
   #endif // VFILEBASE
   data().banyread   = 0;

   if (!strcmp(pmode, "rb"))
      { } // pure read is always ok
   else
   if (!strcmp(pmode, "r")) {
      // read of text: open as binary
      pmode = "rb";
      // but stop as soon as binary is detected.
      data().bstoprdbin = 1;
   }
   else
   if (!strcmp(pmode, "r+b") || !strcmp(pmode, "wb")) {
      #ifdef VFILEBASE
      if (isVirtual(1)) // WITH root zips
         return 9+perr("write not supported: %s", name());
      #endif // VFILEBASE
      // TODO: not sure if this protects utf16 files in every case,
      //       so far it requires an isBinary() check before.
      if (nClUCS)
         return 9+perr("write to utf-16 file not supported: %s", name());
      // read+write ok
      data().bwrite = 1;
   }
   else
      return 9+perr("unsupported mode \"%s\": %s", pmode, name());

   // remember I/O mode
   strcopy(data().szmode, pmode);

   // take cached data?
   if (data().src.data) 
   {
      if (data().bwrite) {
         // re-write of a file: reset cache
         mtklog("coi-open for write: reset cache");
         setContent(0,0);
      } else {
         // read: simply reset read index
         mtklog("coi-open uses cached data, %ld bytes",data().src.size);
         data().src.index = 0;
         return 0;
      }
   }

   #ifdef VFILEBASE
   // this can be reached in READ mode only
   // http://thehost/thefile.txt
   if (isHttp()) return rawOpenHttpSubFile(pmode);
   if (isFtp())  return rawOpenFtpSubFile(pmode);
   #endif // VFILEBASE

   // native file I/O: thefile.dat
   data().pfile = fopen(name(), pmode);
   if (data().pfile) {
      data().bfileopen = 1;
      return 0;
   }
   return 9;
}

char *Coi::lasterr( ) {
   if (!hasData()) return "";
   return data().szlasterr;
}

#define MY_GETBUF_MAX ((MAX_LINE_LEN+10)*5)

void Coi::setBinaryFile(bool bYesNo) {
   bClBinary = bYesNo;
   nClHave  |= COI_HAVE_BINARY;
}

bool isTextChar(uchar uc) {
   if (uc >= 0x1C) return 1;
   switch (uc) {
   // case 0x04: return 1; // EOT
   // case 0x07: return 1; // BEL
      case 0x08: return 1; // BS
      case 0x09: return 1; // TAB
      case 0x0A: return 1; // LF
      case 0x0C: return 1; // FF
      case 0x0D: return 1; // CR
      case 0x1A: return 1; // EOF
      case 0x1B: return 1; // ESC
   }
   return 0;
}

uchar Coi::isUTF16( ) { return nClUCS; }

bool Coi::isBinaryFile( )
{__
   // if binary status was alread set, return it:
   if (nClHave & COI_HAVE_BINARY)
      return bClBinary;

   // TODO: buffer file header data, then reuse on later reads
   if (open("rb")) return 0;

   mtklog("coi isbinary %p", this);
 
   // assure read buffer on demand
   if (!data().rbuf.data) {
      memset(&data().rbuf, 0, sizeof(data().rbuf));
      data().rbuf.data = new uchar[MY_GETBUF_MAX+100];
   }

   long nCheckLen = MY_GETBUF_MAX - 10;
   if (nCheckLen > 4096) nCheckLen = 4096;
   long nRead = readRaw(data().rbuf.data, nCheckLen);

   bool brc = 0;

   // if (cs.utf16dec) 
   {
      // ucs-2 heuristic detection
      bool  bbin=0;
      ulong blehead=0,bbehead=0;
      uchar *pdat = data().rbuf.data;
   
      if (nRead>=2 && pdat[0]==0xFF && pdat[1]==0xFE) blehead=1;
      if (nRead>=2 && pdat[0]==0xFE && pdat[1]==0xFF) bbehead=1;
      if (blehead || bbehead) {
         // scan first part of text for double-byte chars.
         // accept only very low code points.
         long nWChars = (nRead - 2) / 2;
         if (nWChars > 10) nWChars = 10;
         long iwc=0;
         for (iwc=0; iwc<nWChars; iwc++) {
            uchar nlo = pdat[2+iwc*2+bbehead];
            uchar nhi = pdat[2+iwc*2+blehead];
            if (!isTextChar(nlo) || isTextChar(nhi))
               break;
         }
         if (iwc >= nWChars) {
            // count detected ucs-2 files
            gs.utf16found++;
            mtklog("utf16%s%s, dec=%d: %s\n",blehead?"le":"",bbehead?"be":"",(int)cs.utf16dec,name());
            // but are we allowed to decode?
            if (cs.utf16dec) {
               if (blehead) nClUCS = (uchar)0xFE;
               if (bbehead) nClUCS = (uchar)0xEF;
               if (cs.verbose)
                  printf("utf16%s%s: %s\n",blehead?"le":"",bbehead?"be":"",name());
            }
         }
      }
   }

   if (!brc && !nClUCS) {
      // binary data heuristic detection
      for (long i=0; i<nRead; i++)
         if (data().rbuf.data[i] == 0x00)
            { brc=1; break; }
   }

   // currently, this frees the rbuf.data!
   close();

   bClBinary = brc;
   nClHave  |= COI_HAVE_BINARY;

   mtklog("%d = coi::isbinary %s",brc,name());

   return brc;
}

// TODO: rework rc handling in case of error
long Coi::readLine(char *pszOutBuf, long nOutBufLen)
{
   if (!data().rbuf.data) {
      memset(&data().rbuf, 0, sizeof(data().rbuf));
      data().rbuf.data = new uchar[MY_GETBUF_MAX+100];
   }

   if (data().rbuf.getsize  < 0 || data().rbuf.getsize  > MY_GETBUF_MAX) return 0+perr("int. #62 %d %d\n",(data().rbuf.getsize < 0),(data().rbuf.getsize > MY_GETBUF_MAX));
   if (data().rbuf.getindex < 0 || data().rbuf.getindex > MY_GETBUF_MAX) return 0+perr("int. #63 %d %d\n",(data().rbuf.getindex < 0),(data().rbuf.getindex > MY_GETBUF_MAX));
   if (data().rbuf.geteod > 1) return 0+perr("int. #65\n");

   // if remaining data is less than halve of buffer, read next block
   if (!data().rbuf.geteod && ( data().rbuf.getsize < (MY_GETBUF_MAX/2)-100 ))
   {
      // move remaining cache data to front of buffer
      long nindex  = data().rbuf.getindex;
      long nremain = data().rbuf.getsize;
      if (nindex + nremain < 0) return 0+perr("int. #60\n");
      if (nindex + nremain > MY_GETBUF_MAX) return 0+perr("int. #61\n");
      if (nremain > (MY_GETBUF_MAX/2)) return 0+perr("int. #62\n");
      if (nremain > 0)
         memcpy(data().rbuf.data, &data().rbuf.data[nindex], nremain);

      // now remaining data starts from front of buffer,
      // filling less than the first halve of the buffer.
      data().rbuf.getindex = 0;

      // re-fill remaining buffer space
      long nBufFree = MY_GETBUF_MAX - data().rbuf.getsize;
      uchar *pRead  = data().rbuf.data + data().rbuf.getsize;

      long nRead = 0;
      if ((nRead = read(pRead, nBufFree)) <= 0)
         data().rbuf.geteod = 1;
      else
         data().rbuf.getsize += nRead;
   }

   // anything remaining?
   if (data().rbuf.getsize == 0) {
      data().rbuf.geteod = 2;
      return 0;
   }

   // copy next line from copy index
   uchar *psrc     = data().rbuf.data + data().rbuf.getindex;
   uchar *psrcmax  = psrc + data().rbuf.getsize;
   if (psrcmax > data().rbuf.data + MY_GETBUF_MAX) return 0+perr("int. #63");

   uchar *pdst     = (uchar*)pszOutBuf;
   uchar *pdstmax  = pdst + nOutBufLen - 10;

   bool bBinary    = 0;
   long nSrcBytes  = 0;
   long nDstBytes  = 0;

   for (; psrc < psrcmax && pdst < pdstmax;)
   {
      uchar c1 = *psrc++;
      nSrcBytes++;

      if (c1 == 0x00 || c1 == 0x1A) {
         if (!c1)
            bBinary = 1;
         c1 = (uchar)'.';
      }
      else
      if (c1 == (uchar)'\r')
         continue;

      *pdst++ = (char)c1;
      nDstBytes++;

      if (c1 == (uchar)'\n')
         break;
   }
   *pdst = '\0';

   data().rbuf.getindex += nSrcBytes; // copy next line from there
   data().rbuf.getsize  -= nSrcBytes; // reduce remaining bytes in buf
   data().rbuf.getpos   += nSrcBytes; // absolute source position in file

   if (bBinary && data().bstoprdbin)
      return 0; // "EOD", force end of reading

   return nDstBytes;
}

size_t Coi::read(void *pbufin, size_t nBufSize)
{__
   if (nClUCS && (nBufSize & 0x1UL)) {
      // force even buffer size on ucs-2
      nBufSize ^= (size_t)0x1UL;
      if (!nBufSize)
         return 0+perr("cannot read ucs-2, buffer too small: %s", name());
   }

   bool bfirst = data().banyread ? 0 : 1;

   size_t nraw = readRaw(pbufin, nBufSize);
   size_t nres = nraw; // resulting size

   data().banyread = 1;

   if (nClUCS) 
   {
      // transparent ucs-2 decoding.
      // this will return less bytes than nBufSize!
      if (nBufSize & 1) // shouldn't happen due to above alignment
         return 0+perr("cannot read ucs-2, uneven buffer size: %s", name());

      uchar *psrc    = (uchar*)pbufin;
      uchar *psrcmax = (uchar*)pbufin + nraw;
      uchar *pdst    = (uchar*)pbufin;
      uchar *pdstbeg = pdst;
      uchar *pdstmax = (uchar*)pbufin + nBufSize;

      // skip byte order mark?
      if (nClUCS == 0xFE && psrc[0] == 0xFF && psrc[1] == 0xFE)
         psrc += 2;
      else
      if (nClUCS == 0xEF && psrc[0] == 0xFE && psrc[1] == 0xFF)
         psrc += 2;

      // copy loop with zero truncation
      ulong nreloff = (nClUCS == 0xFE) ? 0 : 1;
      while (psrc < psrcmax && pdst < pdstmax) {
         *pdst++ = psrc[nreloff];
         psrc += 2;
      }

      // calc new netto size
      nres = pdst - pdstbeg;

      mtklog("filtered %ld ucs-2 chars", (long)nres);

      if (bfirst) gs.utf16read++;
   }

   return nres;
}

size_t Coi::readRaw(void *pbufin, size_t nBufSize)
{__
   // take cached data?
   if (data().src.data) 
   {
      long nremain = data().src.size - data().src.index;
      long ntocopy = (long)nBufSize;
      if (ntocopy > nremain) ntocopy = nremain;
      if (ntocopy > 0) {
         memcpy(pbufin, data().src.data + data().src.index, ntocopy);
         data().src.index += ntocopy;
      }
      mtklog("coi-read copied %ld bytes from cache idx %ld", ntocopy, (long)data().src.index);
      data().ntotalread += ntocopy;
      return ntocopy;
   }

   #ifdef VFILEBASE
   if (isHttp())  {
      size_t nread = rawReadHttpSubFile(pbufin, nBufSize);
      data().ntotalread += nread;
      return nread;
   }

   if (isFtp())   {
      size_t nread = rawReadFtpSubFile(pbufin, nBufSize);
      data().ntotalread += nread;
      return nread;
   }
   #endif // VFILEBASE

   // native file I/O:
   if (!data().pfile) {
      perr("read on non-open file: %s",name());
      return 0;
   }

   uchar *pBuf = (uchar *)pbufin;

   size_t nOffset = 0;
   size_t nRemain = nBufSize;
   while (nRemain > 0)
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nReadSub = fread(pBuf+nOffset, 1, nBlock, data().pfile);
      if (nReadSub <= 0)
         break;

      nOffset += nReadSub;
      nRemain -= nReadSub;

      // if (nMax > 0)
      //    info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   // if (nOffset > 0 && pmd5 != 0)
   //    pmd5->update(pBuf, nOffset);

   data().ntotalread += nOffset;

   return nOffset;
}

// rc0:ok >=0:failed to seek
int Coi::seek(num nOffset, int nOrigin)
{__
   if (nOrigin != SEEK_SET)
      return 9+perr("internal: seek: supports only SEEK_SET");

   #ifdef VFILEBASE
   if (!data().src.data && isVirtual()) // w/o root zips
   {
      // force caching of virtual files, except root zips
      uchar *pdummy = 0;
      num    ndummy = 0;
      if (getContent(&pdummy, ndummy))
         return 9+perr("seek failed: %s", name());
      // else fall through to cache use
   }   
   #endif // VFILEBASE

   // take cached data?
   if (data().src.data) 
   {
      mtklog("coi::seek to %ld in cache", (long)nOffset);
      if (nOffset < 0 || nOffset > data().src.size)
         return 9+perr("cannot seek to position %s", numtoa(nOffset));
      data().src.index = nOffset;
      return 0;
   }

   #ifdef VFILEBASE
   // virtual file I/O: shouldn't be reached
   if (isHttp())  return 9+perr("cannot seek on http file");
   if (isFtp())   return 9+perr("cannot seek on ftp file");
   if (isZipSubEntry()) return 9+perr("cannot seek on zip entry");
   #endif // VFILEBASE

   // native file I/O:
   if (!data().pfile) {
      perr("seek on non-open file: %s",name());
      return 0;
   }

   FILE *f = data().pfile;

   #ifdef _WIN32
   if (sizeof(num) != sizeof(fpos_t)) return 9+perr("internal: myfseek: wrong fpos_t size, need 64 bits");
   return fsetpos(f, &nOffset);
   #else
   fpos64_t xpos;
   if (fgetpos64(f, &xpos)) // read xpos.__state
      return 9+perr("internal: seek: failed to read position");
    #ifdef MAC_OS_X
     xpos = (fpos_t)nOffset;
    #else
     if (sizeof(xpos.__pos) != sizeof(nOffset)) return 9+perr("internal: myfseek: wrong __pos size, need 64 bits");
     xpos.__pos = nOffset;
    #endif
   return fsetpos64(f, &xpos);
   #endif
}

size_t Coi::write(uchar *pBuf, size_t nBytes)
{__
   if (data().src.data)
      return 9+perr("write: conflict with cached data");

   #ifdef VFILEBASE
   // virtual file I/O:
   if (isHttp())  return 9+perr("cannot write on http file");
   if (isFtp())   return 9+perr("cannot write on ftp file");
   if (isZipSubEntry()) return 9+perr("cannot write on zip entry");
   #endif // VFILEBASE

   // native file I/O:
   if (!data().pfile) {
      perr("write on non-open file: %s",name());
      return 0;
   }

   size_t nOffset = 0;
   size_t nRemain = nBytes;

   while (nRemain > 0)
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nWriteSub = fwrite(pBuf+nOffset, 1, nBlock, data().pfile);
      if (nWriteSub != nBlock)
         return nOffset+nWriteSub; // return no. of bytes actually written

      nOffset += nWriteSub;
      nRemain -= nWriteSub;

      // if (nMax > 0)
      //    info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   // if (nOffset > 0 && pmd5 != 0)
   //    pmd5->update(pBuf, nOffset);

   return nOffset;
}

void Coi::close( )
{__
   mtklog("coi-close %p %s", this, name());

   // reset per-file statistics
   resetIOStatus();

   // assuming: close methods below do NOT use rbuf
   if (data().rbuf.data) {
      mtklog("coi-close deletes rbuf %p size %ld", data().rbuf.data, data().rbuf.getsize);
      delete [] data().rbuf.data;
   }
   memset(&data().rbuf, 0, sizeof(data().rbuf));
 
   if (data().src.data) {
      mtklog("coi-close finished read from cache");
      data().src.index = 0; // safety
      return;
   }
 
   #ifdef VFILEBASE
   // http://thehost/thefile.txt
   if (isHttp())  { rawCloseHttpSubFile(); return; }
   if (isFtp())   { rawCloseFtpSubFile(); return; }
   #endif // VFILEBASE
 
 
   // in any case, reset the flag:
   data().bfileopen = 0;

   // native file I/O:
   if (!data().pfile) {
      perr("close on non-open file: %s",name());
      return;
   }
   fclose(data().pfile);
_  data().pfile = 0;
}

long Coi::openDir( )
{__
   #ifdef VFILEBASE
   if (isTravelZip() || isNet()) {
      long nrc = rawLoadDir();
      if (nrc >= 5) return nrc; // failed
      data().bdiropen = 1;
      return 0;
   }
   #endif // VFILEBASE

   if (rawIsDir())
      return rawOpenDir();

   perr("no filesystem directory, cannot open: %s", name());
   return 9;
}

// caller MUST RELEASE COI after use!
Coi *Coi::nextEntry( )
{__
   // additional filter loop: block any kind of endless
   // link looping, i.e. dir links within a dir to itself.
   while (1)
   {
      Coi *psub = nextEntryRaw();
      if (!psub) return 0;
      if (psub == this) {
         mtklog("coi.nextentry: skip sub == top for %p", psub);
         // psub is OWNED BY US, so release it first.
         if (!psub->decref())
            perr("int. #1310281137"); // should NOT happen
         // do NOT delete! it was a double ref onto THIS.
         continue;
      }
      if (!strcmp(psub->name(), name())) {
         mtklog("coi.nextentry: skip equal sub %p, top %p for name %s", psub, this, psub->name());
         // psub is OWNED BY US, so release it first.
         if (!psub->decref())
            delete psub; // no refs remaining, not cached
         continue;
      }
      // is different, return entry.
      return psub;
   }
   return 0; // not reached
}

// caller MUST RELEASE COI after use!
Coi *Coi::nextEntryRaw( )
{__
   #ifdef VFILEBASE
   if (isHttp())  return rawNextHttpEntry();
   if (isFtp())   return rawNextFtpEntry();
   #endif // VFILEBASE

   if (rawIsDir()) return rawNextEntry();

   perr("no directory, cannot read: %s", name());
   return 0;
}

void Coi::closeDir( )
{__
   mtklog("coi::closedir %p", this);

   #ifdef VFILEBASE
   if (isHttp())  return rawCloseHttpDir();
   if (isFtp())   return rawCloseFtpDir();
   #endif // VFILEBASE

   if (rawIsDir())
      return rawCloseDir();

   perr("no directory, cannot close: %s", name());
}

long Coi::rawOpenDir( ) 
{
   long joinPath(char *pszDst, long nMaxDst, char *pszSrc1, char *pszSrc2);

   // prepare traversal pattern, or simply
   // the directory name stripped from possible slash

   long nsize1 = strlen(name());
   if (data().pdirpat) delete [] data().pdirpat;
   data().pdirpat = new char[nsize1+12];
   #ifdef _WIN32
   joinPath(data().pdirpat, nsize1+8, name(), (char*)"*");
   #else
   joinPath(data().pdirpat, nsize1+8, name(), (char*)"");
   #endif
   
   #ifdef _WIN32

   // delay real actions until first nextEntry()

   #else

   // linux:
   if (!(data().ptrav = opendir(data().pdirpat)))
      return 1; // no such dir

   #endif

   data().bdiropen = 1;

   return 0;
}

bool isAbsolutePath(char *psz1)
{
   #ifdef _WIN32
   if (strlen(psz1) >= 2) {
      // try for C:\thedir
      char c1 = tolower(*psz1);
      if (c1 >= 'a' && c1 <= 'z' && *(psz1+1) == ':') // && *(psz1+2) == '\\')
         return 1;
   }
   #endif
   // e.g. /tmp
   // e.g. \\machine\path
   if (psz1[0] == glblPathChar) return 1;
   return 0;
}

long joinPath(char *pszDst, long nMaxDst, char *pszSrc1, char *pszSrc2)
{
   mystrcopy(pszDst, pszSrc1, nMaxDst-4); // colon, terminator, 2 buffer.
   long nlen = strlen(pszDst);
   if (nlen > 0) {
      char clast = pszDst[nlen-1];
      #ifdef _WIN32
      if (clast != ':') // AND below
      #endif
      if (clast != glblPathChar) {
         strcat(pszDst, glblPathStr);
         nlen++;
      }
   }
   if (nlen < nMaxDst)
      mystrcopy(pszDst+nlen, pszSrc2, nMaxDst-nlen);
   // printf("JOIN \"%s\" \"%s\" => \"%s\"\n",pszSrc1,pszSrc2,pszDst);
   return 0;
}

long joinShadowPath(char *pszDst, long nMaxDst, char *pszSrc1, char *pszSrc2)
{
   mystrcopy(pszDst, pszSrc1, nMaxDst-4); // colon, terminator, 2 buffer.
   long nlen = strlen(pszDst);
   if (nlen > 0) {
      char clast = pszDst[nlen-1];
      #ifdef _WIN32
      if (clast != ':') // AND below
      #endif
      if (clast != glblPathChar) {
         strcat(pszDst, glblPathStr);
         nlen++;
      }
   }
   mystrcopy(pszDst+nlen, "zz-shadow-01", (nMaxDst-2)-nlen);
   strcat(pszDst, glblPathStr);
   nlen = strlen(pszDst);
   mystrcopy(pszDst+nlen, pszSrc2, nMaxDst-nlen);
   // printf("JOIN \"%s\" \"%s\" => \"%s\"\n",pszSrc1,pszSrc2,pszDst);
   return 0;
}

// caller MUST RELEASE COI after use!
Coi *Coi::rawNextEntry( ) 
{
   if (!data().bdiropen) {
      perr("nextEntry() called without openDir()");
      return 0;
   }

   SFKFindData myfdat;

   char *pabsname = 0; // full combined filename

   // loop to skip ".", ".." and invalid files:
   while (1)
   {
      memset(&myfdat, 0, sizeof(myfdat));
   
      #ifdef _WIN32
   
      // windows:
      if (!data().bdir1stdone) {
         data().bdir1stdone = 1;
         // first call:
         #ifdef SFK_W64
         data().otrav = _findfirst64(data().pdirpat, &myfdat);
         #else
          #ifndef _INTPTR_T_DEFINED
           typedef long intptr_t;
          #endif
         data().otrav = _findfirst(data().pdirpat, &myfdat);
         #endif
         if (data().otrav == -1)
            return 0; // probably empty dir
      } else {
         // subsequent calls
         #ifdef SFK_W64
         int nrc = _findnext64(data().otrav, &myfdat);
         #else
         int nrc = _findnext(data().otrav, &myfdat);
         #endif
         if (nrc) return 0; // no further entries
      }

      mtklog("rawnextentry attr %lxh %s", (ulong)myfdat.attrib, myfdat.name);
   
      #else
   
      // linux:
      struct dirent *e = readdir(data().ptrav);
      if (e == NULL)
         return 0; // no further entries
   
      myfdat.name    = e->d_name;
      myfdat.attrib  = 0;
      myfdat.rawtype = (ulong)e->d_type;

      // dirent symbolic links have their own inode,
      // and are of no use to detect repeated content listings.
      //   myfdat.ninode  = (num)e->d_ino;
      //   myfdat.bhavenode = 1;
      // the actual inode is fetched below through stat64.
   
      #endif

      // always skip "." and ".."
      if (   !strcmp(myfdat.name, ".")
          || !strcmp(myfdat.name, ".."))
         continue;

      // construct absolute name of entry now,
      // although we may decide to skip the file.
      long nRootLen = strlen(name());
      long nSubLen  = strlen(myfdat.name);
   
      // create tmp absname, taking care of ":" and slash
      long nMixLen  = nRootLen+nSubLen;
      pabsname = new char[nMixLen+20];
      joinPath(pabsname, nMixLen+10, name(), myfdat.name);

      // identify further file attributes:
      // symbolic link directory under linux?
   
      #ifndef _WIN32

      // get further dir/file statistics. no 32 bit compat here -
      // getting the latest g++ for linux shouldn't be too difficult.
      struct stat64 hStat1;
      if (stat64(pabsname, &hStat1)) {
         if (cs.verbose) printf("nostat: %s (non-regular file)\n", pabsname);
         cs.noFiles++;
         delete [] pabsname;
         continue;
      }
   
      myfdat.rawmode = (ulong)hStat1.st_mode;
      myfdat.rawnlnk = (ulong)hStat1.st_nlink;
   
      // get the "true" (dereferenced) inode,
      // allowing dup content listing detection:
      myfdat.ninode  = (num)hStat1.st_ino;
      memcpy(&myfdat.ostdev, &hStat1.st_dev, sizeof(__dev_t));
      myfdat.bhavenode = 1;

      // DT_LNK: not available on older Linux versions
      if (e->d_type == DT_LNK)
         myfdat.islink = 1; // cannot tell here if dir or file link
      else
      if (e->d_type == DT_DIR)
         myfdat.attrib = 0x10; // dir
      else
      if (e->d_type == DT_REG)
         myfdat.attrib = 0x00; // regular file
      // else probably DT_UNKNOWN
   
      // general linux, including older variants
      #ifdef S_IFLNK
      if ((hStat1.st_mode & S_IFLNK) == S_IFLNK)
         myfdat.islink = 1;
      #endif
      // no else here.
      if ((hStat1.st_mode & S_IFDIR) == S_IFDIR)
         myfdat.attrib = 0x10; // dir
      else
      if ((hStat1.st_mode & S_IFREG) == S_IFREG)
         myfdat.attrib = 0x00; // regular file
      else {
         if (cs.verbose) printf("nofile: %s (non-regular file)\n", myfdat.name);
         cs.noFiles++;
         delete [] pabsname;
         continue;
      }
   
      /*
         NOTE: these are OCTAL VALUES, NOT hexadecimal.
         __S_IFDIR   0040000  // Directory.
         __S_IFCHR   0020000  // Character device.
         __S_IFBLK   0060000  // Block device.
         __S_IFREG   0100000  // Regular file.
         __S_IFIFO   0010000  // FIFO.
         __S_IFLNK   0120000  // Symbolic link.
         __S_IFSOCK  0140000  // Socket.
      */

      // skip of dirlinks should be done by caller
      // if (myfdat.islink && ((hStat1.st_mode & _S_IFDIR) == _S_IFDIR)) {
      //    // symbolic directory link:
      //    bIsDirLink = 1;
      //    if (cs.skipLinks && (nGlblFunc != eFunc_FileStat)) {
      //       delete [] pabsname;
      //       continue;
      //    }
      // }
   
      // may also set 0x02 here for hidden files.
      // may also set 0x04 here for system files.
   
      myfdat.time_write  = hStat1.st_mtime;
      myfdat.time_create = hStat1.st_ctime;
      myfdat.size        = hStat1.st_size;
   
      #endif

      // entry valid, not skipped: take it
      break;

   }  // endwhile (1)

   // expect that we (the parent of psub) have a root
   // copied through from higher levels. if not,
   // set ourselves as the root.
   Coi *psub = new Coi(pabsname, pszClRoot ? pszClRoot : name());
   psub->fillFrom(&myfdat);
   // time, size, hidden, link

   // verified file system directory:
   if (myfdat.attrib & 0x10)
      psub->bClFSDir = 1;

   psub->incref("rne");

   // read metadata successfully:
   psub->nClStatus = 1;

   delete [] pabsname;

   return psub; // managed by caller
}

bool Coi::isHidden( ) {
   // TODO: so far, readStat can NOT determine the hidden status,
   //       therefore the call doesn't help unless this changes.
   if (!nClStatus) readStat();
   mtklog("%d = coi::ishidden %s",bClHidden,name());
   return bClHidden; 
}

bool Coi::isLink   ( ) {
   // TODO: so far, readStat can NOT determine the link status,
   //       therefore the call doesn't help unless this changes.
   if (!nClStatus) readStat();
   return bClLink;
}

bool Coi::isDirLink( ) {
   // TODO: so far, readStat can NOT determine the link status,
   //       therefore the call doesn't help unless this changes.
   if (!nClStatus) readStat();
   return bClDir && bClLink;
}

void Coi::rawCloseDir( ) 
{
   if (!data().bdiropen)
      pwarn("closeDir() called on non-open dir");

   #ifdef _WIN32

   if (data().otrav != -1) {
      _findclose(data().otrav);
      data().otrav = -1;
   }

   #else

   if (data().ptrav) {
      closedir(data().ptrav);
      data().ptrav = 0;
   }

   #endif

   if (data().pdirpat) {
      delete [] data().pdirpat;
      data().pdirpat = 0;
   }

   data().bdiropen = 0;
}

CoiTable::CoiTable() {
   mtklog("coitab ctr %p",this);
   nClArraySize = 0;
   nClArrayUsed = 0;
   apClArray    = 0;
}

CoiTable::~CoiTable() {
   mtklog("coitab dtr %p",this);
   resetEntries();
}

void CoiTable::resetEntries() {
   for (long i=0; i<nClArrayUsed; i++) {
      if (apClArray[i]) delete apClArray[i];
      apClArray[i] = 0;
   }
   nClArrayUsed = 0;
   if (apClArray)
      delete [] apClArray;
   apClArray = 0;
   nClArraySize = 0;
}

long CoiTable::numberOfEntries() { return nClArrayUsed; }

bool CoiTable::isSet(long iIndex) {
   if (iIndex < 0) { pwarn("illegal index: %d\n", iIndex); return 0; }
   return (iIndex < nClArrayUsed) ? 1 : 0;
}

long CoiTable::expand(long nSoMuch) {
   Coi **apTmp = new Coi*[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (apClArray) {
      memcpy(apTmp, apClArray, nClArraySize*sizeof(Coi*));
      delete [] apClArray;
   }
   apClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

// add a COPY of the supplied coi
long CoiTable::addEntry(Coi &ocoi, long nAtPos) {
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (long i=nClArrayUsed; i>nAtPos; i--)
         apClArray[i] = apClArray[i-1];
      apClArray[nAtPos] = ocoi.copy();
      nClArrayUsed++;
   } else {
      apClArray[nClArrayUsed++] = ocoi.copy();
   }
   return 0;
}

long CoiTable::addSorted(Coi &ocoi, char cSortedBy, bool bUseCase) 
{
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }

   Coi *padd = &ocoi;

   long nInsPos = -1;

   long nCnt = numberOfEntries();
   long i=0; bool bbail=0;
   for (i=0; i<nCnt; i++) 
   {
      Coi *pown = apClArray[i];
      switch (cSortedBy) {
         case 'T': bbail = (pown->getTime() > padd->getTime()); break;
         case 't': bbail = (pown->getTime() < padd->getTime()); break;
         case 'S': bbail = (pown->getSize() > padd->getSize()); break;
         case 's': bbail = (pown->getSize() < padd->getSize()); break;
         case 'N': {
            long ncmp = bUseCase ?      strcmp(pown->name(), padd->name())
                                   : mystricmp(pown->name(), padd->name());
            bbail = (ncmp > 0);
            break;
         }
         case 'n': {
            long ncmp = bUseCase ?      strcmp(pown->name(), padd->name())
                                   : mystricmp(pown->name(), padd->name());
            bbail = (ncmp < 0);
            break;
         }
         default: return 9+perr("internal #141272256\n");
      }
      if (bbail) break;
   }
   if (i < nCnt) nInsPos = i;

   return addEntry(ocoi, nInsPos);
}

long CoiTable::removeEntry(long nAtPos) {
   if (nAtPos < 0 || nAtPos >= nClArrayUsed)
      return 9;
   if (apClArray[nAtPos]) delete apClArray[nAtPos];
   for (long i=nAtPos; i<nClArrayUsed-1; i++)
      apClArray[i] = apClArray[i+1];
   apClArray[nClArrayUsed-1] = 0; // just in case
   nClArrayUsed--;
   return 0;
}

long CoiTable::setEntry(long nIndex, Coi *pcoi) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("illegal set index: %d\n", nIndex);
   if (apClArray[nIndex])
      delete apClArray[nIndex];
   apClArray[nIndex] = pcoi ? pcoi->copy() : 0;
   return 0;
}

Coi *CoiTable::getEntry(long nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return apClArray[nIndex];
   perr("illegal CoiTable index: %d tline %d\n", nIndex, nTraceLine);
   return 0;
}

// - - - - - CoiTable end - - - - -

ProgressInfo info;

void initConsole()
{
   // manually set or override console width:
   char *psz2 = getenv("SFK_CONFIG");
   if (psz2) {
      psz2 = strstr(psz2, "columns:");
      if (psz2) {
         long ncols = atol(psz2+8);
         if (ncols >= 40) {
            nGlblConsColumns = ncols;
            bGlblConsColumnsSet = true;
            info.setWidth(nGlblConsColumns);
         }
      }
   }

   // need this also for html help
   char *pszColEnv = getenv("SFK_COLORS");
   if (pszColEnv)
      setColorScheme(pszColEnv);

   #ifdef WINFULL
   hGlblConsole = GetStdHandle(STD_OUTPUT_HANDLE);
   CONSOLE_SCREEN_BUFFER_INFO oConInf;
   if (!GetConsoleScreenBufferInfo(hGlblConsole, &oConInf)) {
      // not in interactive mode, e.g. output redirected to file:
      bGlblUseColor = bGlblUseHelpColor = 0;
      return;
   }
   bGlblHaveInteractiveConsole = 1;
   nGlblConsAttrib = oConInf.wAttributes;
   /*
   printf("CONSATTRIB DEFAULTS %lxh:\n",nGlblConsAttrib);
   printf("   %lu  BACKGROUND_BLUE\n" , nGlblConsAttrib & BACKGROUND_BLUE);
   printf("   %lu  BACKGROUND_GREEN\n", nGlblConsAttrib & BACKGROUND_GREEN);
   printf("   %lu  BACKGROUND_RED\n"  , nGlblConsAttrib & BACKGROUND_RED);
   */
   if (!bGlblConsColumnsSet && (oConInf.dwSize.X >= 60)) {
      nGlblConsColumns = oConInf.dwSize.X;
      bGlblConsColumnsSet = true;
      info.setWidth(nGlblConsColumns);
   }

   if (!pszColEnv)
   {
      // if we autodetect a black background shell
      ulong nBackMask = BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE;
      if ((nGlblConsAttrib & (nBackMask)) == 0) {
         // auto-select color theme:black
         setColorScheme("theme:black");
      }
      if ((nGlblConsAttrib & (nBackMask)) == nBackMask) {
         // optimize colors for white background
         setColorScheme("theme:white");
      }
   }
   #endif

   #ifdef _WIN32

   #ifdef WINFULL
   if (bGlblUseColor)
      SetConsoleCtrlHandler(ctrlcHandler, 1);
   #endif

   #else

   signal(SIGINT, ctrlcHandler);

   #endif
}

long autoCalcWrapColumns() {
   long ncols = 80;
   if (bGlblConsColumnsSet) {
      if (cs.verbose >= 2) printf("ConsoleColumns=%ld\n",nGlblConsColumns);
      return nGlblConsColumns-2;
   }
   #ifdef _WIN32
   HWND hDeskWin = GetDesktopWindow();
   if (hDeskWin) {
      HDC hdcDesk = GetWindowDC(hDeskWin);
      if (hdcDesk != NULL) {
         long ndeskw = GetDeviceCaps(hdcDesk, HORZRES);
         long ncols2 = ndeskw / 10; // default char width: 10 pixels
         if (ncols2 > 80)
            ncols = ncols2;
         if (cs.verbose >= 2) printf("wdesk %ld col.calc %ld used %ld\n",ndeskw,ncols2,ncols);
         ReleaseDC(hDeskWin, hdcDesk);
      }
   }
   #else
   // identify number of linux shell columns
   #endif
   return ncols-2;
}

ProgressInfo::ProgressInfo() 
{
   memset(this, 0, sizeof(ProgressInfo));
   setWidth(80);
   nLastDumpTime = getCurrentTime();
   bAddInfoPrio  = 1;
}

void ProgressInfo::setWidth(long nColumns) {
   nMaxChars      = nColumns  -  3;
   nMaxSubChars   = nMaxChars - 20;
}

void ProgressInfo::setAddInfoWidth(long nAddCols) {
   nAddInfoCols = nAddCols;
   // vrfy  58% [filename]......... addinfo
   // 1234567890                    addcols
   nAddCols += 10; // add left side columns
   if (nMaxChars > nAddCols + 30)
      nMaxSubChars = nMaxChars - nAddCols;
}

void ProgressInfo::fixAddInfoWidth() {
   if ((long)strlen(szAddInfo) > nAddInfoCols) {
      nAddInfoCols = (long)strlen(szAddInfo);
      long nAddCols = nAddInfoCols + 10;
      if (nMaxChars > nAddCols + 30)
         nMaxSubChars = nMaxChars - nAddCols;
   }
}

void ProgressInfo::setAddInfoHalve() {
   long nAddCols = (nMaxChars - 10) / 2;
   nAddInfoCols = nAddCols;
   nAddInfoReserve = nAddCols; // if addinfo is overwritten
   nAddCols += 10; // add left side columns
   nMaxSubChars = nMaxChars - nAddCols;
   bAddInfoPrio = 0;
}

void ProgressInfo::setStatus(char *pverb, char *psubj, char *pszAddInfo, long nKeepFlags) 
{
   strcopy(szVerb, pverb);
   strcopy(szSubject, psubj);
   if (nKeepFlags & eKeepProg)  // keep progress
      szPerc[0] = '\0';
   if (pszAddInfo) {
      if (!strcmp(pszAddInfo, "00")) {
         strcpy(szPerc, "... ");
         strcopy(szAddInfo, pszAddInfo+2);
      } else
         strcopy(szAddInfo, pszAddInfo);
   }
   else
   if (!(nKeepFlags & eKeepAdd)) { // keep addinfo
      szAddInfo[0] = '\0';
   }

   fixAddInfoWidth();

   if (nKeepFlags & eSlowCycle)
      nLastDumpTime = getCurrentTime();

   if (!(nKeepFlags & eNoCycle))
      cycle();
}

void ProgressInfo::setStatProg(char *pverb, char *psubj, num nMax, num nCur, char *pszUnit) {
   strcopy(szVerb, pverb);
   strcopy(szSubject, psubj);
   szAddInfo[0] = '\0';
   setProgress(nMax, nCur, pszUnit);
}

void ProgressInfo::setProgress(num nMax, num nCur, char *pszUnit) {
   if (nMax <= 0) nMax = 1; // safe division
   long nPerc = (long)(nCur * 100 / nMax);
   if (nPerc > 0 && nPerc <= 100)
      sprintf(szPerc, "%02ld%% ", nPerc);
   else
   if (nPerc > 100) {
      sprintf(szPerc, "100%% ");
      if (cs.debug) printf("[progress: cur=%ld max=%ld perc=%ld]\n", (long)nCur, (long)nMax, (long)nPerc);
   } else {
      sprintf(szPerc, "... ");
      if (cs.debug) printf("[progress: cur=%ld max=%ld perc=%ld]\n", (long)nCur, (long)nMax, (long)nPerc);
   }
   cycle();
}

void ProgressInfo::cycle() {
   #ifdef _WIN32
   // windows: if output is redirected, info display makes no sense.
   if (!bGlblHaveInteractiveConsole)
      return;
   #endif
   if (cs.quiet || cs.noprog)
      return;
   if (getCurrentTime() >= (nLastDumpTime + 500)) {
      dumpTermStatus();
   }
}

void ProgressInfo::setAction(char *pverb, char *psubj, char *pszAddInfo, long nKeepFlags) {
   setStatus(pverb, psubj, pszAddInfo, nKeepFlags);
   print();
}

void ProgressInfo::print() {
   if (cs.quiet || cs.noprog)
      return;
   dumpTermStatus();
}

void ProgressInfo::printLine(long nFilter) {
   if (cs.quiet || cs.noprog)
      return;
   if (nFilter & (1<<1)) {
      // print only subject, but with unlimited length
      clearTermStatus();
      oprintf("%s\n", szSubject);
   } else {
      if (nFilter & (1<<2))
         strcpy(szPerc, " ");
      dumpTermStatus(); // may clear previous status output
      printf("\n");
   }
   nDumped = 0;
}

long ProgressInfo::print(const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf, sizeof(szPrintBuf)-10, pszFormat, argList);
   szPrintBuf[sizeof(szPrintBuf)-10] = '\0';
   clear();
   printf("%s", szPrintBuf);
   return 0;
}

void ProgressInfo::setAddInfo(const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szAddInfo, sizeof(szAddInfo)-10, pszFormat, argList);
   szAddInfo[sizeof(szAddInfo)-10] = '\0';
   fixAddInfoWidth();
}

void ProgressInfo::clear() 
{__
   clearTermStatus();
   szVerb[0]      = '\0';
   szSubject[0]   = '\0';
   szAddInfo[0]   = '\0';
   szPerc[0]      = '\0';
   // nLastDumpTime  = getCurrentTime();
}

void ProgressInfo::clearTermStatus() 
{__
   if (nDumped) {
      mtklog("info::clearterm");
      memset(szTermBuf, ' ', nDumped);
      szTermBuf[nDumped] = '\0';
      printf("%s\r",szTermBuf);
      fflush(stdout);
      nDumped = 0;
   }
   // do NOT reset szVerb etc. here
}

void ProgressInfo::dumpTermStatus() 
{__
   if (cs.quiet || cs.noprog)
      return;

   if (nDumped)
      clearTermStatus();

   if (!szSubject[0])
      return;  // nothing to dump

   long nMaxMiddle = nMaxSubChars;
   if (!szPerc[0])
      nMaxMiddle += 2; // no percentage: have more chars to use

   // if there is few space, and low addinfo prio
   bool bWithAdd = 1;
   if ((long)strlen(szSubject) > nMaxMiddle) {
      if (!bAddInfoPrio) {
         bWithAdd = 0;
         nMaxMiddle += nAddInfoReserve; // add space to center
      }
   }

   if ((long)strlen(szSubject) > nMaxMiddle) {
      long nlen  = strlen(szSubject);
      long nmax2 = nMaxMiddle - 3;
      if (nmax2 < 0) nmax2 = 0;
      char *psz1 = &szSubject[nlen-nmax2];
      snprintf(szTermBuf, sizeof(szTermBuf)-10, "...%s", psz1);
   } else {
      snprintf(szTermBuf, sizeof(szTermBuf)-10, "%-*.*s", (int)nMaxMiddle, (int)nMaxMiddle, szSubject);
   }

   nDumped = 0;

   char cTurn = (nTurn & 1) ? '.':' ';   
   nTurn++;

   if (szVerb[0]) {
      int nvlen = strlen(szVerb);
      if (nvlen > 5) nvlen = 5;
      while (nvlen > 3 && szVerb[nvlen-1] == ' ')
         nvlen--;
      if (szPerc[0]) {
         char *pszPerc2 = szPerc;
         if (!strcmp(szPerc, " "))
            pszPerc2 = ""; // ignore, is just a dummy
         printx("<head>%-*.*s %s<def>", nvlen,nvlen, szVerb, pszPerc2);
         nDumped += 6 + strlen(szPerc);
      } else {
         printx("<head>%-*.*s <time>%c<def> ", nvlen,nvlen, szVerb, cTurn);
         nDumped += 6 + 2;
      }
   }

   mtklog("info::dump \"%s\"", szTermBuf);
   printf("%s ",szTermBuf);
   nDumped += strlen(szTermBuf) + 1;

   if (bWithAdd && strlen(szAddInfo)) {
      setTextColor(nGlblTimeColor);
      printf("%s", szAddInfo);
      setTextColor(-1);
      nDumped += strlen(szAddInfo);
   }

   printf("\r");
   fflush(stdout);
   nLastDumpTime = getCurrentTime();
}

// FIX for Windows 60 MB I/O Bug: Windows XP fails to read blocks
// larger than 60 MByte, therefore use myfread instead of fread:

// large block read incl. optional info update and checksum building
size_t myfread(uchar *pBuf, size_t nBufSize, FILE *fin, num nMax, num nCur, SFKMD5 *pmd5)
{
   size_t nOffset = 0;
   size_t nRemain = nBufSize;
   while (nRemain > 0) 
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nReadSub = fread(pBuf+nOffset, 1, nBlock, fin);
      if (nReadSub <= 0)
         break;

      nOffset += nReadSub;
      nRemain -= nReadSub;

      if (nMax > 0)
         info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   if (nOffset > 0 && pmd5 != 0)
      pmd5->update(pBuf, nOffset);
   
   return nOffset;
}

// large block write incl. optional info update and checksum building
size_t myfwrite(uchar *pBuf, size_t nBytes, FILE *fout, num nMax, num nCur, SFKMD5 *pmd5)
{
   size_t nOffset = 0;
   size_t nRemain = nBytes;

   while (nRemain > 0) 
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nWriteSub = fwrite(pBuf+nOffset, 1, nBlock, fout);

      // mtklog("myfwrite: %ld = fwrite(%ld)",(long)nWriteSub,(long)nBlock);

      if (nWriteSub != nBlock)
         return nOffset+nWriteSub; // return no. of bytes actually written

      nOffset += nWriteSub;
      nRemain -= nWriteSub;

      if (nMax > 0)
         info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   if (nOffset > 0 && pmd5 != 0)
      pmd5->update(pBuf, nOffset);

   return nOffset;
}

#ifdef _WIN32
void timetToFileTime(num ntimet, FILETIME *pft)
{
   time_t t = (time_t)ntimet;
   LONGLONG ll = Int32x32To64(t, 10000000) + 116444736000000000;
   pft->dwLowDateTime  = (DWORD)ll;
   pft->dwHighDateTime = (DWORD)(ll>>32);
}

num fileTimeToTimeT(num nwft)
{
   nwft -= 116444736000000000;
   nwft /= 10000000;
   return nwft;
}

num fileTimeToTimeT(FILETIME *pft)
{
   num nwft =     (((num)pft->dwHighDateTime) << 32)
               |  (((num)pft->dwLowDateTime));
   nwft -= 116444736000000000;
   nwft /= 10000000;
   return nwft;
}
#endif

size_t safefread(void *pBuf, size_t nBlockSize, size_t nBufSize, FILE *fin)
   { return myfread((uchar*)pBuf, nBufSize, fin); }

size_t safefwrite(void *pBuf, size_t nBlockSize, size_t nBufSize, FILE *fin)
   { return myfwrite((uchar*)pBuf, nBufSize, fin); }

// FROM HERE ON, ALL fread() and fwrite() calls are MAPPED to SAFE versions:

#define fread  safefread
#define fwrite safefwrite

// sockLastError  : see netErrno
// sockLastErrStr : see netErrStr

int netErrno()
{
   #ifdef _WIN32
   return WSAGetLastError();
   #else
   return errno;
   #endif
}

char *netErrStr(int ncode=-1)
{
   if (ncode < 0)
      ncode = netErrno();

   static char szErrBuf[200];
 
   const char *perr = "";

   #ifdef _WIN32
   switch (ncode)
   {
      case WSAEWOULDBLOCK      : perr="WSAEWOULDBLOCK"; break;
      case WSAEINPROGRESS      : perr="WSAEINPROGRESS"; break;
      case WSAEALREADY         : perr="WSAEALREADY"; break;
      case WSAENOTSOCK         : perr="WSAENOTSOCK"; break;
      case WSAEDESTADDRREQ     : perr="WSAEDESTADDRREQ"; break;
      case WSAEMSGSIZE         : perr="WSAEMSGSIZE"; break;
      case WSAEPROTOTYPE       : perr="WSAEPROTOTYPE"; break;
      case WSAENOPROTOOPT      : perr="WSAENOPROTOOPT"; break;
      case WSAEPROTONOSUPPORT  : perr="WSAEPROTONOSUPPORT"; break;
      case WSAESOCKTNOSUPPORT  : perr="WSAESOCKTNOSUPPORT"; break;
      case WSAEOPNOTSUPP       : perr="WSAEOPNOTSUPP"; break;
      case WSAEPFNOSUPPORT     : perr="WSAEPFNOSUPPORT"; break;
      case WSAEAFNOSUPPORT     : perr="WSAEAFNOSUPPORT"; break;
      case WSAEADDRINUSE       : perr="WSAEADDRINUSE"; break;
      case WSAEADDRNOTAVAIL    : perr="WSAEADDRNOTAVAIL"; break;
      case WSAENETDOWN         : perr="WSAENETDOWN"; break;
      case WSAENETUNREACH      : perr="WSAENETUNREACH"; break;
      case WSAENETRESET        : perr="WSAENETRESET"; break;
      case WSAECONNABORTED     : perr="WSAECONNABORTED"; break;
      case WSAECONNRESET       : perr="WSAECONNRESET"; break;
      case WSAENOBUFS          : perr="WSAENOBUFS"; break;
      case WSAEISCONN          : perr="WSAEISCONN"; break;
      case WSAENOTCONN         : perr="WSAENOTCONN"; break;
      case WSAESHUTDOWN        : perr="WSAESHUTDOWN"; break;
      case WSAETOOMANYREFS     : perr="WSAETOOMANYREFS"; break;
      case WSAETIMEDOUT        : perr="WSAETIMEDOUT"; break;
      case WSAECONNREFUSED     : perr="WSAECONNREFUSED"; break;
      case WSAELOOP            : perr="WSAELOOP"; break;
      case WSAENAMETOOLONG     : perr="WSAENAMETOOLONG"; break;
      case WSAEHOSTDOWN        : perr="WSAEHOSTDOWN"; break;
      case WSAEHOSTUNREACH     : perr="WSAEHOSTUNREACH"; break;
      case WSAENOTEMPTY        : perr="WSAENOTEMPTY"; break;
      case WSAEUSERS           : perr="WSAEUSERS"; break;
      case WSAEDQUOT           : perr="WSAEDQUOT"; break;
      case WSAESTALE           : perr="WSAESTALE"; break;
      case WSAEREMOTE          : perr="WSAEREMOTE"; break;
   }
   #else
   switch (ncode)
   {
      case EWOULDBLOCK         : perr="EWOULDBLOCK"; break;
      case EINPROGRESS         : perr="EINPROGRESS"; break;
      case EALREADY            : perr="EALREADY"; break;
      case ENOTSOCK            : perr="ENOTSOCK"; break;
      case EDESTADDRREQ        : perr="EDESTADDRREQ"; break;
      case EMSGSIZE            : perr="EMSGSIZE"; break;
      case EPROTOTYPE          : perr="EPROTOTYPE"; break;
      case ENOPROTOOPT         : perr="ENOPROTOOPT"; break;
      case EPROTONOSUPPORT     : perr="EPROTONOSUPPORT"; break;
      case ESOCKTNOSUPPORT     : perr="ESOCKTNOSUPPORT"; break;
      case EOPNOTSUPP          : perr="EOPNOTSUPP"; break;
      case EPFNOSUPPORT        : perr="EPFNOSUPPORT"; break;
      case EAFNOSUPPORT        : perr="EAFNOSUPPORT"; break;
      case EADDRINUSE          : perr="EADDRINUSE"; break;
      case EADDRNOTAVAIL       : perr="EADDRNOTAVAIL"; break;
      case ENETDOWN            : perr="ENETDOWN"; break;
      case ENETUNREACH         : perr="ENETUNREACH"; break;
      case ENETRESET           : perr="ENETRESET"; break;
      case ECONNABORTED        : perr="ECONNABORTED"; break;
      case ECONNRESET          : perr="ECONNRESET"; break;
      case ENOBUFS             : perr="ENOBUFS"; break;
      case EISCONN             : perr="EISCONN"; break;
      case ENOTCONN            : perr="ENOTCONN"; break;
      case ESHUTDOWN           : perr="ESHUTDOWN"; break;
      case ETOOMANYREFS        : perr="ETOOMANYREFS"; break;
      case ETIMEDOUT           : perr="ETIMEDOUT"; break;
      case ECONNREFUSED        : perr="ECONNREFUSED"; break;
      case ELOOP               : perr="ELOOP"; break;
      case ENAMETOOLONG        : perr="ENAMETOOLONG"; break;
      case EHOSTDOWN           : perr="EHOSTDOWN"; break;
      case EHOSTUNREACH        : perr="EHOSTUNREACH"; break;
      case ENOTEMPTY           : perr="ENOTEMPTY"; break;
      case EUSERS              : perr="EUSERS"; break;
      case EDQUOT              : perr="EDQUOT"; break;
      case ESTALE              : perr="ESTALE"; break;
      case EREMOTE             : perr="EREMOTE"; break;
   }
   #endif

   #ifdef _WIN32
   if (strBegins((char*)perr, "WSA")) perr += 3;
   #endif

   if (strlen(perr))
      snprintf(szErrBuf, sizeof(szErrBuf)-10, "status=%d (%s)", ncode, perr);
   else
      snprintf(szErrBuf, sizeof(szErrBuf)-10, "status=%d", ncode);

   return szErrBuf;
}

// optional reroute of error messages
long (*pGlblSFKStatusCallBack)(long nMsgType, char *pmsg) = 0;

long perr(const char *pszFormat, ...)
{
   if (cs.noerr) return 0;

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   szErrBuf[sizeof(szErrBuf)-10] = '\0';

   #ifdef WINCE

   printf("error: %s", szErrBuf);
   bErrBufSet = 1;
   nGlblErrors++;
   return 0;

   #else

   if (pGlblSFKStatusCallBack) {
      // output to callback
      removeCRLF(szErrBuf);
      pGlblSFKStatusCallBack(1, szErrBuf);
   } else {
      // output to terminal
      if (!strchr(szErrBuf, '\n'))
         strcat(szErrBuf, "\n");
      info.clear();
      setTextColor(nGlblErrColor, 1); // on stderr
      fprintf(stderr, "error: %s", szErrBuf);
      setTextColor(-1, 1);
   }

   mtkerr("%s", szErrBuf);
   bErrBufSet = 1;
   nGlblErrors++;

   if (bGlblPauseOnError) {
      printf("Press ENTER to continue.\n");
      while (getchar() != '\n');
   }

   return 0;

   #endif
}

long pwarn(const char *pszFormat, ...)
{
   if (cs.nowarn) return 0;
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   szErrBuf[sizeof(szErrBuf)-10] = '\0';

   if (pGlblSFKStatusCallBack) {
      // output to callback
      removeCRLF(szErrBuf);
      char *pbuf = szErrBuf;
      if (!strncmp(pbuf, "[nopre] ", 8))
         pbuf += 8;
      pGlblSFKStatusCallBack(2, pbuf);
   } else {
      // output to terminal
      if (!strchr(szErrBuf, '\n'))
         strcat(szErrBuf, "\n");
      info.clear();
      setTextColor(nGlblWarnColor, 1);
      char *psz = szErrBuf;
      if (!strncmp(psz, "[nopre] ", 8))
         fprintf(stderr, "%s", psz+8);
      else
         fprintf(stderr, "warn : %s", psz);
      setTextColor(-1, 1);
   }

   mtkwarn("%s", szErrBuf);
   nGlblWarnings++;

   return 0;
}

long pinf(const char *pszFormat, ...)
{
   if (cs.nonotes) return 0;

   // does NOT use szErrBuf to allow access to last
   // error message through sfkLastError().

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   if (pGlblSFKStatusCallBack) {
      // output to callback
      removeCRLF(szPrintBuf1);
      pGlblSFKStatusCallBack(3, szPrintBuf1);
   } else {
      // output to terminal
      info.clear();
      setTextColor(nGlblTimeColor, 1);
      char *psz = szPrintBuf1;
      if (!strncmp(psz, "[nopre] ", 8))
         fprintf(stderr, "%s", psz+8);
      else
         fprintf(stderr, "note : %s", psz);
      setTextColor(-1, 1);
   }

   mtklog("note: %s", szPrintBuf1);

   return 0;
}

void perrinfo(const char *pszContext)
{
   // general reasons first
   if (!strcmp(pszContext, "fwrite")) {
      pinf("the target volume may have no space left on the device.\n");
      pinf("if the target is a network drive, a file size limit may apply.\n");
   }

   // then dump system infos, if any
   #ifdef _WIN32

   #ifdef WINFULL
   long  nerr1 = errno;
   DWORD nerr2 = GetLastError();
   LPVOID lpMsgBuf = 0;
   FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, nerr2,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &lpMsgBuf,
        0, NULL );
   if (lpMsgBuf) removeCRLF((char*)lpMsgBuf);
   info.clear(); // in case no perr was done
   setTextColor(nGlblWarnColor);
   printf("cerno: %ld,%s\n", nerr1, strerror(nerr1));
   printf("werno: %lu,%s\n", nerr2, lpMsgBuf ? lpMsgBuf : "");
   setTextColor(-1);
   LocalFree(lpMsgBuf);
   #endif

   #else

   long  nerr1 = errno;
   info.clear(); // in case no perr was done
   setTextColor(nGlblWarnColor);
   printf("cerno: %ld,%s\n", nerr1, strerror(nerr1));
   setTextColor(-1);

   #endif
}

bool bGlblSysErrOccured = 0;

static long esys(const char *pszContext, const char *pszFormat, ...)
{
   bGlblSysErrOccured = 1;

   // just like perr:
   if (cs.noerr) return 0;
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   szErrBuf[sizeof(szErrBuf)-10] = '\0';
   if (!strchr(szErrBuf, '\n'))
      strcat(szErrBuf, "\n");
   info.clear();
   setTextColor(nGlblErrColor, 1); // on stderr
   fprintf(stderr, "error: %s", szErrBuf);
   setTextColor(-1, 1);
   mtkerr("%s", szErrBuf);
   bErrBufSet = 1;
   nGlblErrors++;

   // optionally extend output by runtime info:
   if (bGlblSysErrDetail)
      perrinfo(pszContext);

   if (bGlblPauseOnError) {
      printf("Press ENTER to continue.\n");
      while (getchar() != '\n');
   }

   return 0;
}

bool cmpchr(char c1, char cmsk, bool bcase, bool besc) {
   if (!besc && cmsk == '?') return 1;
   if (!bcase) c1   = tolower(c1);
   if (!bcase) cmsk = tolower(cmsk);
   if (c1 == cmsk) return 1;
   return 0;
}

enum eMatchStr {
   eMatchCase     = 1,
   eMatchLiteral  = 2,
   eMatchHead     = 4,
   eMatchTail     = 8
};

// get single char from mask, managing \* etc.
char getpatchr(char **ppPat, long &rEscaped)
{
   rEscaped = 0;
   char *p = *ppPat;
   char c  = *p++;
   if (!cs.spat || c != '\\') {
      *ppPat = p;
      return c;
   }
   char c2 = *p;
   switch (c2) {
      case 't' : rEscaped=1; c='\t'; break;
      case 'q' : rEscaped=1; c='"'; break;
      case '\\': 
      case '*' :
      case '?' : rEscaped=1; c=c2;   break;
      case 'x' :
         if (p[1] && p[2]) {
            rEscaped=3;
            c = (char)getTwoDigitHex(p+1);
         }
         break;
   }
   *ppPat = p;
   return c;
}

char peekpatchr(char *p, long &rEscaped)
{
   rEscaped = 0;
   char c  = *p++;
   if (!cs.spat || c != '\\')
      return c;
   char c2 = *p;
   switch (c2) {
      case 't' : rEscaped=1; c='\t'; break;
      case 'q' : rEscaped=1; c='"'; break;
      case '\\': 
      case '*' :
      case '?' : rEscaped=1; c=c2;   break;
      case 'x' :
         if (p[1] && p[2]) {
            rEscaped=3;
            c = (char)getTwoDigitHex(p+1);
         }
         break;
   }
   return c;
}

bool mystrhit(char *pszStr, char *pszPat, bool bCase, long *pOutHitIndex)
{
   if (bCase) {
      char *psz = strstr(pszStr, pszPat);
      if (psz) {
         if (pOutHitIndex) *pOutHitIndex = (long)(psz-pszStr);
         return true;
      } else {
         if (pOutHitIndex) *pOutHitIndex = -1;
         return false;
      }
   } else {
      if (mystrstri(pszStr, pszPat, pOutHitIndex))
         return true;
      else
         return false;
   }
}

bool matchstr(char *pszHay, char *pszPat, long nFlags, long &rfirsthit, long &rhitlen)
{
   if (cs.debug)
      printf("match: enter matchstr \"%s\" \"%s\" flags %lu\n",pszHay,pszPat,nFlags);

   bool bCase = ( nFlags & 1) ? 1 : 0;
   bool bHead = ( nFlags & 4) ? 1 : 0;
   bool bTail = ( nFlags & 8) ? 1 : 0;

   long nhaylen = strlen(pszHay);
   long ibase   = 0;
   long ifirst  = -1;     // pos'n of first matching char
   long ilast   = -1;     // pos'n of last matching char
   bool bmatch  = 0;
   long nesc    = 0;      // escapes not (0), or 1 or 3 chars

   if (!cs.wpat) {
      // no wildcard interpretation
      long npatlen = strlen(pszPat);
      if (bTail) {
         // check for end-of-line match
         if (nhaylen < npatlen) return 0;
         char *pend = pszHay+nhaylen-npatlen;
         if (!mystrncmp(pend,pszPat,npatlen,bCase)) {
            if (cs.debug)
               printf("match:  direct at %ld len %ld\n",nhaylen-npatlen,npatlen);
            rfirsthit = nhaylen-npatlen;
            rhitlen   = npatlen;
            return 1;
         }
         return 0;
      } else {
         // check for anywhere or start-of-line match
         long ihit = 0;
         bool brc = mystrhit(pszHay, pszPat, bCase, &ihit);
         if (!brc) return 0;
         if (bHead && ihit != 0) return 0;
         rfirsthit = ihit;
         rhitlen   = npatlen;
         if (cs.debug)
            printf("match:  direct at %ld len %ld\n",ihit,npatlen);
         rfirsthit = ihit;
         rhitlen   = npatlen;
         return 1;
      }
   }

   do
   {
      char *ppat = pszPat;       // pattern read cursor
      char *phay = pszHay+ibase; // haystack read cursor
   
      bool biskip = !bHead; // initial skip, add * at start
      ifirst = -1;     // pos'n of first matching char
      ilast  = -1;     // pos'n of last matching char
   
      bmatch=0;
      while (true)
      {
         if (!*ppat) {
            bmatch = 1;
            break;
         }

         char cpat  = 0;
         char cpat2 = 0;
         bool bdowc = cs.wpat; // do the wild char, or not
    
         if (biskip) {
            biskip = 0;
            cpat   = '*';
            if (cs.debug)
               printf("match:  process %c index %ld \"%s\"\n", cpat, ppat-pszPat, ppat);
         } else {
            cpat  = *ppat++;
            cpat2 = *ppat;
            if (cs.debug)
               printf("match:  process %c index %ld \"%s\"\n", cpat, ppat-pszPat-1, ppat-1);
         }
      
         // remapping of \\ \n \t \* \?
         if (cs.spat && cpat == '\\') {
            switch (cpat2) {
               case '\\': ppat++; break;
               case 't' : ppat++; cpat = '\t'; break;
               case 'q' : ppat++; cpat = '"';  break;
               case '*' : ppat++; cpat = '*'; bdowc = 0; break;
               case '?' : ppat++; cpat = '?'; bdowc = 0; break;
               case 'x' :
                  if (ppat[1] && ppat[2]) {
                     cpat = (char)getTwoDigitHex(ppat+1);
                     ppat += 3;
                     bdowc = 0;
                  }
                  break;
            }
         }
    
         if (bdowc && cpat == '*') 
         {
            // seek forward over *
            char cnext = peekpatchr(ppat, nesc);
            bool enext = (nesc > 0) ? 1 : 0;
            if (!cnext) { bmatch=1; break; }
            // **?
            if (!nesc && cnext == '*') continue;
            // isolate next non-* part
            long isrc=0,idst=0;
            while (idst<MAX_MATCH_BUF) {
               char csub = peekpatchr(ppat+isrc, nesc);
               if (nesc)
                  isrc += 1+nesc; // fetched \* or \xnn
               else {
                  if (!csub || csub == '*') break; // NO isrc increment on *
                  isrc++;
               }
               szMatchBuf[idst  ] = csub;
               szMatchEsc[idst++] = (bool)nesc;
            }
            szMatchBuf[idst] = '\0';
            szMatchEsc[idst] = '\0';
            ppat += isrc;
            if (cs.debug)
               printf("match:   check part \"%s\" cnext \"%c\" with hay at \"%.10s\"\n",szMatchBuf,cnext,phay);
            // find next occurrence of non-* part
            bool bsubmatch=0;
            while (*phay) {
               while (*phay && !cmpchr(*phay,cnext,bCase,enext)) phay++;
               if (!*phay) break;
               if (cs.debug)
                  printf("match:   from %.10s\n",phay);
               // matched first char, compare rest
               long isub=0;
               char *ppat2=szMatchBuf;
               bool *epat2=szMatchEsc;
               for (; phay[isub] && ppat2[isub]; isub++)
                  if (!cmpchr(phay[isub], ppat2[isub], bCase, epat2[isub]))
                     break;
               if (!ppat2[isub]) {
                  // rest matched: adapt hit positions
                  bsubmatch=1;
                  if (ifirst < 0)
                     ifirst = phay - pszHay;
                  ilast = phay - pszHay + isub - 1;
                  // jump past non-* part
                  if (cs.debug)
                     printf("match:   submatched \"%s\"\n",szMatchBuf);
                  phay += isub;
                  break;
               }
               // else retry from next position
               if (cs.debug)
                  printf("match:   submiss\n");
               phay++;
            }
            // synced past *
            if (!*ppat){
               if (bsubmatch) {
                  if (cs.debug)
                     printf("match:   full inner match, %ld %ld\n",ifirst,ilast);
                  bmatch=1;
               } else {
                  if (cs.debug)
                     printf("match:   full inner miss\n");
               }
               break; // match or miss
            }
            if (!*phay) break; // miss
            if (cs.debug)
               printf("match:   cont hay \"%.10s\" pat \"%.10s\"\n",phay,ppat);
            continue;
         }
         else 
         {
            // compare single char, adapt match positions
            if (!cmpchr(*phay, cpat, bCase, 0)) {
               if (cs.debug)
                  printf("match:   miss at haychr \"%c\" msk %c position %ld\n",*phay,cpat,phay-pszHay);
               break; // miss
            }
            if (ifirst < 0)
               ifirst = phay - pszHay;
            ilast  = phay - pszHay;
            phay++;
            // and continue
         }
      }  // end inner search loop
 
      if (cs.debug)
         printf("match:  1) ifirst %ld ilast %ld bmatch %d\n",ifirst,ilast,bmatch);

      if (bmatch) {
         // full hit somewhere, do we accept?
         if (!bTail) break;
         if (nhaylen > 0 && ilast == nhaylen-1) break;
         if (cs.debug)
            printf("match:  c) no line-end hit, %ld != %ld\n",ilast,nhaylen-1);
         // tail, and no hit at end: continue searching
      }
 
      if (ifirst < 0) break; // full miss
 
      ibase = ifirst+1; // try again
   }
   while (ibase < nhaylen);
 
   if (cs.debug)
      printf("match:  2) ifirst %ld ilast %ld bmatch %d for hay \"%s\" pat \"%s\"\n",ifirst,ilast,bmatch,pszHay,pszPat);

   if (bmatch && ifirst >= 0) {
      rfirsthit  = ifirst;
      if (ilast >= ifirst)
         rhitlen = (ilast-ifirst)+1;
      return 1;
   }

   return 0;
}

long indent(char *pszin) {
   char *psz = pszin;
   bool bempty = 1;
   for (; *psz; psz++)
      if (*psz != ' ' && *psz != '\t')
         { bempty = 0; break; }
   if (bempty) return -1;
   return psz-pszin;
}

// uses szLineBuf:
num getOldDirTime(char *pszName) 
{
   // printf("gdt %s\n",pszName);
   if (!pszGlblDirTimes)
      return 0;
   // direct search of entry in text file
   sprintf(szLineBuf, " %s\r", pszName);
   char *psz1 = strstr(pszGlblDirTimes, szLineBuf);
   if (!psz1)
      return 0;
   // step back to start of line, with timestamp
   while ((psz1 > pszGlblDirTimes) && (*psz1 != '\n'))
      psz1--;
   // skip LF, if not in very first line
   if (psz1 > pszGlblDirTimes)
      psz1++;
   num nTime = atonum(psz1);
   // printf("-> TIME %u\n",nTime);
   return nTime;
}

bool equalFileName(char *psz1, char *psz2) {
   #ifdef _WIN32
   // Windows: expect case-insensitive filenames
   return (!_stricmp(psz1, psz2)) ? 1 : 0;
   #else
   // Unix: expect case-sensitive filenames
   return (!strcmp(psz1, psz2)) ? 1 : 0;
   #endif
}

bool strBegins(char *pszStr, char *pszPat) {
   if (!strncmp(pszStr, pszPat, strlen(pszPat)))
      return 1;
   return 0;
}

bool striBegins(char *pszStr, char *pszPat) {
   long mystrnicmp(char *psz1, char *psz2, long nLen);
   if (!mystrnicmp(pszStr, pszPat, strlen(pszPat)))
      return 1;
   return 0;
}

bool strEnds(char *pszStr, char *pszPat) {
   long nlenhay = strlen(pszStr);
   long nlenpat = strlen(pszPat);
   if (nlenhay < nlenpat) return 0;
   return !strcmp(pszStr+nlenhay-nlenpat, pszPat) ? 1 : 0;
}

bool startsLikeSnapFile(char *psz) {
   return strBegins(psz, ":snapfile sfk,") || strBegins(psz, ":cluster sfk,");
}

bool startsLikeActFile(char *psz) {
   return strBegins(psz, "<interleaved-attributes-text version=\"1.0\" prefix=\"\">");
}

class InfoCounter {
public:
   InfoCounter    ( );
   ulong count    ( );  // RC > 0 says print the counter now
   bool  checkTime( );  // RC > 0 says print the counter now
   bool  countSkip(char *pszFile);
   ulong value    ( );
   ulong skipped  ( );
   char  *skipInfo( );
   void  reset    ( );
private:
   void  copyAll  ( );

   ulong nClUnits;
   ulong nClSkipped;
   num   nClTime;

   ulong nClTellSteps;
   ulong nClLastTold;
   ulong nClTellSteps2;
   ulong nClLastTold2;
   num   nClLastTimeTold;
   long  nClTimeInertia; // to avoid calling getCurrentTime() too often

   char  aClSkipInfo[100];
   long  nClSkipIdx;
};

InfoCounter::InfoCounter() { reset(); }

void InfoCounter::reset() 
{
   nClUnits      = 0;
   nClSkipped    = 0;
   nClTime       = 0;

   nClLastTold   = 0;
   nClTellSteps  = 1;
   nClLastTold2  = 0;
   nClTellSteps2 = 1;
   nClLastTimeTold = 0;
   nClTimeInertia = 10;

   memset(aClSkipInfo, 0, sizeof(aClSkipInfo));
   // memset(aClSkipInfo, ' ', 5 * 3);
   nClSkipIdx = 2; // force switch to 0 on first add
}

void InfoCounter::copyAll() {
   nClLastTimeTold = nClTime;
   nClLastTold     = nClUnits;
   nClLastTold2    = nClSkipped;
   nClTimeInertia  = 10;
}

ulong InfoCounter::value()    { return nClUnits; }
ulong InfoCounter::skipped()  { return nClSkipped; }
char *InfoCounter::skipInfo() { return aClSkipInfo; }

ulong InfoCounter::count() {
   nClUnits++;
   if (nClUnits >= (nClLastTold+nClTellSteps)) {
      nClTellSteps++;
      copyAll();
      return 1;
   }
   return checkTime();
}

bool InfoCounter::countSkip(char *pszFile)
{
   nClSkipped++;

   // mtklog("countskip %s", pszFile);

   // update list of skipped file extensions
   char *pszInfo = pszFile;
   char *pszExt  = strrchr(pszInfo, '.');
   if (pszExt) pszInfo = pszExt;
   long nInfoLen = strlen(pszInfo);
   if (nInfoLen > 4) pszInfo = pszInfo + nInfoLen - 4;
   char *pszCur = &aClSkipInfo[5*nClSkipIdx];
   nInfoLen = strlen(pszInfo);
   if (   strncmp(&aClSkipInfo[ 0], pszInfo, nInfoLen)
       && strncmp(&aClSkipInfo[ 5], pszInfo, nInfoLen)
       && strncmp(&aClSkipInfo[10], pszInfo, nInfoLen)
      )
   {
      // there is a change, so step and write
      nClSkipIdx = (nClSkipIdx + 1) % 3;
      pszCur = &aClSkipInfo[5*nClSkipIdx];
      memset(pszCur, ' ', 5);
      strncpy(pszCur, pszInfo, nInfoLen);
      if (nClSkipIdx == 2)
         pszCur[4] = '\0';
   }

   // mtklog("countskip info %s", aClSkipInfo);

   if (nClSkipped >= (nClLastTold2+nClTellSteps2)) {
      nClTellSteps2++;
      copyAll();
      return 1;
   }
   return checkTime();
}

bool InfoCounter::checkTime() {
   if (nClTimeInertia-- > 0)
      return 0;
   nClTimeInertia = 10;
   nClTime = getCurrentTime();
   if (nClTime > nClLastTimeTold + 1000) {
      copyAll();
      return 1;
   }
   return 0;
}

InfoCounter glblFileCount;

void resetFileCounter()   { glblFileCount.reset(); }
bool fileCountCheckTime() { return glblFileCount.checkTime(); }

class NoCaseText
{
public:
   NoCaseText    ( );
   inline  char lowerChar ( char c) { return aClLowerTab[(uchar)c]; }
   inline uchar lowerUChar(uchar c) { return (uchar)aClLowerTab[(uchar)c]; }
   void  setStringToLower(char *psz);

   char aClLowerTab[256+10];
};

NoCaseText glblNoCase;

NoCaseText::NoCaseText()
{
   memset(aClLowerTab, 0, sizeof(aClLowerTab));
   for (ulong u1=0; u1<256; u1++)
   {
      uchar u2 = (uchar)u1;

      if (u1 >= 0x41 && u1 <= 0x5A)    // A-Z
         u2 += 0x20U;    // -> a-z

      // ISO 8859-1 special character lowercase mapping

      if (u1 >= 0xC0 && u1 <= 0xDE)    // special characters
         if (u1 != 0xD7 && u1 != 0xDF) // NOT these two
            u2 += 0x20U; // e.g.  -> 

      aClLowerTab[u1] = (char)u2;
   }
}

void NoCaseText::setStringToLower(char *psz)
{
   ulong nLen = strlen(psz);
   for (ulong i=0; i<nLen; i++) {
      // psz[i] = tolower(psz[i]);
      psz[i] = aClLowerTab[(uchar)psz[i]];
   }
}

char  mytolower(char c)    { return glblNoCase.lowerChar(c);   }
uchar mytoloweru(uchar uc) { return glblNoCase.lowerUChar(uc); }

uchar *memIFind(uchar *pNeedle, num nNeedleSize, uchar *pHayStack, num nHaySize)
{
   num nRemain = nHaySize;
   uchar *pCur = pHayStack;
   uchar *pMax = pHayStack + nHaySize - nNeedleSize; // inclusive
   uchar c1    = glblNoCase.lowerUChar(*pNeedle);
   while (pCur <= pMax)
   {
      uchar *p1 = pCur;
      // seek to next potential start
      while ((p1 <= pMax) && (glblNoCase.lowerUChar(*p1) != c1))
         p1++;
      if (!p1 || (p1 > pMax))
         return 0;
      // compare from p1, case-insensitive
      // pMax assures that from p1, there are at least nNeedleSize
      // bytes available for actual compare, so we don't check
      // p1 against pMax again here.
      num i=0;
      for (; i<nNeedleSize; i++)
         if (glblNoCase.lowerUChar(pNeedle[i]) != glblNoCase.lowerUChar(p1[i]))
            break;
      if (i >= nNeedleSize)
         return p1;  // hit
      // no hit, proceed
      pCur = p1+1;
   }
   return 0;
}

class FileInfo {
public:
      FileInfo    (bool bWriteOnly=false);
     ~FileInfo    ( );
long  init        (char *pszFileName, long nShortNameLen=60, num nFileSize=0);
bool  fileValid   ( );
bool  timeToTell  ( );
long  percentage  (num nPosition);
char  *prefix     ( );
char  *shortName  ( );
num   fileSize    ( ) { return nClFileSize; }
void  printBlankLine (long nChars);
private:
bool  bClWriteOnly;
char  *pszClName;
long  nClNameLen;
long  nClShortNameLen;
num   nClStartTime;
num   nClNextTell;
num   nClFileSize;
};

FileInfo::FileInfo(bool bWriteOnly) {
   bClWriteOnly   = bWriteOnly;
   pszClName      = 0;
   nClNameLen     = 0;
   nClStartTime   = 0;
   nClNextTell    = 0;
   nClFileSize    = 0;
}

long FileInfo::init(char *pszName, long nShortNameLen, num nFileSize) 
{
   pszClName = strdup(pszName);
   if (!pszClName) return 9+perr("out of memory\n");
   nClNameLen = strlen(pszClName);
   nClShortNameLen = nShortNameLen;
   nClStartTime = getCurrentTime();
   nClNextTell = nClStartTime + 1000;
   nClFileSize = nFileSize;
   return 0;
}

bool FileInfo::fileValid() {
   return (nClFileSize >= 0);
}

FileInfo::~FileInfo() {
   if (pszClName) delete [] pszClName;
}

bool FileInfo::timeToTell() {
   if (getCurrentTime() >= nClNextTell) {
      nClNextTell = getCurrentTime() + 1000;
      return true;
   }
   return false;
}

long FileInfo::percentage(num nPosition) {
   if (!nClFileSize) return 100;
   return (long)(nPosition * 100 / nClFileSize);
}

char *FileInfo::prefix() {
   long nLimit = nClShortNameLen;
   if (nClNameLen > nLimit)
      return "...";
   return "";
}

char *FileInfo::shortName() {
   long nLimit = nClShortNameLen;
   if (!pszClName) return "";
   long noff = 0;
   if (nClNameLen > nLimit)
        noff = nClNameLen - nLimit;
   return pszClName+noff;
}

void FileInfo::printBlankLine(long nChars) {
   for (long i=0; i<nChars; i++)
      putchar(' ');
   printf("\r");
}

FileSet  glblFileSet;   // long format -dir and -file set
CoiTable glblSFL;       // short format specific file list

long glblSFLNumberOfEntries() { return glblSFL.numberOfEntries(); }

long StringPipe::setEntry(long iIndex, char *psz, char *pAttr)
{
   if (clAttr.setEntry(iIndex, pAttr)) return 9;
   return clText.setEntry(iIndex, psz);
}

long StringPipe::addEntry(char *psz, char *pAttr)
{
   if (clAttr.addEntry(pAttr)) return 9;
   return clText.addEntry(psz);
}

void StringPipe::resetEntries()
{
   clText.resetEntries();
   clAttr.resetEntries();
}

char *StringPipe::getEntry(long nIndex, long nLine, char **ppAttr)
{
   char *ptext = clText.getEntry(nIndex, nLine);
   char *pattr = clAttr.getEntry(nIndex, nLine);
   if (ppAttr) *ppAttr = pattr;
   return ptext;
}

void StringPipe::resetPipe()
{
   resetEntries();
   nReadIndex = 0;
}

void StringPipe::dump(char *pszTitle)
{
   printf("[pipe %s contents (%ld lines):]\n",pszTitle,numberOfEntries());
   for (long i=0; i<numberOfEntries(); i++)
      printf("[   \"%s\"]\n",getEntry(i,__LINE__));
}

void oprintf(char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';
   char *psz = szPrintBufMap;

   #ifdef _WIN32
   // windows only: if output is NOT directed to file, map it to DOS charset,
   // to have filenames listed with correct umlauts etc.
   if (bGlblEnableOPrintf && (bGlblForceCConv || bGlblHaveInteractiveConsole)) {
      while (*psz)
         *psz++ = ansiCharToOEM(*psz);
   }
   #endif

   printf("%s", szPrintBufMap);
   fflush(stdout);
}

void oprintf(StringPipe *pOutData, char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';

   char *psz = szPrintBufMap;

   if (pOutData) {
      // auto-strip LF if given. oprintf adds full records only.
      // do NOT convert text, as it is passed to further chain commands.
      long nlen = strlen(psz);
      if (nlen > 0 && psz[nlen-1] == '\n')
         psz[nlen-1] = '\0';
      pOutData->addEntry(psz, "");
   } else {
      #ifdef _WIN32
      // windows only: if output is NOT directed to file, map it to DOS charset,
      // to have filenames listed with correct umlauts etc.
      if (bGlblEnableOPrintf && (bGlblForceCConv || bGlblHaveInteractiveConsole)) {
         while (*psz)
            *psz++ = ansiCharToOEM(*psz);
      }
      #endif
      printf("%s", szPrintBufMap);
      fflush(stdout);
   }
}

class CommandChaining
{
public:
   CommandChaining ( );

   bool  colfiles;   // collect filenames
   bool  usefiles;   // use collected filenames
   bool  coldata;    // collect data
   bool  usedata;    // use collected data

   CoiTable *infiles;   // while using filenames
   CoiTable *outfiles;  // while collecting filenames

   StringPipe *indata;  // text and attributes
   StringPipe *outdata; // text and attributes

   bool  text2files;
   bool  files2text;

   long  init();
   void  reset();    // per loop
   void  shutdown();
   bool  colany() { return colfiles || coldata; }
   bool  useany() { return usefiles || usedata; }
   long  moveOutToIn(char *pszCmd);
   long  convInDataToInFiles ( );

   long  addLine(char *pszText, char *pszAttr, bool bSplitByLF=0);
   long  addToCurLine(char *pszWords, char *pszAttr, bool bNewLine=0);

   long  addFile(Coi &ocoi); // is COPIED
   long  numberOfInFiles() { return infiles->numberOfEntries(); }
   Coi  *getFile(long nIndex); // returns null on wrong index

   long  print(char cattrib, long nflags, char *pszFormat, ...); // no multi-line
   long  print(char *pszFormat, ...); // multi-line support

   long  printFile(char *pszOutFile, bool bWriteFile, char *pszFormat, ...);

   void  dumpContents();   // to terminal

private:
   char  szClBuf[MAX_LINE_LEN+10];
   char  szClAttr[MAX_LINE_LEN+10];
   bool  btold1;
}
chain;

// bool chainColFiles() { return chain.colfiles; }

long chainAddLine(char *pszText, char *pszAttr, bool bSplitByLF) 
{
   // mtklog("chain-add: \"%.50s\"", pszText);
   return chain.addLine(pszText, pszAttr, bSplitByLF);
}

long CommandChaining::addFile(Coi &ocoi) {
   return outfiles->addEntry(ocoi);
}

Coi *CommandChaining::getFile(long nIndex) {
   return infiles->getEntry(nIndex, __LINE__);
}

void CommandChaining::dumpContents() 
{
   if (usedata) {
      printf("[indata]\n");
      for (long i=0; i<chain.indata->numberOfEntries(); i++) {
         char *pattr = "";
         char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
         if (ptext)
            printColorText(ptext, pattr, 1); // with lf
      }         
   }

   if (usefiles) {
      printf("[infiles]\n");
      for (long i=0; i<chain.numberOfInFiles(); i++) {
         Coi *pcoi = chain.getFile(i);
         if (pcoi) {
            oprintf("%s\n", pcoi->name());
         }
      }
   }
}

// uses print buffers from printx
long CommandChaining::print(char cattrib, long nflags, char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);

   bool bWithPostLF = (nflags & 1) ? 1 : 0;
   bool bWithPreLF  = (nflags & 2) ? 1 : 0;

   // prepare text
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   // prepare mono color
   long nlen = strlen(szPrintBuf1);
   memset(szPrintAttr, cattrib, nlen);
   szPrintAttr[nlen] = '\0';

   if (coldata) {
      if (bWithPreLF)
         addLine("", "");
      if (bWithPostLF) {
         return addLine(szPrintBuf1, szPrintAttr);
      } else {
         return addToCurLine(szPrintBuf1, szPrintAttr, bWithPreLF);
      }
   } else {
      info.clear();
      if (bWithPreLF)
         printf("\n");
      printColorText(szPrintBuf1, szPrintAttr, bWithPostLF);
   }
   return 0;
}

// uses print buffers from printx
long CommandChaining::printFile(char *pszOutFile, bool bWriteFile, char *pszFormat, ...)
{
   long nrc = 0;

   // there should be no redirect file open
   if (cs.outfile) return 9+perr("redirect file already open");

   if (bWriteFile) {
      // isolate path, create all directories
      long createSubDirTree(char *pszDstRoot, char *pszDirTree, char *pszRefRoot);
      strcopy(szPrintBuf2, pszOutFile);
      char *psz1 = strrchr(szPrintBuf2, glblPathChar);
      if (psz1) {
         *psz1 = '\0'; 
         if (nrc = createSubDirTree(szPrintBuf2, "", 0))
            return nrc+perr("cannot create dir: %s\n", szPrintBuf2);
      }
   
      // init redirect outfile
      if (!(cs.outfile = fopen(pszOutFile, "w")))
         return 9+perr("cannot write: %s\n", pszOutFile);
   } else {
      // just simulate the file writing:
      printf("\n:file:\n%s\n", pszOutFile);
   }

   // NO RETURN WITHOUT CONDITIONAL FILE CLOSE BEGIN

   va_list argList;
   va_start(argList, pszFormat);

   // prepare text
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   if (!coldata && !cs.outfile)
      info.clear();

   char *psz1 = szPrintBuf1;
   while (psz1 && *psz1)
   {
      char *psz2 = strchr(psz1, '\n');
      if (psz2) {
         // intermediate record
         long n = psz2-psz1;
         if (n > MAX_LINE_LEN) n = MAX_LINE_LEN;
         memcpy(szPrintBuf2, psz1, n);
         szPrintBuf2[n] = '\0';
         psz2++;
      } else {
         // last record
         strcopy(szPrintBuf2, psz1);
      }

      long nlen = strlen(szPrintBuf2);
      memset(szPrintAttr, ' ', nlen);
      szPrintAttr[nlen] = '\0';

      if (coldata)
         addLine(szPrintBuf2, szPrintAttr);
      else
      if (cs.outfile)
         fprintf(cs.outfile, "%s\n", szPrintBuf2);
      else
         printColorText(szPrintBuf2, szPrintAttr, 1);

      psz1 = psz2;
   }

   // NO RETURN WITHOUT FILE CLOSE END

   if (bWriteFile && cs.outfile) {
      fclose(cs.outfile);
      cs.outfile = 0;
      printf("written: %s\n", pszOutFile);
   }

   return nrc;
}

// raw printf like method. no colors, no special options,
// but it splits multiline text into many records.
// one-line text SHOULD be terminated with LF.
long CommandChaining::print(char *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);

   // prepare text
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   if (!coldata && !cs.outfile)
      info.clear();

   char *psz1 = szPrintBuf1;
   while (psz1 && *psz1)
   {
      char *psz2 = strchr(psz1, '\n');
      if (psz2) {
         // intermediate record
         long n = psz2-psz1;
         if (n > MAX_LINE_LEN) n = MAX_LINE_LEN;
         memcpy(szPrintBuf2, psz1, n);
         szPrintBuf2[n] = '\0';
         psz2++;
      } else {
         // last record
         strcopy(szPrintBuf2, psz1);
      }

      long nlen = strlen(szPrintBuf2);
      memset(szPrintAttr, ' ', nlen);
      szPrintAttr[nlen] = '\0';

      if (coldata)
         addLine(szPrintBuf2, szPrintAttr);
      else
      if (cs.outfile)
         fprintf(cs.outfile, "%s\n", szPrintBuf2);
      else
         printColorText(szPrintBuf2, szPrintAttr, 1);

      psz1 = psz2;
   }

   return 0;
}

long CommandChaining::convInDataToInFiles()
{
   // user wants to convert text to filename list
   for (long i=0; i<indata->numberOfEntries(); i++) {
      char *psz1 = indata->getEntry(i, __LINE__);
      // strip LFs (if any) from indata. we will drop
      // all indata records below, therefore edit directly:
      long nlen = strlen(psz1);
      if (nlen > 0 && psz1[nlen-1] == '\n')
          psz1[nlen-1] = '\0';
      Coi ocoi(psz1, 0);
      infiles->addEntry(ocoi); // is copied
   }
   indata->resetEntries();
   if (cs.verbose)
      printf("[chain converts text data to filename list]\n");
   usefiles = 1;
   usedata  = 0;
   return 0;
}

long CommandChaining::addLine(char *pszText, char *pszAttr, bool bSplitByLF)
{
   mtklog("addl.text: %d %04d \"%s\"", bSplitByLF, strlen(pszText), pszText);
   mtklog("addl.attr: %d %04d \"%s\"", bSplitByLF, strlen(pszAttr), pszAttr);

   if (pszText[0] && bSplitByLF) 
   {
      // detect if the line contains multiple linefeeds. 
      // if so, create multiple records.
      bool btermlf = 0;
      char *psz  = pszText;
      long nalen = strlen(pszAttr);
      while (*psz) 
      {
         char *psz2 = psz;
         while (*psz2 && *psz2 != '\n')
            psz2++;
         long nlen = psz2-psz;
         if (nlen > MAX_LINE_LEN) nlen = MAX_LINE_LEN;

         // isolate text part
         memcpy(szClBuf, psz, nlen);
         szClBuf[nlen] = '\0';
         removeCRLF(szClBuf); // just in case

         // isolate attribute part
         long noff = psz-pszText;
         if (noff < nalen) {
            strncpy(szClAttr, pszAttr+noff, nlen);
            szClAttr[nlen] = '\0';
         } else {
            szClAttr[0] = '\0';
         }

         // then store both parts
         outdata->addEntry(szClBuf, szClAttr);

         if (*psz2) {
            psz2++; // skip lf
            if (!*psz2) btermlf = 1;
         }
         psz = psz2;
      }
      if (btermlf && (bSplitByLF > 1)) {
         // the text was ended by a LF. this should procude
         // an empty line only if SplitByLF == 2.
         outdata->addEntry("", "");
      }
   } else {
      // used also for empty strings, to add empty line
      outdata->addEntry(pszText, pszAttr);
   }
   return 0;
}

long CommandChaining::addToCurLine(char *pszWords, char *pszAttr, bool bNewLine)
{
   mtklog("addc.text: %d %04d \"%s\"", bNewLine, strlen(pszWords), pszWords);
   mtklog("addc.attr: %d %04d \"%s\"", bNewLine, strlen(pszAttr ), pszAttr );

   if (!outdata->numberOfEntries() || bNewLine)
       if (outdata->addEntry("", ""))
         return 9;

   // append actual text
   {
      long nidx = outdata->numberOfEntries()-1;
      if (nidx < 0) return 9+perr("internal 200706102039");

      char *pAttr  = 0;   
      char *pszCur = outdata->getEntry(nidx, __LINE__, &pAttr);
      strcopy(szClBuf, pszCur);
      if (pAttr) strcopy(szClAttr, pAttr);
      else szClAttr[0] = '\0';

      long icurlen = strlen(szClBuf);   
      long nremain = MAX_LINE_LEN - icurlen - 1;

      // append text
      long naddlen = strlen(pszWords);
      if (naddlen > nremain) {
         if (!btold1) {
            btold1 = 1;
            perr("line buffer overflow: cannot join \"%s\" and following\n", pszWords);
            pinf("buffered lines may have %ld characters max.\n", MAX_LINE_LEN-10);
         }
         return 1;
      }

      // and attributes as well, length limited by text
      long nattlen = strlen(pszAttr);
      if (nattlen > naddlen) nattlen = naddlen;

      strncpy(szClBuf+icurlen, pszWords, naddlen);
      szClBuf[icurlen+naddlen] = '\0';

      strncpy(szClAttr+icurlen, pszAttr, nattlen);
      szClAttr[icurlen+nattlen] = '\0';

      outdata->setEntry(nidx, szClBuf, szClAttr);
   }

   return 0;
}

long CommandChaining::moveOutToIn(char *pszCmd)
{
   CoiTable *p1 = infiles;
   infiles      = outfiles;
   outfiles     = p1;
   outfiles->resetEntries();

   usefiles = colfiles;

   StringPipe *p3 = indata;
   indata   = outdata;
   outdata  = p3;
   outdata->resetPipe();

   usedata  = coldata;

   colfiles = 0;
   coldata  = 0;

   if (usefiles && usedata) 
   {
      // chain command with ANY input:
      // can work only if one stream has data AND other is empty
      if (numberOfInFiles() && indata->numberOfEntries()) {
         perr("command chaining: cannot use text data AND filename list in parallel.\n");
         exit(9); 
      }

      // reduce mode selection, following given data
      if (indata->numberOfEntries()) usefiles = 0;
      if (numberOfInFiles()) usedata = 0;
   }

   if (cs.verbose)
      printf("[chain swaps out and in, text2files=%d files2text=%d]\n",text2files,files2text);

   bool bt2f = text2files;
   bool bf2t = files2text;

   text2files = 0;
   files2text = 0;

   if (bt2f && bf2t)
      return 9+perr("command chaining stopped: cannot execute text2files AND files2text\n");

   if (usedata && !usefiles && !indata->numberOfEntries()) {
      if (cs.verbose)
         printf("[chain autoselects ftt from %ld filenames.]\n",numberOfInFiles());
      bf2t = 1;
   }

   if (usefiles && !usedata && !numberOfInFiles()) {
      if (cs.verbose)
         printf("[chain autoselects ttf from %ld text lines.]\n",indata->numberOfEntries());
      bt2f = 1;
   }

   if (bf2t)
   {
      // autoconvert filename list to text, even on empty list.
      long nrec = numberOfInFiles();
      char *pfile=0;
      for (long i=0; i<nrec; i++) {
         Coi *pcoi = getFile(i);
         if (pcoi) indata->addEntry(pcoi->name(), "");
      }
      infiles->resetEntries();
      if (cs.verbose)
         printf("[chain converts filename list to text data, %ld records]\n", nrec);
      usefiles = 0;
      usedata  = 1;
   }
   else
   if (bt2f)
   {
      if (indata->numberOfEntries()) {
         // user wants to convert text to filename list
         convInDataToInFiles();
      } else {
         // out of chain filenames
         if (!cs.quiet) {
            pinf("chaining stops before %s: no more filenames\n",pszCmd);
         }
         return 1;
      }
   }

   if (cs.verbose) {
      if (usefiles)
         printf("[chain passes %ld files to %s]\n",numberOfInFiles(),pszCmd);
      if (usedata)
         printf("[chain passes %ld text lines to %s]\n",indata->numberOfEntries(),pszCmd);
   }

   return 0;
}

CommandChaining::CommandChaining()
{
   colfiles   = 0;
   usefiles   = 0;
   coldata    = 0;
   usedata    = 0;

   infiles    = 0;
   outfiles   = 0;

   indata     = 0;
   outdata    = 0;

   text2files = 0;
   files2text = 0;
   btold1     = 0;
}

long CommandChaining::init()
{
   infiles  = new CoiTable();
   outfiles = new CoiTable();

   indata   = new StringPipe();
   outdata  = new StringPipe();

   memset(szClBuf, 0, sizeof(szClBuf));
   memset(szClAttr, 0, sizeof(szClAttr));

   return 0;
}

void CommandChaining::reset()
{
   colfiles   = 0;
   usefiles   = 0;
   coldata    = 0;
   usedata    = 0;
   text2files = 0;
   files2text = 0;
   btold1     = 0;

   infiles->resetEntries();
   outfiles->resetEntries();

   indata->resetEntries();
   outdata->resetEntries();
}

void CommandChaining::shutdown()
{
   if (infiles) {
      infiles->resetEntries();
      delete infiles;
   }
   if (outfiles) {
      outfiles->resetEntries();
      delete outfiles;
   }

   if (indata) {
      indata->resetEntries();
      delete indata;
   }
   if (outdata) {
      outdata->resetEntries();
      delete outdata;
   }
}

long printEcho(bool bAddToCurLine, const char *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';
   char *pszSrc = szPrintBuf1;
   long iDst = 0;
   char nAttr = ' ';
   bool bResetOnLF = 0;
   while (*pszSrc && (iDst < sizeof(szPrintBuf2)-10)) 
   {
      /*
      if (pszSrc[0] == '\\' && pszSrc[1] == glblWildChar) {
         pszSrc += 2;
         szPrintBuf2[iDst] = glblWildChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      */

      if (!strncmp(pszSrc, "[["    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = '[';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "]]"    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = ']';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      // base colors are bright or dark depending on their first name char
      if (!mystrncmp(pszSrc, "[red]"    , 5)) { nAttr = pszSrc[1]; pszSrc += 5; } else
      if (!mystrncmp(pszSrc, "[green]"  , 7)) { nAttr = pszSrc[1]; pszSrc += 7; } else
      if (!mystrncmp(pszSrc, "[blue]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[yellow]" , 8)) { nAttr = pszSrc[1]; pszSrc += 8; } else
      if (!mystrncmp(pszSrc, "[cyan]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[magenta]", 9)) { nAttr = pszSrc[1]; pszSrc += 9; } else

      if (!strncmp(pszSrc, "[def]"    , 5)) { pszSrc += 5; nAttr = ' '; }

      else 
      {
         szPrintBuf2[iDst] = *pszSrc;
         szPrintAttr[iDst] = nAttr;
         if (*pszSrc == '\n' && bResetOnLF) {
            nAttr = ' ';
            szPrintAttr[iDst] = nAttr;
            bResetOnLF = 0;
         }
         pszSrc++;
         iDst++;
      }
   }
   szPrintBuf2[iDst] = '\0';
   if (chain.coldata) {
      if (bAddToCurLine) {
         chain.addToCurLine(szPrintBuf2, szPrintAttr, 0);
      } else {
         // mode 2: if echo text ends with "\n", add an empty line.
         chain.addLine(szPrintBuf2, szPrintAttr, 2);
      }
   } else {
      printColorText(szPrintBuf2, szPrintAttr, 0);
      if (!bAddToCurLine) printf("\n");
      fflush(stdout);
   }
   return 0;
}

bool bGlblInSpecificProcessing = 0;

Array glblGrepPat("grep");
Array glblIncBin("incbin");

StringTable::StringTable() {
   nClArraySize = 0;
   nClArrayUsed = 0;
   apClArray    = 0;
}

StringTable::~StringTable() {
   resetEntries();
}

void StringTable::dump(long nIndent) {
   printf("] %.*sstringtable %p, %d entries:\n",nIndent,pszGlblBlank,this,nClArrayUsed);
   for (long i=0; i<nClArrayUsed; i++) {
      printf("]   %.*s%s\n", nIndent,pszGlblBlank,apClArray[i] ? apClArray[i] : "<null>");
   }
}

void StringTable::resetEntries() {
   for (long i=0; i<nClArrayUsed; i++) {
      if (apClArray[i]) delete [] apClArray[i];
      apClArray[i] = 0;
   }
   nClArrayUsed = 0;
   if (apClArray)
      delete [] apClArray;
   apClArray = 0;
   nClArraySize = 0;
}

long StringTable::numberOfEntries() {
   return nClArrayUsed;
}

bool StringTable::isSet(long iIndex) {
   if (iIndex < 0)
      { pwarn("illegal index: %d\n", iIndex); return 0; }
   return (iIndex < nClArrayUsed) ? 1 : 0;
}

long StringTable::expand(long nSoMuch) {
   char **apTmp = new char*[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (apClArray) {
      memcpy(apTmp, apClArray, nClArraySize*sizeof(char*));
      delete [] apClArray;
   }
   apClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

long StringTable::addEntry(char *psz, long nAtPos, char **ppCopy) 
{
   char *pCopy = 0;
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (long i=nClArrayUsed; i>nAtPos; i--)
         apClArray[i] = apClArray[i-1];
      pCopy = psz ? strdup(psz) : 0;
      apClArray[nAtPos] = pCopy;
      nClArrayUsed++;
   } else {
      pCopy = psz ? strdup(psz) : 0;
      apClArray[nClArrayUsed++] = pCopy;
   }
   if (ppCopy) *ppCopy = pCopy;
   return 0;
}

long StringTable::removeEntry(long nAtPos) {
   if (nAtPos < 0 || nAtPos >= nClArrayUsed)
      return 9;
   if (apClArray[nAtPos]) delete [] apClArray[nAtPos];
   for (long i=nAtPos; i<nClArrayUsed-1; i++)
      apClArray[i] = apClArray[i+1];
   apClArray[nClArrayUsed-1] = 0; // just in case
   nClArrayUsed--;
   return 0;
}

long StringTable::addEntryPrefixed(char *psz, char cPrefix) {
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   // create extended copy with prefix at beginning
   long nLen = strlen(psz);
   char *pszCopy = new char[nLen+2];
   pszCopy[0] = cPrefix;
   strcpy(pszCopy+1, psz);
   // add this copy
   apClArray[nClArrayUsed++] = pszCopy;
   if (cs.debug) printf("]  stringtable %p added %s, have %d\n",this,pszCopy,nClArrayUsed);
   return 0;
}

long StringTable::setEntry(long nIndex, char *psz) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("illegal set index: %d\n", nIndex);
   if (apClArray[nIndex])
      delete [] apClArray[nIndex];
   apClArray[nIndex] = strdup(psz);
   return 0;
}

long StringTable::setEntryPrefixed(long nIndex, char *psz, char cPrefix) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("illegal set index: %d\n", nIndex);
   // create extended copy with prefix at beginning
   long nLen = strlen(psz);
   char *pszCopy = new char[nLen+2];
   pszCopy[0] = cPrefix;
   strcpy(pszCopy+1, psz);
   // delete old entry, if any
   if (apClArray[nIndex])
      delete [] apClArray[nIndex];
   // set new copy
   apClArray[nIndex] = pszCopy;
   if (cs.debug) printf("]  stringtable %p set %s, have %d\n",this,pszCopy,nClArrayUsed);
   return 0;
}

char *StringTable::getEntry(long nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return apClArray[nIndex];
   perr("illegal StringTable index: %d tline %d\n", nIndex, nTraceLine);
   return 0;
}

long StringTable::find(char *psz) {
   for (long i=0; i<nClArrayUsed; i++)
      if (apClArray[i] && !strcmp(apClArray[i], psz))
         return i;
   return -1;
}

StringTable glblErrorLog;
StringTable glblStaleLog;

StringPipe::StringPipe()
{
   nReadIndex = 0;
}

bool StringPipe::eod()
{
   return (nReadIndex >= numberOfEntries());
}

char *StringPipe::read(char **ppAttr)
{
   if (nReadIndex < numberOfEntries()) {
      char *psz   = clText.getEntry(nReadIndex, __LINE__);
      char *pattr = clAttr.getEntry(nReadIndex, __LINE__);
      // printf("PIPE.READ %ld = %s\n",nReadIndex,psz);
      nReadIndex++;
      if (ppAttr)
         *ppAttr = pattr;
      return psz;
   }
   return 0; // EOD
}

void logError(const char *format, ...)
{
   va_list arg_ptr;
   va_start(arg_ptr, format);

   char szTmpBuf[4096];
   vsprintf(szTmpBuf, format, arg_ptr);

   glblErrorLog.addEntry(szTmpBuf);
   printf("%s\n", szTmpBuf);
}

char *skipDotSlash(char *psz) {
   if (!strncmp(psz, glblDotSlash, 2))
      psz += 2;
   return psz;
}

void trackStaleZip(char *pszFileName)
{
   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   long nEntries = glblStaleLog.numberOfEntries();
   for (long i=0; i<nEntries; i++)
   {
      char *psz = glblStaleLog.getEntry(i, __LINE__);
      if (!strcmp(psz, pszFileName))
         return; // is already registered
   }

   // add zip containing stale files to stale list
   glblStaleLog.addEntry(pszFileName);
}

bool endsWithPathChar(char *pszPath, bool bAcceptFWSlash=0) {
   long nLen = strlen(pszPath);
   if (nLen>0) {
      if (pszPath[nLen-1] == glblPathChar)
         return 1;
      if (bAcceptFWSlash && pszPath[nLen-1] == '/')
         return 1;
   }
   return 0;
}

bool endsWithColon(char *pszPath) {
   #ifdef _WIN32
   long nLen = strlen(pszPath);
   if (nLen>0 && pszPath[nLen-1] == ':')
      return 1;
   #endif
   return 0;
}

// ============================================================

Array::Array(const char *pszID) {
   nClRowsSize = 0;
   nClRowsUsed = 0;
   apClRows    = 0;
   nClCurRow   = 0;
   pszClID     = pszID;
}

Array::~Array() {
   reset();
}

void Array::dump() {
   printf("] array %s dump:\n",pszClID);
   for (long iRow=0; iRow<nClRowsUsed; iRow++) {
      StringTable *pRow = apClRows[iRow];
      printf("]   row %p:\n",pRow);
      pRow->dump(5);
   }
}

// internal: expand row array
long Array::expand(long nSoMuch) {
   StringTable **apTmp = new StringTable*[nClRowsSize+nSoMuch];
   if (!apTmp) return 9;
   if (apClRows) {
      memcpy(apTmp, apClRows, nClRowsSize*sizeof(StringTable*));
      delete [] apClRows;
   }
   apClRows = apTmp;
   nClRowsSize += nSoMuch;
   return 0;
}

// internal: make sure at least one row exists
long Array::ensureBase( ) {
   if (!nClRowsSize) {
      // if (cs.debug) printf("] array %p crt initial\n",this);
      // create initial row, for one-dimensional mode
      if (expand(1)) return 9;
      StringTable *pFirst = new StringTable();
      if (!pFirst) return 9;
      apClRows[nClRowsUsed++] = pFirst;
   }
   return 0;
}

// public: remove everything
void Array::reset() {
   // if (cs.debug) printf("] array %p RESET\n",this);
   for (long i=0; i<nClRowsUsed; i++) {
      delete apClRows[i];
      apClRows[i] = 0;
   }
   nClRowsUsed = 0;
   if (apClRows) {
      delete [] apClRows;
      apClRows = 0;
   }
   nClRowsSize = 0;
}

// public: return number of columns in current row
long Array::numberOfEntries() {
   if (ensureBase()) return 0;
   return apClRows[nClCurRow]->numberOfEntries();
}

long Array::numberOfEntries(long lRow) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   return apClRows[lRow]->numberOfEntries();
}

// public: add string object to current row
long Array::addString(char *psz) {
   if (ensureBase()) return 0;
   if (cs.debug) printf("] array %s: add to row %d entry %s. [%d rows total]\n",pszClID,nClCurRow,psz,nClRowsUsed);
   long lRC = apClRows[nClCurRow]->addEntryPrefixed(psz, 's');
   return lRC;
}

long Array::addString(long lRow, char *psz) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   if (cs.debug) printf("] array %s: add to row %d entry %s. [%d rows total]\n",pszClID,lRow,psz,nClRowsUsed);
   long lRC = apClRows[lRow]->addEntryPrefixed(psz, 's');
   return lRC;
}

long Array::addNull(long lRow) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   if (cs.debug) printf("] array %s: add NULL to row %d. [%d rows total]\n",pszClID,lRow,nClRowsUsed);
   long lRC = apClRows[lRow]->addEntry(0);
   return lRC;
}

long Array::setString(long lRow, long nIndex, char *psz) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   if (cs.debug) printf("] array %s: set row %d:%d entry %s. [%d rows total]\n",pszClID,lRow,nIndex,psz,nClRowsUsed);
   long lRC = apClRows[lRow]->setEntryPrefixed(nIndex, psz, 's');
   return lRC;
}

// public: get string object from current row
char *Array::getString(long nIndex) {
   if (ensureBase()) return 0;
   char *pszRaw = apClRows[nClCurRow]->getEntry(nIndex, __LINE__);
   if (!pszRaw)
      return 0; // NULL entry
   if (pszRaw[0] != 's') { perr("%s: no string entry type at %u %u\n", pszClID, nClCurRow, nIndex); return 0; }
   return pszRaw+1;
}

char *Array::getString(long lRow, long nIndex) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   char *pszRaw = apClRows[lRow]->getEntry(nIndex, __LINE__);
   if (!pszRaw)
      return 0; // NULL entry
   if (pszRaw[0] != 's') { perr("%s: no string entry type at %u %u\n", pszClID, lRow, nIndex); return 0; }
   return pszRaw+1;
}

// public: add integer to current row, internally encoded as string
long Array::addLong(long nValue, int nTraceLine) {
   if (ensureBase()) return 0;
   if (cs.debug) printf("] array %s: add to row %d entry %d [tline %d]\n",pszClID,nClCurRow,nValue,nTraceLine);
   char szBuf[100];
   ulong uValue = (ulong)nValue;
   // char *_ultoa( unsigned long value, char *string, int radix );
   #ifdef _WIN32
   _ultoa(uValue, szBuf, 16);
   #else
   sprintf(szBuf, "%lx", uValue);
   #endif
   return apClRows[nClCurRow]->addEntryPrefixed(szBuf, 'i');
}

long Array::addLong(long lRow, long nValue, int nTraceLine) {
   if (ensureBase()) return 0;
   if (cs.debug) printf("] array %s: add to row %d entry %d [tline %d]\n",pszClID,lRow,nValue,nTraceLine);
   if (lRow < 0 || lRow > nClRowsUsed) return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   char szBuf[100];
   ulong uValue = (ulong)nValue;
   #ifdef _WIN32
   _ultoa(uValue, szBuf, 16);
   #else
   sprintf(szBuf, "%lx", uValue);
   #endif
   return apClRows[lRow]->addEntryPrefixed(szBuf, 'i');
}

long Array::getLong(long nIndex) {
   if (ensureBase()) return 0;
   char *pszRaw = apClRows[nClCurRow]->getEntry(nIndex, __LINE__);
   if (!pszRaw)
      return 0;
   if (pszRaw[0] != 'i') { perr("no long entry type at row %u col %u\n", nClCurRow, nIndex); return 0; }
   // unsigned long strtoul( const char *nptr, char **endptr, int base );
   ulong uValue = strtoul(pszRaw+1, 0, 16);
   return (long)uValue;
}

long Array::getLong(long lRow, long nIndex, int nTraceLine) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   char *pszRaw = apClRows[lRow]->getEntry(nIndex, nTraceLine);
   if (!pszRaw)
      return 0;
   if (pszRaw[0] != 'i') { perr("no long entry type at row %u col %u\n", lRow, nIndex); return 0; }
   // unsigned long strtoul( const char *nptr, char **endptr, int base );
   ulong uValue = strtoul(pszRaw+1, 0, 16);
   return (long)uValue;
}

long Array::setLong(long lRow, long nIndex, long nValue, int nTraceLine) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   char szBuf[100];
   ulong uValue = (ulong)nValue;
   // char *_ultoa( unsigned long value, char *string, int radix );
   #ifdef _WIN32
   _ultoa(uValue, szBuf, 16);
   #else
   sprintf(szBuf, "%lx", uValue);
   #endif
   return apClRows[lRow]->setEntryPrefixed(nIndex, szBuf, 'i');
}

// public: create new row. shouldn't be called for first row.
long Array::addRow(int nTraceLine) {
   long nOldRows = nClRowsSize;
   if (ensureBase()) return 0;
   // if anyone calls this before adding first data, accept it.
   if (!nOldRows)
      return 0;
   // for all further rows, check if row table is full.
   // if so, expand in exponential steps.
   if (nClRowsUsed == nClRowsSize) {
      if (expand(nClRowsSize)) return 9;
   }
   // finally, add new row object
   StringTable *pFirst = new StringTable();
   if (!pFirst) return 9;
   apClRows[nClRowsUsed++] = pFirst;
   nClCurRow = nClRowsUsed-1;
   if (cs.debug) printf("array %s extended to %d rows [tln %d]\n",pszClID,nClRowsUsed,nTraceLine);
   return 0;
}

// public: select current row
long Array::setRow(long iCurRow, int nTraceLine) {
   if (ensureBase()) return 9;
   if (iCurRow < 0 || iCurRow >= nClRowsUsed)
      return 9+perr("%s: illegal row index: %d on setRow, tline %d\n",pszClID,iCurRow,nTraceLine);
   nClCurRow = iCurRow;
   if (cs.debug) printf("array %s setrow %d\n",pszClID,nClCurRow);
   return 0;
}

// public: tell if index in current row is set, used for loops
bool Array::isSet(long iIndex) {
   if (ensureBase()) return 0;
   return apClRows[nClCurRow]->isSet(iIndex);
}

// public: tell if index in current row is set with a string
bool Array::isStringSet(long iIndex) {
   if (ensureBase()) return 0;
   if (!apClRows[nClCurRow]->isSet(iIndex)) {
      // if (cs.debug) printf("] %s: no string set at %d:%d\n",pszClID,nClCurRow,iIndex);
      return 0;
   }
   char *pszRaw = apClRows[nClCurRow]->getEntry(iIndex, __LINE__);
   // printf("xxx %s:%d:%d %s\n",pszClID,nClCurRow,iIndex,pszRaw);
   if (!pszRaw) {
      if (cs.debug) {
         printf("error: no entry at index %d, table %p, within array %p\n",iIndex,apClRows[nClCurRow],this);
         apClRows[nClCurRow]->dump();
      }
      return 0;
   }
   if (pszRaw[0] != 's') {
      perr("no string type at %s:%d:%d\n",pszClID,nClCurRow,iIndex);
      return 0;
   }
   return 1;
}

bool Array::isStringSet(long lRow, long iIndex) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   if (!apClRows[lRow]->isSet(iIndex))
      return 0;
   char *pszRaw = apClRows[lRow]->getEntry(iIndex, __LINE__);
   if (!pszRaw) {
      if (cs.debug) {
         printf("error: no entry at index %d, table %p, within array %p\n",iIndex,apClRows[lRow],this);
         apClRows[lRow]->dump();
      }
      return 0;
   }
   return (pszRaw[0] == 's') ? 1 : 0;
}

// public: tell if index in current row is set with a long
bool Array::isLongSet(long lRow, long iIndex) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   if (!apClRows[lRow]->isSet(iIndex))
      return 0;
   char *pszRaw = apClRows[lRow]->getEntry(iIndex, __LINE__);
   if (!pszRaw)
      return 0;
   return (pszRaw[0] == 'i') ? 1 : 0;
}

// public: tell if row exists
bool Array::hasRow(long iRow) {
   if (ensureBase()) return 0;
   if (iRow < 0) {  perr("%s: illegal row index: %d on hasRow\n",pszClID,iRow); return 0; }
   return (iRow < nClRowsUsed) ? 1 : 0;
}

// ============================================================

LongTable::LongTable() {
   nClArraySize = 0;
   nClArrayUsed = 0;
   pClArray     = 0;
}

LongTable::~LongTable() {
   resetEntries();
}

void LongTable::resetEntries() {
   nClArrayUsed = 0;
   if (pClArray)
      delete [] pClArray;
   pClArray = 0;
   nClArraySize = 0;
}

long LongTable::numberOfEntries() {
   return nClArrayUsed;
}

long LongTable::expand(long nSoMuch) {
   long *apTmp = new long[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (pClArray) {
      memcpy(apTmp, pClArray, nClArraySize*sizeof(long));
      delete [] pClArray;
   }
   pClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

long LongTable::addEntry(long nValue, long nAtPos)
{
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (long i=nClArrayUsed; i>nAtPos; i--)
         pClArray[i] = pClArray[i-1];
      pClArray[nAtPos] = nValue;
      nClArrayUsed++;
   } else {
      pClArray[nClArrayUsed++] = nValue;
   }
   return 0;
}

long LongTable::updateEntry(long nValue, long nIndex) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("wrong index for updateEntry: %ld\n", nIndex);
   pClArray[nIndex] = nValue;
   return 0;
}

long LongTable::getEntry(long nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return pClArray[nIndex];
   perr("illegal LongTable index: %d %d tline %d\n", nIndex, nClArrayUsed, nTraceLine);
   return -1;
}

// ======================================================

NumTable::NumTable() {
   nClArraySize = 0;
   nClArrayUsed = 0;
   pClArray     = 0;
}

NumTable::~NumTable() {
   resetEntries();
}

void NumTable::resetEntries() {
   nClArrayUsed = 0;
   if (pClArray)
      delete [] pClArray;
   pClArray = 0;
   nClArraySize = 0;
}

long NumTable::numberOfEntries() {
   return nClArrayUsed;
}

long NumTable::expand(long nSoMuch) {
   num *apTmp = new num[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (pClArray) {
      memcpy(apTmp, pClArray, nClArraySize*sizeof(num));
      delete [] pClArray;
   }
   pClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

long NumTable::addEntry(num nValue, long nAtPos) {
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (long i=nClArrayUsed; i>nAtPos; i--)
         pClArray[i] = pClArray[i-1];
      pClArray[nAtPos] = nValue;
      nClArrayUsed++;
   } else {
      pClArray[nClArrayUsed++] = nValue;
   }
   return 0;
}

long NumTable::updateEntry(num nValue, long nAtPos) {
   if (nAtPos >= nClArrayUsed)
      return 9+perr("illegal index for updateEntry: %ld\n", nAtPos);
   pClArray[nAtPos] = nValue;
   return 0;
}

num NumTable::getEntry(long nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return pClArray[nIndex];
   perr("illegal NumTable index: %d %d tline %d\n", nIndex, nClArrayUsed, nTraceLine);
   return -1;
}

// ==========================================================

SFKMD5::SFKMD5()
{
   bClDigDone  = 0;

   nClDigLen   = 16;
   nClBufLen   = 64;
   pClBuf      = aClBuf;
   pClDig      = aClDig;

   nClCntHigh  = nClCntLow = nClBufCnt = 0;

   alClSta[0] = 0x67452301;
   alClSta[1] = 0xefcdab89;
   alClSta[2] = 0x98badcfe;
   alClSta[3] = 0x10325476;
}

SFKMD5::~SFKMD5() { }

void SFKMD5::update(uchar *pData, uint32_t nLen)
{
   if (bGlblOldMD5)
   {
      for (uint32_t i=0; i<nLen; i++)
         update(pData[i]);
   }
   else
   {
      int nCnt = 0;
   
      if (nClBufCnt != 0)
      {
         int nAvail = nClBufLen - nClBufCnt;
         int nMax = nAvail < nLen ? nAvail : nLen;
   
         for (; nCnt < nMax; nCnt++)
            update(pData[nCnt]);
      }
   
      int nBlocks = (nLen - nCnt) / nClBufLen;
   
      unsigned int ulNumChars = nBlocks * nClBufLen;
   
      nClCntLow += ulNumChars;
   
      if (nClCntLow < ulNumChars)
         nClCntHigh++;
   
      for (int i = 0; i < nBlocks; i++)
      {
         memcpy(pClBuf, pData + nCnt, nClBufLen);
         transform();
         nCnt += nClBufLen;
      }
   
      for (; nCnt < nLen; nCnt++)
         update(pData[nCnt]);
   }
}

void SFKMD5::update(uchar c)
{
   pClBuf[nClBufCnt++] = c;
   if (nClBufCnt == nClBufLen)
   {
      transform();
      nClBufCnt = 0;
   }
   if (++nClCntLow == 0)
      nClCntHigh++;
}

void SFKMD5::transform()
{
   #define MD5XOR0(x, y, z) (z ^ (x & (y ^ z)))
   #define MD5XOR1(x, y, z) (y ^ (z & (x ^ y)))
   #define MD5XOR2(x, y, z) (x ^ y ^ z)
   #define MD5XOR3(x, y, z) (y  ^  (x | ~z))
   #define MD5ROT(a, n) a = (a << n) | (a >> (32 - n))
   #define MD5PR0(a, b, c, d, k, s, t) { a += k + t + MD5XOR0(b, c, d); MD5ROT(a, s); a += b; }
   #define MD5PR1(a, b, c, d, k, s, t) { a += k + t + MD5XOR1(b, c, d); MD5ROT(a, s); a += b; }
   #define MD5PR2(a, b, c, d, k, s, t) { a += k + t + MD5XOR2(b, c, d); MD5ROT(a, s); a += b; }
   #define MD5PR3(a, b, c, d, k, s, t) { a += k + t + MD5XOR3(b, c, d); MD5ROT(a, s); a += b; }

   uchar *pBuf = pClBuf;
   for (uint32_t i = 0; i < 16; i++)
   {
      uint32_t ul;
      ul = pBuf[0];
      ul |= pBuf[1] << 8;
      ul |= pBuf[2] << 16;
      ul |= pBuf[3] << 24;
      pBuf += 4;
      alClBuf[i] = ul;
   }

   uint32_t a = alClSta[0];
   uint32_t b = alClSta[1];
   uint32_t c = alClSta[2];
   uint32_t d = alClSta[3];

   MD5PR0(a, b, c, d, alClBuf[ 0],  7, 0xd76aa478);
   MD5PR0(d, a, b, c, alClBuf[ 1], 12, 0xe8c7b756);
   MD5PR0(c, d, a, b, alClBuf[ 2], 17, 0x242070db);
   MD5PR0(b, c, d, a, alClBuf[ 3], 22, 0xc1bdceee);
   MD5PR0(a, b, c, d, alClBuf[ 4],  7, 0xf57c0faf);
   MD5PR0(d, a, b, c, alClBuf[ 5], 12, 0x4787c62a);
   MD5PR0(c, d, a, b, alClBuf[ 6], 17, 0xa8304613);
   MD5PR0(b, c, d, a, alClBuf[ 7], 22, 0xfd469501);
   MD5PR0(a, b, c, d, alClBuf[ 8],  7, 0x698098d8);
   MD5PR0(d, a, b, c, alClBuf[ 9], 12, 0x8b44f7af);
   MD5PR0(c, d, a, b, alClBuf[10], 17, 0xffff5bb1);
   MD5PR0(b, c, d, a, alClBuf[11], 22, 0x895cd7be);
   MD5PR0(a, b, c, d, alClBuf[12],  7, 0x6b901122);
   MD5PR0(d, a, b, c, alClBuf[13], 12, 0xfd987193);
   MD5PR0(c, d, a, b, alClBuf[14], 17, 0xa679438e);
   MD5PR0(b, c, d, a, alClBuf[15], 22, 0x49b40821);

   MD5PR1(a, b, c, d, alClBuf[ 1],  5, 0xf61e2562);
   MD5PR1(d, a, b, c, alClBuf[ 6],  9, 0xc040b340);
   MD5PR1(c, d, a, b, alClBuf[11], 14, 0x265e5a51);
   MD5PR1(b, c, d, a, alClBuf[ 0], 20, 0xe9b6c7aa);
   MD5PR1(a, b, c, d, alClBuf[ 5],  5, 0xd62f105d);
   MD5PR1(d, a, b, c, alClBuf[10],  9, 0x02441453);
   MD5PR1(c, d, a, b, alClBuf[15], 14, 0xd8a1e681);
   MD5PR1(b, c, d, a, alClBuf[ 4], 20, 0xe7d3fbc8);
   MD5PR1(a, b, c, d, alClBuf[ 9],  5, 0x21e1cde6);
   MD5PR1(d, a, b, c, alClBuf[14],  9, 0xc33707d6);
   MD5PR1(c, d, a, b, alClBuf[ 3], 14, 0xf4d50d87);
   MD5PR1(b, c, d, a, alClBuf[ 8], 20, 0x455a14ed);
   MD5PR1(a, b, c, d, alClBuf[13],  5, 0xa9e3e905);
   MD5PR1(d, a, b, c, alClBuf[ 2],  9, 0xfcefa3f8);
   MD5PR1(c, d, a, b, alClBuf[ 7], 14, 0x676f02d9);
   MD5PR1(b, c, d, a, alClBuf[12], 20, 0x8d2a4c8a);

   MD5PR2(a, b, c, d, alClBuf[ 5],  4, 0xfffa3942);
   MD5PR2(d, a, b, c, alClBuf[ 8], 11, 0x8771f681);
   MD5PR2(c, d, a, b, alClBuf[11], 16, 0x6d9d6122);
   MD5PR2(b, c, d, a, alClBuf[14], 23, 0xfde5380c);
   MD5PR2(a, b, c, d, alClBuf[ 1],  4, 0xa4beea44);
   MD5PR2(d, a, b, c, alClBuf[ 4], 11, 0x4bdecfa9);
   MD5PR2(c, d, a, b, alClBuf[ 7], 16, 0xf6bb4b60);
   MD5PR2(b, c, d, a, alClBuf[10], 23, 0xbebfbc70);
   MD5PR2(a, b, c, d, alClBuf[13],  4, 0x289b7ec6);
   MD5PR2(d, a, b, c, alClBuf[ 0], 11, 0xeaa127fa);
   MD5PR2(c, d, a, b, alClBuf[ 3], 16, 0xd4ef3085);
   MD5PR2(b, c, d, a, alClBuf[ 6], 23, 0x04881d05);
   MD5PR2(a, b, c, d, alClBuf[ 9],  4, 0xd9d4d039);
   MD5PR2(d, a, b, c, alClBuf[12], 11, 0xe6db99e5);
   MD5PR2(c, d, a, b, alClBuf[15], 16, 0x1fa27cf8);
   MD5PR2(b, c, d, a, alClBuf[ 2], 23, 0xc4ac5665);

   MD5PR3(a, b, c, d, alClBuf[ 0],  6, 0xf4292244);
   MD5PR3(d, a, b, c, alClBuf[ 7], 10, 0x432aff97);
   MD5PR3(c, d, a, b, alClBuf[14], 15, 0xab9423a7);
   MD5PR3(b, c, d, a, alClBuf[ 5], 21, 0xfc93a039);
   MD5PR3(a, b, c, d, alClBuf[12],  6, 0x655b59c3);
   MD5PR3(d, a, b, c, alClBuf[ 3], 10, 0x8f0ccc92);
   MD5PR3(c, d, a, b, alClBuf[10], 15, 0xffeff47d);
   MD5PR3(b, c, d, a, alClBuf[ 1], 21, 0x85845dd1);
   MD5PR3(a, b, c, d, alClBuf[ 8],  6, 0x6fa87e4f);
   MD5PR3(d, a, b, c, alClBuf[15], 10, 0xfe2ce6e0);
   MD5PR3(c, d, a, b, alClBuf[ 6], 15, 0xa3014314);
   MD5PR3(b, c, d, a, alClBuf[13], 21, 0x4e0811a1);
   MD5PR3(a, b, c, d, alClBuf[ 4],  6, 0xf7537e82);
   MD5PR3(d, a, b, c, alClBuf[11], 10, 0xbd3af235);
   MD5PR3(c, d, a, b, alClBuf[ 2], 15, 0x2ad7d2bb);
   MD5PR3(b, c, d, a, alClBuf[ 9], 21, 0xeb86d391);

   alClSta[0] += a;
   alClSta[1] += b;
   alClSta[2] += c;
   alClSta[3] += d;
}

uchar *SFKMD5::digest()
{
   if (bClDigDone)
      return pClDig;

   uint32_t lLow  = nClCntLow << 3;
   uint32_t lHigh = (nClCntLow >> 29) | (nClCntHigh << 3);

   update(128);

   while ((nClCntLow & 63) != 56)
      update(0);

   update((uchar)lLow);
   update((uchar)(lLow >> 8));
   update((uchar)(lLow >> 16));
   update((uchar)(lLow >> 24));

   update((uchar)lHigh);
   update((uchar)(lHigh >> 8));
   update((uchar)(lHigh >> 16));
   update((uchar)(lHigh >> 24));

   // above code should ensure that last update() lead to empty buffer.
   if (nClBufCnt != 0) { fprintf(stderr, "ERROR: SFKMD5 internal #1\n"); }

   uchar *pDigest = pClDig;
   for (uint32_t i = 0; i < 4; i++)
   {
      uint32_t ul = alClSta[i];
      pDigest[0] = (uchar)ul; ul >>= 8;
      pDigest[1] = (uchar)ul; ul >>= 8;
      pDigest[2] = (uchar)ul; ul >>= 8;
      pDigest[3] = (uchar)ul;
      pDigest += 4;
   }

   bClDigDone = 1;
   return pClDig;
}

// ==========================================================

class FileList {
public:
   FileList       ( );
  ~FileList       ( );
   long  addFile        (char *pszAbsName, char *pszRoot, num nTimeStamp, num nSize, char cSortedBy=0);
   long  checkAndMark   (char *pszName, num nSize);
   void  reset          ( );
   StringTable clNames;
   StringTable clRoots;
   NumTable    clTimes;
   NumTable    clSizes;
};

FileList::FileList()  { }
FileList::~FileList() { }

void FileList::reset()
{
   clNames.resetEntries();
   clRoots.resetEntries();
   clTimes.resetEntries();
   clSizes.resetEntries();
}

long FileList::addFile(char *pszAbsName, char *pszRoot, num nTimeStamp, num nSize, char cSortedBy)
{
   // IF filename starts with ".\\", skip this part
   if (!strncmp(pszAbsName, glblDotSlash, strlen(glblDotSlash)))
      pszAbsName += strlen(glblDotSlash);

   // insert sorted by (1)name, (2)time, (3)size?
   long nInsPos = -1;

   if (cSortedBy == 'T' || cSortedBy == 't') {
      // find insert by time position
      long nCnt = clTimes.numberOfEntries();
      long i=0;
      for (i=0; i<nCnt; i++)
         if (cSortedBy=='T' && (clTimes.getEntry(i, __LINE__) > nTimeStamp))
            break;
         else
         if (cSortedBy=='t' && (clTimes.getEntry(i, __LINE__) < nTimeStamp))
            break;
      if (i < nCnt)
         nInsPos = i;         
   }

   if (cSortedBy == 'S' || cSortedBy == 's') {
      // find insert by size position
      long nCnt = clSizes.numberOfEntries();
      long i=0;
      for (i=0; i<nCnt; i++)
         if (cSortedBy=='S' && (clSizes.getEntry(i, __LINE__) > nSize))
            break;
         else
         if (cSortedBy=='s' && (clSizes.getEntry(i, __LINE__) < nSize))
            break;
      if (i < nCnt)
         nInsPos = i;         
   }

   if (cSortedBy == 'N' || cSortedBy == 'n') {
      // find insert by name position
      long nCnt = clNames.numberOfEntries();
      long i=0;
      for (i=0; i<nCnt; i++) {
         char *psz1 = clNames.getEntry(i, __LINE__);
         char *psz2 = pszAbsName;
         // both psz1 and psz2 point to a mixed string with a prefix.
         // need to find the actual filename first:
         long npre1 = atol(psz1)+6; if (npre1 < (long)strlen(psz1)) psz1 += npre1;
         long npre2 = atol(psz2)+6; if (npre2 < (long)strlen(psz2)) psz2 += npre2;
         long ncmp  = cs.usecase ? strcmp(psz1,psz2) : mystricmp(psz1, psz2);
         if (cSortedBy=='N' && ncmp > 0)
            break;
         else
         if (cSortedBy=='n' && ncmp < 0)
            break;
      }
      if (i < nCnt)
         nInsPos = i;         
   }

   if (clNames.addEntry(pszAbsName, nInsPos)) return 9;
   if (clRoots.addEntry(pszRoot   , nInsPos)) return 9;
   if (clTimes.addEntry(nTimeStamp, nInsPos)) return 9;
   if (clSizes.addEntry(nSize     , nInsPos)) return 9;

   return 0;
}

// checkAndMark checks the filename and size,
// but NOT the rather complicated timestamps.
long FileList::checkAndMark(char *pszName, num nSize) {
   long nEntries = clNames.numberOfEntries();
   for (long i=0; i<nEntries; i++) {
      char *psz = clNames.getEntry(i, __LINE__);
      if ((psz[0] != 0) && !strcmp(psz, pszName)) {
         num nSize2 = clSizes.getEntry(i, __LINE__);
         if (nSize != nSize2)
            return 2; // on size mismatch, do NOT mark as done.
         psz[0] = '\0';
         return 0;
      }
   }
   return 1;
}

// ====================================================

#ifndef USE_SFK_BASE

class DupScanner {
public:
   DupScanner     ( );
   long  addFile  (char *psz);
   long  analyze  (bool blistorg);
   void  reset    ( );
public:
   void  analyzeBlock   (long ilo, long ihi, bool blistorg);
   NumTable    clSizes;
   StringTable clNames; // if name==null, was already processed
   StringTable clRoots;
   NumTable    clSumHi;
   NumTable    clSumLo;
   long  clNumOrgs;
   long  clNumDups;
   num   clOrgBytes;
   num   clDupBytes;
   bool  clDiffDirs;    // list only dups from different dirs
};

DupScanner::DupScanner() { reset(); }

void DupScanner::reset() {
   clSizes.resetEntries();
   clNames.resetEntries();
   clRoots.resetEntries();
   clSumHi.resetEntries();
   clSumLo.resetEntries();
   clNumOrgs  = 0;
   clNumDups  = 0;
   clOrgBytes = 0;
   clDupBytes = 0;
   clDiffDirs = 0;
}

long DupScanner::addFile(char *pszFile) 
{
   num nSize = getFileSize(pszFile);
   if (nSize <= 0) return 1;
   // filter by size selection
   if (cs.selMinSize > 0 && nSize < cs.selMinSize)
      return 0;
   // find insert position
   long ipos=0;
   for (; ipos<clSizes.numberOfEntries(); ipos++)
      if (nSize < clSizes.getEntry(ipos, __LINE__))
         break;
   if (ipos >= clSizes.numberOfEntries())
      ipos = -1;
   // mtklog("insert %s size %s at %ld",pszFile,numtoa(nSize),ipos);
   clSizes.addEntry(nSize  , ipos);
   clNames.addEntry(pszFile, ipos);
   clRoots.addEntry(glblFileSet.root(), ipos);
   num nDummy = 0;
   clSumHi.addEntry(nDummy , ipos);
   clSumLo.addEntry(nDummy , ipos);
   return 0;
}

long DupScanner::analyze(bool blistorg) 
{
   char szAddInfo[200];

   long nTotal   = clSizes.numberOfEntries();

   #ifdef WITH_TRACING
   mtklog("] scanned file sizes:");
   for (long idump=0; idump<nTotal; idump++)
   {
      num nref  = clSizes.getEntry(idump, __LINE__);
      char *psz = clNames.getEntry(idump, __LINE__);
      mtklog("%s %s",numtoa(nref),psz);
   }
   #endif

   num  nCurSize = -1;
   for (long iouter=0; iouter<nTotal && !userInterrupt();)
   {
      num nref = clSizes.getEntry(iouter, __LINE__);
      if (nref == nCurSize)
         return 9+perr("internal 279122205");

      // found start of new size block.
      nCurSize = nref;
      long iblocklo = iouter + 0;
      long iblockhi = iouter + 1;
      for (; iblockhi<nTotal && clSizes.getEntry(iblockhi, __LINE__) == nCurSize;)
         iblockhi++;

      // size block ranges from iblocklo to iblockhi-1
      if (iblockhi-iblocklo < 2) {
         // this block has just one entry.
         // if "list just orgs" mode selected
         if (blistorg) {
            char *pszOrg     = clNames.getEntry(iouter, __LINE__);
            char *pszOrgRoot = clRoots.getEntry(iouter, __LINE__);
            if (!pszOrg[0]) return 9+perr("internal 279122206");
            if (chain.colfiles) {
               // collect ORG names for next cmd
               Coi ocoi(pszOrg, pszOrgRoot);
               chain.addFile(ocoi); // is copied
            } else {
               chain.print(' ', 1, "%s", pszOrg);
            }
            clNumOrgs++;
            clOrgBytes += nCurSize;
         }
         iouter = iblockhi;
         continue;
      }

      // have at least two entries in this block.
      // build content md5sums.
      long nBlockFiles  = iblockhi-iblocklo;
      num  nCurFileSize = clSizes.getEntry(iblocklo, __LINE__);
      for (long icur=iblocklo; icur<iblockhi; icur++) 
      {
         char *pszFile = clNames.getEntry(icur, __LINE__);

         info.setProgress(nBlockFiles, icur-iblocklo, "files");
         sprintf(szAddInfo, "%ld files of size %s", nBlockFiles, numtoa(nCurFileSize));
         info.setStatus("scan", pszFile, szAddInfo, (icur==iblocklo) ? eSlowCycle : 0);

         SFKMD5 md5;
         if (getFileMD5(pszFile, md5, 0, 1))
            return 9;
         unsigned char *pmd5 = md5.digest();
         num nsumlo=0, nsumhi=0;
         for (long i=0,b=64-8; i<8; i++) {
            nsumhi = nsumhi | (((num)pmd5[0+i]&0xFF) << b);
            nsumlo = nsumlo | (((num)pmd5[8+i]&0xFF) << b);
            b -= 8;
         }
         clSumHi.updateEntry(nsumhi, icur);
         clSumLo.updateEntry(nsumlo, icur);
         /*
         mtklog("md5raw: %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X"
            ,pmd5[0],pmd5[1],pmd5[2],pmd5[3],pmd5[4],pmd5[5],pmd5[6],pmd5[7]
            ,pmd5[8],pmd5[9],pmd5[10],pmd5[11],pmd5[12],pmd5[13],pmd5[14],pmd5[15]);
         szAddInfo[0] = '\0';
         strcat(szAddInfo, numtohex(nsumhi));
         strcat(szAddInfo, " ");
         strcat(szAddInfo, numtohex(nsumlo));
         mtklog("md5num: %s", szAddInfo);
         */
      }
      // all prepared for this block, list results:
      analyzeBlock(iblocklo, iblockhi, blistorg);

      // proceed to next size block
      iouter = iblockhi;
   }

   return 0;
}

void DupScanner::analyzeBlock(long ilo, long ihi, bool blistorg)
{
   for (long iorg=ilo; iorg<ihi; iorg++)
   {
      char *pszOrg     = clNames.getEntry(iorg, __LINE__);
      if (!pszOrg[0]) continue; // already processed
      char *pszOrgRoot = clRoots.getEntry(iorg, __LINE__);

      // get current potential org data
      num nsumhi = clSumHi.getEntry(iorg, __LINE__);
      num nsumlo = clSumLo.getEntry(iorg, __LINE__);

      // see if any dups are present for this
      bool btoldorg=0;
      for (long idup=iorg+1; idup<ihi; idup++)
      {
         char *pszDup     = clNames.getEntry(idup, __LINE__);
         if (!pszDup[0]) continue; // already processed
         char *pszDupRoot = clRoots.getEntry(idup, __LINE__);

         if (clDiffDirs && !strcmp(pszOrgRoot, pszDupRoot))
            continue; // skip, both files have same root dir

         num nduphi = clSumHi.getEntry(idup, __LINE__);
         num nduplo = clSumLo.getEntry(idup, __LINE__);
         if (nduphi == nsumhi && nduplo == nsumlo)
         {
            // found a dup for iorg.
            if (!blistorg) {
               if (chain.colfiles) {
                  // collect dup names for next cmd
                  Coi ocoi(pszDup, pszDupRoot);
                  chain.addFile(ocoi); // is copied
               } else {
                  if (!btoldorg) {
                     btoldorg = 1;
                     chain.print('f', 1, "%s", pszOrg);
                  }
                  chain.print(' ', 1, "   %s", pszDup);
               }
            }

            clNumDups++;
            clDupBytes += clSizes.getEntry(idup, __LINE__);

            // mark dup as processed
            clNames.setEntry(idup, "");
         }
      }  // endfor potential dups

      // if "list just orgs" mode selected
      if (blistorg) {
         if (chain.colfiles) {
            // collect ORG names for next cmd
            Coi ocoi(pszOrg, pszOrgRoot);
            chain.addFile(ocoi); // is copied
         } else {
            chain.print(' ', 1, "%s", pszOrg);
         }
         clNumOrgs++;
         clOrgBytes += clSizes.getEntry(iorg, __LINE__);
      }

      // mark org as processed
      clNames.setEntry(iorg, "");

   }  // endfor orgs
}

DupScanner glblDupScan;

#endif // USE_SFK_BASE

enum eDirCommands {
   eCmd_CopyDir      = 1,
   eCmd_FreezeDir    = 2,
   eCmd_Undefined    = 0xFF
};

FileSet::FileSet() 
 : clRootDirs("RootDirs"),
   clDirMasks("DirMasks"),
   clFileMasks("FileMasks")
{
   nClCurDir   =  0;
   nClCurLayer = -1;
   pClLineBuf  = new char[MAX_LINE_LEN+10];
   resetAddFlags();
}

FileSet::~FileSet() {
   shutdown();
}

void FileSet::resetAddFlags() {
   bClGotAllMask = 0;
   bClGotPosFile = 0;
   bClGotNegFile = 0;
}

void FileSet::reset() {
   nClCurDir   =  0;
   nClCurLayer = -1;
   resetAddFlags();
   clRootDirs.reset();
   clDirMasks.reset();
   clFileMasks.reset();
}

void FileSet::shutdown() {
   reset();
   delete [] pClLineBuf;
   pClLineBuf = 0;
}

char* FileSet::firstFileMask() {
   Array &rMasks = fileMasks();
   if (!rMasks.isStringSet(0)) return "*";
   return rMasks.getString(0);
}

bool FileSet::isAnyExtensionMaskSet() 
{
   for (int i=0; clFileMasks.isStringSet(i); i++) 
   {
      char *pszMask = clFileMasks.getString(i);
      if (pszMask[0] == '.')
         return true;
   }
   return false;
}

long FileSet::getDirCommand() {
   return clRootDirs.getLong(1, nClCurDir, __LINE__);
}

/*
   A "layer" is a set of dir and file masks, which may be
   referenced by one or many root directories.
*/

void FileSet::dump() 
{
   printf("=== fileset begin ===\n");

   for (long i1=0; clRootDirs.isStringSet(0,i1); i1++)
   {
      long nLayer = clRootDirs.getLong(2,i1, __LINE__);
      long nCmd   = 0;
      if (clRootDirs.isLongSet(1,i1))
           nCmd   = clRootDirs.getLong(1,i1, __LINE__);
      printf("] ROOT %s -> layer %d, cmd %d\n",
         clRootDirs.getString(0,i1),
         nLayer,
         nCmd
         );
   }

   for (long iLayer=0; clDirMasks.hasRow(iLayer); iLayer++) 
   {
      printf("] layer %d:\n", iLayer);

      printf("]  dmsk:\n");
      for (long i5=0; clDirMasks.isStringSet(iLayer, i5); i5++)
         printf("]   %s\n",clDirMasks.getString(iLayer, i5));

      printf("]  fmsk:\n]   ");
      for (long i6=0; clFileMasks.isStringSet(iLayer, i6); i6++)
         printf("%s, ",clFileMasks.getString(iLayer, i6));
      printf("\n");
   }

   printf("=== fileset end ===\n");
}

// like dump, but easier representation, using pinf
void FileSet::info(void (*pout)(long nrectype, char *pline))
{
   char *psml = szLineBuf;
   char *pbig = (char*)abBuf;

   for (long i1=0; clRootDirs.isStringSet(0,i1); i1++)
   {
      long nLayer = clRootDirs.getLong(2,i1, __LINE__);
      long nCmd   = 0;
      if (clRootDirs.isLongSet(1,i1))
           nCmd   = clRootDirs.getLong(1,i1, __LINE__);

      sprintf(pbig, "directory tree %ld:", i1+1);
      pout(1, pbig);

      pout(2, clRootDirs.getString(0,i1));

      // list masks used by that tree, possibly redundant
      long iLayer = nLayer;

      pbig[0] = '\0';
      long i5=0;
      for (; clDirMasks.isStringSet(iLayer, i5); i5++) {
         strcat(pbig, clDirMasks.getString(iLayer, i5));
         strcat(pbig, " ");
      }
      if (i5) {
         sprintf(psml, "... uses %ld dir masks:", i5);
         pout(3, psml);
         pout(4, pbig);
      } else {
         pout(3, "... uses no dir masks.");
      }

      pbig[0] = '\0';
      long i6=0;
      for (; clFileMasks.isStringSet(iLayer, i6); i6++) {
         strcat(pbig, clFileMasks.getString(iLayer, i6));
         strcat(pbig, " ");
      }
      if (i6) {
         sprintf(psml, "... uses %ld file masks:", i6);
         pout(5, psml);
         pout(6, pbig);
      } else {
         pout(5, "... uses no file masks.");
      }
   }
}

long FileSet::checkConsistency()
{
   long nLayers = 0;
   for (long i0=0; clDirMasks.hasRow(i0); i0++) 
      nLayers++;

   mtklog("check consistency of %ld layers", nLayers);

   long lRC = 0;

   long *pRefCnt = new long[nLayers+10];
   memset(pRefCnt, 0, (nLayers+10)*sizeof(long));
   // NO RETURN FROM HERE

   // count for each layer how often it's referenced
   for (long i1=0; clRootDirs.isStringSet(0,i1); i1++)
   {
      long iLayer = clRootDirs.getLong(2,i1, __LINE__);
      if (iLayer < 0 || iLayer >= nLayers) {
         perr("internal #60 %ld\n", iLayer);
         lRC = 9;
         break;
      }
      mtklog("root %ld references layer %ld", i1, iLayer);
      pRefCnt[iLayer]++;
   }

   // find unreferenced layers
   for (long i2=0; i2<nLayers; i2++) {
      if (!pRefCnt[i2]) {
         // if -any is specified, the first layer is used implicitely
         // to list important file extensions.
         if ((i2 == 0) && bGlblAnyUsed)
            continue;
         perr("wrong -dir and -file sequence (%ld)\n", i2);
         pinf("specify -dir ... before -file\n");
         lRC = 9;
      }
   }

   // NO RETURN UNTIL HERE
   delete [] pRefCnt;

   return lRC;
}

bool FileSet::anyRootAdded() {
   return (clRootDirs.numberOfEntries() > 0) ? 1 : 0;
}

// does the current root have any non-"*" file masks set?
bool FileSet::anyFileMasks()
{
   if (clFileMasks.numberOfEntries() <= 0)
      return false;

   // check if there is any non-"*" file mask
   for (int i=0; clFileMasks.isStringSet(i); i++)
   {
      char *pszMask = clFileMasks.getString(i);
      if (strcmp(pszMask, "*"))
         return true;
   }

   // if not, say no mask is set.
   return false;
}

bool FileSet::hasRoot(long iIndex) {
   bool bRC = clRootDirs.isStringSet(iIndex);
   // if (cs.debug) printf("] %d = hasRoot(%d)\n", bRC, iIndex);
   return bRC;
}

char* FileSet::setCurrentRoot(long iIndex) 
{
   if (cs.debug) printf("] select root %d\n",iIndex);
   mtklog("FileSet::setCurrentRoot(%ld)", iIndex);
   nClCurDir = iIndex;
   // the root dir no. iIndex selects a specific layer.
   char *pszDirName = clRootDirs.getString(0, iIndex);
   nClCurLayer      = clRootDirs.getLong(2, iIndex, __LINE__);
   clRootDirs.setRow(0, __LINE__);
   // fully switch to current layer
   if (cs.debug) printf("]  select layer %d\n",nClCurLayer);
   mtklog("   select layer %ld",nClCurLayer);
   clDirMasks.setRow(nClCurLayer, __LINE__);
   clFileMasks.setRow(nClCurLayer, __LINE__);
   return getCurrentRoot();
}

// return current root or simply "" if none:
char *FileSet::root(bool braw) {
   if (!hasRoot(nClCurDir)) return braw ? 0 : (char*)"";
   return getCurrentRoot();
}

char* FileSet::getCurrentRoot()
{
   char *pszDirName = clRootDirs.getString(0, nClCurDir);
   // prefix by preroot, if any
   if (pszGlblPreRoot) {
      // printf("PRE %s ADD %s\n",pszGlblPreRoot,pszDirName);
      strcopy(szGlblMixRoot, pszGlblPreRoot);
      // avoid to append "./" as dir name
      if (!strncmp(pszDirName, glblDotSlash, 2))
         pszDirName += 2;
      // avoid to append "." as dir name
      if (!strcmp(pszDirName, "."))
         pszDirName++;
      // any local dir remaining to append?
      if (strlen(pszDirName)) {
         if (!endsWithPathChar(szGlblMixRoot) && !endsWithColon(szGlblMixRoot))
            strcat(szGlblMixRoot, glblPathStr);
         strcat(szGlblMixRoot, pszDirName);
      }
      pszDirName = szGlblMixRoot;
   }
   return pszDirName;
}

long FileSet::numberOfRootDirs() {
   return clRootDirs.numberOfEntries(0);
}

long FileSet::ensureBase(int nTraceLine) {
   mtklog("fs: ensureBase %d", nTraceLine);
   // clRootDirs must have 3 rows
   while (!clRootDirs.hasRow(2)) {
      mtklog("fs: ... add another row");
      if (clRootDirs.addRow(nTraceLine))
         return 9;
   }
   return 0;
}

// a layer is one set of dir masks and file masks.
// - dir masks is a row in clDirMasks.
// - file masks is a row in clFileMasks.
// - command is 1:1 per directory root,
//   therefore cmd is stored in clRootDirs.
// - clRootDirs row 0 is the directory name.
// - clRootDirs row 1 is the directory command (zip, copy).
// - a directory tree references a layer.

long FileSet::beginLayer(bool bWithEmptyCommand, int nTraceLine)
{
   mtklog("fs: beginlayer %d", nTraceLine);

   // reset state of add sequence controlling
   resetAddFlags();

   // ensure clRootDirs has two columns
   if (ensureBase(__LINE__)) return 9;
   // make space for new layer
   clDirMasks.addRow(__LINE__);
   clFileMasks.addRow(__LINE__);
   // count new layer
   nClCurLayer++;
   // printf("] BEGINLAYER: new current=%d [\n",nClCurLayer);

   // a "command" is "-copy" or "-zip", used only with freezeto.
   // all other commands will just fill the command column with dummys.
   if (bWithEmptyCommand) {
      // set dummy command "0" in row 1 of clRootDirs
      clRootDirs.addLong(1, 0, __LINE__);
   }
   return 0;
}

long FileSet::addRootDir(char *pszRoot, int nTraceLine, bool bNoCmdFillup) 
{
   mtklog("fs: addRootDir %s", pszRoot);

   if (cs.debug) printf("] add root dir: %s, referencing layer: %d [tline %d]\n", pszRoot, nClCurLayer, nTraceLine);

   // purify root: no patch char appended
   strncpy(pClLineBuf, pszRoot, MAX_LINE_LEN);
   pClLineBuf[MAX_LINE_LEN] = '\0';
   pszRoot = pClLineBuf;
   if (endsWithPathChar(pszRoot)) {
      #ifdef _WIN32
      if (strlen(pszRoot) == 3 && pszRoot[1] == ':')
         { } // do not strip / from c:/
      else
      #endif
      pszRoot[strlen(pszRoot)-1] = '\0';
   }

   if (ensureBase(__LINE__)) return 9;
   if (nClCurLayer == -1) {
      if (cs.debug) printf("] impl. create first fileset layer\n");
      beginLayer(true, __LINE__);
   }
   // complete the current column
   long nMax = clRootDirs.numberOfEntries(0);
   if (!bNoCmdFillup)
      if (clRootDirs.numberOfEntries(1) < nMax)
          clRootDirs.addLong(1, 0, __LINE__); // add empty command
   if (clRootDirs.numberOfEntries(2) < nMax)
      return 9+perr("internal #20\n");

   // add another root dir, forward-referencing
   // the current layer in which masks will follow.
   clRootDirs.addString(0,pszRoot);
   clRootDirs.addLong(2,nClCurLayer, __LINE__);

   #ifdef VFILEBASE
   // implicite activation of zip travel by root dir:
   if (endsWithArcExt(pszRoot)) {
      cs.xelike     = 1;
      cs.travelzips = 1;
   }
   #endif // VFILEBASE

   return 0;
}  // FileSet::addRootDir

long FileSet::addDirCommand(long lCmd)
{
   if (ensureBase(__LINE__)) return 9;
   // one single -cmd may map to several root dirs.
   // example: -dir a1 a2 a3 -copy
   // therefore fill up until root dir names number reached.
   long nMax = clRootDirs.numberOfEntries(0);  
   while (clRootDirs.numberOfEntries(1) < nMax)
      clRootDirs.addLong(1, lCmd, __LINE__);
   return 0;
}

long FileSet::addDirMask(char *pszMask) {
   if (ensureBase(__LINE__)) return 9;
   clDirMasks.addString(pszMask);
   return 0;
}

long FileSet::addFileMask(char *pszMask)
{
   // if (cs.debug) printf("] addFileMask %s\n", pszMask);
   if (ensureBase(__LINE__)) return 9;

   #ifdef VFILEBASE
   if (!cs.shallowzips && cs.xelike && cs.travelzips && endsWithArcExt(pszMask)) {
      pinf("file mask \"%s\" may produce no results, because\n",pszMask);
      char *pext = strrchr(pszMask, '.');
      if (!pext) pext = pszMask;
      pinf("option -arc is set, treating %s files as directories.\n",pext);
      pinf("say -dir ... %c%s -file ... instead to use %s as a path mask.\n",glblWildChar,pext,pszMask);
   }
   #endif // VFILEBASE

   if (!strcmp(pszMask, "-all") || isWildStr(pszMask)) {
      if (bClGotAllMask)
         return 9+perr("-all or %s supplied multiple times.\n", glblWildInfoStr);
      if (bClGotPosFile) {
         if (bGlblAllowAllPlusPosFile)
            pwarn("wrong sequence: positive file pattern already given, specify \"%s\" before this.\n", pszMask);
         else
            pwarn("positive file pattern already given, \"%s\" is unexpected.\n", pszMask);
      }
      if (bClGotNegFile)
         return 9+perr("wrong sequence: negative file pattern already given, specify \"%s\" before this.\n", pszMask);
      // map to * internally:
      pszMask = "*";    // no wildstr, using real * internally
      bClGotAllMask = 1;
   }
   else
   if (pszMask[0] == glblNotChar) {
      // negative file pattern: if it is the very first pattern
      if (!bClGotAllMask && !bClGotPosFile && !bClGotNegFile)
         clFileMasks.addString("*"); // IMPLICITELY. no wildstr.
      bClGotNegFile = 1;
   }
   else {
      // positive file pattern:
      // if (isWildChar(pszMask[0]))
      //    pwarn("%s at start of %s is ignored, say %c%s to force word start search.\n",
      //       glblWildInfoStr, pszMask, glblPathChar, pszMask+1);
      if (bClGotAllMask && !bGlblAllowAllPlusPosFile)
         pwarn("-all or * already given, \"%s\" has no effect.\n", pszMask);
      if (bClGotNegFile)
         return 9+perr("wrong sequence: negative file pattern already given, specify \"%s\" before this.\n", pszMask);
      bClGotPosFile = 1;
   }

   clFileMasks.addString(pszMask);
   return 0;
}

long FileSet::autoCompleteFileMasks(int nWhat) 
{
   if (cs.debug) printf("] autocomplete %d:\n", nWhat);

   if (nWhat & 1)
   for (long irow=0; clFileMasks.hasRow(irow); irow++) {
      if (clFileMasks.setRow(irow, __LINE__)) return 9;
      if (clFileMasks.numberOfEntries() == 0) {
         if (cs.debug) printf("]  yes, at layer %d\n",irow);
         if (clFileMasks.addString("*")) return 9;   // no wildstr
      }
   }

   if (nWhat & 2)
   if (clRootDirs.numberOfEntries() == 0) {
      if (cs.debug) printf("] adding dir .\n");
      addRootDir(".", __LINE__, false);
   }

   return 0;
}

void FileSet::setBaseLayer() {
   clRootDirs.setRow(0, __LINE__);
   clDirMasks.setRow(0, __LINE__);
   clFileMasks.setRow(0, __LINE__);
}

// find: BinTexter remembers so many chars from previous line
//       to detect AND patterns spawning across soft-wraps.
#define BT_LASTLINE_LEN 80

class BinTexter
{
public:
   BinTexter         (Coi *pcoi);
  ~BinTexter         ( );

   enum eDoWhat {
      eBT_Print   = 1,  // floating output, LFs blanked
      eBT_Grep    = 2,  // LFs lead to hard line break
      eBT_JamFile = 3   // floating output, LFs blanked
   };

   // uses szLineBuf, szLineBuf2.
   long  process     (int nDoWhat);
   long  processLine (char *pszBuf, int nDoWhat, long nLine, bool bHardWrap);

private:
   Coi  *pClCoi;
   char  szClLastLine[BT_LASTLINE_LEN+40];
   char  szClPreBuf[80];
   char  szClOutBuf[200];
   char  szClAttBuf[200];
   bool  bClDumpedFileName;
};

BinTexter::BinTexter(Coi *pcoi)
{
   memset(this, 0, sizeof(*this));
   pClCoi = pcoi;
}

BinTexter::~BinTexter()
{
   memset(this, 0, sizeof(*this));
}

bool sfkisalnum(uchar uc) {
   if (isalnum((char)uc))
      return 1;
   if (uc > nGlblBinTextBinRange && uc < 0xFF)
      return 1;
   return 0;
}

bool sfkisprint(uchar uc) {
   if (isprint((char)uc))
      return 1;
   if (uc > nGlblBinTextBinRange && uc < 0xFF)
      return 1;
   return 0;
}

// uses szLineBuf. Result in szLineBuf2.
long BinTexter::process(int nDoWhat)
{
   long icol   = 0;
   long istate = 0;
   long iword  = 0;  // index in short word target buffer
   long nword  = 0;  // to count non-binary word length
   long ihi    = 0;
   bool bflush = 0;
   bool bisws  = 0;
   bool bwasws = 0;
   bool bisbin = 0;
   bool bishi  = 0;
   bool bispunct = 0;
   bool bhardwrap = 0;
   bool babineol = 0; // helper flag, add blank if not at end of line
   char c = 0;
   unsigned char uc = 0;
   long nLine = 0;
   long nMinWord = 1; // min word length adapted dynamically below
   long lRC = 0;

   szClOutBuf[0] = '\0';

   num  nTellTime  = getCurrentTime();
   long nTellLines = 0;

   bool bbail = 0;
   while (!bbail)
   {
      // long nRead = pClCoi->readLine(szLineBuf, sizeof(szLineBuf)-10);
      long nRead = pClCoi->read(szLineBuf, sizeof(szLineBuf)-10);

      if (nRead <= 0) {
         bbail = 1;
         nRead = 1;
      }
      
      if (nTellLines++ > 1000) {
         nTellLines = 0;
         if (getCurrentTime() > nTellTime + 1000) {
            // working on the same file for 1000 msec: show status
            nTellTime = getCurrentTime();
            if (!cs.quiet && pClCoi->name()) {
               info.setAddInfo("%lu files, %lu dirs", cs.filesScanned, cs.dirsScanned);
               info.setStatus("scan", pClCoi->name(), 0, eKeepAdd);
            }
         }
      }

      for (long i=0; i<nRead; i++)
      {
         if (bbail) {
            c  = 0x00;
            uc = (unsigned char)c;
            bflush = 1;
         } else {
            c  = szLineBuf[i];
            uc = (unsigned char)c;
            bflush = 0;
         }

         if (c=='\n') {
            nLine++;
            bflush = 1;
            bhardwrap = 1;
         }

         if (cs.rewrap) {
            // reformatting plain text
            bisbin = (uc == 0) ? 1 : 0; // just in case
         } else {
            // reformatting binary
            bisbin = ((uc >= 0x80) && (uc < nGlblBinTextBinRange)) || (uc < 0x20);
            if (nGlblBinTextBinRange == 0xFF)
               bishi = (uc >= 0xC0);
         }

         if (!bisbin && !bishi)
            nword++;

         if (sfkisprint(c) && !bisbin) 
         {
            // printable char
            if (istate == 1) {
               // start collecting next word
               istate = 0;
               iword = 0;
               ihi   = 0;
            }
            // continue collecting current word,
            // reduce multi-whitespace sequences.
            bisws    = (c==' ' || c=='\t');
            bispunct = (c=='.' || c==',' || c==';');
            if (!(bisws && bwasws)) {
               szLineBuf2[iword++] = c;
               if (bishi)
                  ihi++;
            }
            // hard or soft word break?
            if (iword >= cs.wrapbincol)
               bflush = 1;
            else
            if ((iword >= 20) && (bisws || bispunct))
               bflush = 1;
         } else {
            // non-printable (binary) char
            if (istate == 0)  // if collecting a word
               bflush = 1;    // then flush the word
            // start skipping non-word data (binary etc.)
            istate = 1;
            bwasws = 0;
            bisws  = 0;
            bispunct = 0;
            // increment min word length needed to add to buffer.
            nMinWord = 3;
         }

         // dump current word?
         if (bflush) 
         {
            bflush = 0;
            if ((iword >= nMinWord || nword >= nMinWord) || c == '\n' || bbail)
            {
               // reset "add blank if not at end of line"
               babineol = 0;

               szLineBuf2[iword] = '\0';

               // do not add blank after whitespace, punct, or End Of Data.
               // add blank after a linefeed, if not in grep mode.
               if (bisws || bispunct || bbail || c == '\n') {
                  if (nDoWhat != eBT_Grep && c == '\n')
                     if (iword > 0 || nword > 0)
                        babineol = 1;
               } else {
                  // all other cases including '\r':
                  // add blank between isolated expressions
                  babineol = 1; // if not at end of line
               }

               if (strlen(szClOutBuf) + strlen(szLineBuf2) < sizeof(szClOutBuf)-10)
                  strcat(szClOutBuf, szLineBuf2);

               icol += (iword+1);

               // strings and jamfile: create floating text.
               // in case of grep, keep hard line breaks.
               if (nDoWhat != eBT_Grep && c == '\n')
                  c = ' '; // binary to text: wrap floating text

               if (icol >= cs.wrapbincol || c == '\n' || bbail)
               {
                  // line flush.
                  if (lRC = processLine(szClOutBuf, nDoWhat, nLine, bhardwrap))
                     return lRC;
                  bhardwrap = 0;
                  icol = 0;
                  szClOutBuf[0] = '\0';
                  nword = 0;
                  nMinWord = 1;
               }
               else
               if (babineol)
               {
                  // no line flush, further stuff will be added,
                  // and remembered to insert a blank before that.
                  strcat(szClOutBuf, " ");
               }
            }
            iword  = 0;
            ihi    = 0;
            bwasws = 0;
         }
         else
            bwasws = bisws;

         // "sane" word count reset on any binary or non-printable
         if (bisbin || bishi || (c < 0x20))
            nword  = 0;
      }
   }

   return 0;
}

// snapto optional callback functions
long (*pGlblJamFileCallBack)(char *pszFilename, num &rLines, num &rBytes) = 0;
long (*pGlblJamLineCallBack)(char *pszLine, long nLineLen, bool bAddLF) = 0;
long (*pGlblJamStatCallBack)(char *pszInfo, ulong nFiles, ulong nLines, ulong nMBytes, ulong nSkipped, char *pszSkipInfo) = 0;

long BinTexter::processLine(char *pszBuf, int nDoWhat, long nLine, bool bHardWrap)
{
   info.cycle();

   if (nDoWhat == eBT_Print) {
      if (chain.coldata) {
         setattr(szAttrBuf3, 'f', strlen(szClOutBuf)+2, MAX_LINE_LEN);
         chain.addLine(szClOutBuf, szAttrBuf3);
      } else {
         info.print("%s\n", szClOutBuf);
      }
   }
   else
   if (nDoWhat == eBT_JamFile) 
   {
      long dumpJamLine(char *pszLine, long nLineLen, bool bAddLF); // len 0: zero-terminated

      // strip empty lines from binary text:
      if (!strlen(szClOutBuf) || szClOutBuf[0] == '\n')
         return 0;

      long lRC = dumpJamLine(szClOutBuf, 0, 1);

      nGlblBytes += strlen(szClOutBuf);
      cs.lines++;

      // only for callback: check per line if stat update is required.
      // it doesn't matter that nLines is actually counted past call to dumpJamLine.
      if (pGlblJamStatCallBack && glblFileCount.checkTime())
      {
         lRC |= pGlblJamStatCallBack(pClCoi->name(), glblFileCount.value(), cs.lines, (ulong)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
         // NO printf output here! BinTexter is also used by grep, strings.
      }

      return lRC;
   }
   else
   if (nDoWhat == eBT_Grep)
   {
      // 1. count no. of hits across current AND last line
      long nMatchCur = 0;
      long nMatchPre = 0;
      long nGrepPat = glblGrepPat.numberOfEntries();
      for (long i=0; ((nMatchCur+nMatchPre) < nGrepPat) && (i<nGrepPat); i++) 
      {
         if (mystrhit((char*)pszBuf, glblGrepPat.getString(i), cs.usecase, 0))
            nMatchCur++;
         else
         if (szClLastLine[0] && 
             mystrhit(szClLastLine, glblGrepPat.getString(i), cs.usecase, 0))
            nMatchPre++;
      }

      // 2. if ALL pattern parts have a match somewhere, list both lines
      if ((nMatchCur+nMatchPre) == nGrepPat) 
      {
         // found a matching file
         cs.anymatches = 1;

         if (chain.colfiles) {
            // filenames only, as filename chain
            // TODO: set root as glblFileSet.root()?
            chain.addFile(*pClCoi); // is copied
            return 1; // end read loop above
         }

         if (cs.useJustNames) {
            // filenames only, as text data, NOT prefixing
            // further text data, therefore NOT including ":file "
            if (chain.coldata) {
               sprintf(szLineBuf3, "%s", pClCoi->name());
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf3, 'f', strlen(szLineBuf3)+2, MAX_LINE_LEN);
               chain.addLine(szLineBuf3, szAttrBuf3);
            } else {
               info.print("%s\n", pClCoi->name());
            }
            return 1; // end read loop above
         }

         // actually dump the content:

         // list filename first
         if (!bClDumpedFileName && !cs.nonames && !cs.pure) {
            bClDumpedFileName = 1;
            if (chain.coldata) {
               sprintf(szLineBuf3, ":file %s", pClCoi->name());
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf3, 'f', strlen(szLineBuf3)+2, MAX_LINE_LEN);
               chain.addLine(szLineBuf3, szAttrBuf3);
            } else {
               setTextColor(nGlblFileColor);
               info.print("%s :\n", pClCoi->name());
               setTextColor(-1);
            }
         }

         // create coloured display of hits of PREVIOUS line
         if (nMatchPre)
         {
            char *pszTmp = szClLastLine;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            if (bGlblGrepLineNum)
               sprintf(szClPreBuf, " / %04lu ", (nLine > 0) ? (nLine-1) : nLine);
            else
               sprintf(szClPreBuf, " / ");
            szClAttBuf[1] = 'p';
            if (!cs.pure) {
               if (chain.coldata) {
                  chain.addToCurLine(szClPreBuf, szClAttBuf, 0);
               } else {
                  printColorText(szClPreBuf, szClAttBuf, 0); // w/o LF
               }
            }

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            for (long k=0; k<nGrepPat; k++) 
            {
               char *pszPat = glblGrepPat.getString(k);
               long nPatLen = strlen(pszPat);
               long nTmpLen = strlen(pszTmp);
               long nCur = 0, nRel = 0;
               while (mystrhit(pszTmp+nCur, pszPat, cs.usecase, &nRel))
               {
                  if (nCur+nRel+nPatLen < sizeof(szClAttBuf)-10)
                     memset(&szClAttBuf[nCur+nRel], 'i', nPatLen);
                  nCur += nRel+nPatLen;
                  if (nCur >= nTmpLen-1)
                     break;
               }
            }
            if (chain.coldata)
               chain.addLine(pszTmp, szClAttBuf);
            else
               printColorText(pszTmp, szClAttBuf);
         }
 
         // create coloured display of hits of CURRENT line
         if (nMatchCur)
         {
            char *pszTmp = pszBuf;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            if (bGlblGrepLineNum)
               sprintf(szClPreBuf, "   %04lu ", nLine);
            else
               sprintf(szClPreBuf, "   ");
            if (nMatchPre) {
               szClPreBuf[1] = '\\';
               szClAttBuf[1] = 'p';
            }
            if (!cs.pure) {
               if (chain.coldata) {
                  chain.addToCurLine(szClPreBuf, szClAttBuf, 0);
               } else {
                   printColorText(szClPreBuf, szClAttBuf, 0); // w/o LF
               }
            }

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            for (long k=0; k<nGrepPat; k++) 
            {
               char *pszPat = glblGrepPat.getString(k);
               long nPatLen = strlen(pszPat);
               long nTmpLen = strlen(pszTmp);
               long nCur = 0, nRel = 0;
               while (mystrhit(pszTmp+nCur, pszPat, cs.usecase, &nRel)) 
               {
                  // printf("%ld.%ld ",nCur,nRel);
                  if (nCur+nRel+nPatLen < sizeof(szClAttBuf)-10)
                     memset(&szClAttBuf[nCur+nRel], 'i', nPatLen);
                  nCur += nRel+nPatLen;
                  if (nCur >= nTmpLen-1)
                     break;
               }
            }
            if (chain.coldata)
               chain.addLine(pszTmp, szClAttBuf);
            else
               printColorText(pszTmp, szClAttBuf);
         }

         // line was listed, do NOT remember
         szClLastLine[0] = '\0';
      }
      else
      {
         // line was NOT listed
         szClLastLine[0] = '\0';
         if (!bHardWrap) {
            // and it's a soft-wrap line (no LF), so remember it.
            long nCurLen = strlen(pszBuf);
            long nCopyIndex = 0;
            if (nCurLen > BT_LASTLINE_LEN) {
               nCopyIndex = nCurLen - BT_LASTLINE_LEN;
               nCurLen    = BT_LASTLINE_LEN;
            }
            // mystrcopy guarantees a zero terminator if nCurLen > 0.
            mystrcopy(szClLastLine, pszBuf+nCopyIndex, nCurLen+1);
         }
      }
   }
   return 0;
}

// only for processDirParms and walkAllTrees:
long nGlblError = 0;
StringTable *pGlblFileParms = 0;
char **apGlblFileParms = 0;
int  nGlblFileParms    = 0;
bool bGlblHaveMixedDirFileList = 0;

void skipSpaceRem(char **pszInOut)
{
   char *psz1 = *pszInOut;

   // skip all whitespaces and remark lines
   while (*psz1) 
   {
      if (*psz1==' ' || *psz1=='\t' || *psz1=='\r' || *psz1=='\n')
         { psz1++; continue; }

      if (*psz1=='#' || *psz1==';') {
         while (*psz1 && *psz1!='\n')
            psz1++;
         if (*psz1)
            psz1++; // skip LF
      }
      else
         break;
   }

   *pszInOut = psz1;
}

ulong currentProcessID()
{
   #ifdef _WIN32
   return (ulong)GetCurrentProcessId();
   #else
   return (ulong)getpid();
   #endif
}

// temporary file class, REMOVING THE FILE IN DESTRUCTOR.
class SFTmpFile
{
public:
   SFTmpFile   (bool bNoAutoDelete, ulong nTmpFileNum = 0);
  ~SFTmpFile   ( );
   char *name  ( );
   static void setTmpDir(char *pszDir);
private:
   bool  bClAutoDel;
   ulong nClNum;
   char *pszClName;
   static long ncnt;
   static char *pszTmpDir;
};

long SFTmpFile::ncnt = 1;
char *SFTmpFile::pszTmpDir = 0;

SFTmpFile::SFTmpFile(bool bNoAutoDelete, ulong nTmpFileNum) {
   bClAutoDel = !bNoAutoDelete;
   nClNum     = nTmpFileNum;
   pszClName  = 0;
}

SFTmpFile::~SFTmpFile() {
   if (pszClName != 0) {
      if (bClAutoDel && fileExists(pszClName))
         remove(pszClName);
      delete [] pszClName;
      pszClName = 0;
   }
}

void SFTmpFile::setTmpDir(char *pszDir)
{
   pszTmpDir = pszDir;
}

// uses szLineBuf
char *SFTmpFile::name() 
{
   if (!pszClName) {
      char *psz = pszTmpDir;
      if (!psz) psz = getenv("TEMP");
      if (!psz) psz = getenv("TMP");
      #ifndef _WIN32
      if (!psz) psz = "/tmp";
      #endif
      if (!psz) 
         { perr("cannot create temporary file: no TEMP or TMP environment variable found.\n"); return 0; }
      pszClName = new char[MAX_LINE_LEN+10];
      if (joinPath(pszClName, MAX_LINE_LEN-20, psz, "zz-tmp-sfk-"))
         { perr("cannot create temporary file.\n"); return 0; }
      long nlen = strlen(pszClName);
      ulong uprocid = currentProcessID();
      if (nClNum > 0)
         sprintf(pszClName+nlen, "%03lu.txt", nClNum);
      else
         sprintf(pszClName+nlen, "%03lu.txt", uprocid);
      ncnt = (ncnt+1) % 3;
   }
   if (cperm.showtmp) {
       info.clear();
       setTextColor(nGlblTimeColor);
       oprintf("using temporary file: %s\n", pszClName);
       setTextColor(-1);
   }
   return pszClName;
}

bool isDirParm(char *psz)
{
   if (!strcmp(psz, "-dir"))        return true;
   if (!strcmp(psz, "-file"))       return true;
   if (!strncmp(psz, "-from=", 6))  return true;
   if (!strcmp(psz, "-fileset"))    return true;
   if (!strcmp(psz, "-view"))       return true;   // deprecated
   return false;
}

// experimental: change thread priority
void setPriority(long nprio) 
{
   // supported values are -2 to +2
   #ifdef _WIN32
   SetThreadPriority(GetCurrentThread(), nprio);
   #else
   sched_param oschedparm;
   int nNativePrio = 0;
   switch (nprio) {
      case -2 : nNativePrio =   1; break;
      case -1 : nNativePrio =  25; break;
      case  0 : nNativePrio =  50; break;
      case  1 : nNativePrio =  75; break;
      case  2 : nNativePrio = 100; break;
   }
   if (nprio < -2) nNativePrio =   1;
   if (nprio >  2) nNativePrio = 100;
   oschedparm.sched_priority = nNativePrio;
   pthread_setschedparam(pthread_self(), SCHED_OTHER, &oschedparm);
   #endif
}

#ifdef VFILEBASE
extern "C" void setUzpMemLimit(num nlimit);
#endif // VFILEBASE

void setMemoryLimit(long nMBytes) 
{
   num nbytes = nMBytes * 1048576;
   // no not accept limits below 10 MB:
   if (nbytes < 10 * 1000000) {
      perr("ignoring memlimit, illegal value: %ld", nMBytes);
   } else {
      nGlblMemLimit = nbytes;
   }
}

bool setGeneralOption(char *argv[], int argc, int &iOpt, bool bGlobal=0)
{
   struct CommandStats *pcs = (bGlobal ? &gs : &cs);

   char *psz1 = argv[iOpt];

   if (!strcmp(psz1, "-stest"))     { bGlblSyntaxTest = 1; return true; }
   if (!strcmp(psz1, "-debug"))     { pcs->debug = 1; return true; }
   if (!strncmp(psz1, "-coi", 4))   { Coi::bClDebug = 1; return true; }
   if (!strcmp(psz1, "-noop"))      { return true; }
   if (!strcmp(psz1, "-quiet"))     { pcs->quiet = 1; return true; }
   if (!strcmp(psz1, "-quiet=2"))   { pcs->quiet = 2; return true; }
   if (!strcmp(psz1, "-nohead"))    { pcs->nohead = 1; return true; }
   if (!strcmp(psz1, "-nocheck"))   { pcs->nocheck = 1; return true; }
   if (!strncmp(psz1, "-noinf", 6)) { pcs->noinfo = 1; return true; }
   if (!strncmp(psz1, "-nofile", 7)){ pcs->nonames = 1; return true; }
   if (!strncmp(psz1, "-noname", 7)){ pcs->nonames = 1; return true; }
   if (!strcmp(psz1, "-sim"))       { pcs->sim = 1; return true; }
   if (!strcmp(psz1, "-norec"))     { pcs->subdirs = 0; return true; }
   if (!strncmp(psz1, "-nosub", 6)) { pcs->subdirs = 0; return true; }
   if (!strcmp(psz1, "-sub"))       { pcs->subdirs = 1; return true; }
   if (!strcmp(psz1, "-i"))         { bGlblStdInAny = 1; return true; }
   if (!strcmp(psz1, "-verbose"))   { pcs->verbose = 1; return true; }
   if (!strcmp(psz1, "-verbose=2")) { pcs->verbose = 2; return true; }
   if (!strcmp(psz1, "-verbose=3")) { pcs->verbose = 3; return true; }
   if (!strcmp(psz1, "-verbose=4")) { pcs->verbose = 4; return true; }
   if (strBegins(psz1, "-hid"))     { pcs->hidden = 1; return true; }
   if (strBegins(psz1, "-nohid"))   { pcs->hidden = 0; return true; }
   if (!strcmp(psz1, "-yes"))       { pcs->yes = 1; return true; }
   if (!strcmp(psz1, "-umlauts"))   { nGlblBinTextBinRange = 0xC0; return true; }
   if (!strcmp(psz1, "-noumlauts") || strBegins(psz1, "-noacc"))
                                    { nGlblBinTextBinRange = 0xFF; return true; }
   if (strBegins(psz1, "-utf"))     { pcs->utf16dec = 1; return true; }
   if (strBegins(psz1, "-noutf"))   { pcs->utf16dec = 0; return true; }
   if (!strcmp(psz1, "-nocol"))     { bGlblUseColor = bGlblUseHelpColor = 0; return true; }
   if (!strcmp(psz1, "-col"))       { bGlblUseColor = 1; return true; }
   if (!strcmp(psz1, "-case"))      { pcs->usecase = 1; return true; }
   if (!strcmp(psz1, "-nocase"))    { pcs->usecase = 0; pcs->nocase = 1; return true; }
   if (!strcmp(psz1, "-withdirs"))  { pcs->withdirs = 1; return true; }
   if (!strncmp(psz1, "-wdir", 5))  { pcs->withdirs = 1; return true; }
   if (!strcmp(psz1, "-justdirs"))  { pcs->justdirs = 1; return true; }
   if (!strcmp(psz1, "-names"))     { pcs->useJustNames = 1; return true; }
   if (!strncmp(psz1, "-rel", 4))   { pcs->rootrelname = 1; return true; }
   if (!strncmp(psz1, "-absname", 8)) { pcs->rootabsname = 1; return true; }
   if (!strncmp(psz1, "-quot", 5))  { bGlblQuoted = 1; return true; }
   if (!strcmp(psz1, "-nocconv"))   { bGlblEnableOPrintf = 0; return true; }
   if (!strcmp(psz1, "-cconv"))     { bGlblForceCConv = 1; return true; }
   if (!strcmp(psz1, "-incref"))    { bGlblSinceDirIncRef = 1; return true; }
   if (!strcmp(psz1, "-force"))     { pcs->force = 1; return true; }
   if (!strncmp(psz1, "-lit", 4))   { pcs->spat = 0; pcs->wpat = 0; return true; }
   if (!strncmp(psz1, "-spat", 5))  { pcs->spat = 1; return true; }
   if (!strncmp(psz1, "-nospat", 7)){ pcs->spat = 0; return true; }
   if (!strcmp(psz1, "-bright"))    { nGlblDarkColBase = 1; return true; }
   if (!strcmp(psz1, "-dark"))      { nGlblDarkColBase = 0; return true; }
   if (!strcmp(psz1, "-nochain"))   { pcs->nochain = 1; return true; }
   if (!strcmp(psz1, "-showrc"))    { gs.showrc = 1; return true; }
   if (!strcmp(psz1, "-exectime"))  { gs.tellExecTime = 1; return true; }
   if (!strncmp(psz1, "-nowarn", 7)) { pcs->nowarn = 1; return true; }
   if (!strncmp(psz1, "-noerr",  6)) { pcs->noerr = 1; return true; }
   if (!strncmp(psz1, "-nonote", 7)) { pcs->nonotes = 1; return true; }
   if (!strncmp(psz1, "-nofo", 5))   { pcs->skipLinks = 1; return true; }
   if (!strncmp(psz1, "-rawflags", 5)) { pcs->traceFileFlags = 1; return true; }
   if (!strncmp(psz1, "-ltarg", 6))  { pcs->listTargets = 1; return true; }
   if (!strncmp(psz1, "-stoponerr", 10))  { pcs->treeStopRC = 9; return true; }
   if (!strncmp(psz1, "-rcfromerr", 10))  { pcs->rcFromError = 9; return true; }
   if (!strncmp(psz1, "-waitonerr", 11))  { bGlblPauseOnError = 1; return true; }
   else
   if (!strncmp(psz1, "-wait", 5))  { bGlblPauseOnEnd = 1; return true; }
   if (!strncmp(psz1, "-exterr", 7)){ bGlblSysErrDetail = 1; return true; }
   if (!strncmp(psz1, "-detail", 7)){ bGlblSysErrDetail = 1; return true; }
   if (!strcmp(psz1, "-showskip"))  { pcs->showdupdirs = 1; return true; }
   if (strBegins(psz1, "-allowdup")) { pcs->usecirclemap = 0; return true; }
   if (!strcmp(psz1, "-fast"))      { pcs->fast = 1; return true; }
   if (!strcmp(psz1, "-noprog"))    { pcs->noprog = 1; return true; }
   if (!strcmp(psz1, "-test"))      { pcs->test = 1; return true; }
   if (!strcmp(psz1, "-oldmd5"))    { bGlblOldMD5 = 1; return true; }
   if (strBegins(psz1, "-text"))    { pcs->textfiles = 1; return true; }
   if (strBegins(psz1, "-textfile")){ pcs->textfiles = 1; return true; }
   if (strBegins(psz1, "-bin"))     { pcs->binaryfiles = 1; return true; }
   if (strBegins(psz1, "-binfile")) { pcs->binaryfiles = 1; return true; }
   if (strBegins(psz1, "-binaryfile")) { pcs->binaryfiles = 1; return true; }
   if (!strcmp(psz1, "-snap"))      { pcs->usesnap = 1; return true; }
   if (!strncmp(psz1, "-snapw", 6)) { // snapwithnames
      pcs->usesnap = 1;
      pcs->usesnapfiltname = 1;
      return true; 
   }
   if (!strcmp(psz1, "-upat")) {
      // enable unix or unified pattern syntax,
      // esp. for sfk filter under windows.
      glblNotChar = ':';
      glblRunChar = '#';
      return true;
   }
   #ifdef VFILEBASE
   if (!strcmp(psz1, "-qarc")) {
      pcs->travelzips  = 1;
      pcs->xelike      = 1;
      pcs->shallowzips = 1;  // toplevel only
      return true;
   }
   #endif // VFILEBASE
   if (!strcmp(psz1, "-zip") || !strcmp(psz1, "-arc")) {
      pcs->travelzips = 1;
      #ifdef VFILEBASE
      pcs->xelike     = 1;  // process zips as deep as possible
       #ifdef USE_SFK_BASE
       pcs->precachezip = 1; // dv load: always force precache
       #endif // USE_SFK_BASE
      #endif // VFILEBASE
      return true; 
   }
   if (!strcmp(psz1, "-nozip") || !strcmp(psz1, "-noarc"))
      { pcs->travelzips = 0; return true; }

   #ifdef VFILEBASE
   if (!strcmp(psz1, "-extdom"))    { pcs->extdomref = 1; return true; }
   if (!strcmp(psz1, "-xd"))        { pcs->xelike    = 1; return true; }
   if (!strcmp(psz1, "-cacheall"))  { pcs->cacheall  = 1; return true; }
   if (!strcmp(psz1, "-cachestat")) { gs.cachestat   = 1; return true; }
   if (!strcmp(psz1, "-nocache"))   { setDiskCacheActive(0); return true; }
   #endif // VFILEBASE

   if (strBegins(psz1, "-noipex"))  { pcs->noipexpand = 1; return true; }

   // -pure is often a local option, but some commands allow general use:
   if (bGlblAllowGeneralPure && !strcmp(psz1, "-pure"))
      { pcs->pure = 1; return true; }

   if (!strcmp(psz1, "-allbin") || !strcmp(psz1, "-include-all-binaries"))
      { pcs->incbin = 1; return true; }

   if (!strcmp(psz1,"-wrap") || !strcmp(psz1,"-rewrap"))
   {
      if (!strcmp(psz1,"-rewrap")) pcs->rewrap = 1;
      // wrap with auto-calculated number of columns
      long nCols = autoCalcWrapColumns();
      if (nCols) {
         pcs->wrapcol = nCols;
         if (pcs->wrapbincol == 80) // if on default
            pcs->wrapbincol = nCols;
      }
      mtklog("opt: done %s, wrapcol=%ld, wrapbincol=%ld",psz1,pcs->wrapcol,pcs->wrapbincol);
      return true;
   }
   if (strBegins(psz1,"-wrap=") || strBegins(psz1,"-rewrap="))
   {
      long nCols = 0;
      if (strBegins(psz1,"-rewrap=")) {
         pcs->rewrap = 1;
         nCols = atol(psz1+8);
      } else {
         nCols = atol(psz1+6);
      }
      // wrap with fixed (user-defined) number of columns
      if (nCols) {
         pcs->wrapcol = nCols;
         if (pcs->wrapbincol == 80) // if on default
            pcs->wrapbincol = nCols;
      }
      mtklog("opt: done %s, wrapcol=%ld, wrapbincol=%ld",psz1,pcs->wrapcol,pcs->wrapbincol);
      return true;
   }
   if (!strncmp(psz1,"-wrapbin",8)) {
      // wrap for text extracted from binary files
      long nCols = 0;
      if (!strncmp(psz1,"-wrapbin=",9))
         nCols = atol(psz1+9);
      else
         nCols = autoCalcWrapColumns();
      if (nCols) {
         pcs->wrapbincol = nCols;
      }
      return true;
   }
   if (!strncmp(psz1,"-memlimit=",strlen("-memlimit="))) {
      long nMBytes = atol(psz1+strlen("-memlimit="));
      setMemoryLimit(nMBytes);
      return true;
   }
   if (!strncmp(psz1,"-keepstale=",strlen("-keepstale="))) {
      nGlblActiveFileAgeLimit = atol(psz1+strlen("-keepstale="));
      return true;
   }
   if (!strncmp(psz1, "-html", 5)) {
      bGlblHtml = 1;
      if (!getenv("SFK_COLORS"))
         setColorScheme("file:1,head:4,examp:8");
      if (!strcmp(psz1, "-html-head"))
         printf("<font face=\"courier\" size=\"2\"><pre>\n");
      return true; 
   }
   if (   !strcmp(psz1, "-sincedir") || !strcmp(psz1, "-sd")
       || !strcmp(psz1, "-sinceadd") || !strncmp(psz1, "-sincedif", 9)
       || !strncmp(psz1, "-sincech", 8) || !strcmp(psz1, "-sc")
      )
   {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *psz2 = argv[iOpt];
      if (*psz2 == '-') { perr("need directory name, no option allowed after %s\n", psz1); exit(9); }
      pszGlblSinceDir = strdup(psz2);
      if (!bGlblSyntaxTest && !isDir(pszGlblSinceDir))
         { perr("no such directory: %s\n", pszGlblSinceDir); exit(9); }
      if (!strcmp(psz1, "-sinceadd"))
         nGlblSinceMode |= 1;
      else
      if (!strncmp(psz1, "-sincedif", 9))
         nGlblSinceMode |= 2;
      else
      if (!strncmp(psz1, "-sincech", 8) || !strcmp(psz1, "-sc"))
         nGlblSinceMode |= 1+2;  // only add and dif, no time diff
      else
         nGlblSinceMode = 1+2+4; // default: list all differences
      return true;
   }
   if (!strncmp(psz1, "-ignoretime", 11)) {
      // if (!(nGlblSinceMode & 2)) {
      //    perr("-ignoretime can be used only after -sincedir/dif/ch.\n");
      //    exit(9);
      // }
      bGlblIgnoreTime = 1;
      return true;
   }
   if (!strcmp(psz1, "-ignore3600")) {
      bGlblIgnore3600 = 1;
      return true;
   }
   if (!strcmp(psz1, "-noignore3600")) {
      bGlblIgnore3600 = 0;
      return true;
   }
   if (!strncmp(psz1, "-tracesel", 9)) {
      nGlblTraceSel |= 3;
      return true;
   }
   if (!strncmp(psz1, "-tracedir", 9)) {
      nGlblTraceSel |= 1;
      return true;
   }
   if (!strncmp(psz1, "-tracefile", 10)) {
      nGlblTraceSel |= 2;
      return true;
   }
   if (!strcmp(psz1, "-usectime")) {
      pcs->usectime = 1;
      return true;
   }
   #ifdef VFILENET
   if (!strcmp(psz1, "-proxy")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char szBuf[200];
      char *pproxy = argv[iOpt];
      strcopy(szBuf, pproxy);
      char *psz1 = szBuf;
      while (*psz1 && *psz1 != ':') psz1++;
      if (*psz1) *psz1++ = '\0';
      long nport = atol(psz1);
      TCPCore::setProxy(szBuf, nport);
      return true;
   }
   #endif // VFILENET
   if (!strcmp(psz1, "-since")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *psz2 = argv[iOpt];
      if (tryGetRelTime(psz2, pcs->sincetime))
      { }
      else
      if (timeFromString(psz2, pcs->sincetime))
         exit(9);
      if (pcs->untiltime && pcs->untiltime <= pcs->sincetime)
         {  perr("-before lower or equal than -since was specified.\n"); exit(9); }
      return true;
   }
   if (!strcmp(psz1, "-before")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *psz2 = argv[iOpt];
      if (tryGetRelTime(psz2, pcs->untiltime))
      { }
      else
      if (timeFromString(psz2, pcs->untiltime))
         exit(9);
      if (pcs->sincetime && pcs->sincetime >= pcs->untiltime)
         {  perr("-since greater or equal than -before was specified.\n"); exit(9); }
      return true;
   }
   if (!strcmp(psz1, "-to")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      cs.tomask = argv[iOpt];
      return true;
   }
   if (!strcmp(psz1, "-tmpdir")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      SFTmpFile::setTmpDir(argv[iOpt]);
      return true;
   }
   if (!strcmp(psz1, "-keeptmp")) {
      cperm.keeptmp = 1;
      return true;
   }
   if (!strcmp(psz1, "-showtmp")) {
      cperm.showtmp = 1;
      return true;
   }
   if (!strcmp(psz1, "-today")) {
      tryGetRelTime("today", pcs->sincetime);
      return true;
   }
   if (!strcmp(psz1, "-flist") || !strcmp(psz1, "-fl"))
   {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *pszFile = argv[iOpt];

      // read list of filenames from a file.
      Coi ocoi(pszFile, 0);
      if (ocoi.open("rb"))
         { perr("cannot read filename list file: %s\n", pszFile); exit(9); }
      while (ocoi.readLine(szLineBuf, sizeof(szLineBuf)-10) > 0)
      {
         szLineBuf[sizeof(szLineBuf)-10] = '\0';
         removeCRLF(szLineBuf);
         if (cs.debug) printf("] add2flist.1: %s\n", szLineBuf);
         Coi ocoisub(szLineBuf, 0);
         glblSFL.addEntry(ocoisub); // is copied
      }
      ocoi.close();

      // if no further dir parms follow, do not autocomplete.
      cs.blockAutoComplete = 1;

      return true;
   }
   if (!strncmp(psz1,"-prio=", 6)) {
      setPriority(atol(psz1+6));
      return true;
   }
   if (!strncmp(psz1,"-dirdelay=",strlen("-dirdelay="))) {
      pcs->walkDirDelay = atol(psz1+strlen("-dirdelay="));
      return true;
   }
   if (!strncmp(psz1,"-filedelay=",strlen("-filedelay="))) {
      pcs->walkFileDelay = atol(psz1+strlen("-filedelay="));
      return true;
   }
   if (!strcmp(psz1,"-slow=3"))   {
      pcs->walkDirDelay  = 10;
      pcs->walkFileDelay = 10;
      return true;
   }
   if (!strcmp(psz1,"-slow=2"))   {
      pcs->walkDirDelay  = 100;
      return true;
   }
   if (!strncmp(psz1,"-slow", 5)) {
      setPriority(-1);
      return true;
   }
   return false;
}

long processDirParms(char *pszCmd, int argc, char *argv[], int iDir, int nAutoComplete, int *iDirNext=0, bool *pAnyDone=0);

// uses szLineBuf. PreCmd is optional prefix, usually "-any" or NULL.
long processFlatDirParms(char *pszPreCmd, char *pszCmdLine, int nAutoComplete)
{
   if (cs.debug) printf("processFlatDirParms\n");

   // make copy of input to allow overwriting.
   strncpy(szLineBuf, pszCmdLine, sizeof(szLineBuf)-10);
   szLineBuf[sizeof(szLineBuf)-10] = '\0';
   pszCmdLine = szLineBuf;
 
   pGlblFileParms = new StringTable();

   if (pszPreCmd)
      pGlblFileParms->addEntry(pszPreCmd);

   long nAbsPathParms = 0;

   char *psz1 = pszCmdLine;
   while (*psz1) 
   {
      // find next token.
      char *pszo = psz1;
      skipSpaceRem(&psz1);
 
      // find end of token. support "parm with blanks".
      char *psz2 = psz1+1;
      if (*psz1 == '"')
         while (*psz2 && *psz2!='"')
            psz2++;
      while (*psz2 && *psz2!=' ' && *psz2!='\t' && *psz2!='\r' && *psz2!='\n')
         psz2++;

      // isolate token
      if (*psz2)
         *psz2++ = '\0';

      // line-end may lead to empty entry, therefore
      if (strlen(psz1)) // only if not line-end
      {
         // strip "", if any
         if (*psz1 == '"' && strlen(psz1) >= 2) {
            psz1++;
            long nLen = strlen(psz1);
            if (psz1[nLen-1] == '"')
                psz1[nLen-1] = '\0';
         }
         if (cs.debug) printf("token: <<%s>>\n", psz1);
         pGlblFileParms->addEntry(psz1);

         // count number of parms starting absolute
         if (isAbsolutePath(psz1))
            nAbsPathParms++;

         #ifdef VFILEBASE
         Coi ocoi(psz1, "");
         if (endsWithArcExt(psz1) || ocoi.isZipSubEntry())
            setArcTravel(1, 1);
         #endif // VFILEBASE
      }

      // continue with next token, if any
      psz1 = psz2;
   }

   // pGlblFileParms now holds all parms
   long nParms = pGlblFileParms->numberOfEntries();
   mtklog("pfdp nparms %ld", nParms);
   apGlblFileParms = new char*[nParms];
   for (long i=0; i<nParms; i++) {
      char *pszParm = pGlblFileParms->getEntry(i, __LINE__);
      apGlblFileParms[i] = pszParm;
      mtklog("   copied %s", pszParm ? pszParm : "<null>");
   }
   nGlblFileParms = nParms;

   // if user drops a bunch of stuff onto the .exe
   if ((nGlblFileParms > 0) && (nGlblFileParms == nAbsPathParms)) {
      // then we don't process "dir .ext1 .ext2" but a mixed list
      bGlblHaveMixedDirFileList = 1;
   }

   return processDirParms("", nParms, apGlblFileParms, 0, nAutoComplete);
}

enum ePDPStates {
   eST_Idle       = 0,
   eST_RootDirs   = 1,
   eST_FileMasks  = 2,
   eST_GrepPat    = 3,
   eST_IncBin     = 4,
   eST_DirFile    = 5,

   eST_MAXStates
};

long containsWildCards(char *pszName)
{
   if (strchr(pszName, glblWildChar)) return 1;
   if (strchr(pszName, '*')) return 1;
   if (strchr(pszName, '?')) return 1;
   return 0;
}

long lastCharIsBackSlash(char *pszName)
{
   ulong nlen = strlen(pszName);
   if (!nlen) return 0;
   return (pszName[nlen-1] == glblPathChar) ? 1 : 0;
}

void stripTrailingBackSlashes(char *psz)
{
   long nidx = (long)strlen(psz);
   while (nidx > 0 && psz[nidx-1] == glblPathChar) {
      psz[nidx-1] = '\0';
      nidx--;
   }
}

char *aGlblChainCmds[] = 
{
   // list of all chainable commands and their name variations
   // (first unambigious chars). every command is prefixed
   // by the default input data type (1:filenames 2:text)

   "2filt",         // receive+send files and TEXT
   "1ffilt",        // receive+send FILES and text
   "1filefilt",     // receive+send FILES and text
   "1list",         // receive+send FILES and text
   "0sel",          // use nothing, pass-thru

   "1md5gento",     // receive+pass files
   "1snapto",       // receive+pass files
   "1scantab",      // receive+send files
   "2detab",        // receive+send files and TEXT
   "1entab",        // receive+send FILES [and text]
   "1lf-to-crlf","1crlf-to-lf","1addcr","1remcr",
   "1synctext",     // receive files
   "1find","1grep", // receive+send FILES and text
   "1ftext",        // receive+send FILES and text
   "1run",          // receive+send FILES and text
   "1inst",         // receive files
   "1deblank",      // receive+send files
   "0noop", 
   "1rep",          // receive+send files
   "2view",         // receive files and TEXT
   "1fv",           // receive FILES and text (fview)
   "2vc",           // receive files and TEXT
   "1del",          // receive FILES and text
   "1rmtree",       // receive FILES and text
   "0sleep",        // pass-thru text
   "0label",        // pass-thru text
   "3tail",         // receive ANY
   "3head",         // receive ANY
   "2ttail",        // receive TEXT
   "2thead",        // receive TEXT
   "2toclip",       // receive text
   "0beep",         // pass-thru
   "0loop",         // restart chain
   "2hextobin",     // receive text
   "0echo",         // pass-thru
   "1hexdump",      // receive filenames
   "1dup",          // receive filenames
   "1copy",         // receive filenames
   "2script",       // receive TEXT
   "1fscript",      // receive TEXT
   "0end",          // pass-thru
   "1ftee",         // receive filenames
   "2tee",          // receive TEXT
   "2toterm",       // receive TEXT
   "2tofile",       // receive TEXT
   "0sfk",          // flushes chain
   "0then",         // flushes chain
   "1stat",         // receive filenames
   "0fromclip",     // receive nothing
   "0pause",        // receive nothing
   "2dec",          // receive TEXT
   "2hex",          // receive TEXT
   "2sort",         // receive TEXT
   "2count",        // receive TEXT
   "1ftp",          // receive filenames
   "1sft",          // receive filenames
   "0mkdir", "0cd", "0getcwd", "0cwd", // pass-thru
   "0ver",
   "1md5",          // receive files
   "1wget",         // receive files
   "2strlen",       // receive TEXT
   "2webreq",       // receive TEXT
   "1call",         // receive FILES and text
   "1if",           // receive FILES and text
   0
};

// when passing stuff from one command to another,
// what is most probably used: text or filenames?
char *aGlblDefChnModes[] =
{// from    to      use default mode (1==files, 2==text)
   "sel",  "detab", "1",
   "list", "detab", "1",
   "fromclip", "dv", "2",
   0, 0, 0
};

enum eChainCodes {
   ccftt    = -1,
   ccfile   = -2,
   ccttf    = -3,
   cctext   = -4,
   ccthen   = -5,
};

// rc:  0 if NO chain command
//     <0 if +text, +file etc.
//     >0 if one of aGlblChainCmds
long getChainCode(char *pszin, long &rtype)
{__
   if (   !strcmp(pszin, "+ftt")
       || !strcmp(pszin, "+filenamestotext")
      )
   {
      rtype = 1; // files
      return ccftt;
   }

   if (!strcmp(pszin, "+files"))
   {
      rtype = 1; // files
      return ccfile;
   }

   if (   !strcmp(pszin, "+ttf")
       || !strcmp(pszin, "+texttofilenames")
      )
   {
      rtype = 2; // text
      return ccttf;
   }

   if (!strcmp(pszin, "+text"))
   {
      rtype = 2; // text
      return cctext;
   }

   if (!strcmp(pszin, "+then"))
   {
      rtype = 0; // none
      return ccthen;
   }

   if (pszin[0] == '+')
   {
      pszin++;
      for (long i=0; aGlblChainCmds[i]; i++)
      {
         char *psz = aGlblChainCmds[i];
         long aflags = *psz - '0';
         psz++;
         if (!strncmp(psz, pszin, strlen(psz)))
         {
            rtype = aflags;
            return i;
         }
      }
   }

   rtype = 0;
   return 0;   
}

// find next chain command clearly defining a type like FILES or TEXT
// rc: 1==files, 2==text, 0==none
// rforce: type is defined by +text etc. and MUST be used,
//         otherwise caller may use defaults
long findNextChainType(int iDir, char *argv[], int argc, char **pszNext, bool &rforce)
{__
   if (cs.nochain) return 0;

   for (; iDir < argc; iDir++) 
   {
      char *psz  = argv[iDir];
      long ntype = 0;
      long ncode = getChainCode(psz, ntype);
      mtklog("chain: gcc: %ld = getChainCode(%s)",ncode,psz);
      if (ntype != 0) {
         if (psz[0] == '+') psz++;
         *pszNext = psz;
         // is it a forced type like +text?
         if (ncode < 0)
            rforce = 1;
         return ntype;
      }
   }
   return 0;
}

bool isChainStart(char *pszCmd, char *argv[], int argc, int iDir, int *iDirNext, bool bAllowVerbose=0)
{__
   if (cs.nochain) return 0;

   // prefix mode switchers:
   long nplus1=0, nplus2=0;
   long ntype = 0;
   long ncode = getChainCode(argv[iDir], ntype);
   mtklog("chain: ics: %ld = getChainCode(%s)",ncode,argv[iDir]);

   switch (ncode) 
   {
      case ccftt:
         chain.colfiles   = 1;
         chain.files2text = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccfile:
         chain.colfiles = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccttf:
         chain.coldata    = 1;
         chain.text2files = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case cctext:
         chain.coldata = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccthen:
         chain.coldata    = 0;
         chain.colfiles   = 0;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         // use "then" as next chain command
         break;

      default:
         break;   // fall trough
   }
 
   // if +file or +text is specified, following command
   // is not required to start with "+".
 
   char *pszParm = argv[iDir];
   if (!strncmp(pszParm, "+", 1)) {
      nplus2 = 1;
      pszParm++;
   }

   if (ncode == ccthen) {
      // +then stops any further chain detections:
      if (iDirNext) *iDirNext = iDir;
      if (cs.verbose)
         printf("[chain from %s to %s. collect f=%d t=%d, idir %ld %p]\n",pszCmd,pszParm,chain.colfiles,chain.coldata,iDir,iDirNext);
      return true;
   }
 
   if (nplus1 || nplus2)
   {
      if (nplus2)
         nplus1 = 0;
      for (long i=0; aGlblChainCmds[i]; i++) 
      {
         char *psz = aGlblChainCmds[i];
         long aflags = *psz - '0';
         psz++;
         if (!strncmp(psz, pszParm, strlen(psz)))
         {
            // standing on the first following chain command.
            if (!chain.coldata && !chain.colfiles)
            {
               // find out what the next typed chain element is,
               // e.g. +noop +sleep 1000 +text +filter -+foo
               // requires to find +text.
               bool bForce    = 0;
               char *pszNext  = 0;
               long nNextType = findNextChainType(iDir, argv, argc, &pszNext, bForce);
               mtklog("chain: ics: found chain type %ld at %s\n", nNextType, pszNext);
 
               if (cs.verbose && pszNext)
                  printf("[found chain type %ld at %s]\n", nNextType, pszNext);

               // if next type is not a forced one like +text,
               if (!bForce && pszNext)
               {
                  // check if there is a default mapping
                  for (long k=0; aGlblDefChnModes[k]; k += 3) 
                  {
                     // look into defaults table
                     char *pszFrom = aGlblDefChnModes[k+0];
                     char *pszTo   = aGlblDefChnModes[k+1];
                     char *pszMode = aGlblDefChnModes[k+2];
                     if (   !strncmp(pszCmd , pszFrom, strlen(pszFrom))
                         && !strncmp(pszNext, pszTo  , strlen(pszTo  ))
                        )
                     {
                        // found a default:
                        nNextType = pszMode[0] - '0';
                        if (cs.verbose)
                           printf("[but using default type mapping %ld]\n", nNextType);
                        break;
                     }
                  }
               }
 
               if (nNextType & 1)
                  chain.colfiles = 1;

               if (nNextType & 2)
                  chain.coldata = 1;
            }
 
            // if no mode yet set, use command default, if any
            if (!chain.coldata && !chain.colfiles) {
               if (aflags==1)
                  chain.colfiles = 1;
               else
               if (aflags==2)
                  chain.coldata  = 1;
            }
 
            if (iDirNext) *iDirNext = iDir;
            if (cs.verbose) // && bAllowVerbose)
               printf("[chain from %s to %s. collect f=%d t=%d, idir %ld %p]\n",pszCmd,pszParm,chain.colfiles,chain.coldata,iDir,iDirNext);
 
            return true;
         }
      }
   }
 
   if (nplus2) {
      // no chain start although "+" parm
      // find/grep have a very loose syntax, therefore
      if (!strcmp(pszCmd, "find") || !strcmp(pszCmd, "grep"))
         return false; // command handler will issue error
      // check also filter parms
      if (!strncmp(argv[iDir], "++", 2) || !strncmp(argv[iDir], "+ls", 3))
         return false; // accept non-chain start
      char *psz = argv[iDir];
      perr("unknown chain command: %s\n", psz);
      exit(9);
   }
  
   return false;
}

long processDirParms(char *pszCmd, int argc, char *argv[], int iDir, int nAutoComplete, int *iDirNext, bool *pAnyDone)
{
   long checkMask(char *pszMask);

   mtklog("processDirParms with argc=%d",argc);

   bool bAnyDone = 0; // any user-supplied dir/file parm used
   bool bPreFileFlank = 0;
   long lRC = 0;

   bool aStateTouched[eST_MAXStates+10];
   memset(aStateTouched, 0, sizeof(aStateTouched));

   // fetch prefixed general options
   while (iDir < argc) {
      if (setGeneralOption(argv, argc, iDir))
         iDir++;
      else
         break;
   }

   if (iDir < argc)
   {
      if (   !strncmp(argv[iDir], "-from=", 6)
          || !strcmp(argv[iDir], "-fileset")
          || !strcmp(argv[iDir], "-view") // deprecated
         ) 
      {
         // re-create parameter array from input file
         char *pszOpt = argv[iDir];
         char *pszListFile = 0;
         if (!strncmp(argv[iDir], "-from=", 6))
            pszListFile = argv[iDir]+6;
         else {
            iDir++;
            if (iDir >= argc) return 9+perr("missing filename after %s\n", pszOpt);
            pszListFile = argv[iDir];
         }
         char *pszParmFile = loadFile(pszListFile);
         if (!pszParmFile) return 9;

         pGlblFileParms = new StringTable();
         char *psz1 = pszParmFile;
         while (*psz1) 
         {
            // find next token.
            char *pszo = psz1;
            skipSpaceRem(&psz1);

            // find end of token. support "parm with blanks".
            char *psz2 = psz1+1;
            if (*psz1 == '"')
               while (*psz2 && *psz2!='"')
                  psz2++;
            while (*psz2 && *psz2!=' ' && *psz2!='\t' && *psz2!='\r' && *psz2!='\n')
               psz2++;

            // isolate token
            if (*psz2)
               *psz2++ = '\0';

            // line-end may lead to empty entry, therefore
            if (strlen(psz1)) // only if not line-end
            {
               // strip "", if any
               if (*psz1 == '"' && strlen(psz1) >= 2) {
                  psz1++;
                  long nLen = strlen(psz1);
                  if (psz1[nLen-1] == '"')
                      psz1[nLen-1] = '\0';
               }
               if (cs.debug) printf("token: <<%s>>\n", psz1);
               pGlblFileParms->addEntry(psz1);
            }

            // continue with next token, if any
            psz1 = psz2;
         }
         delete [] pszParmFile;

         // pGlblFileParms now holds all parms
         long nParms = pGlblFileParms->numberOfEntries();
         apGlblFileParms = new char*[nParms];
         for (long i=0; i<nParms; i++)
            apGlblFileParms[i] = pGlblFileParms->getEntry(i, __LINE__);
         nGlblFileParms = nParms;

         // restart through recursion
         // printf("[%d parms from file]\n", nParms);
         return processDirParms(pszCmd, nParms, apGlblFileParms, 0, nAutoComplete);
      }
  
      // init fileset
      if (glblFileSet.beginLayer(false, __LINE__))
         return 9;

      // fetch further prefix options, if any
      char *pszFirstParm = argv[iDir];
      while (!strncmp(pszFirstParm, "-", 1)) {
         if (!setGeneralOption(argv, argc, iDir))
            break; // unknown option, fall through to further processing
         pszFirstParm = (iDir < argc-1) ? argv[++iDir] : (char*)"";
      }

      if (*pszFirstParm == '-') 
      {
         if (cs.debug) printf("process long format\n");

         // process long format, allowing multiple dirs:
         // sfk cmd -dir dir1 dir2 !dir3 !dir4 -copy -file .hpp .cpp

         // we now have:
         //   clRootDirs , two rows, DirName(empty) and Cmd(empty)
         // one layer:
         //   clDirMasks , one row , empty
         //   clFileMasks, one row , empty

         long lState = eST_Idle;
         for (;iDir < argc; iDir++)
         {
            if (isChainStart(pszCmd, argv, argc, iDir, iDirNext, 1))
               break;

            // on every state switch, we're first landing here
            if (lState >= 0 && lState < sizeof(aStateTouched)/sizeof(bool))
               aStateTouched[lState] = 1;

            char *psz1 = argv[iDir];
   
            if (cs.debug) printf("] \"%s\" [\n",psz1);

            if (!strcmp(psz1, "-debug")) {
               cs.debug = 1;
               continue;
            }
   
            if (!strcmp(psz1, "-dir"))
            {
               aStateTouched[eST_RootDirs] = 1;
               // creation of new dir/file mask layers:
               // 1. PostFileFlank: on change from non -dir to -dir
               // 2. PreFileFlank: on change from -file to -dir
               if (lState == eST_FileMasks && !bPreFileFlank) {
                  if (cs.debug) printf("] -dir: begin layer\n");
                  // not the very first -dir parm: add another layer
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               else
               if (lState == eST_RootDirs && !bPreFileFlank) {
                  // -dir tmp1 tmp2 -dir tmp3 -file .txt
                  // add implicite "-file *" to first layer
                  lState = eST_FileMasks;
                  lRC |= glblFileSet.addFileMask("*");
                  aStateTouched[lState] = 1;
                  if (cs.debug) printf("] -dir: begin layer.2\n");
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               else {
                  if (cs.debug) printf("] -dir: no begin layer\n");
               }
               // will collect further root dirs next
               lState = eST_RootDirs;
               aStateTouched[eST_FileMasks] = 0;
               continue;
            }

            if (!strcmp(psz1, "-any")) {
               // list of file- and directory names follows.
               bGlblAnyUsed = 1;
               lState = eST_DirFile;
               continue;
            }

            if (psz1[0] == glblNotChar) {
               if (lState == eST_RootDirs)
                  lRC |= glblFileSet.addDirMask(psz1);
               else
                  lRC |= glblFileSet.addFileMask(psz1);
               bAnyDone = 1;
               continue;
            }

            // collection of directory / file path masks:
            if (lState == eST_RootDirs)
            {
               if (psz1[0] == '+') {
                  if (!glblFileSet.rootDirs().numberOfEntries()) {
                     // +dirmask supplied without any previous root dir.
                     // imply that user wants dirs within the current dir "."
                     glblFileSet.addRootDir(".", __LINE__, false);
                     // imply that user does NOT want to process files from "."
                  }
                  bGlblNoRootDirFiles = 1;
                  lRC |= glblFileSet.addDirMask(psz1);
                  bGlblHavePlusDirMasks = 1;
                  bAnyDone = 1;
                  continue;
               }
               else
               if (containsWildCards(psz1)) {
                  if (!glblFileSet.rootDirs().numberOfEntries())
                     glblFileSet.addRootDir(".", __LINE__, false);
                  lRC |= glblFileSet.addDirMask(psz1);
                  bAnyDone = 1;
                  continue;
               }
            }

            if (!strcmp(psz1, "-copy")) {
               glblFileSet.addDirCommand(1);
               continue;
            }
            if (!strcmp(psz1, "-zip")) {
               glblFileSet.addDirCommand(2);
               continue;
            }

            if (!strcmp(psz1, "-file"))
            {
               aStateTouched[eST_FileMasks] = 1;
               if (!strncmp(pszCmd, "freezeto=", strlen("freezeto=")))
                  return 9+perr("no -file masks supported with freezeto command.\n");
               if (bGlblShortSyntax)
                  return 9+perr("you specified a dir name in short syntax. -file is not allowed then.\n");
               if (lState != eST_RootDirs)
                  bPreFileFlank = 1; // -file coming before -dir
               else
               if (bPreFileFlank) {
                  // not the very first -file parm: add another layer
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               lState = eST_FileMasks;
               continue;
            }

            // used only with grep:
            if (!strcmp(psz1, "-pat")) {
               lState = eST_GrepPat;
               continue;
            }

            // force inclusion of binary files
            if (!strcmp(psz1, "-addbin") || !strcmp(psz1, "-include-binary-files"))
            {
               lState = eST_IncBin;
               continue;
            }

            // general option specified inbetween:
            if (setGeneralOption(argv, argc, iDir))
               continue;

            // workaround for "*" under unix. see also short syntax.
            if (!strcmp(psz1, "-all")) {
               if (lState != eST_FileMasks)
                  return 9+perr("wrong context for -all. use within -file.\n");
               // else fall through to add.
            }
            else
            if (*psz1 == '-') {
               perr("unknown dir or file parameter: %s\n", psz1);
               pinf("try to specify %s before -dir ... -file\n", psz1);
               return 9;
            }

            // handle all non-command parameters
            switch (lState) 
            {
               case eST_RootDirs : {
                  // add another root dir, referencing the current layer.
                  if (glblFileSet.addRootDir(psz1, __LINE__, true))
                     return 9; 
                  bAnyDone = 1;
                  break;
               }
               case eST_FileMasks: lRC |= glblFileSet.addFileMask(psz1); break;
               case eST_GrepPat  : {
                  if (!strncmp(psz1, "\\\\", 2) || !strncmp(psz1, "\\+", 2) || !strncmp(psz1, "\\-", 2))
                     psz1++;
                  glblGrepPat.addString(psz1);
                  break;
               }
               case eST_IncBin   : glblIncBin.addString(psz1); break;
               case eST_DirFile  : {
                  // used only in case of explorer drag+drop.
                  Coi ocoi(psz1, 0);
                  if (ocoi.isTravelDir()) {
                     // coi name may have been redirected
                     if (glblFileSet.addRootDir(ocoi.name(), __LINE__, true))
                        return 9;
                  } else {
                     if (cs.debug) printf("add2flist.2: %s\n", psz1);
                     glblSFL.addEntry(ocoi); // is copied
                  }
                  bAnyDone = 1;
                  break;
               }
            }
         }
      }
      else 
      if (isChainStart(pszFirstParm, argv, argc, iDir, iDirNext))
      {
         // no actual dir parms at all, instead "+end" etc.:
         mtklog("pdp: no parms, first is chain: %s", pszFirstParm);
         // fall through to autocomplete, if any
      }
      else 
      if (strlen(pszFirstParm))
      {
         // process short format, either with single dir and fpatterns
         //    . .cpp .hpp !.hppx
         // or with a list of specified file names
         //    test1.txt test2.txt
         // OR, if simple drag+drop from explorer, mixed list.
         mtklog("pdp: short: first=%s havemdfl=%d", pszFirstParm,bGlblHaveMixedDirFileList);

         Coi *pcoi = 0;
         #ifdef VFILEBASE
         pcoi = glblVCache.get(pszFirstParm);
         #endif // VFILEBASE
         if (!pcoi) { 
            pcoi = new Coi(pszFirstParm, 0);
            pcoi->incref("pdp");
         }
         CoiAutoDelete odel(pcoi, 1); // with decref

         if ((!bGlblHaveMixedDirFileList) && pcoi->isTravelDir())
         {
            // fetch dir. coi name may have been redirected.
            glblFileSet.addRootDir(pcoi->name(), __LINE__, false);
            bAnyDone = 1;
            iDir++;

            // fetch masks
            for (; iDir < argc; iDir++)
            {
               if (isChainStart(pszCmd, argv, argc, iDir, iDirNext))
                  break;

               // also care about postfix/inbetween options
               char *psz1 = argv[iDir];
               if (setGeneralOption(argv, argc, iDir))
                  continue;
               if (!strcmp(psz1, "-file"))
                  return 9+perr("mixing of short and long syntax not allowed. you may try -dir %s -file ...\n", pszFirstParm);
               if (!strcmp(psz1, "-dir"))
                  return 9+perr("mixing of short and long syntax not allowed. you may try -dir %s ...\n", pszFirstParm);

               // workaround for "*" under unix. see also long syntax.
               if (!strcmp(psz1, "-all")) {
                  // fall through to add
               }
               else
               if (psz1[0] == '-') {
                  perr("unexpected option in short filename list: %s\n", psz1);
                  pinf("try specifying %s directly after %s\n", psz1, pszCmd);
                  return 9;
               }

               #ifdef VFILEBASE
               // convenience: is user trying to specify .zip file mask
               // although .zip's are directories?
               if (!cs.shallowzips && cs.xelike && cs.travelzips && endsWithArcExt(psz1))
               {
                  // then turn file mask into a path mask
                  static char szMaskBuf[100];
                  if (containsWildCards(psz1))
                     strcopy(szMaskBuf, psz1);
                  else
                     snprintf(szMaskBuf, sizeof(szMaskBuf)-10, "*%s", psz1);
                  if (cs.verbose > 1)
                     pinf("auto-converting %s to path mask %s\n", psz1, szMaskBuf);
                  if (lRC |= glblFileSet.addDirMask(szMaskBuf)) // is copied
                     return 9;
               }
               else
               #endif // VFILEBASE
               if (lRC |= glblFileSet.addFileMask(psz1))
                  return 9;
               bAnyDone = 1;
            }
         }
         else
         {
            // todo: split this in 2 paths. there can be no options
            //       in case of drag+drop on .exe.

            // fetch file and/or dir list. this path is called
            // - either from command prompt
            // - or from drag+drop on .exe (no preconfigured icon)
            for (; iDir < argc; iDir++)
            {
               if (isChainStart(pszCmd, argv, argc, iDir, iDirNext))
                  break;

               char *psz1 = argv[iDir];
               if (*psz1 == '-') {
                  if (!setGeneralOption(argv, argc, iDir))
                     return 9+perr("wrong context or unknown option: %s\n", psz1);
               } else {
                  Coi ocoi(psz1, 0);
                  if (bGlblHaveMixedDirFileList && ocoi.isAnyDir()) {
                     glblFileSet.addRootDir(psz1, __LINE__, false);
                     bAnyDone = 1;
                  } else {
                     if (cs.debug) printf("add2flist.3: %s\n", psz1);
                     glblSFL.addEntry(ocoi); // is copied
                     bAnyDone = 1;
                  }
               }
            }
            if (!bGlblHaveMixedDirFileList)
               nAutoComplete = 0;
         }
      }
   }
   else
   {
      // no parms at all supplied:
      if (!cs.blockAutoComplete && (nAutoComplete & 2))
         glblFileSet.addRootDir(".", __LINE__, false);
      // possibly redundant, see autocomplete below
   }

   bool bFail = (lRC != 0);

   // plausibility checks
   if (aStateTouched[eST_IncBin] && !glblIncBin.numberOfEntries())
      { bFail=1; perr("please supply a list of file extensions after -addbin or -include-binary-files.\n"); }
   if (aStateTouched[eST_GrepPat] && !glblGrepPat.numberOfEntries())
      { bFail=1; perr("please supply some pattern words after option -pat.\n"); }
   if (aStateTouched[eST_FileMasks] && !glblFileSet.fileMasks().numberOfEntries())
      { bFail=1; perr("please supply some file extensions after option -file.\n"); }
   if (aStateTouched[eST_RootDirs] && !glblFileSet.rootDirs().numberOfEntries())
      { bFail=1; perr("please supply some directory names after option -dir.\n"); }

   if (!cs.blockAutoComplete && (nAutoComplete != 0))
      glblFileSet.autoCompleteFileMasks(nAutoComplete);

   if (aStateTouched[1] || aStateTouched[2]) // if any -dir or -file
      if (glblFileSet.checkConsistency()) // then no empty layers allowed
         bFail=1;

   if (cs.debug) glblFileSet.dump();

   glblFileSet.setBaseLayer();

   // -sincedir requires root dir parameters
   if (pszGlblSinceDir && !glblFileSet.hasRoot(0)) {
      // Array &aroots = glblFileSet.rootDirs();
      // long nroots = aroots.numberOfEntries(0);
      // if (nroots <= 0) 
      return 9+perr("-sincedir/add/diff requires two directories.\n");
   }

   // tell caller if any real dir parms were used
   if (pAnyDone) *pAnyDone = bAnyDone;

   return bFail ? 9 : 0;
}

long setProcessSingleDir(char *pszDirName)
{
   #ifdef VFILEBASE
   if (   !strBegins(pszDirName, "http://")
       && !strBegins(pszDirName, "ftp://")
      )
   #endif // VFILEBASE
   {
      Coi ocoi(pszDirName, 0);
      if (!ocoi.isTravelDir())
         return 9+perr("directory not found: %s\n", pszDirName);
   }

   // init fileset
   if (glblFileSet.beginLayer(true, __LINE__))
      return 9;

   glblFileSet.addRootDir(pszDirName, __LINE__, false);
   glblFileSet.autoCompleteFileMasks(3);

   if (cs.debug) glblFileSet.dump();

   glblFileSet.setBaseLayer();

   return 0;
}

void removeCRLF(char *pszBuf) {
   char *pszLF = strchr(pszBuf, '\n');
   if (pszLF) *pszLF = '\0';
   char *pszCR = strchr(pszBuf, '\r');
   if (pszCR) *pszCR = '\0';
}

void fixPathChars(char *pszBuf) {
   // if path contains foreign path chars, change to local
   char *psz = pszBuf;
   for (; *psz; psz++)
      if (*psz == glblWrongPChar)
          *psz = glblPathChar;
}

int myfseek(FILE *f, num nOffset, int nOrigin)
{
   if (nOrigin != SEEK_SET)
      return 9+perr("internal: myfseek: supports only SEEK_SET");

   #ifdef _WIN32
   if (sizeof(num) != sizeof(fpos_t)) return 9+perr("internal: myfseek: wrong fpos_t size, need 64 bits");
   return fsetpos(f, &nOffset);
   #else
   fpos64_t xpos;
   if (fgetpos64(f, &xpos)) // read xpos.__state
      return 9+perr("internal: myfseek: failed to read position");
    #ifdef MAC_OS_X
     xpos = (fpos_t)nOffset;
    #else
     if (sizeof(xpos.__pos) != sizeof(nOffset)) return 9+perr("internal: myfseek: wrong __pos size, need 64 bits");
     xpos.__pos = nOffset;
    #endif
   return fsetpos64(f, &xpos);
   #endif
}

uchar   aGlblGetBuf[MY_GETBUF_MAX+100];
long    nGlblGetSize  = 0;
long    nGlblGetIndex = 0;
long    nGlblGetEOD   = 0;
num     nGlblGetFPos  = 0;

void myfgets_init()
{
   nGlblGetSize  = 0;
   nGlblGetIndex = 0;
   nGlblGetEOD   = 0;
   nGlblGetFPos  = 0;
}

// replacement for fgets, which cannot cope with 0x00 (and 0x1A under windows)
long myfgets(char *pszOutBuf, long nOutBufLen, FILE *fin, bool *rpIsBinary, char *pAttrBuf)
{
   if (!fin) return 9+perr("int. #66 missing file handle\n");
   if (nGlblGetSize  < 0 || nGlblGetSize  > MY_GETBUF_MAX) return 9+perr("int. #62 %d %d\n",(nGlblGetSize < 0),(nGlblGetSize > MY_GETBUF_MAX));
   if (nGlblGetIndex < 0 || nGlblGetIndex > MY_GETBUF_MAX) return 9+perr("int. #63 %d %d\n",(nGlblGetIndex < 0),(nGlblGetIndex > MY_GETBUF_MAX));
   if (nGlblGetIndex > nGlblGetSize) return 9+perr("int. #64\n");
   if (nGlblGetEOD > 1) return 9+perr("int. #65\n");

   long nBufFree = MY_GETBUF_MAX - nGlblGetSize;
   uchar *pRead  = &aGlblGetBuf[nGlblGetSize];

   // refill read buffer
   long nRead = 0;
   if (!nGlblGetEOD && (nGlblGetSize < MY_GETBUF_MAX/2)) {
      if ((nRead = fread(pRead, 1, nBufFree, fin)) <= 0)
         nGlblGetEOD = 1;
      else
         nGlblGetSize += nRead;
   }

   if (cs.debug) printf("] pre size %ld index %ld free %ld nread %ld\n", nGlblGetSize, nGlblGetIndex, nBufFree, nRead);

   // anything remaining?
   if (nGlblGetIndex >= nGlblGetSize) {
      nGlblGetEOD = 2;
      return 0;
   }

   // copy next line from front
   long nIndex     = nGlblGetIndex;
   long nOutIndex  = 0;
   long nOutSecLen = nOutBufLen-10;
   bool bBinary    = 0;
   for (; (nIndex < nGlblGetSize) && (nOutIndex < nOutSecLen);)
   {
      uchar c1 = aGlblGetBuf[nIndex++];
      nGlblGetFPos++; // count source position in file

      if (c1 == 0x00 || c1 == 0x1A) {
         if (!c1)
            bBinary = 1;
         c1 = (uchar)'.';
      }
      else
      if (c1 == (uchar)'\r')
         continue;

      pszOutBuf[nOutIndex++] = (char)c1;

      if (c1 == (uchar)'\n')
         break;
   }
   pszOutBuf[nOutIndex] = '\0';

   // promote binary flag
   if (bBinary && rpIsBinary)
      *rpIsBinary = 1;

   // move remaining cache data
   long nCacheRemain = nGlblGetSize-nIndex;
   if (nIndex + nCacheRemain < 0) return 9+perr("int. #60\n");
   if (nIndex + nCacheRemain > MY_GETBUF_MAX) return 9+perr("int. #61\n");
   if (nCacheRemain > 0)
      memmove(aGlblGetBuf, &aGlblGetBuf[nIndex], nCacheRemain);

   nGlblGetSize -= nIndex;
   nGlblGetIndex = 0;

   // if (cs.debug) printf("] pos size %ld index %ld out %ld\n", nGlblGetSize, nGlblGetIndex, nOutIndex);

   return nOutIndex;
}

// just for sfk run: process text list with file- OR dirnames
long walkStdInListFlat(long nFunc, long &rlFiles, num &rlBytes)
{
   if (nGlblError)
      return 9;

   nGlblFunc = nFunc;

   long lDirs = 0;
   FileList oLocDirFiles;

   while (fgets(szLineBuf, sizeof(szLineBuf)-10, stdin))
   {
      removeCRLF(szLineBuf);

      if (userInterrupt()) break;

      num nLocalMaxTime = 0, nTreeMaxTime  = 0;

      // skip remark and empty lines
      if (szLineBuf[0] == '#') continue;
      if (!strlen(szLineBuf))  continue;

      if (bGlblStdInFiles)
      {
         Coi ocoi(szLineBuf, 0);

         long lRC = execSingleFile(&ocoi, 0,
                        rlFiles, oLocDirFiles.clNames.numberOfEntries(),
                        lDirs, rlBytes,
                        nLocalMaxTime, nTreeMaxTime);

         if (!lRC) rlFiles++;

         // if (lRC >= 9) return lRC;
         if (cs.stopTree(lRC)) return lRC; else lRC=0;
      }

      if (bGlblStdInDirs)
      {
         rlFiles = 0; // reset tree file count

         Coi ocoi(szLineBuf, 0);

         long rlDirs = 0;
         num  nLocalBytes = 0;
         long lRC = execSingleDir(&ocoi, 0, rlFiles, oLocDirFiles, rlDirs, nLocalBytes,
                                  nLocalMaxTime, nTreeMaxTime);
         nLocalMaxTime = 0; // reset after use in execSingleDir
         rlBytes += nLocalBytes;

         // if (lRC >= 9) return lRC;
         if (cs.stopTree(lRC)) return lRC; else lRC=0;
      }
   }

   return 0;
}

// all commands except sfk run:
// take list with mixed file- and dirnames.
// in case of dirs, process each as root tree.
long walkStdInListDeep(long nFunc, long &rlFiles, num &rlBytes)
{
   if (nGlblError)
      return 9;

   long lDirs = 0;
   num nLocalMaxTime = 0, nTreeMaxTime = 0;

   // select the default mask set.
   glblFileSet.setCurrentRoot(0);

   while (fgets(szLineBuf, sizeof(szLineBuf)-10, stdin))
   {
      removeCRLF(szLineBuf);

      // skip remark and empty lines
      if (szLineBuf[0] == '#') continue;
      if (!strlen(szLineBuf))  continue;

      // now holding a file- OR a dirname.
      long lDirs = 0;
      FileList oLocDirFiles;
      num  nLocalBytes = 0, nLocalMaxTime = 0, ntime2 = 0;

      // szLineBuf may be root itself.
      Coi *pcoi = new Coi(szLineBuf, 0);
      CoiAutoDelete odel(pcoi, 0); // 0: no decref

      if (cs.debug) printf("] siw: %s\n", pcoi->name());
      long lRC = walkFiles(pcoi, 0, rlFiles, oLocDirFiles, lDirs, nLocalBytes, nLocalMaxTime, ntime2);

      // if (lRC >= 9) return lRC;
      if (cs.stopTree(lRC)) return lRC; else lRC=0;

      if (pcoi->isTravelDir())
      {
         lDirs++; // count dir as processed

         rlFiles = 0; // reset tree file count

         // if this succeeded, treat the tree as another dir.
         if (cs.debug) printf("] sid: %s\n", pcoi->name());
         lRC = execSingleDir(pcoi, 0, rlFiles, oLocDirFiles, lDirs, nLocalBytes, nLocalMaxTime, ntime2);
         if (cs.stopTree(lRC)) 
         {
            nLocalMaxTime = 0;
            nGlblError = 1;
            return 9;
         }
         lRC = 0;
         nLocalMaxTime = 0;
      }

      rlBytes += nLocalBytes;

      if (bGlblEscape)
         break;
   }

   return 0;
}

// process files from sfl or chain file list.
// does NOT recurse into directories.
long walkFileListFlat(CoiTable &oList, long nFunc, long &rlFiles, num &rlBytes, long &rlDirs)
{
   if (nGlblError)
      return 9;

   long lDirs = 0;
   FileList oLocDirFiles;
   long nLocFiles = 0;
   num  nLocBytes = 0;
   num  nLocalMaxTime = 0, nTreeMaxTime = 0;

   long lRC = 0;

   char szCurPath[300];
   memset(szCurPath, 0, sizeof(szCurPath));

   bGlblInSpecificProcessing = 1;

   long nEntries = oList.numberOfEntries();
   for (long i=0; i<nEntries; i++)
   {
      if (userInterrupt()) break;

      Coi *pcoi = oList.getEntry(i, __LINE__);
      if (!pcoi) return 9+perr("int. #50\n");
      char *pszFile = pcoi->name();

      #ifdef VFILEBASE
      // optim: if the cache contains an identical url,
      // take that coi instead, to avoid double reads.
      Coi *ptmp = glblVCache.get(pszFile);
      // caller (we) MUST RELEASE COI after use!
      if (ptmp) {
         mtklog("wfl: coi replaced by cache entry: %s", pszFile);
         pcoi = ptmp;
      }
      else
      #endif // VFILEBASE
         pcoi->incref("wff");

      // NO RETURN WITHOUT RELEASE!

      // additional fields available only from chain file list:
      char *pszRoot  = pcoi->root(1);  // returns null if none
      char *pszRef   = pcoi->ref(1);   // returns null if none

      if (cs.debug) 
         printf("] wfl: %s   %s   %s   dir=%d\n", pszFile, pszRoot ? pszRoot : "[no root]", pszRef ? pszRef : "[no ref]", pcoi->isTravelDir());

      mtklog("] wfl: %s   %s   %s   dir=%d", pszFile, pszRoot ? pszRoot : "[no root]", pszRef ? pszRef : "[no ref]", pcoi->isTravelDir());

      if (cs.withdirs && pcoi->isTravelDir()) {
         // file list mixed with dir names: expect dirname to come last.
         rlFiles  += nLocFiles;
         rlBytes  += nLocBytes;
         // unsolved: exclude previous files that are not part of the dir.
         nLocFiles = -1; // workaround for now: don't list dirs
         nLocBytes = -1; // workaround for now: don't list dirs
         lRC = execSingleDir(pcoi, 0,
                     nLocFiles, oLocDirFiles,
                     lDirs, nLocBytes,
                     nLocalMaxTime, nTreeMaxTime);
         oLocDirFiles.reset();
         nLocFiles = 0;
         nLocBytes = 0;
         rlDirs++;
      } else {
         // process file entry
         lRC = execSingleFile(pcoi, 0,
                     nLocFiles, 1,
                     lDirs, nLocBytes,
                     nLocalMaxTime, nTreeMaxTime);
         if (!lRC) nLocFiles++;
      }

      // RELEASE COI after use:
      pcoi->decref();

      if (cs.stopTree(lRC)) return lRC; else lRC=0;
   }

   // flush yet uncounted values
   rlFiles += nLocFiles;
   rlBytes += nLocBytes;

   bGlblInSpecificProcessing = 0;

   return lRC;
}

void resetFileSet() { glblFileSet.reset(); }

void resetAllFileSets() 
{
   glblFileSet.reset();
   chain.usefiles = 0;
   bGlblStdInAny  = 0;
   glblSFL.resetEntries();
}

long walkAllTrees(long nFunc, long &rlFiles, long &rlDirs, num &rlBytes) 
{
   mtklog("wat: walkAllTrees fn %ld err %d",nFunc,nGlblError);

   if (nGlblError)
      return 9;

   nGlblFunc = nFunc;

   long lRC = 0;

   if (chain.usefiles) {
      mtklog("wat: chain.usefiles is set, %ld in queue", chain.numberOfInFiles());
      if (chain.numberOfInFiles())
         return walkFileListFlat(*chain.infiles, nFunc, rlFiles, rlBytes, rlDirs);
      else
         return 9+perr("no filenames to process. command chaining stopped.\n");
   }

   if (bGlblStdInAny) {
      mtklog("wat: processing stdinlist");
      return walkStdInListDeep(nFunc, rlFiles, rlBytes);
   }

   if (glblSFL.numberOfEntries()) {
      mtklog("wat: processing SFL entries, %ld in queue", glblSFL.numberOfEntries());
      lRC = walkFileListFlat(glblSFL, nFunc, rlFiles, rlBytes, rlDirs);
      if (cs.stopTree(lRC)) return lRC; else lRC=0;
   }

   for (long nDir=0; glblFileSet.hasRoot(nDir); nDir++)
   {
      mtklog("wat: processing root dir %ld", nDir);

      // local tree statistics:
      long nLocalDirs  = 0;
      long nLocalFiles = 0;
      num  nLocalBytes = 0;

      FileList oDirFiles;

      num nLocalMaxTime = 0, nTreeMaxTime  = 0;

      // process one of the trees given at commandline.
      char *pszTree = glblFileSet.setCurrentRoot(nDir);
      if (cs.debug) printf("] wat: tree %s\n", pszTree);

      char *pszRoot = glblFileSet.root(1); // returns 0 if none

      // The topmost coi gets the top root set.
      // All sub-coi's will copy this root.
      Coi *pcoi = 0;

      #ifdef VFILEBASE
      if (pcoi = glblVCache.get(pszTree)) {
         mtklog("wat: ... reusing root from vcache");
      }
      else
      #endif // VFILEBASE
      {
         pcoi = new Coi(pszTree, pszRoot);
         pcoi->incref("wat");
      }
      CoiAutoDelete odel(pcoi, 1); // with decref

      lRC = walkFiles(pcoi, 0, nLocalFiles, oDirFiles, nLocalDirs, nLocalBytes, nLocalMaxTime, nTreeMaxTime);

      if (cs.stopTree(lRC)) {
         nGlblError = 1;
         return 9;
      }
      lRC = 0;

      if (cs.debug) printf("] wat: edir %s\n", pszTree);
      lRC = execSingleDir(pcoi, 0, nLocalFiles, oDirFiles, nLocalDirs, nLocalBytes, nLocalMaxTime, nTreeMaxTime);

      if (cs.flatdirstat) {
         cs.flatdircnt++; // count root dir
         cs.flatdircnt  += nLocalDirs;
         cs.flatfilecnt += nLocalFiles;
         cs.flatbytecnt += nLocalBytes;
      } else {
         rlDirs++; // count root dir
         rlDirs   += nLocalDirs; // add it's subdirs
         rlFiles  += nLocalFiles;
         rlBytes  += nLocalBytes;
      }

      if (cs.stopTree(lRC)) {
         nLocalMaxTime = 0;
         nGlblError = 1;
         return 9;
      }
      lRC = 0;

      nLocalMaxTime = 0;

      if (bGlblEscape)
         break;
   }

   return lRC;
}

long isDirByName(char *pszName)
{
   // used for not-yet-existing targets:
   // tell if it should be a dir by looking at the name
   long nlen = strlen(pszName);
   if (nlen <= 0) return 0;
   if (!strcmp(pszName, ".")) return 1;
   if (!strcmp(pszName, "..")) return 1;
   char clast = pszName[nlen-1];
   if (clast == glblPathChar) return 1;
   #ifdef _WIN32
   if (clast == ':') return 1;
   #endif
   // todo: aaa/. and aaa/.. detection
   return 0;
}

long isDir(char *pszName)
{
   if (bGlblSyntaxTest) {
      // if just simulating, check how the name looks
      if (!strcmp(pszName, ".")) return 1;
      return strstr(pszName, "dir") ? 1 : 0;
   }
   if (containsWildCards(pszName))
      return 0;

   #ifdef _MSC_VER
   DWORD nAttrib = GetFileAttributes(pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (nAttrib & FILE_ATTRIBUTE_DIRECTORY)
      return 1;
   #else
   struct stat64 buf;
   if (stat64(pszName, &buf))
      return 0;
   if (buf.st_mode & _S_IFDIR )
      return 1;
   #endif

   return 0;
}

long fileExists(char *pszName, bool bOrDir)
{
   #ifdef _MSC_VER
   DWORD nAttrib = GetFileAttributes(pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (!bOrDir && (nAttrib & FILE_ATTRIBUTE_DIRECTORY))
      return 0; // is a dir, not a file
   #else
   struct stat64 buf;
   if (stat64(pszName, &buf))
      return 0;
   if (!bOrDir && (buf.st_mode & _S_IFDIR))
      return 0; // is a dir, not a file
   #endif

   // we can get the attribs, and it's not a dir,
   // so expect that it is a file.
   // TODO: maybe further checks should be added.
   return 1;
}

long coiExists(char *pszName, bool bOrDir)
{
   Coi *pcoi = new Coi(pszName, 0);
   if (!pcoi) return 0;
   pcoi->incref("cex");

   long nrc = pcoi->existsFile(bOrDir);

   if (!pcoi->decref())
      delete pcoi;

   return nrc;   
}

long getFileStat( // RC == 0 if exists anything
   char  *pszName,
   long   &rbIsDirectory,
   long   &rbCanRead,
   long   &rbCanWrite,
   num    &rlFileTime,
   num    &rlFileSize,
   num   *ppcatimes,     // optional: creation and access time
   void  *prawstat,      // optional: create copy of stat structure
   long   nrawstatmax    // size of above buffer
 )
{
   if (prawstat) memset(prawstat, 0, nrawstatmax);

   #ifdef _MSC_VER

   #ifdef WINFULL
   // special case: top level of UNC paths
   // \\host\root          fails with stat()
   // \\host\root\subdir   can be used
   if (   !strncmp(pszName, "\\\\", 2)
       || !strncmp(pszName, "//", 2)
      )
   {
      char  psep    = pszName[0];
      char *pszHost = pszName+2;
      char *pszRoot = strchr(pszHost, psep);
      if (!pszRoot) return -1; // wrong format
      pszRoot++;
      char *pszSub  = strchr(pszRoot, psep);
      if (!pszSub) 
      {
         // handle \\host\root using GetFileAttributesEx
         mtklog("GetFileAttributesEx %s", pszName);
         WIN32_FILE_ATTRIBUTE_DATA oinf;
         if (!GetFileAttributesEx(pszName, GetFileExInfoStandard, &oinf))
            return -1;
         ulong nattrib = oinf.dwFileAttributes;
         rbIsDirectory = (nattrib & FILE_ATTRIBUTE_DIRECTORY) ? 1 : 0;
         rbCanRead     = 1;
         rbCanWrite    = (nattrib & FILE_ATTRIBUTE_READONLY)  ? 0 : 1;
         // on old msvc, this may be 0xFFFF... for timestamps > 2038:
         rlFileSize    =  (((num)oinf.nFileSizeHigh) << 32)
                        | ((num)oinf.nFileSizeLow);
         rlFileTime    =  fileTimeToTimeT(&oinf.ftLastWriteTime);
         if (ppcatimes != 0) {
            ppcatimes[0] = fileTimeToTimeT(&oinf.ftCreationTime);
            ppcatimes[1] = fileTimeToTimeT(&oinf.ftLastAccessTime);
         }
         return 0;
      }
      // else fall through
   }
   #else
   ulong nattrib = GetFileAttributesA(pszName);
   rbIsDirectory = (nattrib & FILE_ATTRIBUTE_DIRECTORY) ? 1 : 0;
   rbCanRead     = 1;
   rbCanWrite    = (nattrib & FILE_ATTRIBUTE_READONLY)  ? 0 : 1;
   #endif

   // using MSC specific 64-bit filesize and time stamp infos
   #ifdef SFK_W64
   struct __stat64 buf;
   if (_stat64(pszName, &buf))
      return -1;
   #else
   struct stat buf;
   if (mystat(pszName, &buf))
      return -1;
   #endif

   rbIsDirectory = (buf.st_mode & _S_IFDIR ) ? 1 : 0;
   rbCanRead     = (buf.st_mode & _S_IREAD ) ? 1 : 0;
   rbCanWrite    = (buf.st_mode & _S_IWRITE) ? 1 : 0;
   // on old msvc, this may be 0xFFFF... for timestamps > 2038:
   rlFileTime    =  buf.st_mtime;
   rlFileSize    =  buf.st_size;
   if (ppcatimes != 0) {
      ppcatimes[0] = buf.st_ctime;
      ppcatimes[1] = buf.st_atime;
   }
   if (prawstat) {
      if (nrawstatmax < sizeof(buf))
         return 9+perr("internal #1090: statbuf too small\n");
      memcpy(prawstat, &buf, sizeof(buf));
   }
   return 0;

   #else

   // generic linux 64-bit stat
   struct stat64 buf;
   if (stat64(pszName, &buf))
      return -1;
   rbIsDirectory = (buf.st_mode & _S_IFDIR ) ? 1 : 0;
   rlFileTime    =  buf.st_mtime;
   rlFileSize    =  buf.st_size;
   rbCanRead     = (buf.st_mode & _S_IREAD ) ? 1 : 0;
   rbCanWrite    = (buf.st_mode & _S_IWRITE) ? 1 : 0;
   if (ppcatimes != 0) {
      ppcatimes[0] = buf.st_ctime;
      ppcatimes[1] = buf.st_atime;
   }
   if (prawstat) {
      if (nrawstatmax < sizeof(buf))
         return 9+perr("internal #1090: statbuf too small\n");
      memcpy(prawstat, &buf, sizeof(buf));
   }
   return 0;

   #endif
}

num getFileSize(char *pszName) 
{
   long bIsDir    = 0;
   long bCanRead  = 1;
   long bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize))
      return -1;
   return nFileSize;
}

num getFileSizeSeek(char *pszName)
{
   FILE *fin = fopen(pszName, "rb");
   if (!fin) return -1;

   if (fseek(fin, 0, SEEK_END))
      { fclose(fin); return -1; }

   num npos = (num)ftell(fin);

   fclose(fin);

   return npos;
}

num getFileTime(char *pszName)
{
   long bIsDir    = 0;
   long bCanRead  = 1;
   long bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize))
      return 0;
   return nFileTime;
}

// get file age in seconds
num getFileAge(char *pszName)
{
   num nFileTime = getFileTime(pszName);
   // printf("filetime: %s\n",numtoa(nFileTime));
   num nNow = getSystemTime();
   // printf("now is  : %s\n",numtoa(nNow));
   num nAge = nNow - nFileTime;
   return nAge;
}

bool canWriteFile(char *pszName, bool bTryCreate)
{
   long bIsDir    = 0;
   long bCanRead  = 0;
   long bCanWrite = 0;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (!getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize)) {
      return bCanWrite ? 1 : 0;
   }
   if (bTryCreate) {
      // file does not exist yet: try creation
      FILE *fout = fopen(pszName, "wb");
      if (!fout) return 0;
      fclose(fout);
      remove(pszName);
      return 1;
   }
   return 1;
}

// uses szLineBuf.
long getFileSystemInfoRaw(
   char  *pszPath,         // e.g. "D:\\", "/home/user/"
   num   &nOutTotalBytes,  // total volume size
   num   &nOutFreeBytes,   // free bytes usable for normal users
   char  *pszOutFSName,    // file system name buffer
   long  nOutFSNMaxSize,   // size of this buffer
   char  *pszOutVolID,     // volume name and serial, if any
   long  nOutVolIDMaxSize  // size of this buffer
   )
{
   nOutTotalBytes  = -1;
   nOutFreeBytes   = -1;
   pszOutFSName[0] = '\0';
   pszOutVolID[0]  = '\0';

   #ifdef _WIN32

   #ifdef WINFULL
   char  szVolName[200];
   DWORD nVolSerNum = 0;
   DWORD nMaxFNLen  = 0;
   DWORD nFSFlags   = 0;

   if (!GetVolumeInformation(
      pszPath,
      szVolName, sizeof(szVolName)-10,
      &nVolSerNum, &nMaxFNLen, &nFSFlags,
      pszOutFSName, nOutFSNMaxSize
      ))
      return 9+perr("unable to get volume information for %s\n", pszPath);

   szVolName[sizeof(szVolName)-10] = '\0';
   sprintf(szLineBuf, "%08lX %s", nVolSerNum, szVolName);
   mystrcopy(pszOutVolID, szLineBuf, nOutVolIDMaxSize);

   ULARGE_INTEGER nFreeCaller;
   ULARGE_INTEGER nTotalBytes;
   ULARGE_INTEGER nFreeTotal;
   if (!GetDiskFreeSpaceEx(
      pszPath,
      &nFreeCaller, &nTotalBytes, &nFreeTotal
      ))
      return 9+perr("unable to get free space of %s\n", pszPath);

   nOutTotalBytes = nTotalBytes.QuadPart;
   nOutFreeBytes  = nFreeCaller.QuadPart;
   #endif

   return 0;

   #else

   // #include <sys/statvfs.h>
   struct statvfs64 oinf;
   if (statvfs64(pszPath, &oinf))
      return 9+perr("unable to get free space of %s\n", pszPath);

   // unsigned long f_bsize   - preferred filesystem blocksize. 
   // unsigned long f_frsize  - fundamental filesystem blocksize (if supported) 
   // fsblkcnt_t f_blocks     - total number of blocks on the filesystem, in units of f_frsize. 
   // fsblkcnt_t f_bfree      - total number of free blocks. 
   // fsblkcnt_t f_bavail     - number of free blocks available to a nonsuperuser. 
   // fsfilcnt_t f_files      - total number of file nodes (inodes). 
   // fsfilcnt_t f_ffree      - total number of free file nodes. 
   // fsfilcnt_t f_favail     - number of inodes available to a nonsuperuser. 
   // unsigned long f_fsid    - filesystem ID (dev for now). 
   // char f_basetype[16]     - type of the target filesystem, as a null-terminated string. 
   // unsigned long f_flag    - bitmask of flags; the function can set these flags: 
   //    ST_RDONLY -- read-only filesystem. 
   //    ST_NOSUID -- the filesystem doesn't support setuid/setgid semantics. 
   // unsigned long f_namemax - maximum filename length.

   // not with linux:
   // mystrcopy(pszOutFSName, oinf.f_basetype, nOutFSNMaxSize);
   pszOutFSName[0] = '\0';

   num nTotalBytes = (num)oinf.f_blocks * (num)oinf.f_frsize;
   num nFreeBytes  = (num)oinf.f_bavail * (num)oinf.f_frsize;

   nOutTotalBytes = nTotalBytes;
   nOutFreeBytes  = nFreeBytes;

   return 0;

   #endif
}

long getFileSystemInfo(
   char  *pszPath,         // e.g. "D:\\", "/home/user/"
   num   &nOutTotalBytes,  // total volume size
   num   &nOutFreeBytes,   // free bytes usable for normal users
   char  *pszOutFSName,    // file system name buffer
   long  nOutFSNMaxSize,   // size of this buffer
   char  *pszOutVolID,     // volume name and serial, if any
   long  nOutVolIDMaxSize  // size of this buffer
   )
{
   char szPath[SFK_MAX_PATH+10];
   strcopy(szPath, (char*)pszPath);

   #ifdef _WIN32

   // need a root dir path like "C:"
   if (szPath[1] == ':') {
      // there is a C:, or D:, etc.
      szPath[2] = '\\';
      szPath[3] = '\0';
   } else {
      // a relative path: check for invalids
      if (!strncmp(szPath, "\\\\", 2))
         return -1;
      if (!strncmp(szPath, "//", 2))
         return -1;
      // find out our drive
      _getcwd(szPath,SFK_MAX_PATH);
      if (szPath[1] != ':')
         return -1;
      // we're on C:, or D:, etc.
      szPath[2] = '\\';
      szPath[3] = '\0';
   }

   #else

   // reduce /media/small/dummydir/whatever.txt
   // to the first existing directory
   while (1)
   {
      struct stat oinf;
      if (!stat(szPath, &oinf))
         break; // exists

      char *psz = strrchr(szPath, '/');
      if (!psz)
         return -1; // failed to reduce

      *psz = '\0';
      // and retry on next higher level
   }

   #endif

   return getFileSystemInfoRaw(szPath,
      nOutTotalBytes,
      nOutFreeBytes, 
      pszOutFSName,  
      nOutFSNMaxSize,
      pszOutVolID,   
      nOutVolIDMaxSize
      );
}

char *timeAsString(num nTime, bool bFlat=0)
{
   static char szTimeStrBuf[200];

   // nTime may be 0xFFFF... in case of times > 2038.

   struct tm *pLocTime = 0;
   mytime_t nTime2 = (mytime_t)nTime;

   #ifdef SFK_W64
   pLocTime = _localtime64(&nTime2);   // may be NULL
   #else
   pLocTime = localtime(&nTime2);      // may be NULL
   #endif

   // size_t strftime( char *strDest, size_t maxsize, const char *format, const struct tm *timeptr );
   szTimeStrBuf[0] = '\0';
   if (pLocTime) {
      if (bFlat)
         strftime(szTimeStrBuf, sizeof(szTimeStrBuf)-10, "%Y%m%d%H%M%S", pLocTime);
      else
         strftime(szTimeStrBuf, sizeof(szTimeStrBuf)-10, "%Y-%m-%d %H:%M:%S", pLocTime);
   } else {
      if (bFlat)
         strcpy(szTimeStrBuf, "99991231235959");
      else
         strcpy(szTimeStrBuf, "9999-12-31 23:59:59");
   }

   return szTimeStrBuf;
}

static const char *pszGlblMonths[] = {
   "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
};

bool tryGetRelTime(char *psz, num &nRetTime)
{
   bool brc = false;

   // get local time (zone)
   time_t now = time(NULL);
   struct tm *tm = 0;
   tm = localtime(&now);
   tm->tm_isdst = -1;

   long nlen = strlen(psz);

   if (!strcmp(psz, "now")) {
      brc = true;
   }
   else
   if (!strcmp(psz, "today")) {
      tm->tm_hour = 0;
      tm->tm_min  = 0;
      tm->tm_sec  = 0;
      brc = true;
   }
   else
   if (!strcmp(psz, "tomonth")) {
      tm->tm_hour = 0;
      tm->tm_min  = 0;
      tm->tm_sec  = 0;
      tm->tm_wday = 0;  // 0..6
      tm->tm_mday = 1;  // 1..31
      brc = true;
   }
   else
   if (!strcmp(psz, "toyear")) {
      tm->tm_hour = 0;
      tm->tm_min  = 0;
      tm->tm_sec  = 0;
      tm->tm_wday = 0;  // 0..6
      tm->tm_mday = 1;  // 1..31
      tm->tm_yday = 0;  // 0..365
      tm->tm_mon  = 0;  // 0..11
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 'd') {
      time_t pre = now - atol(psz) * 3600 * 24;
      tm = localtime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 'h') {
      time_t pre = now - atol(psz) * 3600;
      tm = localtime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 'm') {
      time_t pre = now - atol(psz) * 60;
      tm = localtime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 's') {
      time_t pre = now - atol(psz);
      tm = localtime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }

   time_t nTime = mktime(tm);
   if (!nTime) { perr("cannot calc time: %s\n", psz); return 0; }
   num nTime2 = (num)nTime;
   if (nTime2 <= 0) { perr("cannot calc time: %s\n", psz); return 0; }

   if (cs.verbose > 0) {
      char *psz1 = timeAsString(nTime2);
      // printf("TIME %s => %s\n", psz, psz1);
   }

   nRetTime = nTime2;
   return brc;
}

long timeFromString(char *pszin, num &nRetTime)
{
   char *psz = pszin;

   // get local time (zone)
   time_t now = time(NULL);
   struct tm *tm = 0;
   tm = localtime(&now);
   tm->tm_isdst = -1;

   // accept formats:
   // 12345678901234567890123456789012345678901234567890
   // 01 Jan 2008 01:01:25 +0200 GMT - 30 chars
   // 01 Jan 2008 01:01:25 +0100 - 26 chars
   // 01 Jan 2008 01:01:25 GMT   - 24 chars
   // 2006-11-21 12:49:36  - 19 chars
   // 2006-11-21           - 10 chars
   // 20061121124936       - 14 chars
   // 20061121             - 08 chars
   // Sep 28 2006          - 11 chars
   // Sep 28 14:37         - 12 chars
   ulong nyear=0,nmon=0,nday=0,nhour=0,nmin=0,nsec=0;
   long nslen = strlen(psz);
   long lrc = 0;
   if (nslen == 24 || nslen == 26 || nslen == 30) {
      // TODO: so far, "GMT" or "+0100" postfixes are ignored.
      nday = atol(psz);
      psz += 3;
      char *pszMon = psz;
      for (nmon=0; nmon<12; nmon++)
         if (!strncmp(pszMon, pszGlblMonths[nmon], 3))
            break;
      if (nmon >= 12) return 9+perr("wrong date/time format.0: %s\n", psz);
      psz += 4;
      lrc = sscanf(psz, "%4lu %2lu:%2lu:%2lu", &nyear, &nhour, &nmin, &nsec);
      if (lrc != 4) return 9+perr("wrong date/time format.0: %s\n", psz);
      nmon++; // ONE based months
   }
   else
   if (nslen == 19) {
      lrc = sscanf(psz, "%4lu-%2lu-%2lu %2lu:%2lu:%2lu", &nyear, &nmon, &nday, &nhour, &nmin, &nsec);
      if (lrc != 6) return 9+perr("wrong date/time format.1: %s\n", psz);
   }
   else
   if (nslen == 14) {
      lrc = sscanf(psz, "%4lu%2lu%2lu%2lu%2lu%2lu", &nyear, &nmon, &nday, &nhour, &nmin, &nsec);
      if (lrc != 6) return 9+perr("wrong date/time format.2: %s\n", psz);
   }
   else
   if (nslen == 12) {
      char *pszMon = psz;
      for (nmon=0; nmon<12; nmon++)
         if (!strncmp(pszMon, pszGlblMonths[nmon], 3))
            break;
      if (nmon >= 12) return 9+perr("wrong date/time format.3: %s\n", psz);
      psz += 4;
      lrc = sscanf(psz, "%2lu %2lu:%2lu", &nday, &nhour, &nmin);
      if (lrc == 3) {
         // copy year from current time:
         nyear = tm->tm_year;
         if (nyear < 1970)
            nyear = nyear - 100 + 2000;   // "108" -> "2008"
      } else {
         // retry on "29  2007" with TWO blanks:
         lrc = sscanf(psz, "%2lu  %4lu", &nday, &nyear);
         if (lrc != 2) return 9+perr("wrong date/time format.4: %s\n", psz);
      }
      nmon++; // ONE based months
   }
   else
   if (nslen == 11) {
      char *pszMon = psz;
      for (nmon=0; nmon<12; nmon++)
         if (!strncmp(pszMon, pszGlblMonths[nmon], 3))
            break;
      if (nmon >= 12) return 9+perr("wrong date/time format.5: %s\n", psz);
      psz += 4;
      lrc = sscanf(psz, "%2lu %4lu", &nday, &nyear);
      if (lrc != 2) return 9+perr("wrong date/time format.6: %s\n", psz);
      nmon++; // ONE based months
   }
   else
   if (nslen == 10) {
      lrc = sscanf(psz, "%4lu-%2lu-%2lu", &nyear, &nmon, &nday);
      if (lrc != 3) return 9+perr("wrong date format.7: %s\n", psz);
   }
   else
   if (nslen == 8) {
      lrc = sscanf(psz, "%4lu%2lu%2lu", &nyear, &nmon, &nday);
      if (lrc != 3) return 9+perr("wrong date format.8: %s\n", psz);
   }
   else
      return 9+perr("wrong date and/or time format.9: \"%s\"\n", psz);

   if (nyear < 1970) return 9+perr("unexpected year: %lu\n", nyear);
   if (nmon < 1 || nmon > 12) return 9+perr("unexpected month: %lu in \"%s\" %ld\n", nmon, pszin, nslen);
   if (nday < 1 || nday > 31) return 9+perr("unexpected day: %lu\n", nday);
   if (nhour > 23) return 9+perr("unexpected hour: %lu\n", nhour);
   if (nmin  > 59) return 9+perr("unexpected minute: %lu\n", nmin);
   if (nsec  > 59) return 9+perr("unexpected second: %lu\n", nsec);

   // adjust values
   nyear -= 1900;
   nmon--; // mktime uses ZERO BASED months

   // printf("] %lu-%lu-%lu %lu:%lu:%lu\n",nyear,nmon,nday,nhour,nmin,nsec);

   tm->tm_year = nyear;
   tm->tm_mon  = nmon;
   tm->tm_mday = nday;
   tm->tm_hour = nhour;
   tm->tm_min  = nmin;
   tm->tm_sec  = nsec;

   bool bNearEpoch = 0;
   if (nyear == 70 && nmon == 0 && nday == 1)
        bNearEpoch = 1;

   time_t nTime = mktime(tm);
   num nTime2 = (num)nTime;
   if (     nTime2 < 0
       || (!bNearEpoch && (nTime2 == 0))
      )
      return 9+perr("invalid date/time: %s (%d %d %d)\n", psz, nyear, nmon, nday);

   // char *psz1 = timeAsString(nTime2);
   // printf("] %s\n", psz1);

   nRetTime = nTime2;
   return 0;
}

char getYNAchar()
{
   while (1) {
      int c1 = getchar();
      if (c1=='\r' || c1=='\n')
         continue;
      return c1;
   }
}

// sizefromstr
num numFromSizeStr(char *psz, char *pszLoudInfo=0)
{
   long nLen = strlen(psz);
   if (nLen >= 1) {
      num lNum = myatonum(psz);
      char cPostFix = psz[nLen-1];
      switch (cPostFix) {
         case 'b': return lNum;
         case 'k': return lNum * 1000;
         case 'K': return lNum * 1024;
         case 'm': return lNum * 1000000;
         case 'M': return lNum * 1048576;
         case 'g': return lNum * 1000000000;
         case 'G': return lNum * 1073741824;
         default :
            if (cPostFix >= '0' && cPostFix <= '9')
               return lNum; // no postfix at all: assume bytes
      }
   }
   if (pszLoudInfo) {
      perr("unexpected %s value: %s", pszLoudInfo, psz);
      pinf("supply a value like 1000 500k 100m 5M [k=kbyte,m=mbyte]\n");
   }
   return -1;
}

class FileStat {
public:
   FileStat       ( );
   long  readFrom (char *pszSrcFile, bool bWithFSInfo=0, bool bSilent=0);
   long  writeTo  (char *pszDstFile, int nTraceLine);
   long  differs  (FileStat &oref, bool bSameIfOlderSrc, bool *pSrcIsOlder=0);
   long  dump     ( );
   long  dumpTimeDiff (FileStat &rdst);
   num   getSize  ( )   { return src.nSize; }
   uchar *marshal (long &nRetSize);
   long  setFrom  (uchar *pBuf, long nBufSize);
   char  *attrStr ( );
   const char *diffReason  (long nReason);

   num   getUnixTime ( ) { return src.nMTime; }
   num   getWinTime  ( );

public:
   long  dumpSub  (num nTime, char *pszInfo, long nRow);
   void  reset    ( );

   struct FileStatSrcInfo 
   {
      long  bIsDir;
      long  bIsReadable;
      long  bIsWriteable;
   
      // time of MODIFICATION or LAST WRITE is ALWAYS available.
      num   nMTime;
   
      // time of CREATION and LAST ACCESS is only available on
      // SOME file systems, e.g. NTFS. on FAT32, ATime is 0,
      // and CTime == MTime.
      num   nCTime;
      num   nATime;
   
      #ifdef _WIN32
      FILETIME ftMTime;
      FILETIME ftCTime;
      FILETIME ftATime;
      bool  nHaveWFT;   // 1 = have at least windows mod file time
      #endif            // 2 = also have windows C and A time
   
      num   nSize;
      long  bIsUTCTime;
      ulong nAttribs;
   }
   src;

   char  szClSrcPath[500];
   char  szClSrcFSName[200];
   char  szClSrcVolID[200];
   char  szClTextBuf1[200];
   char  szClTextBuf2[200];
   char  szClAttrStr[50];
   char  szClDiffReason[100];
};

FileStat::FileStat() {
   reset();
}

num FileStat::getWinTime() {
   num nval = 0;
   #ifdef _WIN32
   if (sizeof(nval) == sizeof(src.ftMTime))
      memcpy(&nval, &src.ftMTime, sizeof(nval));
   #endif
   return nval;
}

char *FileStat::attrStr() {
   memset(szClAttrStr, 0, sizeof(szClAttrStr));
   //                   01234
   strcpy(szClAttrStr, "---- ");
   if (src.bIsReadable)  szClAttrStr[0] = 'a';
   if (src.bIsWriteable) szClAttrStr[1] = 'w';
   #ifdef _WIN32
   // if (src.nAttribs & FILE_ATTRIBUTE_READONLY)   szClAttrStr[0] = 'R';
   if (src.nAttribs & FILE_ATTRIBUTE_HIDDEN)     szClAttrStr[2] = 'h';
   if (src.nAttribs & FILE_ATTRIBUTE_SYSTEM)     szClAttrStr[3] = 's';
   // if (src.nAttribs & FILE_ATTRIBUTE_ARCHIVE)    szClAttrStr[4] = 'a';
   if (src.nAttribs) szClAttrStr[4] = '-';
   #endif
   return szClAttrStr;
}

uchar *FileStat::marshal(long &nRetSize) {
   nRetSize = sizeof(src);
   return (uchar*)&src;
}

long FileStat::setFrom(uchar *pBuf, long nBufSize) {
   if (nBufSize != sizeof(src))
      return 9+perr("internal 612112005\n");
   memcpy(&src, pBuf, sizeof(src));
   return 0;
}

long FileStat::dump() 
{
   dumpSub(src.nMTime, " mtime, ", 0);
   dumpSub(src.nATime, " atime, ", 1);
   #ifdef _WIN32
   dumpSub(src.nCTime, " ctime, ", 2);
   #endif
   return 0;
}

long FileStat::dumpTimeDiff(FileStat &rdst)
{
   num nsec = src.nMTime - rdst.src.nMTime;
   printf("diff: mtime %s sec ",numtoa(nsec));
   num nhours = nsec / 3600;
   printf("(= %s hours)",numtoa(nhours));

   #ifdef _WIN32
   num nSrcWFT = 0;
   num nDstWFT = 0;
   if (sizeof(nSrcWFT) == sizeof(src.ftMTime)) {
      memcpy(&nSrcWFT, &src.ftMTime, sizeof(nSrcWFT));
      memcpy(&nDstWFT, &rdst.src.ftMTime, sizeof(nDstWFT));
      num nxnano = nSrcWFT - nDstWFT;
      num nmsec  = nxnano / 10;
      num nwsec  = nmsec / 1000000;
      num nwhours = nwsec / 3600;
      printf(", wft mtime %s usec*10 ", numtoa(nxnano));
      printf(" (= %s sec, ", numtoa(nwsec));
      printf("or %s hours)",numtoa(nwhours));
   }
   #endif

   printf("\n");

   nsec = src.nCTime - rdst.src.nCTime;
   printf("      ctime %s sec ",numtoa(nsec));
   nhours = nsec / 3600;
   printf("(= %s hours)",numtoa(nhours));

   #ifdef _WIN32
   if (sizeof(nSrcWFT) == sizeof(src.ftCTime)) {
      memcpy(&nSrcWFT, &src.ftCTime, sizeof(nSrcWFT));
      memcpy(&nDstWFT, &rdst.src.ftCTime, sizeof(nDstWFT));
      num nxnano = nSrcWFT - nDstWFT;
      num nmsec  = nxnano / 10;
      num nwsec  = nmsec / 1000000;
      num nwhours = nwsec / 3600;
      printf(", wft ctime %s usec*10 ", numtoa(nxnano));
      printf(" (= %s sec, ", numtoa(nwsec));
      printf("or %s hours)",numtoa(nwhours));
   }
   #endif

   printf("\n");

   return 0;
}

long FileStat::dumpSub(num nTime, char *pszInfo, long nRow)
{
   szClTextBuf1[0] = '\0';
   strcat(szClTextBuf1, numtoa(nTime));   strcat(szClTextBuf1, pszInfo);

   num nModHourSec = nTime % (24 * 3600);
   num nModHours   = nModHourSec / 3600;
   char *pszModHr  = numtoa(nModHours);
   if (strlen(pszModHr) < 2)
      strcat(szClTextBuf1, " ");
   strcat(szClTextBuf1, pszModHr);
   strcat(szClTextBuf1, " mh, ");

   mytime_t tTime = (mytime_t)nTime;

   #ifdef SFK_W64
   struct tm *pltime = _localtime64(&tTime);
   #else
   struct tm *pltime = localtime(&tTime);
   #endif
   if (pltime) {
      strftime(szClTextBuf2, sizeof(szClTextBuf2)-10, "%Y-%m-%d %H:%M:%S loc", pltime);
      strcat(szClTextBuf1, szClTextBuf2);
   }

   #ifdef SFK_W64
   struct tm *pgtime = _gmtime64(&tTime);
   #else
   struct tm *pgtime = gmtime(&tTime);
   #endif
   if (pgtime) {
      strftime(szClTextBuf2, sizeof(szClTextBuf2)-10, ", %H:%M:%S utc", pgtime);
      strcat(szClTextBuf1, szClTextBuf2);
   }

   #ifdef _WIN32
   num nWinFileTime = 0;
   bool bCopyDone = 0;
   switch (nRow) {
      case 0:
         if (sizeof(nWinFileTime) == sizeof(src.ftMTime)) {
            memcpy(&nWinFileTime, &src.ftMTime, sizeof(nWinFileTime));
            bCopyDone = 1;
         }
         break;
      case 1:
         if (sizeof(nWinFileTime) == sizeof(src.ftATime)) {
            memcpy(&nWinFileTime, &src.ftATime, sizeof(nWinFileTime));
            bCopyDone = 1;
         }
         break;
      case 2:
         if (sizeof(nWinFileTime) == sizeof(src.ftCTime)) {
            memcpy(&nWinFileTime, &src.ftCTime, sizeof(nWinFileTime));
            bCopyDone = 1;
         }
         break;
   }
   if (bCopyDone) {
      strcat(szClTextBuf1, ", ");
      strcat(szClTextBuf1, numtoa(nWinFileTime));
      strcat(szClTextBuf1, " wft [");
      num ntimet = fileTimeToTimeT(nWinFileTime);
      strcat(szClTextBuf1, numtoa(ntimet));
      strcat(szClTextBuf1, ",");
      nModHourSec = ntimet % (24 * 3600);
      nModHours   = nModHourSec / 3600;
      strcat(szClTextBuf1, numtoa(nModHours));
      strcat(szClTextBuf1, "]");
   }
   #endif

   printf("%s\n", szClTextBuf1);
   return 0;
}

void FileStat::reset() {
   memset(&src, 0, sizeof(src));
   memset(szClSrcPath  , 0, sizeof(szClSrcPath  ));
   memset(szClSrcFSName, 0, sizeof(szClSrcFSName));
   memset(szClSrcVolID , 0, sizeof(szClSrcVolID ));
   memset(szClTextBuf1, 0, sizeof(szClTextBuf1));
   memset(szClTextBuf2, 0, sizeof(szClTextBuf2));
   memset(szClAttrStr, 0, sizeof(szClAttrStr));
   memset(szClDiffReason, 0, sizeof(szClDiffReason));
}

const char *FileStat::diffReason(long nReason)
{
   if (szClDiffReason[0])
      return szClDiffReason;

   switch (nReason) {
      case  0: return "none";
      case  8: return "newer, wft";
      case  7: return "time, wft";
      case  9: return "newer, uft";
      case 10: return "time, uft";
      case  1: return "size";
      case  3: return "isreadable";
      case  4: return "iswriteable";
      case  5: return "attributes";
   }
   return "unknown";
}

bool is3600Range(num n) {
   if (n >= 3598 && n <= 3602)
      return true;
   return false;
}

long FileStat::differs(FileStat &oref, bool bSameIfOlderSrc, bool *pSrcIsOlder)
{
   long nTimeState = 0; // 0: time is no reason to process

   szClDiffReason[0] = '\0';

   #ifdef _WIN32
   if (src.nHaveWFT && oref.src.nHaveWFT) 
   {
      // compare windows filetime, to be safer on DST switches and time zones.
      // NOTE: files from FAT filesystems will also produce a pseudo wft
      // (calculated implicitely by the OS) that will still jump on DST.

      num nSrcMTime = 0;
      num nRefMTime = 0;
      memcpy(&nSrcMTime, &src.ftMTime, sizeof(nSrcMTime));
      memcpy(&nRefMTime, &oref.src.ftMTime, sizeof(nRefMTime));

      num nSrcSec   = fileTimeToTimeT(nSrcMTime);
      num nNowSec   = getSystemTime();
      num nAgeSec   = nNowSec - nSrcSec;
      long nAgeDays = (long)(nAgeSec / (24 * 3600));

      num ndif = (nSrcMTime - nRefMTime) / 10000000; // in seconds
      if (abs((long)ndif) < 3)
         nTimeState = 0; // time is no reason
      else
      if (bGlblIgnore3600 && is3600Range(abs((long)ndif)) && (nAgeDays > nGlblActiveFileAgeLimit))
      {
         nTimeState = 0; // dst jump difference
      }
      else
      if (bSameIfOlderSrc) {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %ld [1]\n", ndif);
         if (ndif > 0) {
            sprintf(szClDiffReason, "newer, wft by %s sec", numtoa(ndif));
            nTimeState = 8; // src is newer, must process
         }
         if ((ndif < 0) && pSrcIsOlder) {
            if (is3600Range(abs((long)ndif)))
               *pSrcIsOlder = 2; // notice: probably older due to dst jump
            else
               *pSrcIsOlder = 1; // notice
         }
      } else {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %ld [2]\n", ndif);
         if (nRefMTime != nSrcMTime) {
            sprintf(szClDiffReason, "time, wft by %s sec", numtoa(ndif));
            nTimeState = 7; // any time diff, must process
         }
         if ((ndif < 0) && pSrcIsOlder)
            *pSrcIsOlder = 1; // just a notice
      }
      // else fall through, time check passed
   }
   else
   #endif
   if (src.nMTime != oref.src.nMTime) 
   {
      // a time difference: ignore below a threshold
      //   NTFS : 100 nanoseconds resolution
      //   Linux:   1 second resolution
      //   FAT32:   2 seconds resolution
      // therefore all differences below 3 seconds are ignored.

      num nSrcSec   = src.nMTime;
      num nNowSec   = getSystemTime();
      num nAgeSec   = nNowSec - nSrcSec;
      long nAgeDays = (long)(nAgeSec / (24 * 3600));

      num ndif = src.nMTime - oref.src.nMTime;
      if (abs((long)ndif) < 3)
         nTimeState = 0; // time is no reason
      else
      if (bGlblIgnore3600 && is3600Range(abs((long)ndif)) && (nAgeDays > nGlblActiveFileAgeLimit))
      {
         nTimeState = 0; // dst jump difference
      }
      else
      if (bSameIfOlderSrc) {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %ld [3]\n", ndif);
         if (ndif > 0) {
            sprintf(szClDiffReason, "newer, uft by %s sec", numtoa(ndif));
            nTimeState = 9; // src is newer, must process
         }
         if ((ndif < 0) && pSrcIsOlder) {
            if (is3600Range(abs((long)ndif)))
               *pSrcIsOlder = 2; // notice: probably older due to dst jump
            else
               *pSrcIsOlder = 1; // notice
         }
      }
      else {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %ld [4]\n", ndif);
         sprintf(szClDiffReason, "time, uft by %s sec", numtoa(ndif));
         nTimeState = 10; // any time diff, must process
         if ((ndif < 0) && pSrcIsOlder)
            *pSrcIsOlder = 1; // just a notice
      }
   }

   // with "sameifolder", processing is based only on timestamp.
   if (bSameIfOlderSrc) 
   {
      // if time is equal, don't process , no matter if size etc. differs!
      // if src  is older, don't process , no matter if size etc. differs!
      // if src  is newer, always process, no matter if size etc. is equal!
      return nTimeState;
   }

   // else process on size or attribute difference.
   if (src.nSize != oref.src.nSize) return 1;

   if (src.bIsReadable  != oref.src.bIsReadable ) return 3;
   if (src.bIsWriteable != oref.src.bIsWriteable) return 4;

   #ifdef _WIN32
   if (   (src.nAttribs      & WINFILE_ATTRIB_MASK)
       != (oref.src.nAttribs & WINFILE_ATTRIB_MASK)
      )
   {
      if (cs.verbose > 1)
         printf("[win_attributes differ, %lx %lx]\n",src.nAttribs,oref.src.nAttribs);
      return 5;
   } else {
      if (cs.verbose > 2)
         printf("[win_attributes match, %lx %lx]\n",src.nAttribs,oref.src.nAttribs);
   }
   #endif

   return nTimeState;
}

long FileStat::readFrom(char *pszSrcFile, bool bWithFSInfo, bool bSilent) 
{
   reset();

   if (cs.debug)
      printf("filestat.1: \"%s\"\n",pszSrcFile);

   #ifdef _MSC_VER
      #ifdef SFK_W64
      struct __stat64 ostat;
      #else
      struct stat ostat;
      #endif
   #else
      struct stat64 ostat;
   #endif

   num aExtTimes[2];
   mclear(aExtTimes);
   if (getFileStat(pszSrcFile, src.bIsDir, src.bIsReadable, src.bIsWriteable, src.nMTime, src.nSize, aExtTimes, &ostat, sizeof(ostat)))
      return 10;
   src.nCTime = aExtTimes[0];
   src.nATime = aExtTimes[1];

   num   nTotalBytes = 0;
   num   nFreeBytes  = 0;

   if (bWithFSInfo)
   {
      // must extract path from pszSrcFile. if there is none, use ".".
      mystrcopy(szClSrcPath, pszSrcFile, sizeof(szClSrcPath)-10);
   
      // turn the/dir into the/dir/
      if (src.bIsDir && strlen(szClSrcPath)>0)
         if (szClSrcPath[strlen(szClSrcPath)-1] != glblPathChar)
            strcat(szClSrcPath,glblPathStr);
   
      #ifdef _WIN32
      // windows only: if path starts with c: ...
      if (strlen(szClSrcPath) >= 2 && szClSrcPath[1] == ':') {
         // then reduce c:\whatever to c:\, extend c: to c:/
         szClSrcPath[2] = glblPathChar;
         szClSrcPath[3] = '\0';
      }
      else
      if (!strncmp(szClSrcPath, "\\\\", 2)) {
         // network path
      }
      else {
         // relative path: reduce to "\\", should be same volume.
         // will probably NOT work with LINKS.
         strcpy(szClSrcPath, "\\");
      }
      #endif
   
      // try for x:\thefile, \thefile, the\path\file
      char *psz1 = strrchr(szClSrcPath, glblPathChar);
      if (psz1 && (psz1 > szClSrcPath)) {
         psz1++;
         *psz1 = '\0';
      } else {
         #ifdef _WIN32
         // try for x:thefile
         psz1 = strchr(szClSrcPath, ':');
         if (psz1 && (psz1 > szClSrcPath)) {
            // change x:thefile to x:/
            psz1++;
            *psz1++ = glblPathChar;
            *psz1   = '\0';
         }
         else
            strcpy(szClSrcPath, "\\");
         #else
         // TODO: use /, ./ or "." with linux?
         strcpy(szClSrcPath, ".");
         #endif
      }

      if (cs.debug)
         printf("filestat: \"%s\" => \"%s\"\n",pszSrcFile,szClSrcPath);

      if (getFileSystemInfo(szClSrcPath, nTotalBytes, nFreeBytes,
         szClSrcFSName, sizeof(szClSrcFSName)-10,
         szClSrcVolID , sizeof(szClSrcVolID)-10
         ))
         return 11;
   
      #ifdef _WIN32
      if (cs.debug)
         printf("\"%s\" => %s, %s\n",szClSrcPath, szClSrcFSName, szClSrcVolID);
      #endif
   
      src.bIsUTCTime = 0;
      if (!strcmp(szClSrcFSName, "NTFS"))
         src.bIsUTCTime = 1;
   }

   #ifdef _WIN32

   #ifdef WINFULL
   WIN32_FILE_ATTRIBUTE_DATA oinf;
   BOOL bok2 = GetFileAttributesEx(pszSrcFile, GetFileExInfoStandard, &oinf);
   if (!bok2) {
      src.nAttribs = 0;
      if (!bSilent)
         perr("cannot read attributes: %s (rc %lu)\n", pszSrcFile, GetLastError());
      return 12;
   }
   src.nAttribs = oinf.dwFileAttributes;
   // => see WINFILE_ATTRIB_MASK
   // ftCreationTime; ftLastAccessTime; ftLastWriteTime
   memcpy(&src.ftMTime, &oinf.ftLastWriteTime , sizeof(src.ftMTime));
   memcpy(&src.ftCTime, &oinf.ftCreationTime  , sizeof(src.ftCTime));
   memcpy(&src.ftATime, &oinf.ftLastAccessTime, sizeof(src.ftATime));
   src.nHaveWFT = 2;
   #else
   src.nAttribs = GetFileAttributes(pszSrcFile);
   #endif

   #else

   // src.bIsReadable, src.bIsWriteable
   src.nAttribs = (ulong)ostat.st_mode;

   #endif

   return 0;
}

num calcSumTime(num nRawTime, long nTimeDiff, char *pszInfo)
{
   // does RawTime point into a summertime section?
   time_t ntmod = (time_t)nRawTime;
   tm *ptmod = localtime(&ntmod);
   if (ptmod && ptmod->tm_isdst) {
      // YES: change by one hour
      nRawTime += (num)nTimeDiff; // seconds
      if (pszInfo)
         printf("%s time adapted, %02d.%02d., %ld\n",pszInfo,ptmod->tm_mday,ptmod->tm_mon+1,nTimeDiff);
   }
   if (ptmod && !ptmod->tm_isdst) {
      if (pszInfo)
         printf("%s time not adapted, %02d.%02d., %ld\n",pszInfo,ptmod->tm_mday,ptmod->tm_mon+1,nTimeDiff);
   }
   return nRawTime;
}

#ifdef _WIN32
long makeWinFileTime(num nsrctime, FILETIME &rdsttime, char *pszDstFile)
{
   time_t ftime = (time_t)nsrctime;
   struct tm *loctm;
   SYSTEMTIME st;
   FILETIME locft, modft;

   loctm = localtime(&ftime);
   if (loctm == NULL)
      return 9+perr("cannot convert time for: %s %lu\n",pszDstFile,(ulong)GetLastError());

   st.wYear         = (WORD)loctm->tm_year + 1900;
   st.wMonth        = (WORD)loctm->tm_mon + 1;
   st.wDayOfWeek    = (WORD)loctm->tm_wday;
   st.wDay          = (WORD)loctm->tm_mday;
   st.wHour         = (WORD)loctm->tm_hour;
   st.wMinute       = (WORD)loctm->tm_min;
   st.wSecond       = (WORD)loctm->tm_sec;
   st.wMilliseconds = 0;

   if (!SystemTimeToFileTime(&st, &locft) ||
      !LocalFileTimeToFileTime(&locft, &modft))
      return 9+perr("cannot convert file time: %s %lu\n",pszDstFile,(ulong)GetLastError());

   rdsttime = modft;

   return 0;
}
#endif

/*
   Factors influencing conversion:
      1. is src on UTC or non-UTC file system
      2. is src time dependent on DST, i.e. is it different
         depending on the fact that we currently have DST or not?
      3. is src's date stamp lying within a DST zone?
      4. all above for dst as well
*/

long FileStat::writeTo(char *pszDstFile, int nTraceLine)
{
   // totally experimental and incomplete,
   // esp. on NTFS <-> FAT file transfers.

   #ifdef _WIN32
   HANDLE hDst = CreateFile(
      pszDstFile,
      FILE_WRITE_ATTRIBUTES,
      0,    // share
      0,    // security
      OPEN_EXISTING,
      src.bIsDir ? FILE_FLAG_BACKUP_SEMANTICS : FILE_ATTRIBUTE_NORMAL,
      0     // template file
      );
   if (hDst == INVALID_HANDLE_VALUE) {
      ulong nerr = GetLastError();
      perr("cannot set attributes (rc=%lu): %s\n",nerr,pszDstFile);
      if (nerr == ERROR_ACCESS_DENIED)
        pinf("make sure you have full access rights. maybe you have to be administrator.\n");
      return 9;
   }

   long nrc = 0;

   // src.nMTime is a value in SECONDS since 1970.

   FILETIME nDstMTime, nDstCTime, nDstATime;

   // native windows file times are copied 1:1
   if (src.nHaveWFT) 
   {
      memcpy(&nDstMTime, &src.ftMTime, sizeof(nDstMTime));
      if (src.nHaveWFT > 1)
         memcpy(&nDstCTime, &src.ftCTime, sizeof(nDstCTime));
      if (src.nHaveWFT > 1)
         memcpy(&nDstATime, &src.ftATime, sizeof(nDstATime));
   }
   else 
   {
      if (!nrc && src.nMTime)
         if (makeWinFileTime(src.nMTime, nDstMTime, pszDstFile))
            nrc = 9;
   
      if (!nrc && src.nCTime)
         if (makeWinFileTime(src.nCTime, nDstCTime, pszDstFile))
            nrc = 9;
   
      if (!nrc && src.nATime)
         if (makeWinFileTime(src.nATime, nDstATime, pszDstFile))
            nrc = 9;
   }

   /*
      // TODO: this works only in SystemInWinterTime. On Windows,
      //       use converted GetFileTime() only.
      long nTimeDiff = 3600;
      num nDstMTime = calcSumTime(src.nMTime, nTimeDiff, 0);
      num nDstCTime = calcSumTime(src.nCTime, nTimeDiff, 0);
      num nDstATime = calcSumTime(src.nATime, nTimeDiff, 0);
   
      // convert times to "1601" format.
      FILETIME oftm, oftc, ofta;
      timetToFileTime(nDstMTime, &oftm);  // modification
      timetToFileTime(nDstCTime, &oftc);  // creation, optional
      timetToFileTime(nDstATime, &ofta);  // access  , optional
   */

   #ifdef WINFULL
   if (!nrc) {
      if (!SetFileTime(hDst, &nDstCTime, &nDstATime, &nDstMTime)) {
         perr("cannot set file time (rc=%lu): %s %s\n", (ulong)GetLastError(), pszDstFile, numtohex(src.nMTime));
         nrc = 9;
      }
   }
   #endif
   
   CloseHandle(hDst);

   // CreateFile() was done ONLY to set filetime.
   // the attributes require another API call:
   if (src.nAttribs == 0) {
      perr("no attributes to set for %s\n",pszDstFile);
      nrc = 9;
   }
   else
   if (!SetFileAttributes(pszDstFile, src.nAttribs)) {
      perr("failed to set attributes (rc=%lu): %s %s\n", (ulong)GetLastError(), pszDstFile, numtohex(src.nMTime));
      nrc = 9;
   }

   return nrc;

   #else

   // linux generic

   struct utimbuf otimes;
   if (src.nATime)
      otimes.actime = src.nATime;
   otimes.modtime = src.nMTime;
   int iRC = utime(pszDstFile, &otimes);
   if (iRC) return 9+perr("failed to set file times (rc=%d): %s\n",iRC,pszDstFile);

   mode_t nmode = (mode_t)src.nAttribs;
   if (nmode == 0) return 9+perr("no attributes to set for %s\n",pszDstFile);
   iRC = chmod(pszDstFile, nmode);
   if (iRC) return 9+perr("failed to set file attributes (rc=%d): %s\n",iRC,pszDstFile);

   return 0;

   #endif
}

long cloneAttributes(char *pszSrc, char *pszDst, int nTraceLine)
{
   FileStat ofs;
   if (ofs.readFrom(pszSrc)) return 9;
   if (ofs.writeTo(pszDst, nTraceLine)) return 9;
   return 0;
}

long getFileMD5(char *pszFile, SFKMD5 &md5, bool bSilent, bool bInfoCycle)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      if (!bSilent) perr("cannot read: %s\n", pszFile);
      return 9; 
   }
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      nGlblBytes += nRead;
      if (bInfoCycle)
         info.cycle();
   }
   fclose(fin);
   return 0;
}

long getFileMD5(char *pszFile, uchar *abOut16)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;
   SFKMD5 md5;
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      nGlblBytes += nRead;
   }
   fclose(fin);
   uchar *pmd5 = md5.digest();
   for (ulong k=0; k<16; k++)
      abOut16[k] = pmd5[k];
   return 0;
}

#ifdef _WIN32
// size of windows-specific read buffer must be
// a multiple of disk's sector size. the following
// should be sufficient for everything.
long   nGlblMD5NoCacheBufSize = 128000;
LPVOID pGlblMD5NoCacheBuf     = 0;
#endif

long getFileMD5NoCache(char *pszFile, uchar *abOut16, bool bSilent)
{
   #ifdef _WIN32
   long lRC = 0;

   long nBufSize = nGlblMD5NoCacheBufSize;

   // alloc read buffer on demand
   if (pGlblMD5NoCacheBuf == 0) {
      pGlblMD5NoCacheBuf = VirtualAlloc(0, nBufSize, MEM_COMMIT, PAGE_READWRITE);
      if (!pGlblMD5NoCacheBuf) return 11;
   }

   LPVOID pBuf = pGlblMD5NoCacheBuf;

   /*
   DWORD nBytesPerSector = 0;
   DWORD nDummy1, nDummy2, nDummy3;
   // try to get sector size
   if (GetDiskFreeSpace(szRootDir, &nDummy1, &nBytesPerSector, &nDummy2, &nDummy3)) {
      // adjust max. read size to multiples of sector size
      if (nBytesPerSector > 0) {
         long nBufSize2 = (long)(nBufSize / nBytesPerSector) * nBytesPerSector;
         printf("adjusted %ld => %ld by %ld\n",nBufSize,nBufSize2,nBytesPerSector);
         nBufSize = nBufSize;
      }
   } else {
      printf("GetDiskFreeSpace failed\n");
   }
   */

   HANDLE hDst = CreateFile(
      pszFile,
      FILE_READ_DATA,
      0,    // share
      0,    // security
      OPEN_EXISTING,
      FILE_FLAG_NO_BUFFERING,
      0     // template file
      );

   if (hDst == INVALID_HANDLE_VALUE) 
      return 9;

   SFKMD5 md5;
   DWORD nRead = 0;
   while (true) {
      nRead = 0;
      if (!ReadFile(hDst, pBuf, nBufSize, &nRead, 0))
         {  lRC = 10; break;   }
      if (nRead <= 0)
         break;
      // printf("%ld bytes,\n\"%.*s\"\n",nRead,(int)nRead,pBuf);
      md5.update((uchar*)pBuf,nRead);
      nGlblBytes += nRead;
      if (userInterrupt(bSilent))
         {  lRC = 8; break;   }
      info.cycle();
   }

   CloseHandle(hDst);

   if (lRC == 10 && GetLastError() == 87) {
      // ReadFile did not accept buffer size. try fallback:
      // pwarn("md5nocache: readfile failed, using fallback\n");
      return getFileMD5(pszFile, abOut16);
   }

   uchar *pdigest = md5.digest();
   memcpy(abOut16, pdigest, 16);

   return lRC;
   #else
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;
   SFKMD5 md5;
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      nGlblBytes += nRead;
      if (userInterrupt(bSilent)) {
         fclose(fin);
         return 8;
      }
      info.cycle();
   }
   fclose(fin);
   uchar *pmd5 = md5.digest();
   for (ulong k=0; k<16; k++)
      abOut16[k] = pmd5[k];
   return 0;
   #endif
}

void ab8ToNum(uchar *pin, num &rn1) {
    num n1 =  (num)(*(pin+0)) & 0xFFUL;
    n1 = (n1 << 8) | ((num)(*(pin+1)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+2)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+3)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+4)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+5)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+6)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+7)) & 0xFFUL);
    rn1 = n1;
}

ulong ab4toulong(uchar *pin) {
    ulong n1 = (ulong)(*(pin+0)) & 0xFFUL;
    n1 = (n1 << 8) | ((ulong)(*(pin+1)) & 0xFFUL);
    n1 = (n1 << 8) | ((ulong)(*(pin+2)) & 0xFFUL);
    n1 = (n1 << 8) | ((ulong)(*(pin+3)) & 0xFFUL);
    return n1;
}

void ab16ToNum(uchar *pin, num &rn1, num &rn2) {
    ab8ToNum(pin+0, rn1);
    ab8ToNum(pin+8, rn2);
}

void numToAb8(num n1, uchar *pout) {
   pout[7]  = (uchar)n1;
   n1 = (n1 >> 8); pout[6] = (uchar)n1;
   n1 = (n1 >> 8); pout[5] = (uchar)n1;
   n1 = (n1 >> 8); pout[4] = (uchar)n1;
   n1 = (n1 >> 8); pout[3] = (uchar)n1;
   n1 = (n1 >> 8); pout[2] = (uchar)n1;
   n1 = (n1 >> 8); pout[1] = (uchar)n1;
   n1 = (n1 >> 8); pout[0] = (uchar)n1;
}

void ulongtoab4(ulong n1, uchar *pout) {
   pout[3]  = (uchar)n1;
   n1 = (n1 >> 8); pout[2] = (uchar)n1;
   n1 = (n1 >> 8); pout[1] = (uchar)n1;
   n1 = (n1 >> 8); pout[0] = (uchar)n1;
}

void numToAb16(num n1, num n2, uchar *pout) {
   numToAb8(n1, pout+0);
   numToAb8(n2, pout+8);
}

#ifndef USE_SFK_BASE

class FileMetaDB
{
public:
   FileMetaDB  ( );

   bool  canRead     ( ) { return nClMode == 1; }
   bool  canUpdate   ( ) { return nClMode == 2; }

   long  openUpdate  (char *pszFilename);
   long  openRead    (char *pszBaseName, bool bVerbose); // zz-sign w/o .dat
   long  updateFile  (char *pszName, uchar *pmd5cont = 0, bool bJustKeep=false);
   long  removeFile  (char *pszName, bool bPrefixLF = 0);
   long  updateDir   (char *pszName);
   long  save        (long &rnSignsWritten);
   void  reset       ( );
   long  checkFile   (char *pszName);
   long  numberOfFiles  ( ) { return aUnixTime.numberOfEntries(); }

   long  getFileFlags   (long nIndex) { return aFlags.getEntry(nIndex, __LINE__); }

   long  verifyFile  (char *pszFilename, char *pszShFile=0, bool bSilentAttribs=0);
   long  verifyFile  (long nIndex, bool bCleanup);
   // 0:ok 1:notfound 9:file_differs_inconsistently

   long  numberOfVerifies  ( ) { return nClVerified; }
   long  numberOfVerMissing( ) { return nClVerMissing; }
   long  numberOfVerFailed ( ) { return nClVerFailed; }
   bool  anyEvents         ( ) { return nClVerified || nClVerMissing || nClVerFailed; }
   char *filename          ( ) { return pszClDBFile; }
   long  setMetaDir        (char *psz);
   char  *metaDir          ( ) { return pszClMetaDir; }
   bool  isSignatureFile   (char *pszFile);

private:
   long  indexOf     (char *pszFile);
   long  writeRecord (FILE *fout, long nIndex, SFKMD5 *pmd5, bool bIsLastRec);
   long  writeEpilogue     (FILE *fout, SFKMD5 *pmd5);
   long  loadDB      (char *pszBasePath, bool bVerbose);
   long  loadRecord  (FILE *fin, SFKMD5 *pmd5, bool bSim); // uses szLineBuf
   long  loadHeader  (FILE *fin, SFKMD5 *pmd5);
   long  loadCheckEpilogue (FILE *fin, SFKMD5 *pmd5);

   static char *pszClFileDBHead;

   char     *pszClDBPath;
   char     *pszClDBFile;
   char     *pszClLineBuf;
   char     *pszClMetaDir;
   long     nClMode;
   long     nClVerified;
   long     nClVerMissing;
   long     nClVerFailed;
   NumTable  aUnixTime;
   NumTable  aWinTime;
   NumTable  aContSumLo;
   NumTable  aContSumHi;
   LongTable aFlags;
   StringTable aPath;

   uchar     abClRecBuf[1024];
};

char *FileMetaDB::pszClFileDBHead = (char*)"SFKSIG10";

FileMetaDB filedb;

FileMetaDB::FileMetaDB()
{
   pszClDBPath    = 0;
   pszClDBFile    = 0;
   pszClLineBuf   = 0;
   pszClMetaDir   = 0;
   nClMode        = 0;
   nClVerified    = 0;
   nClVerMissing  = 0;
   nClVerFailed   = 0;
}

long FileMetaDB::setMetaDir(char *psz)
{
   if (pszClMetaDir) delete [] pszClMetaDir;
   pszClMetaDir = strdup(psz);
   return 0;
}

bool FileMetaDB::isSignatureFile(char *pszBase)
{
   if (!pszClLineBuf)
      if (!(pszClLineBuf = new char[MAX_LINE_LEN+100]))
         { perr("outofmem.1\n"); return 0; }

   bool bChecked = 0;

   long i=0;
   for (i=1; i<=3 && !bChecked; i++)
   {
      SFKMD5 md5; // re-init per loop

      sprintf(pszClLineBuf, "%s-%02ld.dat", pszBase, i);

      FILE *fin = fopen(pszClLineBuf, "rb");
      if (!fin) return 0;
   
      uchar abin[20];
      char *pszHead = pszClFileDBHead;
      long nread = fread(abin, 1, 8, fin);
      if (nread < 8) { fclose(fin); return 1; } // EOD
      abin[8] = '\0';
      if (!strcmp((char*)abin, pszHead))
         bChecked = 1;
   
      fclose(fin);
   }

   return bChecked;
}

long FileMetaDB::indexOf(char *pszInFile)
{
   long nEntries = aUnixTime.numberOfEntries();
   for (long i=0; i<nEntries; i++) 
   {
      char *pszRefFile = aPath.getEntry(i, __LINE__);
      if (!strcmp(pszInFile, pszRefFile))
      {
         return i;
      }
   }
   return -1;
}

long FileMetaDB::loadDB(char *pszBase, bool bVerbose)
{
   if (pszClDBPath) { delete [] pszClDBPath; pszClDBPath=0; }
   pszClDBPath = strdup(pszBase);

   if (pszClDBFile) { delete [] pszClDBFile; pszClDBFile=0; }
   pszClDBFile = new char[strlen(pszClDBPath)+100];

   bool bChecked = 0;
   long nSigRes  = 0;

   // pass 1: check several sign files until a functional one is found
   long i=0;
   for (i=1; i<=3 && !bChecked; i++)
   {
      SFKMD5 md5; // re-init per loop

      sprintf(pszClDBFile, "%s-%02ld.dat", pszClDBPath, i);

      // if (i > 1)
      //   pwarn("retrying on signature db: %s\n", pszClDBFile);

      if (fileExists(pszClDBFile)) 
      {
         // printf("load %s\n", pszClDBFile);

         FILE *fin = fopen(pszClDBFile, "rb");
         if (!fin)
            nSigRes = 3;
         else   
         if (!loadHeader(fin, &md5))
         for (long nrec=1; ;nrec++)
         {
            long nrc = loadRecord(fin, &md5, 1); // uses szLineBuf
            // printf("   rec %ld loaded, rc %ld\n", nrec, nrc);
            if (nrc == 1)
               break; // EOD
            if (bChecked) {
               perr("unexpected record data at end of %s\n", pszClDBFile);
               break;
            }
            if (nrc == 2) {
               if (!(nSigRes = loadCheckEpilogue(fin, &md5)))
                  bChecked = 1;
            }
            if (nrc > 2) {
               perr("error while reading %s: wrong content format (%ld)\n", pszClDBFile, nrc);
               break;
            }
         }

         fclose(fin);
      } else {
         nSigRes = 3;
      }

      if (!bChecked) {
         if (nSigRes == 3) {
            if (bVerbose)
               printf("signature db not found: %s\n", pszClDBFile);
         }
         else
         if (i < 3) {
            if (nSigRes == 2)
               pwarn("signature db modified: %s - retrying on copy\n", pszClDBFile);
            else
               pwarn("invalid signature db: %s - retrying on copy\n", pszClDBFile);
         } else {
            perr("all signature databases unreadable or modified.\n", pszClDBFile);
         }
      }
   }

   // pass 2: load the first functional file
   if (!bChecked) {
      return 9; // +perr("cannot find a valid signature database.");
   }
   else
   {
      // pszClDBFile is still the valid name
      FILE *fin = fopen(pszClDBFile, "rb");
      if (!fin) return 9+perr("cannot read: %s\n", pszClDBFile);

      SFKMD5 md5;

      if (!loadHeader(fin, &md5))
      while (1) {
         long nrc = loadRecord(fin, &md5, 0); // uses szLineBuf
         if (nrc == 1)
            break; // EOD
         if (nrc == 2) {
            if (loadCheckEpilogue(fin, &md5))
               { fclose(fin); return 9+perr("internal #11571940"); }
         }
         if (nrc > 2) {
            perr("error while reading %s: wrong content format\n", pszClDBFile);
            break;
         }
      }

      fclose(fin);
   }

   return 0;   
}

long FileMetaDB::openUpdate(char *pszBase)
{
   loadDB(pszBase, 0);
   // ignore rc

   nClMode = 2;

   return 0;
}

long FileMetaDB::openRead(char *pszBase, bool bVerbose)
{
   if (loadDB(pszBase, bVerbose))
      return 9;

   nClMode = 1;

   return 0;
}

long FileMetaDB::verifyFile(char *pszName, char *pszShadow, bool bSilentAttribs)
{
   char *relName(char *pszRoot, char *pszAbs);
   char *pszRelName = pszName;

   if (pszGlblCopySrc)
      pszRelName = relName(pszGlblCopySrc, pszName);

   long nind = indexOf(pszRelName);
   if (nind < 0) {
      nClVerMissing++;
      return 8;   // not found
   }

   // get archived metadata
   num nUnixTime2  = aUnixTime.getEntry(nind, __LINE__);
   num nWinTime2   = aWinTime.getEntry(nind, __LINE__);
   num nContSumLo2 = aContSumLo.getEntry(nind, __LINE__);
   num nContSumHi2 = aContSumHi.getEntry(nind, __LINE__);

   // build current metadata
   FileStat ofs;
   ofs.readFrom(pszName, 0, bSilentAttribs);
   num nUnixTime = ofs.getUnixTime();
   num nWinTime  = ofs.getWinTime();
   num ncontlo, nconthi;
   uchar abContSum[20];
   if (getFileMD5(pszName, abContSum)) {
      perr("no such file: %s - cannot read checksum\n", pszName);
      return 9;
   }
   ab16ToNum(abContSum, ncontlo, nconthi);

   // let's expect that time is the same, all that matters is
   // if the content was tampered during transport:
   if (ncontlo != nContSumLo2 || nconthi != nContSumHi2)
   {
      nClVerFailed++;

      if (pszShadow && fileExists(pszShadow))
      {
         // try fallback to shadow file
         if (getFileMD5(pszShadow, abContSum)) {
            perr("no such file: %s - cannot read shadow file\n", pszShadow);
            return 9;
         }
         ab16ToNum(abContSum, ncontlo, nconthi);
         if (ncontlo == nContSumLo2 && nconthi == nContSumHi2)
            return 5;   // fallback to shadow is possible
      }

      return 9;
   }

   nClVerified++;

   if (nUnixTime != nUnixTime2)  return 1; // informal

   return 0;
}

long FileMetaDB::verifyFile(long nind, bool bCleanup)
{
   ulong currentKBPerSec();

   // if anything fails with this record, skip it on cleanup
   aFlags.updateEntry(0, nind); // no save by default

   // get archived metadata
   char *pszRelName = aPath.getEntry(nind, __LINE__);
   if (!pszRelName) return 9+perr("unexpected filedb entry at record %ld\n", nind);

   num nUnixTime2  = aUnixTime.getEntry(nind, __LINE__);
   num nWinTime2   = aWinTime.getEntry(nind, __LINE__);
   num nContSumLo2 = aContSumLo.getEntry(nind, __LINE__);
   num nContSumHi2 = aContSumHi.getEntry(nind, __LINE__);

   // create absolute filename
   if (!pszGlblCopySrc) return 9+perr("internal #0605071204");
   joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszGlblCopySrc, pszRelName);
   char *pszName = szRefNameBuf;

   joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszGlblCopySrc, pszRelName);
   char *pszShadow = szRefNameBuf2;

   // show detailed info
   char szAddInfo[200];
   long nVerOK     = filedb.numberOfVerifies();
   long nVerFailed = filedb.numberOfVerFailed();
   if (nVerFailed > 0)
      sprintf(szAddInfo, "%u files ok, %ld failed, %u mb %u kbs", nVerOK, nVerFailed, (ulong)(nGlblBytes/1000000UL), currentKBPerSec());
   else
      sprintf(szAddInfo, "%u files %u mb %u kbs", nVerOK, (ulong)(nGlblBytes/1000000UL), currentKBPerSec());
   info.setProgress(numberOfFiles(), nind, "files");
   info.setStatus("verfy", pszName, szAddInfo, eKeepProg);

   // build current metadata
   FileStat ofs;
   if (ofs.readFrom(pszName)) {
      nClVerMissing++;
      return 9+perr("file not found: %s\n", pszName);
   }
   num nUnixTime = ofs.getUnixTime();
   num nWinTime  = ofs.getWinTime();
   num ncontlo, nconthi;
   uchar abContSum[20];
   if (getFileMD5(pszName, abContSum)) {
      perr("no such file: %s - cannot read checksum\n", pszName);
      nClVerMissing++;
      return 9;
   }
   ab16ToNum(abContSum, ncontlo, nconthi);

   // check if the content was tampered during transport:
   if (ncontlo != nContSumLo2 || nconthi != nContSumHi2)
   {
      // primary file content corrupted
      nClVerFailed++;

      if (bCleanup) {
         setTextColor(nGlblErrColor);
         oprintf("DEL: %s - was modified, please resync\n", pszName);
         if (remove(pszName)) {
            if (setWriteEnabled(pszName))
               perr("cannot delete: %s\n", pszName);
            else
            if (remove(pszName))
               perr("cannot delete: %s\n", pszName);
         }
         setTextColor(-1);
         return 9;
      }

      if (pszShadow && fileExists(pszShadow))
      {
         // try fallback to shadow file
         if (getFileMD5(pszShadow, abContSum)) {
            perr("content modified  : %s\n", pszName);
            perr("cannot read shadow: %s\n", pszShadow);
            return 9;
         }

         ab16ToNum(abContSum, ncontlo, nconthi);

         if (ncontlo == nContSumLo2 && nconthi == nContSumHi2)
         {
            cs.shadowFallbacks++;
            pwarn("content modified: %s\n", pszName);
            pwarn("shadow file ok  : %s\n", pszShadow);
            return 5;   // fallback to shadow is possible
         }

         perr("content modified: %s\n", pszName);
         perr("shadow modified : %s\n", pszShadow);

         return 9;
      }

      perr("content modified: %s\n", pszName);

      return 9;
   }

   // produce only notic if time mismatches:
   if (nUnixTime != nUnixTime2) 
   {
      num nTimeDiff = nUnixTime - nUnixTime2;
      if (nTimeDiff < -5 || nTimeDiff > 5) 
      {
         pinf("time difference (%s sec), content ok: %s\n", numtoa(nTimeDiff), pszName);
         // in case cleanup is done: update with current times
         aUnixTime.updateEntry(nUnixTime, nind);
         if (nWinTime != 0)
            aWinTime.updateEntry(nWinTime, nind);
      }
      // else ignore: up to 5 sec time diff happens between file systems
   }

   nClVerified++;

   // record confirmed, keep it in case of cleanup.
   aFlags.updateEntry(1, nind);

   return 0;
}

long FileMetaDB::updateFile(char *pszName, uchar *pmd5cont, bool bJustKeep)
{
   // printf("updateFile %s, %02X%02X%02X%02X\n", pszName, *(pmd5cont+0),*(pmd5cont+1),*(pmd5cont+2),*(pmd5cont+3));

   char *relName(char *pszRoot, char *pszAbs);

   // printf("updatefile: %s\n", pszName);

   FileStat ofs;
   ofs.readFrom(pszName);

   num nUnixTime = ofs.getUnixTime();
   num nWinTime  = ofs.getWinTime();

   // strip x:\the\foo\bar.txt to the\foo\bar.txt
   char *pszRelName = relName(pszGlblCopySrc, pszName);

   long nind = indexOf(pszRelName);
   if (nind >= 0)
   {
      // we have this filename in the db.
      if (bJustKeep) {
         // unconditionally keep the entry of a non-synced file
         // e.g. on copy: target is newer than source (no copy)
         // if (aUnixTime.getEntry(nind, __LINE__) == nUnixTime) {
         aFlags.updateEntry(1, nind); // store file entry again
         return 0;
         // }
      }

      // update metadata:
      aUnixTime.updateEntry(nUnixTime, nind);
      aWinTime.updateEntry(nWinTime, nind);

      // update content checksum
      num ncontlo, nconthi;
      uchar abContSum[20];
      // take supplied content md5, or build now
      if (pmd5cont != 0)
         memcpy(abContSum, pmd5cont, 16);
      else
         if (getFileMD5(pszName, abContSum)) return 9;
      ab16ToNum(abContSum, ncontlo, nconthi);
      aContSumLo.updateEntry(ncontlo, nind);
      aContSumHi.updateEntry(nconthi, nind);

      // mark this record as updated, for save:
      aFlags.updateEntry(2, nind);
   }
   else
   {
      // not yet in the db
      if (aUnixTime.addEntry(nUnixTime))  return 9;
      if (aWinTime.addEntry(nWinTime))    return 9;

      // add content checksum
      num ncontlo, nconthi;
      uchar abContSum[20];
      // take supplied content md5, or build now
      if (pmd5cont != 0)
         memcpy(abContSum, pmd5cont, 16);
      else
         if (getFileMD5(pszName, abContSum)) return 9;
      ab16ToNum(abContSum, ncontlo, nconthi);
      if (aContSumLo.addEntry(ncontlo))   return 9;
      if (aContSumHi.addEntry(nconthi))   return 9;

      if (aFlags.addEntry(2)) return 9;

      // add also path for easier verify syntax
      if (aPath.addEntry(pszRelName)) return 9;
   }

   return 0;
}

long FileMetaDB::removeFile(char *pszName, bool bPrefixLF)
{
   char *relName(char *pszRoot, char *pszAbs);

   // strip x:\the\foo\bar.txt to the\foo\bar.txt
   char *pszRelName = relName(pszGlblCopySrc, pszName);

   long nind = indexOf(pszRelName);
   if (nind >= 0)
   {
      // mark this record as deleted, for save:
      aFlags.updateEntry(0, nind);
   }
   else
   {
      if (bPrefixLF) printf("\n");
      pwarn("cannot remove filename from metadb: %s\n", pszName);
   }

   return 0;
}

long FileMetaDB::checkFile(char *pszName)
{
   FileStat ofs;
   if (ofs.readFrom(pszName)) {
      perr("cannot read file infos: %s\n", pszName);
      return 5;
   }

   cs.files++;

   num nUnixTime = ofs.getUnixTime();
   num nWinTime  = ofs.getWinTime();

   long nind = indexOf(pszName);
   if (nind >= 0)
   {
      // we have this filename in the db
      num nUnixTime2  = aUnixTime.getEntry(nind, __LINE__);
      num nWinTime2   = aUnixTime.getEntry(nind, __LINE__);
      num nContSumLo2 = aContSumLo.getEntry(nind, __LINE__);
      num nContSumHi2 = aContSumHi.getEntry(nind, __LINE__);

      if (nUnixTime2 != nUnixTime) {
         printf("time: %s\n", pszName);
         return 0;
      }

      num ncontlo, nconthi;
      uchar abContSum[20];
      if (getFileMD5(pszName, abContSum)) return 9;
      ab16ToNum(abContSum, ncontlo, nconthi);

      if (ncontlo != nContSumLo2 || nconthi != nContSumHi2) {
         printf("cont: %s\n", pszName);
         return 0;
      }
   }  

   return 0;
}

long FileMetaDB::updateDir(char *pszName)
{
    return 0;
}

long FileMetaDB::writeRecord(FILE *fout, long nIndex, SFKMD5 *pmd5, bool bIsLastRec)
{
   uchar about1[20];

   // since SFKSIG10, first field is ulong nmetalen.
   ulong nmetalen = 16+16+2;
   ulongtoab4(nmetalen, about1);
   if (myfwrite(about1, 4, fout, 0,0,pmd5) != 4) return 9;

   // - - - meta data block: - - -

   // file times
   numToAb16(aUnixTime.getEntry(nIndex, __LINE__),
             aWinTime.getEntry(nIndex, __LINE__) ,
             about1);
   if (myfwrite(about1, 16, fout, 0,0,pmd5) != 16) return 9;

   // content checksum
   numToAb16(aContSumLo.getEntry(nIndex, __LINE__),
             aContSumHi.getEntry(nIndex, __LINE__), 
             about1);
   if (myfwrite(about1, 16, fout, 0,0,pmd5) != 16) return 9;

   // update flags
   uchar abFlags[2];
   ulong nflags = aFlags.getEntry(nIndex, __LINE__);
   if (bIsLastRec)
      nflags |= 4;
   abFlags[0] = (uchar)(nflags >> 8);
   abFlags[1] = (uchar)(nflags     );
   if (myfwrite(abFlags, 2, fout, 0,0,pmd5) != 2) return 9;

   // - - - end meta data block - - -

   uchar abPathLen[2];
   memset(abPathLen, 0, sizeof(abPathLen));
   if (aPath.isSet(nIndex)) {
      char *psz  = aPath.getEntry(nIndex, __LINE__);
      // printf("WRITE %ld %s\n", nIndex, psz);
      ulong nlen = strlen(psz);
      abPathLen[0] = (uchar)(nlen >> 8);
      abPathLen[1] = (uchar)(nlen     );
      if (myfwrite(abPathLen,    2, fout, 0,0,pmd5) !=    2) return 9;
      if (myfwrite((uchar*)psz    , nlen, fout, 0,0,pmd5) != nlen) return 9;
   } else {
      // printf("WRITE %ld [noname]\n", nIndex);
      if (myfwrite(abPathLen,    2, fout, 0,0,pmd5) != 2) return 9;
   }

   // printf(" saved record, %ld %d\n", nflags, bIsLastRec);

   return 0;
}

long FileMetaDB::loadHeader(FILE *fin, SFKMD5 *pmd5)
{
   uchar abin[20];
   char *pszHead = pszClFileDBHead;
   long nread = myfread(abin, 8, fin, 0,0,pmd5);
   if (nread < 8) { fclose(fin); return 1; } // EOD
   abin[8] = '\0';
   if (strcmp((char*)abin, pszHead))
      return 9+perr("wrong signature db version: \"%s\"\n", abin);

   return 0;
}

long FileMetaDB::loadCheckEpilogue(FILE *fin, SFKMD5 *pmd5)
{
   uchar abin[20];

   long nread = myfread(abin, 16, fin, 0,0,0);
   if (nread < 16) {
      return 1; // EOD
   }

   uchar *pdig = pmd5->digest();
   if (memcmp(abin, pdig, 16)) {
      return 2; // mismatch
   }

   return 0;
}

// uses szLineBuf
long FileMetaDB::loadRecord(FILE *fin, SFKMD5 *pmd5, bool bSim)
{
   memset(abClRecBuf, 0, sizeof(abClRecBuf));
   uchar *abin = abClRecBuf;

   long nread = myfread(abin, 4, fin, 0,0,pmd5);
   if (nread < 4) return 1; // EOD, read after epilogue
   ulong nmetalen = ab4toulong(abin);

   if (nmetalen > sizeof(abClRecBuf)-10)
      return 9+perr("metadb: header block too large (%lu), cannot load.\n",nmetalen);

   if (nmetalen < 16+16+2)
      return 9+perr("metadb: header block too small (%lu), cannot load.\n",nmetalen);

   // - - - meta data block - - -

   nread = myfread(abin, nmetalen, fin, 0,0,pmd5);
   if (nread < (long)nmetalen) return 10; // unexpected

   num n1, n2;
   ab16ToNum(abin+0, n1, n2);
   if (!bSim) {
      if (aUnixTime.addEntry(n1)) return 9;
      if (aWinTime.addEntry(n2))  return 9;
   }

   ab16ToNum(abin+16, n1, n2);
   if (!bSim) {
      if (aContSumLo.addEntry(n1)) return 9;
      if (aContSumHi.addEntry(n2)) return 9;
   }

   // read flag value
   uchar abFlags[2];
   memcpy(abFlags, abin+32, 2);
   ulong nflags = (((ulong)abFlags[0]) << 8) | ((ulong)abFlags[1]);
   if (!bSim) {
      // filter out flag "4" (last record marker):
      if (aFlags.addEntry(nflags & (255UL ^ 4))) return 9;
   }

   // - - - end of meta data block - - -

   // read filename
   uchar abPathLen[2];
   nread = myfread(abPathLen, 2, fin, 0,0,pmd5);
   if (nread < 2) return 12; // unexpected
   ulong nlen = (((ulong)abPathLen[0]) << 8) | ((ulong)abPathLen[1]);
   if (nlen > 0) {
      if (nlen > MAX_LINE_LEN-1) return 13;
      nread = myfread((uchar*)szLineBuf, nlen, fin, 0,0,pmd5);
      if (nread < (long)nlen) return 14;
      szLineBuf[nlen] = '\0';
      if (!bSim) {
         aPath.addEntry(szLineBuf);
      }
      // printf("LOADED NAME %s\n", szLineBuf);
   } else {
      // printf("LOADED NO NAME\n");
   }

   if (nflags & 4) {
      // printf("metadb load: lastrec found\n");
      return 2; // last data record read, md5 follows
   }

   return 0;
}

long FileMetaDB::writeEpilogue(FILE *fout, SFKMD5 *pmd5)
{
   uchar *pdig = pmd5->digest();
   if (myfwrite(pdig, 16, fout, 0,0,0) != 16) return 9;
   return 0;
}

long FileMetaDB::save(long &rnSignsWritten)
{
   if (!pszClDBPath) return 9+perr("internal #11571945");

   if (pszClDBFile) { delete [] pszClDBFile; pszClDBFile=0; }
   pszClDBFile = new char[strlen(pszClDBPath)+100];

   long nCopies = 3;
   long nCopied = 0;

   // write signature db 3 times
   for (long i=1; i<=nCopies; i++)
   {
      sprintf(pszClDBFile, "%s-%02ld.dat", pszClDBPath, i);
   
      SFKMD5 md5;
   
      // printf("saveto %s\n", pszClDBFile);
      FILE *fout = fopen(pszClDBFile, "wb");
      if (!fout) {
         perr("cannot write file meta db: %s\n", pszClDBFile);
         continue; // but retry with next
      }
   
      char *pszHead = pszClFileDBHead;
      if (myfwrite((uchar*)pszHead, 8, fout, 0,0,&md5) != 8)
         {  fclose(fout); continue; }
   
      bool bFailed = 0;
      bool bDoneLastRec = 0;

      long nEntries = aUnixTime.numberOfEntries();

      // identify last valid record to be saved
      long ilastval = 0;
      for (long k=0; k<nEntries; k++) {
         if (aFlags.getEntry(k, __LINE__) >= 1)
            ilastval = k;
      }

      long nWritten = 0;
      for (long i=0; i<nEntries; i++) 
      {
         // write only added or updated records
         if (aFlags.getEntry(i, __LINE__) >= 1) {
            bool bIsLastRec = (i == ilastval);
            // printf("   write rec %ld last=%d\n",i,bIsLastRec);
            if (writeRecord(fout, i, &md5, bIsLastRec)) {
               perr("error while writing file meta db: %s\n", pszClDBFile);
               bFailed = 1;
               break;
            } else {
               nWritten++;
               if (bIsLastRec)
                  bDoneLastRec = 1;
            }
         }
      }

      if (!bDoneLastRec)
         perr("internal: no lastrec saved %ld %ld\n",ilastval,nEntries);
   
      if (!bFailed)
         writeEpilogue(fout, &md5);
   
      fclose(fout);

      if (!bFailed) {
         rnSignsWritten = nWritten;
         nCopied++;
      }
   }

   if (nCopied <= 0)
      return 9+perr("failed to write any metadb copy.\n");

   if (nCopied < nCopies)
      return 5+perr("%ld metadb copies written, %ld failed.\n", nCopied, (nCopies-nCopied));

   return 0;
}

void FileMetaDB::reset( )
{
   if (pszClDBPath) {
      delete [] pszClDBPath;
      pszClDBPath = 0;
   }
   if (pszClDBFile) {
      delete [] pszClDBFile;
      pszClDBFile = 0;
   }
   if (pszClLineBuf) {
      delete [] pszClLineBuf;
      pszClLineBuf = 0;
   }
   if (pszClMetaDir) {
      delete [] pszClMetaDir;
      pszClMetaDir = 0;
   }
   aUnixTime.resetEntries();
   aWinTime.resetEntries();
   aContSumLo.resetEntries();
   aContSumHi.resetEntries();
   aFlags.resetEntries();
   aPath.resetEntries();
}

class FileVerifier
{
public:
   FileVerifier   ( );
   long  remember (char *pszDstName, num nsumhi, num nsumlo);
   long  verify   ( );
   void  reset    ( );
   long  matchedFiles( ) { return nClMatched; }
   long  failedFiles ( ) { return nClFailed; }
   long  totalFiles  ( ) { return aClDst.numberOfEntries(); }
private:
   NumTable    aClSumHi;
   NumTable    aClSumLo;
   StringTable aClDst;
   long  nClMatched;
   long  nClFailed;
};

FileVerifier glblVerifier;

FileVerifier::FileVerifier() 
{ 
   nClMatched = 0;
   nClFailed  = 0;
}

void FileVerifier::reset() 
{
   aClSumHi.resetEntries();
   aClSumLo.resetEntries();
   aClDst.resetEntries();
}

long FileVerifier::remember(char *pszDst, num nsumhi, num nsumlo)
{
   if (aClSumHi.addEntry(nsumhi)) return 9;
   if (aClSumLo.addEntry(nsumlo)) return 9;
   if (aClDst.addEntry(pszDst))   return 9;
   return 0;
}

long FileVerifier::verify()
{
   char szAddInfo[200];

   long lRC = 0;

   long nFiles = totalFiles();
   for (long i=0; i<nFiles; i++)
   {
      if (userInterrupt(1, 1)) // silent, wait for release
      {
         info.print("verify stopped by user.\n");
         bGlblEscape = 0;
         return 1;
      }

      // get source file sum
      num nsrchi = aClSumHi.getEntry(i, __LINE__);
      num nsrclo = aClSumLo.getEntry(i, __LINE__);

      // build destination sum
      char *pszDst = aClDst.getEntry(i, __LINE__);
      info.setProgress(nFiles, i, "files");
      sprintf(szAddInfo, "file %ld/%ld", i+1, nFiles);
      info.setStatus("verfy", pszDst, szAddInfo);
      uchar abMD5Dst[20];
      if (getFileMD5NoCache(pszDst, abMD5Dst, 1)) // silent
      {
         if (userInterrupt(1, 1)) {
            pinf("[nopre] verify skipped.\n");
            lRC = 1;
            break;
         }
         perr("unable to read for verify: %s   \n", pszDst);
         lRC = 5;
         nClFailed++;
         continue;
      }
      uchar *pmd5dst = abMD5Dst;
      num ndstlo=0, ndsthi=0;
      for (long i=0,b=64-8; i<8; i++) {
         ndsthi = ndsthi | (((num)pmd5dst[0+i]&0xFF) << b);
         ndstlo = ndstlo | (((num)pmd5dst[8+i]&0xFF) << b);
         b -= 8;
      }

      // compare both
      if (nsrchi!=ndsthi || nsrclo!=ndstlo) {
         perr("verify failed, file differs: %s   \n", pszDst);
         nClFailed++;
         lRC = 6;
      } else {
         // info.setStatus("vryfd", pszDst); // , 0, eNoCycle);
         // info.printLine(1<<2); // w/o progress
         nClMatched++;
      }
   }

   return lRC;
}

void printCopyCompleted(char *pszName, ulong nflags)
{
   info.clear();
   if (cs.quiet >= 2)
      return;
   char *pszpre = "";
   if (nflags & 8) {
      printx("<warn>##<def>"); pszpre=" "; 
   }
   switch (nflags & 3) {
      case 1 : printx("<prefix>]<def>"); pszpre=" "; break;
      case 3 : printx("<warn>]<def>");   pszpre=" "; break;
   }
   if (nflags & 4) {
      printx("<prefix>><def>"); pszpre=" "; 
   }
   oprintf("%s%s", pszpre, pszName);
   if (nflags & 8)
      printx(" <warn>[sync'ing older file]<def>");
   printf("\n");
}

class CopyCache
{
public:
   CopyCache      ( );
   void setBuf    (uchar *pBuf, num nBufSize);
   long process   (char *pszSrcFile, char *pszDstFile, char *pszShDst, ulong nflags);
   long flush     ( );
   void setEmpty  ( );
private:
   long putBlock  (uchar *pData, long nDataSize);
   uchar *pClBuf;
   num   nClBufSize;
   num   nClUsed;
   char  szTmpBuf[MAX_LINE_LEN+10];
};

CopyCache glblCopyCache;

CopyCache::CopyCache()
{
}

void CopyCache::setBuf(uchar *pBuf, num nBufSize)
{
   pClBuf      = pBuf;
   nClBufSize  = nBufSize;
   nClUsed     = 0;
}

long CopyCache::process(char *pszSrcFile, char *pszDstFile, char *pszShDst, ulong nflags)
{
   if (!pszShDst) pszShDst = "";

   // may another source file fit into the cache?
   FileStat ofsrc;
   if (ofsrc.readFrom(pszSrcFile))
      return 9+perr("unable to read: %s\n", pszSrcFile);
   num nSrcSize = ofsrc.getSize();
   num nRemain  = nClBufSize - nClUsed;
   if (nRemain < 0) return 9+perr("internal 612112001\n");

   // if not, write all cache contents
   if (nSrcSize + 1500 > nRemain) {
      long lRes = flush();
      if (lRes >= 9)
         return lRes;
      setEmpty(); // in case flush was interrupted
   }
 
   if (nSrcSize + 1500 > nClBufSize)
      return 1;   // file too large to fit into cache, copy directly
 
   // cache is ready to accept file
   num nUsedSave = nClUsed;

   // 1. filenames
   if (putBlock((uchar*)pszSrcFile, strlen(pszSrcFile)+1)) return 9+perr("internal 612112002\n");
   if (putBlock((uchar*)pszDstFile, strlen(pszDstFile)+1)) return 9+perr("internal 612112009\n");
   if (putBlock((uchar*)pszShDst  , strlen(pszShDst  )+1)) return 9+perr("internal 612112029\n");
 
   // 2. meta data: filestat and flags
   long nMetaSize = 0;
   uchar *pMeta = ofsrc.marshal(nMetaSize);
   if (putBlock(pMeta, nMetaSize)) return 9+perr("internal 612112006\n");

   uchar abflags[10];
   ulongtoab4(nflags, abflags);
   if (putBlock(abflags, 4)) return 9+perr("internal 612112006.2\n");

   // 3. if it's a directory,
   if (ofsrc.src.bIsDir)
   {
      // set zero-sized content, meta data is sufficient
      uchar *pCur = pClBuf+nClUsed;
      long nLongSize = 0;
      memcpy(pCur, &nLongSize, sizeof(long));
      pCur += sizeof(long);
      nClUsed += sizeof(long);
   }
   else
   {
      // else add the file content
      uchar *pCur = pClBuf+nClUsed;
      long nLongSize = (long)nSrcSize;
      memcpy(pCur, &nLongSize, sizeof(long));
      pCur += sizeof(long);
      nClUsed += sizeof(long);
  
      info.setStatProg("cache", pszSrcFile, nClBufSize, nUsedSave, "bytes");

      FILE *fin = fopen(pszSrcFile, "rb");
      if (!fin) {
         nClUsed = nUsedSave;
         return 5+perr("cannot open input file %s   \n", pszSrcFile);
         // non-fatal, proceed copy, but list error count at end.
      }
   
      size_t nRead = 0;
      if (cs.sim)
         nRead = nSrcSize;
      else
         nRead = myfread(pCur, (size_t)nSrcSize, fin, nClBufSize, nUsedSave);

      fclose(fin);
   
      if (nRead != nSrcSize) {
         perr("while reading %s: incomplete data\n", pszSrcFile);
         // fall back, remove metadata from cache
         nClUsed = nUsedSave;
      } else {
         SFKMD5 md5in;
         md5in.update(pCur, nSrcSize);
   
         nClUsed += nSrcSize;
         pCur += nSrcSize;
   
         // 4. md5
         uchar *pmd5in = md5in.digest();

         // remember source sum in case of late verify:
         if (cs.verifyLate) {
            num nsumlo=0, nsumhi=0;
            for (long i=0,b=64-8; i<8; i++) {
               nsumhi = nsumhi | (((num)pmd5in[0+i]&0xFF) << b);
               nsumlo = nsumlo | (((num)pmd5in[8+i]&0xFF) << b);
               b -= 8;
            }
            glblVerifier.remember(pszDstFile, nsumhi, nsumlo);
         }

         memcpy(pCur, pmd5in, 16);

         // printf("1] %02X%02X%02X%02X %s %p %s\n",pmd5in[0],pmd5in[1],pmd5in[2],pmd5in[3], numtoa(nSrcSize), pCur, pszSrcFile);

         pCur += 16;
         nClUsed += 16;

         // and also to filedb, if active
         if (filedb.canUpdate())
            if (filedb.updateFile(pszSrcFile, pmd5in))
               return 9;
      }
   }
 
   return 0;   
}

long CopyCache::putBlock(uchar *pData, long nDataSize) 
{
   uchar *pCur = pClBuf+nClUsed;
   num nRemain = nClBufSize-nClUsed;
   if (nDataSize > nRemain + 100) return 9;
   memcpy(pCur, &nDataSize, sizeof(long));
   memcpy(pCur+sizeof(long), pData, nDataSize);
   nClUsed += sizeof(long)+nDataSize;
   return 0;
}

void CopyCache::setEmpty()
{
   nClUsed = 0;
}

long CopyCache::flush() 
{
   uchar *pCur = pClBuf;
   uchar *pMax = pClBuf+nClUsed;
   while (pCur < pMax) 
   {
      bool bDoneFile = 0;

      // 1. filenames
      long nBlockSize = 0;
      if (pCur >= (pMax - sizeof(long))) return 9+perr("internal #113701\n");
      memcpy(&nBlockSize, pCur, sizeof(long));
      pCur += sizeof(long);
      char *pszSrc = (char*)pCur;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur >= pMax) return 9+perr("internal #113702\n");

      memcpy(&nBlockSize, pCur, sizeof(long));
      pCur += sizeof(long);
      char *pszDst = (char*)pCur;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur >= pMax) return 9+perr("internal #113703\n");

      memcpy(&nBlockSize, pCur, sizeof(long));
      pCur += sizeof(long);
      char *pszShDst = (char*)pCur;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur >= pMax) return 9+perr("internal #113733\n");

      char *pszTell = chain.usefiles ? pszDst : pszSrc;
      if (cs.listTargets) pszTell = pszDst;

      // 2. meta data
      // filestat
      memcpy(&nBlockSize, pCur, sizeof(long));
      pCur += sizeof(long);
      uchar *pMeta = pCur;
      long nMetaSize = nBlockSize;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur >= pMax) return 9+perr("internal #113704\n");

      // flags, also prefixed by blocksize (4)
      memcpy(&nBlockSize, pCur, sizeof(long));
      pCur += sizeof(long);
      if (nBlockSize != 4) return 9+perr("internal #113704.2\n");
      uchar abflags[10];
      memcpy(abflags, pCur, 4);
      pCur += 4;
      ulong nflags = ab4toulong(abflags);
      // bit0: verified by checksum. 
      // bit1: is shadow fallback.
      // bit2: 
      // bit3: source is older than target (sync)

      // 3. file content
      memcpy(&nBlockSize, pCur, sizeof(long));
      pCur += sizeof(long);
      uchar *pContent = pCur;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur > pMax) return 9+perr("internal #113705\n");

      FileStat ofsdst;
      if (ofsdst.setFrom(pMeta, nMetaSize))
         return 9;
 
      if (ofsdst.src.bIsDir)
      {
         // set target dir meta data
         if (cs.verbose > 2)
            info.print("[%s : about to copy time]\n", pszDst);
         if (!cs.sim)
            if (!ofsdst.writeTo(pszDst, __LINE__)) {
               cs.dirsCloned++;
               if (cs.verbose)
                  info.print("[%s : time copied]\n", pszDst);
            }
         // IGNORE rc. error messages are counted.
         // cs.dirs++;
      }
      else
      if (cs.sim)
      {
         // 4. skip md5
         uchar *pmd5in = pCur;
         pCur += 16;

         info.setStatus("", pszTell, "-----", eNoCycle);
         info.printLine(nGlblCopyStyle);
         cs.files++;
      }
      else
      {
         // 4. md5
         uchar *pmd5in = pCur;
         pCur += 16;

         for (long ntry=1; ntry<=3; ntry++)
         {
            // write target file
            info.setStatus("write", pszDst, "00");
   
            FILE *fout = myfopen(pszDst, "wb");
            if (!fout) {
               perr("cannot open output file %s (rc %ld)\n", pszDst, (long)errno); 
               break; // PROCEED with next file. errors are counted.
            }
      
            num nSize = ofsdst.src.nSize;
   
            size_t nWrite = myfwrite(pContent, nSize, fout, nSize, 0);
   
            myfclose(fout);
   
            if (bGlblEscape) {
               remove(pszDst);
               return 9+perr("failed to fully write %s, user interrupt\n", pszDst);
            }
            else
            if (nWrite != nSize)
               return 9+esys("fwrite", "failed to fully write %s   \n", pszDst);
               // do NOT proceed, this seems fatal.
      
            // set target meta data
            if (!ofsdst.writeTo(pszDst, __LINE__))
               cs.filesCloned++;
            // IGNORE rc. errors are counted.
         
            if (!cs.sim && cs.verifyEarly)
            {
               // run target verify
               info.setStatus("verfy", pszDst, "00");
               uchar abmd5[20];

               long nrcsub = getFileMD5NoCache(pszDst, abmd5, 1);

               if (userInterrupt(1))
               {
                  info.setAction("stop", pszDst, 0, 4);
                  info.printLine();
                  break;
               }
               else
               if (nrcsub == 0)
               {
                  if (memcmp(pmd5in, abmd5, 16)) {
                     if (ntry < 3) {
                        pwarn("verify failed, file differs: %s - retrying write\n", pszDst);
                        // fall through, next retry
                        remove(pszDst);
                     } else {
                        perr("verify failed, file differs: %s - giving up\n", pszDst);
                        remove(pszDst);
                     }
                  } else {
                     // verify succeeded
                     bDoneFile = 1;
                     cs.files++;
                     break;
                  }
               }
            }
            else
            {
               // no verify selected
               bDoneFile = 1;
               cs.files++;
               break;
            }
         }  // endfor tries

         // pszShDst must be set, but may be empty
         if (   filedb.canUpdate() && nGlblCopyShadows && strlen(pszShDst)
             && (!nGlblShadowSizeLimit || (ofsdst.src.nSize < nGlblShadowSizeLimit))
            )
         {
            // write shadow
            pszDst = pszShDst;

            info.setStatus("write", pszDst, "00");
            FILE *fout = myfopen(pszDst, "wb");
            if (!fout) {
               perr("cannot open output file %s (rc %ld)\n", pszDst, (long)errno); 
            } else {
               num nSize = ofsdst.src.nSize;
               size_t nWrite = myfwrite(pContent, nSize, fout, nSize, 0);
               myfclose(fout);
               if (bGlblEscape) {
                  remove(pszDst);
                  return 9+perr("failed to fully write %s, user interrupt\n", pszDst);
               }
               else
               if (nWrite != nSize)
                  return 9+esys("fwrite", "failed to fully write %s   \n", pszDst);
                  // do NOT proceed, this seems fatal.

               // set target meta data
               ofsdst.writeTo(pszDst, __LINE__);
               // IGNORE rc. errors are counted.
               nflags |= 4; // shadow written
               cs.shadowsWritten++;
            }
         }

         // print filename, tell how it was copied
         if (bDoneFile)
            printCopyCompleted(pszTell, nflags);
      }  
   }
   setEmpty();
   return 0;
}

#endif // USE_SFK_BASE

num currentElapsedMSec() {
   return getCurrentTime() - nGlblStartTime;
}

ulong currentKBPerSec() {
   num lMSElapsed = currentElapsedMSec();
   if (lMSElapsed == 0) lMSElapsed = 1;
   return (ulong)(nGlblBytes / lMSElapsed);
}

ulong currentMBPerSec() {
   num lMSElapsed = currentElapsedMSec();
   if (lMSElapsed == 0) lMSElapsed = 1;
   return (ulong)((nGlblBytes / lMSElapsed) / 1000);
}

char szCmpBuf1[4096];
char szCmpBuf2[4096];
long mystrstri(char *psz1, char *psz2, long *lpAtPosition)
{
   long slen1 = strlen(psz1);
   if (slen1 > sizeof(szCmpBuf1)-10)
       slen1 = sizeof(szCmpBuf1)-10;
   memcpy(szCmpBuf1, psz1, slen1);
   szCmpBuf1[slen1] = '\0';

   long slen2 = strlen(psz2);
   if (slen2 > sizeof(szCmpBuf2)-10)
       slen2 = sizeof(szCmpBuf2)-10;
   memcpy(szCmpBuf2, psz2, slen2);
   szCmpBuf2[slen2] = '\0';

   for (long i1=0; i1<slen1; i1++)
      szCmpBuf1[i1] = tolower(szCmpBuf1[i1]);

   for (long i2=0; i2<slen2; i2++)
      szCmpBuf2[i2] = tolower(szCmpBuf2[i2]);

   char *pszHit = strstr(szCmpBuf1, szCmpBuf2);

   if (lpAtPosition) {
      if (pszHit)
         *lpAtPosition = (long)(pszHit - szCmpBuf1);
      else
         *lpAtPosition = -1;
   }

   return (pszHit != 0) ? 1 : 0;
}

// same as above, but support "?" wildcards
long mystrstriq(char *psz1, char *psz2, long *lpAtPosition=0)
{
   long slen1 = strlen(psz1);
   if (slen1 > sizeof(szCmpBuf1)-10)
       slen1 = sizeof(szCmpBuf1)-10;
   memcpy(szCmpBuf1, psz1, slen1);
   szCmpBuf1[slen1] = '\0';

   long slen2 = strlen(psz2);
   if (slen2 > sizeof(szCmpBuf2)-10)
       slen2 = sizeof(szCmpBuf2)-10;
   memcpy(szCmpBuf2, psz2, slen2);
   szCmpBuf2[slen2] = '\0';

   for (long i1=0; i1<slen1; i1++)
      szCmpBuf1[i1] = tolower(szCmpBuf1[i1]);
   for (long i2=0; i2<slen2; i2++)
      szCmpBuf2[i2] = tolower(szCmpBuf2[i2]);

   char *pszHay = szCmpBuf1;  // HayStack
   char *pszNed = szCmpBuf2;  // Needle
   char *pszHit = 0;
   while (*pszHay) {
      // optim: quick check of current char
      if (*pszNed != '?' && *pszHay != *pszNed)
         { pszHay++; continue; }
      // compare against needle at current hay position
      long i=0;
      for (; pszHay[i] && pszNed[i]; i++) {
         char c = pszNed[i];
         if (c == '?')
            continue;
         if (c != pszHay[i])
            break;
      }
      // comparison stopped: why?
      if (!pszNed[i]) {
         // needle elapsed: success
         pszHit = pszHay;
         break;
      }
      // needle not elapsed: no hit here
      pszHay++;
   }

   if (lpAtPosition) {
      if (pszHit)
         *lpAtPosition = (long)(pszHit - szCmpBuf1);
      else
         *lpAtPosition = -1;
   }

   return (pszHit != 0) ? 1 : 0;
}

// returns 0 if equal.
long mystrncmp(char *psz1, char *psz2, long nLen, bool bCase)
{
   if (bCase)
      return strncmp(psz1, psz2, nLen);

   long i=0;
   for (i=0; i<nLen && psz1[i] && psz2[i]; i++)
      if (tolower(psz1[i]) != tolower(psz2[i]))
         return 1;

   return (i==nLen) ? 0 : 1;
}

long mystricmp(char *psz1, char *psz2)
{
   while (*psz1 && *psz2 && tolower(*psz1) == tolower(*psz2)) {
      psz1++;
      psz2++;
   }
   return tolower(*psz1) - tolower(*psz2);
}

long mystrnicmp(char *psz1, char *psz2, long nLen)
{
   long i=0;
   for (i=0; i<nLen && psz1[i] && psz2[i]; i++)
      if (tolower(psz1[i]) != tolower(psz2[i]))
         return tolower(psz1[i]) - tolower(psz2[i]);

   if (i >= nLen) return 0;

   return tolower(psz1[i]) - tolower(psz2[i]);
}

#ifdef _WIN32
// type: 1==onlyDown 2==onlyUp 0==any
long getKeyPress(long ntype=0)
{
   #ifdef WINFULL
   DWORD dwNumEvents, dwEventsPeeked, dwInputEvents;
   INPUT_RECORD aInputBuffer[1];

   HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);

   if (!GetNumberOfConsoleInputEvents(hStdIn, &dwNumEvents))
      return -1;

   if (dwNumEvents <= 0)
      return -1;

   if (!PeekConsoleInput(hStdIn, aInputBuffer, 1, &dwEventsPeeked))
      return -1;
   
   if (!ReadConsoleInput(hStdIn, &aInputBuffer[0], 1, &dwInputEvents))
      return -1;

   if (dwInputEvents != 1)
      return -1;

   if (aInputBuffer[0].EventType == KEY_EVENT) {
      long ncode = aInputBuffer[0].Event.KeyEvent.wVirtualKeyCode;
      bool bdown = aInputBuffer[0].Event.KeyEvent.bKeyDown;
      // react only on key down or key up?
      if (ntype == 1 && !bdown) return -1; // no type match
      if (ntype == 2 &&  bdown) return -1; // no type match
      return ncode;
   }
   #endif

   return -1;
}

bool userInterrupt(bool bSilent, bool bWaitForRelease) {
   if (bGlblEscape)
      return 1;
   static bool bTold = 0;
   if (getKeyPress() == VK_ESCAPE) {
      if (!bSilent && !bTold) {
         bTold = 1;
         info.clear(); // if any
         printf("[aborted by user]%.50s\n", pszGlblBlank);
      }
      if (bWaitForRelease)
         while (getKeyPress() == VK_ESCAPE)
            doSleep(200);
      bGlblEscape = 1;
      return 1;
   }
   return 0;
}
#else
bool userInterrupt(bool bSilent, bool bWait) { return 0; }
#endif

char *loadFile(char *pszFile, bool bquiet)
{
   num nFileSize = getFileSize(pszFile);
   if (nFileSize < 0) {
      if (!bquiet) perr("file not found: %s", pszFile);
      return 0;
   }

   num nTolerance = 10;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut) {
      perr("out of memory: %s\n", pszFile);
      return 0; 
   }
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      if (!bquiet) perr("cannot read: %s\n", pszFile);
      delete [] pOut;
      return 0; 
   }

   long nRead = fread(pOut, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      if (!bquiet) perr("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pOut;
      return 0;
   }

   // loadFile guarantees zero termination after buffer:
   pOut[nFileSize] = '\0';
   return pOut;
}

uchar *loadBinaryFile(char *pszFile, num &rnFileSize) 
{
   num nFileSize = getFileSize(pszFile);
   if (nFileSize < 0)
      return 0;

   num nTolerance = 10;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut) {
      perr("out of memory: %s\n", pszFile);
      return 0; 
   }
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      perr("cannot read: %s\n", pszFile); 
      delete [] pOut; 
      return 0; 
   }

   long nRead = fread(pOut, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      perr("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pOut;
      return 0;
   }

   // not strictly needed w/binary data, but anyway.
   pOut[nFileSize] = '\0';

   rnFileSize = nFileSize;
   return (uchar*)pOut;
}

#ifndef USE_SFK_BASE
class TextFile {
public:
   TextFile (char *pszInFileName);
  ~TextFile ( );
   long  loadFromFile      ( );
   long  writeToFile       ( );
   long  createFromMemory  (char *pszInTextMemBlock);
   char  *getFileName      ( ) { return pszClFileName; }
   long  dumpTo            (FILE *fout);
   TextFile *clone         ( );
   bool  equals            (TextFile *pOther);
   void  setTouched        (bool b) { bClTouched = b; }
   bool  isTouched         ( )      { return bClTouched; }
   bool  fileStatChanged   ( );  // 1==yes, 2==gone
   bool  isContentValid    ( );  // i.e., contains no :create etc.
   long  dataSize          ( )      { return nClDataSize; }
   long  numberOfLines     ( )      { return nClLines; }
   bool  isReadOnly        ( )      { return bClReadOnly; }
   void  setReadOnly       (bool b) { bClReadOnly = b; }
private:
   void  checkIntegrity    ( );
   char  *pszClFileName;
   long  nClLines;
   char  **apClLines;
   char  *pClData;
   long  nClDataSize;
   num   lClFileTime;
   bool  bClTouched;
   bool  bClReadOnly;
};

// all keywords of sfk and patch files
char *apBlockedKeys[] = 
{
   // input files containing these keys might break a cluster file's syntax. 
   // therefore input files containing them must be skipped.
   ":snapfile ", ":cluster ", ":create ",
   ":done\n", ":done\r\n",
   ":cluster-end\n", ":cluster-end\r\n",

   // these keys are less relevant, but also blocked by default.
   // if sfk refuses to integrate some files into a cluster,
   // you may try to ease restrictions by setting this flag:
   #ifndef SFK_LESS_STRICT_KEY_BLOCKING
   ":file:\n", ":file:\r\n",
   ":skip-begin\n" , ":skip-begin\r\n"
   ":skip-end\n"   , ":skip-end\r\n",
   ":patch ", ":info ", ":root ", ":file ",
   ":from\n", ":from\r\n",
   ":to\n", ":to\r\n",
   ":mkdir ", ":select-replace ", ":set ",
   ":edit ", ":READ ",
   #endif

   0 // EOT
};

bool TextFile::isContentValid() {
   if (!pClData || !apClLines)
      { perr("internal #40\n"); return 0; }
   for (long i1=0; i1<nClLines; i1++) {
      char *psz1 = apClLines[i1];
      for (long i2=0; apBlockedKeys[i2]; i2++) {
         if (!strncmp(psz1, apBlockedKeys[i2], strlen(apBlockedKeys[i2]))) {
            fprintf(stderr, "info : excluding file from input: %s\n", pszClFileName);
            fprintf(stderr, "info : contains line beginning with %s\n", apBlockedKeys[i2]);
         // fprintf(stderr, "info : ... will not recursively collect cluster files.\n");
            return 0; // == false
         }
      }
   }
   return 1; // == true
}

bool TextFile::fileStatChanged() {
   long bIsDir    = 0;
   long bCanRead  = 1;
   long bCanWrite = 1;
   num  lFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszClFileName, bIsDir, bCanRead, bCanWrite, lFileTime, nFileSize)) {
      // perr("unable to re-read file: %s\n", pszClFileName);
      return 2;
   }
   // change in file attributes?
   long bReadOnly = 1 - bCanWrite;
   if (bReadOnly != bClReadOnly)
      return 1;
   // change in file time?
   if (lFileTime != lClFileTime)
      return 1;
   return 0;
}

TextFile::TextFile(char *pszFileName) {
   pszClFileName  = strdup(pszFileName);
   nClLines       = 0;
   apClLines      = 0;
   pClData        = 0;
   nClDataSize    = 0;
   lClFileTime    = 0;
   bClTouched     = 0;
   bClReadOnly    = 0;
}

TextFile::~TextFile() {
   if (pszClFileName)   delete [] pszClFileName;
   if (pClData)         delete [] pClData;
   if (apClLines)       delete [] apClLines;
}

bool TextFile::equals(TextFile *pOther) {
   checkIntegrity();
   pOther->checkIntegrity();
   if (strcmp(pszClFileName, pOther->pszClFileName)) return 0;
   if (nClLines != pOther->nClLines) return 0;
   for (long i=0; i<nClLines; i++)
      if (strcmp(apClLines[i], pOther->apClLines[i]))
         return 0;
   if (pOther->isReadOnly() != isReadOnly())
      return 0;
   return 1;
}

void TextFile::checkIntegrity() {
   if (!pszClFileName) { perr("internal #20\n"); exit(1); }
   if (!nClLines     ) { return; } // perr("internal #21\n"); exit(1); }
   if (!apClLines    ) { perr("internal #22\n"); exit(1); }
   if (!pClData      ) { perr("internal #23\n"); exit(1); }
   for (long i=0; i<nClLines; i++)
      if (!apClLines[i])
         { perr("internal #24\n"); exit(1); }
}

TextFile *TextFile::clone() {
   checkIntegrity();
   TextFile *pNew = new TextFile(pszClFileName);
   if (!(pNew->pClData = new char[nClDataSize+10]))
      return 0;
   pNew->nClDataSize = nClDataSize;
   memcpy(pNew->pClData, pClData, nClDataSize);
   pNew->pClData[nClDataSize] = '\0';
   pNew->apClLines = new char*[nClLines];
   for (long i=0; i<nClLines; i++)
      pNew->apClLines[i] = apClLines[i] - pClData + pNew->pClData;
   pNew->nClLines = nClLines;
   pNew->lClFileTime = lClFileTime;
   pNew->bClReadOnly = bClReadOnly;
   // pszClFileName was done in new's ctr
   return pNew;
}

long TextFile::dumpTo(FILE *fout) {
   // size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream );
   // int fputs( const char *string, FILE *stream );
   for (long i=0; i<nClLines; i++) {
      fputs(apClLines[i], fout);
      fputc('\n', fout);
   }
   return 0;
}

long TextFile::loadFromFile() 
{
   if (getFileSize(pszClFileName) == 0) {
      pwarn("zero-sized file, skipping: %s\n", pszClFileName);
      return 1;
   }

   // get all infos about the file to load
   long bIsDir    = 0;
   long bCanRead  = 1;
   long bCanWrite = 1;
   num  lFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszClFileName, bIsDir, bCanRead, bCanWrite, lFileTime, nFileSize)) {
      pwarn("cannot read file, skipping: %s\n", pszClFileName);
      return 1;
   }
   // remember only the stats we care about
   lClFileTime  = lFileTime;
   bClReadOnly  = bCanWrite ? 0 : 1;
   // printf("%d on %s\n",bClReadOnly,pszClFileName);

   char *pszRaw = loadFile(pszClFileName);
   if (!pszRaw) return 9;

   long lRC = createFromMemory(pszRaw);
   delete [] pszRaw;
   return lRC;
}

long TextFile::writeToFile() {
   FILE *fout = fopen(pszClFileName, "w");
   if (!fout) return 9+perr("unable to write: %s\n", pszClFileName);
   dumpTo(fout);
   fclose(fout);
   lClFileTime = getFileTime(pszClFileName);
   return 0;
}

long TextFile::createFromMemory(char *pszRaw) 
{
   // delete old data, if any
   if (pClData) delete [] pClData;
   if (apClLines) delete [] apClLines;

   // copy new raw data
   nClDataSize = strlen(pszRaw);
   pClData     = new char[nClDataSize+10];
   memcpy(pClData, pszRaw, nClDataSize);
   pClData[nClDataSize] = '\0';

   // create line index
   apClLines   = 0;

   // determine number of lines in raw data.
   long nLineFeeds = 0;
   for (long i1=0; i1<nClDataSize; i1++) {
      if (pClData[i1] == '\n')
         nLineFeeds++;
   }

   // if the very last content has no linefeed,
   // it counts as a line without linefeed.
   if (pClData[nClDataSize-1] != '\n')
      nClLines = nLineFeeds+1;
   else
      nClLines = nLineFeeds;

   // convert raw data into array of lines
   apClLines = new char*[nClLines+2];
   long iLine = 0;
   char *psz1 = pClData;
   while (psz1 && *psz1 && (iLine < nClLines)) {
      char *psz2 = strchr(psz1, '\n');
      if (psz2) *psz2++  = '\0'; // remove LF, skip past LF
      apClLines[iLine++] = psz1;
      char *pszCR = strchr(psz1, '\r');
      if (pszCR) *pszCR = '\0';
      psz1 = psz2;
   }
   if (iLine != nClLines) return 9+perr("internal #10 %d %d %p\n",iLine,nClLines,psz1);

   // printf("[%d lines read, %s]\n", nClLines, pszClFileName);
   if (!isContentValid())
      return 9;

   return 0;
}

#define MAX_SYNC_INFO     10
#define MAX_NOTES_LINES 1000

class SnapShot {
public:
   SnapShot (const char *pszID);
  ~SnapShot ( );
   long  addTarget   (char *pszFileName);
   long  addTarget   (TextFile *pTarget);
   void  setFileName (char *pszFileName);
   char *getFileName ( ) { return pClFileName; }
   long  writeToFile ( );
   long  readFromFile(long &rbDroppedAny, long bForceBuildMatch);
   void  addNotesLine(char *pszLine);
   void  setRootDir  (char *pszDirName);
   long  copyTargetsFrom   (SnapShot &rFrom);
   long  numberOfTargets   ( ) { return nClTargets; }
   long  syncDownTargets   (SnapShot &oMaster, long &nSync);
   long  syncUpTargets     (SnapShot &oSrc, long &nSynced);
   long  mirrorTargetsFrom (SnapShot &oSrc, long &nMissing); // copies filenames, but up-loads
   long  checkLoadTargets  ( );
   long  hasTarget   (char *pszFileName); // based on the real target list
   long  dropTarget  (char *pszFileName); // just the entry, doesn't delete the file
   void  dumpTargets ( );
   void  shutdown    ( );
   void  setAllTouched     ( );
   void  resetLastSync     ( );
   void  registerLastSync  (char *pszInfo);
   char *getLastSyncInfo   (unsigned long iIndex);
   void  mapCompilerOutput (bool bMix, char *pszCmd);
protected:
   void  expandTargets     (long lSoMuch);
   long  removeTargetEntry (long n);
   void  adjustNamePadding ( );
   void  resetTargets      (const char *pszInfo);
   void  resetNotes        ( );
   TextFile **apClTargets;
   long  nClMaxTargets;
   long  nClTargets;
   char  *pClFileName;
   char  *pClRootName;
   long  nClNamePadding;
   long  lClLastSavedBuild;
   long  lClLoadedRevision;
   char  *apLastSync[MAX_SYNC_INFO];
   char  *apNotes[MAX_NOTES_LINES+10]; // used only in FileSnap
   long  nClNotes;
   const char *pszClID;
};

SnapShot glblMemSnap("mem");
SnapShot glblFileSnap("fil");

SnapShot::SnapShot(const char *pszID) {
   apClTargets       =  0;
   nClMaxTargets     =  0;
   nClTargets        =  0;
   pClFileName       =  0;
   pClRootName       =  0;
   nClNamePadding    = 30;
   lClLastSavedBuild = 0;
   for (int i=0; i<MAX_SYNC_INFO; i++)
      apLastSync[i]  = 0;
   memset(apNotes, 0, sizeof(apNotes));
   nClNotes          = 0;
   pszClID           = pszID;
   lClLoadedRevision = 0;
}

SnapShot::~SnapShot() {
   shutdown();
}

void SnapShot::addNotesLine(char *pszLine) {
   if (nClNotes < MAX_NOTES_LINES) {
      apNotes[nClNotes++] = strdup(pszLine);
   }
   else
      pwarn("max. number of notes lines exceeded (%ld), ignoring\n", (long)MAX_NOTES_LINES);
}

void SnapShot::shutdown() {
   resetTargets("shutdown");
   resetLastSync();
   if (pClFileName)  { delete [] pClFileName; pClFileName = 0; }
   if (pClRootName)  { delete [] pClRootName; pClRootName = 0; }
   resetNotes();
}

void SnapShot::resetNotes() {
   for (int i=0; i<nClNotes; i++)
      delete [] apNotes[i];
   memset(apNotes, 0, sizeof(apNotes));
   nClNotes = 0;
}

void SnapShot::resetLastSync() {
   for (int i=0; i<MAX_SYNC_INFO; i++)
      if (apLastSync[i]) {
         delete [] apLastSync[i];
         apLastSync[i] = 0;
      }
}

void SnapShot::registerLastSync(char *pszFileName) {
   for (int i=0; i<MAX_SYNC_INFO; i++)
      if (!apLastSync[i]) {
         apLastSync[i] = strdup(pszFileName);
         break;
      }
}

char *SnapShot::getLastSyncInfo(unsigned long iIndex) {
   if (iIndex < MAX_SYNC_INFO)
      return apLastSync[iIndex];
   return 0;
}

char szPadBuf[1024];
char *padString(char *psz1, long lLen) {
   long lBaseLen = strlen(psz1);
   long lMaxLen  = sizeof(szPadBuf)-10;
   if (lBaseLen > lMaxLen)
       lBaseLen = lMaxLen;
   if (lLen > lMaxLen)
       lLen = lMaxLen;
   strncpy(szPadBuf, psz1, lBaseLen);
   while (lBaseLen < lLen)
      szPadBuf[lBaseLen++] = ' ';
   szPadBuf[lBaseLen] = '\0';
   return szPadBuf;
}

/*
   /models/DeviceControllerSystemModel/SYS/sources/BHDiagManager.cpp:109: #error testError01
   cc: C:/Programme/QNX630BH/host/win32/x86/usr/lib/gcc-lib/ntosh/2.95.3/cpp0 caught signal 33
*/

void SnapShot::mapCompilerOutput(bool bMixMappedWithUnmappedOutput, char *pszCmd)
{
   // read compiler errors from stdin
   long nMaxLineLen = sizeof(szLineBuf)-10;
   long nLine = 0;
   long nMaps = 0;
   while (fgets(szLineBuf, nMaxLineLen, stdin))
   {
      nLine++;

      char *psz1 = 0;
      if (psz1 = strchr(szLineBuf, '\n'))
         *psz1 = '\0';
      if (psz1 = strchr(szLineBuf, '\r'))
         *psz1 = '\0';

      // any indication for an error or warning?
      // if (!strstr(szLineBuf, "err") && !strstr(szLineBuf, "warn")) {
      //    // no: skip input, copy-through if required
      //    if (bMixMappedWithUnmappedOutput)
      //       printf("] %s\n", szLineBuf);
      //    continue;
      // }

      // map every potential path info to our path char
      while (psz1 = strchr(szLineBuf, glblWrongPChar))
         *psz1 = glblPathChar;

      // calc line number of first target's :create
      ulong nBaseLine = 0;
      nBaseLine += 5;            // header before index
      nBaseLine += nClTargets;   // index lines
      nBaseLine += 2;            // header after index

      // fix: if notes-begin given, count this section as well
      if (nClNotes > 0)
         nBaseLine += 3 + nClNotes;

      // now search for matching patch expressions
      char *pszHit = 0;
      TextFile *pTarget = 0;
      char *pszTargName = 0;
      for (long i=0; i<nClTargets && !pszHit; i++) {
         nBaseLine++; // skip :create, now on 1st line of content
         pTarget = apClTargets[i];
         pszTargName = pTarget->getFileName();
         if (!(pszHit = strstr(szLineBuf, pszTargName))) {
            // adjust line start number within index
            nBaseLine += pTarget->numberOfLines();
            nBaseLine += 2; // skip :done and blank line
         }
      }

      char szLineNum[100];
      ulong iLineNum =  0;
      ulong iMaxSeek = 10; // search a max. of 10 chars for line number, past filename
      if (pszHit) {
         // a filename from the cluster appeared.
         // can we identify a line number nearby behind?
         for (char *psz2 = pszHit+strlen(pszTargName);
              *psz2 && (iLineNum < sizeof(szLineNum)-10) && (iMaxSeek-- > 0);
              psz2++)
         {
            if (*psz2 >= '0' && *psz2 <= '9')
               szLineNum[iLineNum++] = *psz2;
            else
            if (iLineNum > 0) // end of number stream
               break;
         }
      }
      szLineNum[iLineNum] = '\0';

      if ((iLineNum > 0) && pTarget && pszTargName) 
      {
         // dump mapped output.
         printf("* %s\n", szLineBuf);
         // it seems we have a filename and a line number.
         ulong aRelLine = (ulong)atol(szLineNum);
         printf("* ===> %s %u\n", getFileName(), nBaseLine+aRelLine);
         // if this is the first hit, exec optional command
         if (nMaps==0 && pszCmd!=0) {
            sprintf(szLineBuf2, "%s %s %d", pszCmd, getFileName(), nBaseLine+aRelLine);
            // printf("RUN: %s\n", szLineBuf2);
            int iRC = system(szLineBuf2);
            if (iRC) { perr("unable to run: %s, rc %d\n", szLineBuf2, iRC); }
         }
         nMaps++;
      }
      else 
      if (bMixMappedWithUnmappedOutput)
      {
         // copy-through compiler output
         printf("] %s\n", szLineBuf);
      }
   }
   // printf("] %u mappings for %s, %u lines\n", nMaps, getFileName(), nLine);
}

long SnapShot::hasTarget(char *pszTargetName) {
   for (long i=0; i<nClTargets; i++) {
      TextFile *pTarget = apClTargets[i];
      if (!strcmp(pTarget->getFileName(), pszTargetName))
         return 1;
   }
   return 0;
}

long SnapShot::dropTarget(char *pszFileName) {
   // remove from list of targets
   long i2, bDone=0;
   for (i2=0; i2<nClTargets; i2++) {
      TextFile *pTarget = apClTargets[i2];
      if (!strcmp(pTarget->getFileName(), pszFileName)) {
         removeTargetEntry(i2);
         bDone = 1;
         break;
      }
   }
   if (!bDone) {
      pwarn("not in target list: %s\n", pszFileName);
      dumpTargets();
   }
   return 0;
}

void SnapShot::dumpTargets() {
   for (long i=0; i<nClTargets; i++)
      printf("... %s\n",apClTargets[i]->getFileName());
}

void SnapShot::setAllTouched() {
   for (long i=0; i<nClTargets; i++)
      apClTargets[i]->setTouched(1);
}

long SnapShot::removeTargetEntry(long n) {
   if (n >= nClTargets) return 9+perr("internal #53\n");
   delete apClTargets[n];
   for (long k=n; k<nClTargets-1; k++)
      apClTargets[k] = apClTargets[k+1];
   nClTargets--;
   // printf("[ dropped target entry %d, %d remaining ]\n", n, nClTargets);
   return 0;
}

long SnapShot::syncDownTargets(SnapShot &oMaster, long &rnSync)
{
   resetLastSync();

   if (nClTargets != oMaster.nClTargets)
      return 9+perr("target number differs (%s %d, %s %d)\n", oMaster.pszClID, oMaster.nClTargets, pszClID, nClTargets);

   long nSynced = 0;

   // on every difference to master, take master's target
   if (nClTargets != oMaster.nClTargets)
      return 9+perr("number of targets changed (%u %u)\n", nClTargets, oMaster.nClTargets);

   // we expect an absolutely identical list of targets, with same sequence
   for (long iTarg=0; iTarg<nClTargets; iTarg++) {
      TextFile *pMemTarget    = apClTargets[iTarg];
      TextFile *pMasterTarget = oMaster.apClTargets[iTarg];
      if (strcmp(pMemTarget->getFileName(), pMasterTarget->getFileName()))
         return 9+perr("change in target names or sequence:\n%s\n%s\n",pMemTarget->getFileName(), pMasterTarget->getFileName());
      // printf("[check: %s]\n",pMemTarget->getFileName());
      if (!pMemTarget->equals(pMasterTarget)) {
         // pre-check: is target writeable at all?
         if (!pMemTarget->isReadOnly()) {
            // on every difference, take master's target data
            // first, collect some difference stats
            long lSizeDiff = pMasterTarget->dataSize() - pMemTarget->dataSize(); 
            long lLineDiff = pMasterTarget->numberOfLines() - pMemTarget->numberOfLines(); 
            // printf("[internal-replace: %s]\n", oMaster.getFileName());
            TextFile *pDownClone = oMaster.apClTargets[iTarg]->clone();
            if (!pDownClone) return 9+perr("internal #11\n");
            delete apClTargets[iTarg];
            apClTargets[iTarg] = pDownClone;
            // and write down to file
            // printf("[write: %s]\n",pDownClone->getFileName());
            printf("[ WRITE: %s %s%d size %s%d lines]\n",
               padString(pDownClone->getFileName(), nClNamePadding),
               (lSizeDiff >= 0) ? "+":"", lSizeDiff,
               (lLineDiff >= 0) ? "+":"", lLineDiff
               );
            if (pDownClone->writeToFile())
               return 9;
            nSynced++;
            registerLastSync(pDownClone->getFileName());
         } else {
            // conflict: target is read-only
            printf("[ *!*!*: %s is READ-ONLY, will not write.]\n",
                  padString(pMemTarget->getFileName(), nClNamePadding)
               );
         }
      }
   }
   rnSync = nSynced;
   return 0;
}

long SnapShot::mirrorTargetsFrom(SnapShot &oMaster, long &nMissing)
{
   resetTargets("mirror");

   nClMaxTargets  = oMaster.nClMaxTargets;
   apClTargets    = new TextFile*[nClMaxTargets];
   nClTargets     = oMaster.nClTargets;

   long lMissing = 0;
   for (long iTarg=0; iTarg<nClTargets; iTarg++) 
   {
      TextFile *pMasterTarget = oMaster.apClTargets[iTarg];
      TextFile *pCopy = new TextFile(pMasterTarget->getFileName());
      apClTargets[iTarg] = pCopy;
      if (pCopy->loadFromFile()) {
         // fprintf(stderr, "[ -n/a-: %s\n", pCopy->getFileName());
         lMissing++;
      }
   }

   adjustNamePadding();

   nMissing = lMissing;
   return 0;
}

long SnapShot::syncUpTargets(SnapShot &oMaster, long &rnSynced) {
   long nSynced = 0;
   // on every difference to master, take master's target
   if (nClTargets != oMaster.nClTargets) return 9+perr("number of targets changed (%u %u)\n", nClTargets, oMaster.nClTargets);
   // we expect an absolutely identical list of targets, with same sequence
   for (long iTarg=0; iTarg<nClTargets; iTarg++) {
      TextFile *pMemTarget      = oMaster.apClTargets[iTarg];
      TextFile *pSnapFileTarget = apClTargets[iTarg];
      if (strcmp(pMemTarget->getFileName(), pSnapFileTarget->getFileName()))
         return 9+perr("change in target names or sequence:\n%s\n%s\n",pMemTarget->getFileName(), pSnapFileTarget->getFileName());
      if (!pMemTarget->isTouched())
         continue;
      pMemTarget->setTouched(0);
      // printf("[check: %s]\n",pMemTarget->getFileName());
      if (pMemTarget->equals(pSnapFileTarget)) {
         printf("[ NODIF: %s ]\n", pMemTarget->getFileName());
      } else {
         // on every difference, take master's target data
         long lSizeDiff = pMemTarget->dataSize() - pSnapFileTarget->dataSize();
         long lLineDiff = pMemTarget->numberOfLines() - pSnapFileTarget->numberOfLines();
         // printf("[internal-replace: %s]\n", oMaster.getFileName());
         TextFile *pUpClone = pMemTarget->clone();
         if (!pUpClone) return 9+perr("internal #30\n");
         delete apClTargets[iTarg];
         apClTargets[iTarg] = pUpClone;
         printf("[ READ : %s %s%d size %s%d lines]\n", 
            padString(pUpClone->getFileName(), nClNamePadding),
            (lSizeDiff >= 0) ? "+":"", lSizeDiff,
            (lLineDiff >= 0) ? "+":"", lLineDiff
            );
         nSynced++;
      }
   }
   // if any content really synced, re-write whole snapfile
   if (nSynced > 0) {
      // printf("[ WRITE: %s ]\n", getFileName());
      writeToFile();
   }
   rnSynced = nSynced;
   return 0;
}

long SnapShot::checkLoadTargets() {
   long lRC = 0;
   bool bReRun = false;
   do {
    bReRun = false;
    for (long iTarg=0; iTarg<nClTargets; iTarg++) {
      TextFile *pMemTarget = apClTargets[iTarg];
      long lStatRC = 0;
      if (lStatRC = pMemTarget->fileStatChanged()) {
         // printf("[ RELOAD: %s ]\n", pMemTarget->getFileName());
         if ((lStatRC==2) || pMemTarget->loadFromFile()) {
            // a target was probably deleted
            char *pszGoneFile = pMemTarget->getFileName();
            printf("[ DROP  : %s - file unreadable ]\n", pszGoneFile);
            // remove from both snapshots
            glblFileSnap.dropTarget(pszGoneFile);
            removeTargetEntry(iTarg);
            // must re-run our loop, iTarg's now invalid
            bReRun = true;
            lRC |= 2;
            break;
         } else {
            // file load succeded
            pMemTarget->setTouched(1);
            lRC |= 1;
         }
      }
    } // endfor
   }
   while (bReRun);
   return lRC;
}

void SnapShot::resetTargets(const char *pszInfo) 
{
   if (cs.debug) printf("%s reset tlist due to %s\n", pszClID, pszInfo);
   if (apClTargets) {
      for (long i=0; i<nClTargets; i++)
         delete apClTargets[i];
      delete [] apClTargets;
      apClTargets   = 0;
      nClMaxTargets = 0;
      nClTargets    = 0;
   }
}

long SnapShot::copyTargetsFrom(SnapShot &oSrc) 
{
   resetTargets("copy");
   nClMaxTargets = oSrc.nClMaxTargets;
   if (!(apClTargets = new TextFile*[nClMaxTargets]))
      return -1;
   nClTargets    = oSrc.nClTargets;
   for (long i=0; i<nClTargets; i++) {
      // printf("[cloning %s]\n",oSrc.apClTargets[i]->getFileName());
      if (!(apClTargets[i] = oSrc.apClTargets[i]->clone()))
         return -1;
   }
   // printf("[%d targets cloned]\n",nClTargets);
   return 0;
}

void SnapShot::setFileName(char *pszFileName) {
   pClFileName = strdup(pszFileName);
}

void SnapShot::setRootDir(char *pszDirName) {
   pClRootName = strdup(pszDirName);
}

long SnapShot::writeToFile() 
{
   if (!pClFileName || !pClRootName) 
      return 9+perr("missing filename, or root\n");

   FILE *fout = fopen(pClFileName, "w");

   if (!fout)
      return 9+perr("cannot write file: %s\n", pClFileName);

   fprintf(fout,
      "%s,build=%u\n\n"
      ":root %s\n\n",
      pszGlblClusterFileStamp,
      ++lClLastSavedBuild,
      pClRootName);

   // write notes, if any
   if (nClNotes > 0)
   {
      fprintf(fout, ":notes-begin\n");
      for (long i0=0; i0<nClNotes; i0++) {
         fprintf(fout, "%s\n", apNotes[i0]);
      }
      fprintf(fout, ":notes-end\n\n");
   }

   // write target index
   fprintf(fout, ":# ----- %d target files -----\n", nClTargets);
   for (long i1=0; i1<nClTargets; i1++) {
      TextFile *pTarget = apClTargets[i1];
      if (pTarget->isReadOnly())
         fprintf(fout, ":READ %s\n", pTarget->getFileName());
      else
         fprintf(fout, ":edit %s\n", pTarget->getFileName());
   }
   fprintf(fout, ":# ----- target index end -----\n\n");
   
   // write all targets
   for (long i2=0; i2<nClTargets; i2++) {
      TextFile *pTarget = apClTargets[i2];
      fprintf(fout, ":create %s\n", pTarget->getFileName());
      pTarget->dumpTo(fout); // writes line by line, with guranteed LF at end
      fprintf(fout, ":done\n\n");
   }

   // write epilogue
   fprintf(fout, ":cluster-end\n");

   fclose(fout);
   return 0;
}

long SnapShot::readFromFile(long &rbDroppedAny, long bForceBuildMatch) 
{
   resetTargets("read");
   resetNotes();

   if (!pClFileName) return 9+perr("missing filename, or root\n");

   char *pszRaw = 0;
   long lRetryCnt = 0;
   long lOldLen  = -1;
   long lOldBail = 0;
   while (true)
   {
      // load snapfile in one block
      pszRaw = loadFile(pClFileName);
      if (!pszRaw) return 9;
   
      // NOTE: if the editor is writing to the cluster RIGHT NOW,
      //       we get incomplete data. therefore:
      if (   !strstr(pszRaw, ":cluster-end\n")
          && !strstr(pszRaw, ":cluster-end\r\n")
         ) 
      {
         // keep some compat to old-format clusters:

         // direct revision check, if available
         if (!strncmp(pszRaw, ":cluster sfk,1.0,", strlen(":cluster sfk,1.0,"))) {
            printf("info : old-format cluster detected, loaded.\n");
            printf("info : please add \":cluster-end\" line at end of file.\n");
            break;
         }

         // if size doesn't change over 3 sec, load although
         long lNewLen = strlen(pszRaw);
         if (lOldLen == lNewLen) {
            if (++lOldBail >= 3) {
               printf("info : probably old-format cluster, loaded.\n");
               printf("info : please add \":cluster-end\" line at end of file.\n");
               break;
            }
         }
         lOldLen = lNewLen;

         // else drop current load, retry
         delete [] pszRaw;
         lRetryCnt++;
         printf("info : cluster probably locked, retrying (%d) \r", lRetryCnt);
         fflush(stdout);
         doSleep(1000);
      }
      else
      {
         if (lRetryCnt) printf("info : cluster read completed.               \n");
         break; // full load done, continue
      }
      if (userInterrupt())
         return 9;
   }

   long lRawSize = strlen(pszRaw);
   if (lRawSize < 100) return 9+perr("insufficient bytes from %s, %u\n", pClFileName, lRawSize);

   // pass 1: parse control block, build target index
   char *psz1 = pszRaw;

   long nIndexSize = 0;
   char **apIndex  = 0;
   long nIndexUsed = 0;

   rbDroppedAny = 0;
   bool bWithinNotes = 0;

   while (psz1)
   {
      // printf("] \"%.10s\"\n", psz1);

      // fetch another control line
      char *psz2 = strchr(psz1, '\n');
      if (psz2)
      {
         char *pszContinue = psz2+1;
         int nLineLen = psz2 - psz1;
         if (nLineLen > MAX_LINE_LEN) nLineLen = MAX_LINE_LEN;
         strncpy(szLineBuf, psz1, nLineLen);
         szLineBuf[nLineLen] = '\0';
         // finish control line
         char *pszCR = strchr(szLineBuf, '\r');
         if (pszCR) *pszCR = '\0';

         // parse control line
         if (!strcmp(szLineBuf, ":notes-begin")) {
            bWithinNotes = true;
         }
         else
         if (bWithinNotes) {
            if (!strcmp(szLineBuf, ":notes-end")) {
               bWithinNotes = false;
            }
            else
               addNotesLine(szLineBuf);
         }
         else
         if (!strncmp(szLineBuf, ":cluster ", strlen(":cluster "))) 
         {
            // process header line
            char *psz1 = strstr(szLineBuf, ",build=");
            if (psz1) {
               // verify if user forgot to reload the fileset
               psz1 += strlen(",build=");
               long lFileBuild = atol(psz1);
               if (bForceBuildMatch) {
                  if (lFileBuild != lClLastSavedBuild) {
                     printf("[ ERROR: YOU FORGOT TO RELOAD THE CLUSTER, AND TRY TO SAVE CHANGES !! ]\n");
                     return 9;
                  }
               } else {
                  lClLastSavedBuild = lFileBuild;
               }
            }
            // retrieve revision from ":cluster sfk,1.0,prefix=:"
            char *psz2 = strstr(szLineBuf, "sfk,");
            if (psz2) {
               // so far, there are just a few possible revisions
               psz2 += strlen("sfk,");
               if (!strncmp(psz2, "1.0,", strlen("1.0,")))
                  lClLoadedRevision = 0x010000;
               else
               if (!strncmp(psz2, "1.0.7,", strlen("1.0.7,")))
                  lClLoadedRevision = 0x010007;
               else
               if (!strncmp(psz2, "1.1,", strlen("1.1,")))
                  lClLoadedRevision = 0x010100;
               else
               {
                  static bool bWarned = 0;
                  if (!bWarned) {
                     bWarned = 1;
                     fprintf(stderr, "warn : cluster syntax may be too new for this sfk.\n");
                     lClLoadedRevision = 0x010100;
                  }
               }
            }
            // if (cs.debug) printf("fetched :cluster\n");
         }
         else
         if (!strncmp(szLineBuf, ":root ", strlen(":root "))) {
            // verify root of cluster
            char *pszTmpRoot = &szLineBuf[strlen(":root ")];
            if (!pClRootName) return 9+perr("internal #50\n");
            if (strcmp(pszTmpRoot, pClRootName)) return 9+perr("root mismatch: make sure you are within the directory: %s\n", pszTmpRoot);
            // if (cs.debug) printf("fetched :root\n");
         }
         else
         if (   !strncmp(szLineBuf, ":edit ", strlen(":edit "))
             || !strncmp(szLineBuf, ":READ ", strlen(":READ "))
            ) 
         {
            // build temporary index table
            if (nIndexUsed == nIndexSize) {
               // expand table
               long nAddSize = (nIndexSize == 0) ? 2 : nIndexSize;
               long nNewSize = nIndexSize + nAddSize;
               char **apNew  = new char*[nNewSize+10];
               if (nIndexUsed > 0)
                  memcpy(apNew, apIndex, sizeof(char*) * nIndexUsed);
               delete [] apIndex;
               apIndex    = apNew;
               nIndexSize = nNewSize;
               // printf("index expanded:\n");
               // for (long i=0; i<nIndexUsed; i++)
               //    printf("   %s\n", apIndex[i]);
            }
            // add next entry, INCLUDING the :edit or :READ statement!
            apIndex[nIndexUsed++] = strdup(szLineBuf);
            // printf("add-index %s\n",szLineBuf);
         }
         else
         if (!strncmp(szLineBuf, ":# ", strlen(":# "))) {
            // todo: store user comments
         }
         else
         if (!strncmp(szLineBuf, ":create ", strlen(":create "))) {
            // end of control block is marked by first target content, if any
            pszContinue = 0;
         }
         psz1 = pszContinue;
      } else {
         if (strlen(psz1) > 10) {
            perr("unexpected content in %s:\n", pClFileName);
            fprintf(stderr, "\"%.100s\"\n", psz1);
            return 9;
         }
         psz1 = 0;
      }
   }  // endwhile psz1

   long lPreFix  = strlen(":edit "); // and :READ

   // pass 2: isolate target contents
   psz1 = pszRaw;
   while (psz1) 
   {
      char *psz2 = strstr(psz1, "\n:create ");
      if (psz2)
      {
         // found another :create, isolate target name
         char *pszTargetName = psz2 + strlen("\n:create ");
         char *psz3 = strchr(pszTargetName, '\n');
         if (!psz3) return 9+perr("wrong syntax: \"%.100s\"\n", pszTargetName);
         *psz3++ = '\0'; // remove and skip LF, go to start of content
         char *psz3b = strchr(pszTargetName, '\r');
         if (psz3b) *psz3b = '\0'; // remove possible CR
         // printf("create %s\n", pszTargetName);

         // find end of content
         char *pszContentBegin = psz3;
         char *pszDone = strstr(pszContentBegin, "\n:done\n");
         if (!pszDone) pszDone = strstr(pszContentBegin, "\n:done\r\n");
         if (!pszDone) return 9+perr("missing :done after :create in %s\n\"%.100s\"\n",pszTargetName,pszContentBegin);
         char *pszContentEnd = pszDone+1;
         *pszContentEnd = '\0'; // set end of content, including last LF
         char *pszContinue = pszContentEnd+1; // not perfect, but simple

         // is target listed in index?
         bool bInIndex  = 0;
         bool bReadOnly = 0;
         for (long i=0; i<nIndexUsed; i++)
            if (!strcmp(&apIndex[i][lPreFix], pszTargetName)) {
               bInIndex = 1;
               // check if it's read-only
               if (!strncmp(apIndex[i], ":READ ", strlen(":READ ")))
                  bReadOnly = 1;
               // and immediately mark index entry as used
               char *psz1 = &apIndex[i][lPreFix];
               *psz1 = '\0';
               break;
            }

         if (bInIndex) {
            // create Target entry and add
            TextFile *pTarget = new TextFile(pszTargetName);
            if (pTarget->createFromMemory(pszContentBegin))
               return 9;
            pTarget->setReadOnly(bReadOnly);
            if (addTarget(pTarget)) {
               printf("RFF returns 9.1\n");
               return 9;
            }
         } else {
            // drop target, by not loading
            printf("[ DROP : %s ] %.20s\n", pszTargetName, pszGlblBlank);
            // at mem snapshot as well
            // NOTE: if user forgot to reload snapfile, target
            //       was already dropped before at mem-snap.
            if (glblMemSnap.hasTarget(pszTargetName))
               glblMemSnap.dropTarget(pszTargetName);
            else
               printf("[ WARN : reload the cluster! ] %.20s\n", pszTargetName, pszGlblBlank);
            rbDroppedAny = 1;
         }

         // continue in snapfile
         psz1 = pszContinue;
      }
      else 
      {
         // last :done, with :cluster-end
         if (strlen(psz1) > (strlen("done\r\n\n:cluster-end\r\n")+5)) {
            fprintf(stderr, "warn : unexpected content in %s:\n", pClFileName);
            fprintf(stderr, "\"%.100s\"\n", psz1);
            // return 9;
         }
         psz1 = 0;
      }
   }

   // pass 3: add all files of index not yet in snapfile
   for (long i5=0; i5<nIndexUsed; i5++) 
   {
      if (strlen(&apIndex[i5][lPreFix])) 
      {
         char *pszTargetName = &apIndex[i5][lPreFix];
         if (fileExists(pszTargetName)) 
         {
            // create and load to file-snap
            TextFile *pTarget = new TextFile(pszTargetName);
            if (pTarget->loadFromFile()) {
               // loading failed, e.g. due to keywords contained
               printf("[ SKIP : %s ] %.20s\n", pszTargetName, pszGlblBlank);
               delete pTarget;
            } else {
               // loading ok: add to file snapshot (this)
               printf("[ ADD  : %s ] %.20s\n", pszTargetName, pszGlblBlank);
               if (addTarget(pTarget)) {
                  printf("RFF returns 9.3\n");
                  return 9;
               }
               // and add to mem-snap
               TextFile *pClone = pTarget->clone();
               glblMemSnap.addTarget(pClone);
               // tell caller have to reload
               rbDroppedAny = 1;
            }
         } else {
            printf("[ ERROR: %s ] no such file\n", pszTargetName);
         }
      }
   }

   // pass 4: cleanup
   if (apIndex && (nIndexSize > 0)) {
      for (long i=0; i<nIndexUsed; i++)
         delete [] apIndex[i]; // char array
      delete [] apIndex;
   }

   adjustNamePadding();

   // all done, free temporary stuff
   delete [] pszRaw;

   // printf("%s re-read, %u targets\n", pszClID, numberOfTargets());
   if (numberOfTargets() < 1) return 9+perr("no targets found after cluster re-read\n");

   return 0;
}

void SnapShot::expandTargets(long lSoMuch) {
   // printf("[expand target array from %d to %d]\n",nClMaxTargets,nClMaxTargets+lSoMuch);
   TextFile **apTmp = new TextFile*[nClMaxTargets+lSoMuch];
   if (apClTargets) {
      memcpy(apTmp, apClTargets, nClMaxTargets*sizeof(TextFile*));
      delete [] apClTargets;
   }
   apClTargets = apTmp;
   nClMaxTargets += lSoMuch;
}

long SnapShot::addTarget(char *pszFileName) {
   // create new target entry and add
   TextFile *pTarget = new TextFile(pszFileName);
   long lRC = pTarget->loadFromFile();
   if (lRC == 1) {
      delete pTarget;
      return 0;
   }
   if (lRC > 1) {
      if (cs.debug) printf("SAT returns 9\n");
      delete pTarget;
      return 9;
   }
   return addTarget(pTarget);
}

long SnapShot::addTarget(TextFile *pTarget) {
   // is array still large enough? if not, expand
   if (nClTargets > nClMaxTargets-2)
      if (nClMaxTargets==0)
         expandTargets(100);
      else
         expandTargets(nClMaxTargets);
   // add new target entry
   apClTargets[nClTargets++] = pTarget;
   // update statistics
   adjustNamePadding();
   return 0;
}

void SnapShot::adjustNamePadding() {
   // determine max length over all filenames, calc a padding value
   long lMaxLen = 20; // always at least this minimum
   for (long iTarg=0; iTarg<nClTargets; iTarg++) {
      char *psz1 = apClTargets[iTarg]->getFileName();
      long lLen  = strlen(psz1);
      if (lLen > lMaxLen)
          lMaxLen = lLen;
   }
   if (lMaxLen > 20)
       lMaxLen = 20;
   lMaxLen = (lMaxLen / 5) * 5; // force alignment
   nClNamePadding = lMaxLen;
}
#endif // USE_SFK_BASE

// used by matchesName only to check .ext dir masks
bool dirExtEndMatch(char *pszHay, char *pszPat)
{
   // hay1: ".svn/"
   // pat1: ".svn"
   // pat2: ".svn/"
   long npatlen = strlen(pszPat);
   if (npatlen < 1) return 0; // shouldn't happen
   // case ".svn/" == ".svn/"
   if (pszPat[npatlen-1] == glblPathChar)
      return mystricmp(pszHay, pszPat) ? 0 : 1;
   // pat differs in length to hay,
   // case ".svn/" == ".svn"
   long nhaylen = strlen(pszHay);
   if (nhaylen != npatlen+1)
      return 0;
   if (mystrnicmp(pszHay, pszPat, npatlen))
      return 0;
   if (pszHay[npatlen] != glblPathChar)
      return 0;
   return 1;
}

bool matchesName(char *pszStr, char *pszMask,
   bool *rPartMatch = 0, long nFlags = 0,
   long *pHitPos = 0, long *pHitLen = 0
   )
{
    // printf("\nmname %s %s\n",pszStr,pszMask);

    // flags, bit 0: DISABLE start of name comparison
    bool bEnableSNC = ((nFlags & 1) == 0);

    // flags, bit 1: PATH matching mode i/o FILE.
    bool bPathMatch =  (nFlags & 2) ? 1 : 0;

    // flags, bit 2: matchesDirMask mode, no ".ext" comparison.
    bool bMDirMask = (nFlags & 4) ? 1 : 0;

    //  foo         -> thefoosys.txt
    //  *foo*bar*   -> thefooanybar.txt
    //  .txt        -> only .txt files
    //  !.txt       -> all except .txt files
    //  * anywhere  -> ignore . position

    if (rPartMatch) *rPartMatch = false;

    szMatchBuf[0] = '\0';

    long nMinHitPos = -1;
    long nMaxHitLen =  0;

    char *pstr1  = pszStr;
    char *pmsk1  = pszMask;
    char *pmsk2  = pmsk1;
    bool  bneg   = 0;
    bool  bimt   = true; // inner match
    long  nmpos  = 0;
    long  nlen   = 0;
    bool  bwild2 = 0;

    while (*pmsk1) 
    {
        char c = *pmsk1;
        bool bIsLastChr = (*(pmsk1+1) == '\0');

        // initial negation
        if (!nmpos && (c == glblNotChar))
            { bneg=1; pmsk1++; pmsk2=pmsk1; nmpos++; continue; }
        nmpos++;

        // identify tokens between *
        bool bwild = isWildChar(c); // checks for *, but not ?
        if (bwild || bIsLastChr) 
        {
            // have mask part from pmsk2 to pmsk1-1
            nlen = pmsk1 - pmsk2;
            if (!bwild) nlen++; // do not exlude * then

            // "*" as first character of mask?
            if (nlen <= 0) { 
               if (bPathMatch) {
                  pmsk1++; pmsk2=pmsk1; bwild2=1; continue;
               } else {
                  pmsk1++; pmsk2=pmsk1; continue;
               }
            }

            // have mask part from pmsk2 with length nlen
            if (nlen > MAX_MATCH_BUF-2) {
               if (cs.verbose >= 3) printf("0 = MATCH (msk %.100s, str %s) r2\n",pmsk2,pszStr);
               return false;
            }
            memcpy(szMatchBuf, pmsk2, nlen);
            szMatchBuf[nlen] = '\0';
            if (cs.verbose >= 4) printf("PART %s neg %d\n", szMatchBuf, bneg);

            // special case ".ext" part at end of mask?
            if (!bwild && !bwild2 && szMatchBuf[0] == '.') 
            {
                // compare mask: szMatchBuf e.g. ".1.txt"
                // against end of: pstr1    e.g. "foo.1.txt"
                int nMaskLen = strlen(szMatchBuf);
                int nNameLen = strlen(pstr1);

                // FIX: R157: no longer use strrchr(pstr1, '.')
                char *psz5 = 0;
                if (nMaskLen <= nNameLen) {
                   psz5 = pstr1 + nNameLen - nMaskLen;
                   if (*psz5 != '.') psz5 = 0;   
                }

                bool bmatch1 = false;
                if (!psz5)
                    bmatch1 = false;
                else
                if (bMDirMask)
                    bmatch1 = dirExtEndMatch(psz5, szMatchBuf);
                else
                    bmatch1 = !mystricmp(psz5, szMatchBuf);
                if (bmatch1 && rPartMatch) *rPartMatch = true;
                // final match decision by extension:
                if (cs.verbose >= 3) printf("%d = MATCH (msk %s, str %s) %d^%d r3\n",bneg^bmatch1,szMatchBuf,pszStr,bneg,bmatch1);
                return bneg ^ bmatch1;
            }

            long nHitPos = 0;

            // string cursor is pstr1
            bool bmatch2 = false;

            #ifdef SFK_STRICT_MATCH
            // on first mask part, if it's not an extension:
            if (pmsk2 == pszMask && szMatchBuf[0] != '.') {
               // start of name comparison:
               if (mystrstriq(pstr1, szMatchBuf, &nHitPos))
                  if (nHitPos == 0) {
                     if (bwild || (strlen(pstr1+nHitPos) == strlen(szMatchBuf)))
                     {
                        bmatch2 = true;
                     }
                  }
            }
            #else
            if (bEnableSNC && (szMatchBuf[0] == glblPathChar) && (szMatchBuf[1] != '\0')) {
               // start of name comparison:
               if (mystrstriq(pstr1, &szMatchBuf[1], &nHitPos))
                  if (nHitPos == 0) {
                     bmatch2 = true;
                     if (pHitPos) {
                        nMinHitPos = 0;
                        nMaxHitLen = strlen(&szMatchBuf[1]);
                     }
                  }
            }
            #endif
            else 
            {
               // normal within-name comparison:
               if (mystrstriq(pstr1, szMatchBuf, &nHitPos)) {
                   // part matches:
                   #ifdef SFK_STRICT_MATCH
                   if (bwild || (strlen(pstr1+nHitPos) == strlen(szMatchBuf)))
                   {
                   #endif
                   if (rPartMatch) *rPartMatch = true;
                   if (cs.verbose >= 4) printf("CHK0 bneg %d (msk %s,str %s)\n",bneg,szMatchBuf,pszStr);
                   // if (bneg) return false;
                   // else continue, no mismatch yet.
                   if (pHitPos) {
                      long nAbsPos1 = (pstr1-pszStr)+nHitPos;
                      if (nMinHitPos < 0) nMinHitPos = nAbsPos1;
                      long nAbsPos2 = nAbsPos1 + strlen(szMatchBuf);
                      nMaxHitLen = nAbsPos2 - nMinHitPos;
                   }
                   // have to step past hit in string.
                   pstr1 += nHitPos + strlen(szMatchBuf);
                   pmsk1++; pmsk2=pmsk1;
                   continue;
                   #ifdef SFK_STRICT_MATCH
                   }
                   #endif
               }
               // else fall through, bmatch2 hasn't been raised.
            }

            if (!bmatch2)
            {
                // part mismatch:
                bimt = false; // no inner match
                if (!bneg) {
                   if (cs.verbose >= 3) printf("0 = MATCH (msk %s, str %s) r4\n",szMatchBuf,pszStr);
                   return false;
                }
                if (cs.verbose >= 4) printf("CHK2 bneg %d (msk %s,str %s)\n",bneg,szMatchBuf,pszStr);
                // else continue, no negation match yet
                // e.g. "!the*foo" over "bigtest.txt";
                // do not step pstr1 at all.
                if (cs.verbose >= 4) printf("CNT2 bneg %d\n",bneg);
                pmsk1++; pmsk2=pmsk1; continue;
            } else {
                pmsk1++; pmsk2=pmsk1; continue;
            }
        }
        // continue on characters within tokens
        pmsk1++;
    }
    // the string past "!" (if any) matches:
    if (cs.verbose >= 3) printf("%d = MATCH (msk \"%s\", str \"%s\") %d^%d\n",bimt^bneg,szMatchBuf,pszStr,bimt,bneg);
    bool brc = bimt ^ bneg;
    if (brc && pHitPos && (nMinHitPos >= 0) && (nMaxHitLen > 0)) {
       if (pHitPos) *pHitPos = nMinHitPos;
       if (pHitLen) *pHitLen = nMaxHitLen;
    }
    return brc;
}

long matchesFileMask(char *pszStr, char *pszInfoAbsName=0)
{
   long lMatched = 0;
   bool bPart    = 0;
   char *pszPart = 0;
   char *pszInfo = pszInfoAbsName ? pszInfoAbsName : pszStr;

   long nPosMasks = 0;
   long nPosHits  = 0;

   Array &rMasks = glblFileSet.fileMasks();
   for (int i=0; rMasks.isStringSet(i); i++) 
   {
      char *pszMask = rMasks.getString(i);

      if (isWildStr(pszMask)) {
         lMatched |= 0x1;
         continue;
      }

      if (pszMask[0] == glblNotChar) {
         if (matchesName(pszStr, pszMask+1)) {
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceExcColor);
               info.print("file-exclude: %s due to \"%s\"\n", pszInfo, pszMask);
               setTextColor(-1);
            }
            return 0; // negative mask hit
         }
         continue;
      }

      // positive mask check:
      nPosMasks++;
      if (matchesName(pszStr, pszMask, &bPart)) {
         lMatched |= 0x2;
         pszPart   = pszMask;
         nPosHits++;
      }
   }

   // if special mode AND mask check is set:
   if (cs.fileMaskAndMatch) {
      if (nPosMasks > 0 && nPosHits < nPosMasks) {
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceExcColor);
            info.print("file-exclude: %s [no AND match, %ld/%ld]\n", pszInfo, nPosHits, nPosMasks);
            setTextColor(-1);
         }
         return 0;
      }
   }

   if (nGlblTraceSel & 2) {
      if (lMatched) {
         setTextColor(nGlblTraceIncColor);
         if (pszPart)
            info.print("file-include: %s due to \"%s\"\n", pszInfo, pszPart);
         else
            info.print("file-include: %s\n", pszInfo);
         setTextColor(-1);
      } else {
         setTextColor(nGlblTraceExcColor);
         info.print("file-exclude: %s\n", pszInfo); // probably not reached
         setTextColor(-1);
      }
   }

   return lMatched;
}

// NOTE: although both matchesDirMask and matchesPathMask
//       use dirMasks(), they do NOT influence each other:
// => matchesDirMask  only checks against "+" and "!" masks
// => matchesPathMask only checks against "*" masks

// check done per directory: does dirname match?
bool matchesDirMask(char *pszStr, bool bQuiet)
{
   // deprecated:
   //    if '+' masks are given, all dirs are excluded
   //    except those matching the masks.
   //    if no '+' are given, all dirs are included
   //    except those matching negative masks.
   bool lRC = bGlblHavePlusDirMasks ? 0 : 1;
   // ... should always be 1 initially.

   Array &rMasks = glblFileSet.dirMasks();
   for (int i=0; rMasks.isStringSet(i); i++) 
   {
      char *pszMask = rMasks.getString(i);
      if (pszMask[0] == glblNotChar)
      {
         mtklog("mdm: check neg mask: %s %s", pszMask, pszStr);
         // ,5: disable start-of-name comparison AND disable 
         //     the .extension comparison (the latter would
         //     never work as pszStr ends with slash).
         if (matchesName(pszStr, pszMask+1, 0, 5)) {
            if (!bQuiet && (nGlblTraceSel & 1)) {
               setTextColor(nGlblTraceExcColor);
               info.print("dir-exclude : %s due to \"%s\"\n", skipDotSlash(pszStr), pszMask);
               setTextColor(-1);
            }
            mtklog("mdm: 0, neg mask hit: %s %s", pszMask, pszStr);
            return 0;
         } else {
            if (cs.verbose >= 4) printf("1 = MDSB (msk %s, str %s)\n", pszMask, pszStr);
            mtklog("mdm: neg mask miss %s %s", pszMask, pszStr);
         }
      }
      else
      if (pszMask[0] == '+')
      {
         if (mystrstriq(pszStr, pszMask+1))
            lRC = 1; // but continue checking for negative masks
      } else {
         mtklog("mdm: skip wild mask: %s %s (checked later)", pszMask, pszStr);
         lRC = 1; // mask with wildcards: NOT used here, but in matchesPathMask()
      }
   }

   if (!bQuiet && (nGlblTraceSel & 1)) {
      if (lRC) {
         setTextColor(nGlblTraceIncColor);
         info.print("dir-include : %s\n", skipDotSlash(pszStr));
         mtklog("mdm: include %s", pszStr);
      } else {
         setTextColor(nGlblTraceExcColor);
         info.print("dir-exclude : %s\n", skipDotSlash(pszStr));
         mtklog("mdm: exclude %s", pszStr);
      }
      setTextColor(-1);
   }

   mtklog("mdm: %ld for %s", lRC, pszStr);

   return lRC;
}

// check done per filename: does the file path match?
bool matchesPathMask(char *pszFilename)
{
   long nPosMasks = 0;
   long nPosHits  = 0;

   // isolate path from filename
   static char szPathBuf[500];
   strcopy(szPathBuf, pszFilename);
   if (!cs.incFNameInPath) {
      char *psz = strrchr(szPathBuf, glblPathChar);
      // terminate AFTER slash, allowing for more
      // checks against last element of path:
      if (psz) *++psz = '\0';
   }
   char *pszPath = szPathBuf;

   Array &rMasks = glblFileSet.dirMasks();
   for (int i=0; rMasks.isStringSet(i); i++)
   {
      char *pszMask = rMasks.getString(i);
      if (pszMask[0] == glblNotChar) {
         // also check neg masks, in case it wasn't done in walkFiles.
         if (matchesName(pszPath, pszMask+1, 0, 3)) { // ,3: no start-of-name + cmp-path
            // negative mask hit:
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceExcColor);
               info.print("path-exclude: %s [due to %s]\n", pszPath, pszMask);
               setTextColor(-1);
            }
            mtklog("mpm: 0, neg mask hit: %s", pszFilename);
            return 0;
         }
      }
      else
      if (pszMask[0] == '+') { }
      else
      {
         // mask with wildcards.
         nPosMasks++;
         if (matchesName(pszPath, pszMask, 0, 3)) { // ,3: no start-of-name + cmp-path
            nPosHits++;
            // continue processing as neg masks may follow.
         }
      }
   }

   // if special mode AND mask check is set:
   if (cs.pathMaskAndMatch) {
      if (nPosMasks > 0 && nPosHits < nPosMasks) {
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceExcColor);
            info.print("path-exclude: %s [no AND match, %ld/%ld]\n", pszPath, nPosHits, nPosMasks);
            setTextColor(-1);
         }
         mtklog("mpm: 0, no matches: %s", pszFilename);
         return 0;
      }
   }

   if (!nPosMasks) {
      mtklog("mpm: 1, no pos masks: %s", pszFilename);
      return true;
   }

   if (nPosHits) {
      mtklog("mpm: 1, pos hits: %s", pszFilename);
      return true;
   }

   mtklog("mpm: 0, default: %s", pszFilename);
   return false;
}

void padBuffer(char *pszBuf, long nMaxLen, char c, long nTargLen)
{
   long nlen = strlen(pszBuf);
   if (nlen < nTargLen) {
      long ndif = nTargLen-nlen;
      if (nlen+ndif < nMaxLen) {
         memset(pszBuf+nlen, c, ndif);
         pszBuf[nlen+ndif] = '\0';
      }
   }
}

long execGrep(Coi *pcoi) 
{__
   bool isBinaryFile(char *pszFile);

   info.setAddInfo("%lu files, %lu dirs", cs.filesScanned, cs.dirsScanned);
   info.setStatus("scan ", pcoi->name(), 0, eKeepAdd);

   bool bBinGrep = bGlblBinGrep;
 
   if (bGlblBinGrepAutoDetect)
   {
      bBinGrep = pcoi->isBinaryFile();
   }
  
   if (bBinGrep)
   {
      if (pcoi->open("rb"))
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      cs.filesScanned++;
  
      BinTexter bt(pcoi);
      bt.process(BinTexter::eBT_Grep);
  
      pcoi->close();
   }
   else
   {
      // this is only reached with "-text" option specified.
      // we're using TEXT MODE and fgets BY INTENTION.
      // on the first NULL or EOF byte, the scanning will stop.
  
      if (pcoi->open("r")) // TEXT only read mode
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      cs.filesScanned++;

      long nMaxLineLen = sizeof(szLineBuf)-10; // YES, szLineBuf
      memset(abBuf, 0, nMaxLineLen+2); // yes, abBuf is larger by far
   
      long nLocalLines = 0;
      long nMatchLines = 0;
      bool bDumpedFileName = 0;
      bool btold1 = 0;

      while (pcoi->readLine((char*)abBuf, nMaxLineLen) > 0) // yes, exact len
      {
         cs.lines++;
         nLocalLines++;
   
         if (!btold1 && (strlen((char*)abBuf) == nMaxLineLen)) {
            btold1 = 1;
            pwarn("max line length %d reached, splitting input line(s) in file %s\n", nMaxLineLen, pcoi->name());
         }
   
         removeCRLF((char*)abBuf);
   
         long nMatch = 0;
         long nGrepPat = glblGrepPat.numberOfEntries();
         for (long i=0; (nMatch < nGrepPat) && (i<nGrepPat); i++)
            if (mystrhit((char*)abBuf, glblGrepPat.getString(i), cs.usecase, 0))
               nMatch++;
   
         if (nMatch == nGrepPat) 
         {
            // found a matching file
            cs.anymatches = 1;

            if (chain.colfiles) {
               // filenames only, as filename chain
               // TODO: set root here as glblFileSet.root()?
               chain.addFile(*pcoi); // is copied
               break;
            }

            if (cs.useJustNames) {
               nMatchLines++;
               // if counting matches, continue until end of file.
               if (cs.countMatchLines)
                  continue;
               // fall through to printing of filename.
               break;
            }

            // actually dump the content:

            // list filename first
            if (!bDumpedFileName && !cs.nonames && !cs.pure) {
               bDumpedFileName = 1;
               if (chain.coldata) {
                  sprintf(szLineBuf2, ":file %s", pcoi->name());
                  // note: +view scans extended end of attribute line
                  //       to identify 'f'ile header lines, therefore +2:
                  setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
                  chain.addLine(szLineBuf2, szAttrBuf2);
               } else {
                  setTextColor(nGlblFileColor);
                  info.print("%s :\n", pcoi->name());
                  setTextColor(-1);
               }
            }

            // list the line
            bool bdump2 = 0;
            if (bGlblGrepLineNum)
               { sprintf(szLineBuf2, "   %04lu ", nLocalLines); bdump2=1; }
            else
            if (!cs.pure)
               { sprintf(szLineBuf2, "   "); bdump2=1; }

            if (bdump2)
               if (chain.coldata) {
                  szAttrBuf2[0] = '\0';
                  padBuffer(szAttrBuf2, MAX_LINE_LEN, ' ', strlen(szLineBuf2));
                  chain.addToCurLine(szLineBuf2, szAttrBuf2, 0);
               } else {
                  info.print("%s", szLineBuf2);
               }

            char *pszTmp  = (char*)abBuf;
            long nAttrPad = strlen(pszTmp);
            if (nAttrPad > sizeof(szAttrBuf)-10)
                nAttrPad = sizeof(szAttrBuf)-10;

            memset(szAttrBuf, ' ', nAttrPad);
            szAttrBuf[nAttrPad] = '\0';

            for (long k=0; k<nGrepPat; k++) 
            {
               char *pszPat = glblGrepPat.getString(k);
               long nPatLen = strlen(pszPat);
               long nTmpLen = strlen(pszTmp);
               long nCur = 0, nRel = 0;
               while (mystrhit(pszTmp+nCur, pszPat, cs.usecase, &nRel)) 
               {
                  if (nCur+nRel+nPatLen < sizeof(szAttrBuf)-10)
                     memset(&szAttrBuf[nCur+nRel], 'i', nPatLen);
                  nCur += nRel+nPatLen;
                  if (nCur >= nTmpLen-1)
                     break;
               }
            }

            if (chain.coldata)
               chain.addLine((char*)abBuf, szAttrBuf);
            else
               printColorText((char*)abBuf, szAttrBuf);

         }  // endif all patterns match

      }  // endwhile fgets
   
      pcoi->close();

      if (cs.useJustNames && nMatchLines) {
         // filenames only, as text data, NOT prefixing
         // further text data, therefore NOT including ":file "
         if (chain.coldata) {
            if (cs.countMatchLines) {
               // do not pass file headers, but pure text
               sprintf(szLineBuf2, "%05ld : %s", nMatchLines, pcoi->name());
               setattr(szAttrBuf2, ' ', strlen(szLineBuf2), MAX_LINE_LEN);
            } else {
               sprintf(szLineBuf2, "%s", pcoi->name());
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
            }
            chain.addLine(szLineBuf2, szAttrBuf2);
         } else {
            if (cs.countMatchLines)
               info.print("%05ld : %s\n", nMatchLines, pcoi->name());
            else
               info.print("%s\n", pcoi->name());
         }
      }

   }  // endelse bingrep
 
   return 0;
}

CoiTable glblFileListCache;

long prtFile(char *pszPreInfo, char *pszRelName, Coi *pcoi, char *pszZip, long nFlags, const char *pszFormat, ...)
{__
   char *pszFilename = pszRelName;
   num nTime   = pcoi->getTime();
   num nSize   = pcoi->getSize();

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   char *pq = bGlblQuoted ? (char*)"\"" : (char*)"";

   bool bshowprog = 0;

   if (cs.listByTime || cs.listBySize || cs.listByName) {
      // remember string with metadata length prefix, for easier output formatting
      char cOrder = 0;
      if (cs.listByTime) cOrder = (cs.listByTime < 0) ? 't':'T';
      if (cs.listBySize) cOrder = (cs.listBySize < 0) ? 's':'S';
      if (cs.listByName) cOrder = (cs.listByName < 0) ? 'n':'N';
      int nLen = strlen(pszFilename);
      if (nLen > sizeof(szPrintBuf2)-100)
          nLen = sizeof(szPrintBuf2)-100;
      sprintf(szPrintBuf2, "%05u %s%s%.*s%s", strlen(szPrintBuf1), szPrintBuf1, pq,nLen,pszFilename,pq);
      pcoi->setExtStr(szPrintBuf2);
      if (glblFileListCache.addSorted(*pcoi, cOrder, cs.usecase))
         return 9;
      bshowprog = 1;
   }
   else
   if (cs.outfile) {
      // direct filename listing to an output file
      chain.print("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
      bshowprog = 1;
   }
   else
   if (chain.colfiles) {
      // chain mode: do not print files, collect them
      // if (pszZip)
      //    sprintf(szPrintBuf2, "%s%c%s", pszZip, glblPathChar, pszFilename);
      // else
      //    strcopy(szPrintBuf2, pszFilename);
      chain.addFile(*pcoi); // is COPIED
      bshowprog = 1;
   }
   else 
   {
      StringPipe *pout = 0;
      if (chain.coldata) {
         nFlags = 0; // no highlighting, just collect text
         pout = chain.outdata;
         bshowprog = 1;
      }

      // no sorted listing: try to highlight hidden files
      if (nFlags & 128) { // link
         setTextColor(nGlblLinkColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      } 
      else
      if (nFlags & 64) { // hidden
         setTextColor(nGlblFileColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      } 
      else
      if (nFlags & 4) { // added
         setTextColor(nGlblWarnColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      } 
      else
      if (nFlags & 1) { // time
         setTextColor(nGlblTimeColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      } 
      else {
         oprintf(pout, "%s%s%s%s%s\n", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
      }
   }

   // show progress info, if filenames are not printed
   // onto terminal, but redirected:
   if (bshowprog) {
      cs.filesScanned++;
      mtklog("prtfile.bshowprog=%d q=%d nhead=%d",bshowprog,cs.quiet,cs.nohead);
      if (!cs.quiet && !cs.nohead) {
         info.setAddInfo("%lu files", cs.filesScanned);
         info.setStatus("scan", pszFilename, 0, eKeepAdd);
      }
   }

   return 0;
}

char *sizeOrDir(num nSize, long nFlags)
{
   static char szInfo[200];
   long ndig = (ulong)nGlblListDigits;
   if (ndig < 1) ndig = 1;
   if (ndig > sizeof(szInfo)-10) ndig = sizeof(szInfo)-10;
   if (nFlags & 1) {
      sprintf(szInfo, "%*.*s",(int)ndig,(int)ndig,"[dir]");
   } else {
      strcpy(szInfo, numtoa_blank(nSize, ndig));
   }
   return szInfo;
}

long listSingleFile(long lLevel, Coi *pcoi, char *pszParentZip, bool bIsDir, long nSinceReason)
{__
   char *pszFileName = pcoi->name();
   num   nFileTime   = pcoi->getTime();
   num   nFileSize   = pcoi->getSize();

   const char *p1 = "";
   const char *p2 = "";

   char *pz = pszParentZip;
   num nt = nFileTime;
   num ns = nFileSize;

   long nf = 0; // flags
   if (bIsDir)
        nf |= 32;
   if (pcoi->isHidden())
        nf |= 64;
   if (pcoi->isLink())
        nf |= 128;

   char szSinceInfo[50];
   szSinceInfo[0] = '\0';
   if (!cs.pure) {
      if (nSinceReason & 2) { strcpy(szSinceInfo, "[dif] "); nf |= 2; }
      else
      if (nSinceReason & 1) { strcpy(szSinceInfo, "[tim] "); nf |= 1; }
      if (nSinceReason & 4) { strcpy(szSinceInfo, "[add] "); nf |= 4; }
   }
   char *ps = szSinceInfo;

   // RELATIVIZE FILENAME (OPTIONAL)
   char *pf = cs.rootrelname ? pcoi->rootRelName() : pszFileName;
   if (!pf) return 9;

   switch (nGlblListMode)
   {
      case 1:
         if (!cs.quiet && (nGlblListMinSize > 0))
         {
            long lMBytes = (long)(nFileSize / 1000000L);
            if (nFileSize >= nGlblListMinSize)
            {
               int nIndent = (int)lLevel;
               if (nIndent > (long)strlen(pszGlblBlank)) nIndent = strlen(pszGlblBlank);
               if (nIndent > 10) nIndent = 10;

               switch (cs.listunit) {
                  case 'b':
                     prtFile(ps,pf,pcoi,pz,nf, "%s,              %.*s%s%s", numtoa_blank(nFileSize, 12), nIndent, pszGlblBlank, p1,p2);
                     break;
                  case 'k':
                     prtFile(ps,pf,pcoi,pz,nf, "%s kb,              %.*s%s%s", numtoa_blank(nFileSize/1000, 10), nIndent, pszGlblBlank, p1,p2);
                     break;
                  default :
                     prtFile(ps,pf,pcoi,pz,nf, "%5ld mb,              %.*s%s%s", lMBytes, nIndent, pszGlblBlank, p1,p2);
                     break;
               }
            }
         }
         break;

      case 2:
         #ifndef _WIN32
         if (cs.traceFileFlags) {
            printf("t=%04lx m=%04lx l=%04lx ", pcoi->rawtype, pcoi->rawmode, pcoi->rawnlnk);
         }
         #endif
         switch (cs.listForm)
         {
            // plain filename, nothing else:
            case 0: prtFile(ps,pf,pcoi,pz,nf, "%s%s", p1,p2); break;
            // size and filename:
            case 1: prtFile(ps,pf,pcoi,pz,nf, "%s %s%s", sizeOrDir(nFileSize, nf), p1,p2); break;
            // time and filename:
            case 2: prtFile(ps,pf,pcoi,pz,nf, "%s %s%s", timeAsString(nFileTime), p1,p2); break;

            // size time filename:
            case 0x0102: prtFile(ps,pf,pcoi,pz,nf, "%s %s %s%s", sizeOrDir(nFileSize, nf), timeAsString(nFileTime), p1,p2); break;
            // time size filename:
            case 0x0201: prtFile(ps,pf,pcoi,pz,nf, "%s %s %s%s", timeAsString(nFileTime), sizeOrDir(nFileSize, nf), p1,p2); break;
         }
         break;
   }

   return 0;
}

#ifndef USE_SFK_BASE
long execDupScan(char *pszFile)
{
   if (glblDupScan.addFile(pszFile))
      return 0;

   char szAddInfo[200];
   sprintf(szAddInfo, "%ld files", glblDupScan.clSizes.numberOfEntries());
   info.setStatus("scan", pszFile, szAddInfo);
   return 0;
}
#endif // USE_SFK_BASE

// uses szLineBuf, szLineBuf2
long execAliasList(char *pszFileName, bool *pbIsAlias = 0)
{
   FILE *fin = fopen(pszFileName, "r");
   if (!fin) return 1; // ignore

   // read header of potential alias batch
   szLineBuf[0] = '\0';
   if (!fgets(szLineBuf, sizeof(szLineBuf)-10, fin))
      { fclose(fin); return 1; } // ignore

   long lRC = 0;

   if (!strncmp(szLineBuf, pszGlblAliasBatchHead, strlen(pszGlblAliasBatchHead)))
   {
      /* get additional info
      char *psz2 = szLineBuf+strlen(pszGlblAliasBatchHead);
      if (*psz2 == ' ') psz2++;
      long nCmdLines = atol(psz2);
      */

      if (pbIsAlias)
         *pbIsAlias = 1;

      // reduce filename back to alias name
      char *psz1 = strrchr(pszFileName, glblPathChar);
      if (psz1) pszFileName = psz1+1;
      int nLen = strlen(pszFileName);
      char *pszBat = strstr(pszFileName, ".bat");
      if (pszBat) nLen = pszBat-pszFileName;

      sprintf(szLineBuf2, "%.*s\t= ", (int)nLen, pszFileName);
      if (chain.coldata) {
         chain.addToCurLine(szLineBuf2, "", 1); // 1: add new line first
      } else {
         printf("%s", szLineBuf2);
      }

      // read the actual command lines
      long nMaxLines = 10;
      bool bFirst = 1;
      while (nMaxLines-- > 0)
      {
         if (!fgets(szLineBuf, sizeof(szLineBuf)-10, fin))
            break;
         int nLen2 = strlen(szLineBuf);
         if (nLen2 > 0) nLen2--; // strip linefeed
         char *pszCmd = szLineBuf;
         #ifdef _WIN32
         if ((*pszCmd == '@') && nLen2) { pszCmd++; nLen2--; } // strip silencer
         #else
         if ((*pszCmd == '#') && nLen2) { pszCmd++; nLen2--; } // strip silencer
         #endif
         sprintf(szLineBuf2, "%s%.*s", bFirst ? "":" , ", (int)nLen2, pszCmd);
         if (chain.coldata)
            chain.addToCurLine(szLineBuf2, "");
         else
            printf("%s", szLineBuf2);
         bFirst = 0;
      }

      if (!chain.coldata)
         printf("\n");
   }

   fclose(fin);

   return lRC;
}

// for windows: convert "/" to "\\"
void setSystemSlashes(char *pdst)
{
   #ifdef _WIN32
   for (; *pdst; pdst++)
      if (*pdst == glblWrongPChar)
          *pdst = glblPathChar;
   #endif
}

void setNetSlashes(char *pdst)
{
   for (; *pdst; pdst++)
      if (*pdst == '\\')
          *pdst = '/';
}

long execFileStat(Coi *pcoi, long lLevel, long &lFiles, long &lDirs, num &lBytes, num &nLocalMaxTime, num &nTreeMaxTime, long nSinceReason)
{
   char *pszFileName = pcoi->name();

   long bIsDir    = 0;
   long bCanRead  = 1;
   long bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   getFileStat(pszFileName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize);

   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   listSingleFile(lLevel, pcoi, 0, 0, nSinceReason);
   cs.files++;
   nGlblBytes += nFileSize;

   if (pcoi->isHidden())
      cs.numHiddenFiles++;

   #ifdef VFILEBASE
   if (0) // cs.shallowzips) // else skip below
   #endif // VFILEBASE
   if (cs.travelzips) 
   {
      // char *psz1 = strrchr(pszFileName, '.');
      // if (psz1 && 
      //     (   !mystricmp(psz1, ".zip") || !mystricmp(psz1, ".jar") 
      //      || !mystricmp(psz1, ".war") || !mystricmp(psz1, ".aar") || !mystricmp(psz1, ".ear")
      //      || !mystricmp(psz1, ".xpi")
      //     )
      //    )
      bool endsWithArcExt(char *pname);
      if (endsWithArcExt(pszFileName))
      {
         // long getZipMD5(char *pszFile, SFKMD5 &md5, FileList &rFileList, bool bMakeList);
         long getZipList(char *pszFile, FileList &rFileList);
         // SFKMD5 md5;
         FileList oFiles;
         // uses szLineBuf2
         char *pszRootZip = pszFileName;
         if (!getZipList(pszRootZip, oFiles)) 
         {
            long nFiles = oFiles.clNames.numberOfEntries();
            for (long i=0; i<nFiles; i++) 
            {
               char *pRelSubName = oFiles.clNames.getEntry(i, __LINE__);
               num nSize = oFiles.clSizes.getEntry(i, __LINE__);
               num nTime = oFiles.clTimes.getEntry(i, __LINE__);

               // construct absolute, double-slashed name of zip file entry
               long nRootLen  = strlen(pszRootZip);
               long nSubLen   = strlen(pRelSubName);
               char *psubname = new char[nRootLen+nSubLen+10]; // TEMPORARY
               if (!psubname) return 9+perr("out of memory");
               sprintf(psubname, "%s%c%c%s", pszRootZip, glblPathChar, glblPathChar, pRelSubName);
               setSystemSlashes(psubname + nRootLen + 2);

               // create a temporary coi, which may be copied in listSingleFile.
               Coi *psub = new Coi(psubname, pszRootZip);
               psub->incref("efs"); // mark as used

               psub->setSize(nSize);
               psub->setTime(nTime);
               listSingleFile(lLevel+1, psub, pszRootZip, 0, nSinceReason);

               // cleanup temporary data
               delete [] psubname;  // was copied in ctr
               if (!psub->decref())
                  delete psub;      // no longer used

               cs.files++;
               nGlblBytes += nSize;
            }
         }
      }
   }

   // update maxtimes
   if (nFileTime > nLocalMaxTime)
       nLocalMaxTime = nFileTime;
   if (nFileTime > nTreeMaxTime)
       nTreeMaxTime = nFileTime;

   lBytes += nFileSize;
   return 0;
}

#ifdef WITH_FN_INST
long execInst(char *pszFileName, long lLevel, long &lFiles, long &lDirs, num &lBytes) 
{
   extern int sfkInstrument(char *pszFile, char *pszInc, char *pszMac, bool bRevoke, bool bRedo, bool bTouchOnRevoke, int nmode);

   // source code automatic instrumentation
   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   int nmode = bGlblInstEol ? 1 : 0;

   long nRC = sfkInstrument(pszFileName, pszGlblInstInc, pszGlblInstMac, bGlblInstRevoke, bGlblInstRedo, bGlblTouchOnRevoke, nmode);

   if (nRC < 9)
      return 0;

   return nRC;
}
#endif

enum eRunExpressions 
{
   erun_path      = 0,
   erun_file      = 1,
   erun_file_     = 2,
   erun_relfile   = 3,
   erun_base      = 4,
   erun_ext       = 5,
   erun_since     = 6,
   erun_text      = 7
};

const char *apRunTokens[] =
{
   // new and simple     kept for compatibility     quoted expressions           new ease
   "path"    , ""      , "purepath"    , "ppath"  , "quotpath"     , "qpath"   , "",
   "file"    , ""      , "purefile"    , "pfile"  , "quotfile"     , "qfile"   , "",
   ""        , ""      , "pure_file"   , "p_file" , "quot_file"    , "q_file"  , "",
   "relfile" , "rfile" , "purerelfile" , "prfile" , "quotrelfile"  , "qrfile"  , "qrelfile",
   "base"    , ""      , "purebase"    , "pbase"  , "quotbase"     , "qbase"   , "",
   "ext"     , ""      , "pureext"     , "pext"   , "quotext"      , "qext"    , "",
   "since"   , ""      , "puresince"   , "psince" , "quotsince"    , "qsince"  , "",
   "text"    , ""       , ""            , ""       , "quottext"     , "qtext"   , "",
};

#define RUNTPR 7  // run tokens per row

// tell if a supplied user command references single files.
// if not, it will be applied on directories only.
bool anyFileInRunCmd(char *pszCmd) 
{
   char abToken[100];
   for (ulong i=RUNTPR; i<(sizeof(apRunTokens)/sizeof(apRunTokens[0])); i++) 
   {
      strcpy(&abToken[1], apRunTokens[i]);
      if (!abToken[1]) continue;
      abToken[0] = '#';
      if (strstr(pszCmd, abToken))
         return true;
      #ifdef SFK_BOTH_RUNCHARS
      abToken[0] = '$';
      if (strstr(pszCmd, abToken))
         return true;
      #endif
   }
   return false;
}

bool anyTextInRunCmd(char *pszCmd) 
{
   char abToken[100];
   for (ulong i=RUNTPR*7; i<(sizeof(apRunTokens)/sizeof(apRunTokens[0])); i++) 
   {
      strcpy(&abToken[1], apRunTokens[i]);
      if (!abToken[1]) continue;
      abToken[0] = '#';
      if (strstr(pszCmd, abToken))
         return true;
      #ifdef SFK_BOTH_RUNCHARS
      abToken[0] = '$';
      if (strstr(pszCmd, abToken))
         return true;
      #endif
   }
   return false;
}

long onRunExpression(char *psz1, long &lExpLength, bool &bquot, bool &btext)
{
   char abToken[100];
   ulong nPtrs = (sizeof(apRunTokens)/sizeof(apRunTokens[0]));
   ulong nRows = nPtrs / RUNTPR;
   for (ulong irow=0; irow<nRows; irow++)
   {
      for (ulong icol=0; icol < RUNTPR; icol++)
      {
         strcpy(&abToken[1], apRunTokens[irow * RUNTPR +icol]);
         abToken[0] = '#';
         if (!abToken[1]) continue;
         char *psz2 = abToken;
         if (!strncmp(psz1, psz2, strlen(psz2)))
         {
            lExpLength = strlen(psz2);
            bquot = (icol >= 4) ? true : false;
            if (strstr(psz2, "text")) btext=1;
            if (cs.debug) printf("orp %u %u - %s row %ld\n", lExpLength, bquot, psz2, irow);
            return irow;
         }
         #ifdef SFK_BOTH_RUNCHARS
         else {
          abToken[0] = '$';
          if (!strncmp(psz1, psz2, strlen(psz2)))
          {
            lExpLength = strlen(psz2);
            bquot = (icol >= 4) ? true : false;
            if (strstr(psz2, "text")) btext=1;
            if (cs.debug) printf("orp %u %u - %s row %ld\n", lExpLength, bquot, psz2, irow);
            return irow;
          }
         }
         #endif
      }
   }
   if (cs.debug) printf("orp none in %s\n", psz1);
   return -1;
}

bool isQuoteChar(char c)
{
   switch (c) {
      case '\"': return 1;
      case '\'': return 1;
      case 0x60: return 1;
      case 0x91: return 1;
      case 0x92: return 1;
      case 0x93: return 1;
      case 0x94: return 1;
   }
   return false;
}

long copyFormStr(char *pszDst, long nMaxDst, char *pszSrc, long nSrcLen, ulong nflags=0);

// turn \+file into +file
char *unescf(char *pszFile)
{
   if (pszFile[0] == '\\')
      pszFile++;
   return pszFile;
}

// out   : pDstBuf with MAX_LINE_LEN
// uses  : szLineBuf
// rc    : 0 if replacements done, 1 if none found,
//         >= 9 on format error
long renderOutMask(char *pDstBuf, Coi *pcoi, char *pszMask, char *pszCmd)
{
   char *pszInFile   = pcoi->name();
   char *pszOptRoot  = pcoi->root(1);  // returns 0 if none
   char *pszOptRef   = pcoi->ref(1);   // returns 0 if none

   char *pszFileName = pszInFile;

   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   // relativize filename. todo: used at all?
   if (cs.rootrelname)
      pszFileName = pcoi->rootRelName();

   // copy command template to command buffer
   copyFormStr(pDstBuf, MAX_LINE_LEN, pszMask, strlen(pszMask));

   // preparations
   char *pszRelFilename = relativeFilename(pszFileName);

   bool bDoneAny = 0;
   bool bUsingText = false;

   char *psz1 = strchr(pDstBuf, '#');
   #ifdef SFK_BOTH_RUNCHARS
   if (!psz1) psz1 = strchr(pDstBuf, '$');
   #endif
   while (psz1)
   {
      long lTokenLen = 0;
      bool bQuoted   = false;
      switch (onRunExpression(psz1, lTokenLen, bQuoted, bUsingText))
      {
         case erun_file:
         case erun_text:
         {
            // replace absolute filename
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszFileName);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_file_:
         {
            // absolute filename with blanks replaced by "_".
            // alpha - not yet official.
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            char *psz3 = szLineBuf+strlen(szLineBuf);
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszFileName);
            if (bQuoted) strcat(szLineBuf, "\"");
            // replace blanks, within target buffer
            while (*psz3) {
               if (*psz3 == ' ')
                   *psz3 = '_';
               psz3++;
            }
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_relfile:
         {
            // replace relative filename
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszRelFilename);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_path:
         {
            // replace filename path
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            char *psz3 = strrchr(pszFileName, glblPathChar);
            if (psz3 && (psz3-pszFileName)>0)
               strncat(szLineBuf, pszFileName, psz3-pszFileName);
            else
               strcat(szLineBuf, ".");
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_base:
         {
            // replace file base name, without ".ext"
            // have to use relative filename for this.
            // note: ".afile" has ".afile" as base
            // note: "afile.long.longext" has ".longext" as ext
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            char *psz3 = strrchr(pszRelFilename, '.');
            if (psz3 && (psz3 > pszRelFilename)) {
               // can identify extension
               strncat(szLineBuf, pszRelFilename, psz3-pszRelFilename);
            } else {
               // cannot identify extension
               strcat(szLineBuf, pszRelFilename);
            }
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_ext:
         {
            // replace file extension
            // have to use relative filename for this.
            // note: ".afile" has ".afile" as base
            // note: "afile.long.longext" has ".longext" as ext
            // note: "afile." has "" as extension
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            char *psz3 = strrchr(pszRelFilename, '.');
            if (psz3 && (psz3 > pszRelFilename)) {
               // can identify extension, zero length accepted
               strcat(szLineBuf, psz3+1);
            } else {
               // cannot identify extension, leave empty
            }
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_since:
         {
            // replace absolute sincedir filename incl. root
            char *pszSinceFile = pcoi->ref(1); // returns null if none
            if (!pszSinceFile) {
               perr("missing reference name, cannot replace \"since\" token.\n");
               pinf("-sincedir/add/diff may not have been specified before.\n");
               pinf("a previous command may not support passing -since names.\n");
               return 9;
            }
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszSinceFile);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         default:
            psz1++;
            break;

      }  // end switch

      // find next potential token, if any
      #ifdef SFK_BOTH_RUNCHARS
      if (strchr(psz1, '#'))
         psz1 = strchr(psz1, '#');
      else
         psz1 = strchr(psz1, '$');
      #else
      psz1 = strchr(psz1, '#');
      #endif
   }

   // user error detection:
   // if filename contains blanks,
   if (!bUsingText && !cs.quiet && !cs.noinfo) {
      if (strchr(pszInFile, ' ')) {
         cs.blankRunFiles++;
         // then count quotes in produced expression
         long nlen  = strlen(pDstBuf);
         long nquot = 0;
         for (long i=0; i<nlen; i++)
            if (isQuoteChar(pDstBuf[i]))
               nquot++;
         if (nquot == 0) cs.badNameForm |= 1;
      }
      if (strchr(pszInFile, glblWrongPChar)) {
         cs.wrongpcRunFiles++;
         cs.badNameForm |= 2;
      }
   }

   return bDoneAny ? 0 : 1;
}

long submain(int argc, char *argv[], char *penv[], char *pszCmd, int iDir, bool &bFatal);

// run an sfk command, staying in the current process.
// cannot be used right now, as this requires that command
// chaining data is pushed and later popped on a stack.
long runInternal(char *pcmdraw)
{__
   mtklog("runint: %s", pcmdraw);

   long nrc = 9;

   #ifndef USE_SFK_BASE

   // split whole command string into command and args
   char *pcmd = strdup(pcmdraw);
   CharAutoDel odel(pcmd);

   // e.g.: list mydir .txt
   int nsubargc = 0; 
   char *psubargv[100+10];
   mclear(psubargv);

   char *psz = pcmd;
   while (*psz && (nsubargc < 100))
   {
      skipWhite(&psz);
      psubargv[nsubargc++] = psz;
      char *pcur = psz;
      skipToWhite(&psz);
      if (*psz) *psz++ = '\0';
      printf("[%s] ",pcur);
   }
   printf("\n");

   char *pszSubCmd = psubargv[0];
   int iSubDir = 1;
   // if chain starts like "sfk ...", skip "sfk":
   if (!strcmp(pszSubCmd, "sfk")) {
      pszSubCmd = psubargv[1];
      iSubDir = 2;
   }
   
   bool bFatal = 0;

   // TODO: push command chaining data, provide clean one
   nrc = submain(nsubargc, psubargv, 0, pszSubCmd, iSubDir, bFatal);
   // TODO: pop old command chaining data

   #endif // USE_SFK_BASE

   return nrc;
}

long execRunFile(Coi *pcoi, char *pszOutFile,
   long lLevel, long &lFiles, long &lDirs, num &lBytes
   ) 
{__
   char *pszFileName = pcoi->name();
   char *pszOptRoot  = pcoi->root(1);  // returns 0 if none
   char *pszOptRef   = pcoi->ref(1);   // returns 0 if none

   mtklog("execRunFile: %s", pszFileName);

   long nrc = renderOutMask(szRunCmdBuf, pcoi, cs.runCmd, "run");
   if (nrc >= 9) return nrc;

   bool bDoneAny = (nrc == 0);

   if (!bDoneAny && !cs.force)
      return 9+perr("no valid token in run command. type \"sfk run\" for help.\n");

   int  iRC = 0;
   bool btoldcmd = 0; // command was fully printed, but w/o rc
   bool btoldrc  = 0; // rc status was printed
   char szAddInfo[200];
   long nclines = 0; // no. of collected lines, if any

   if (cs.sim) 
   {
      // simulation: just dump resulting command to terminal
      printf("%s\n", szRunCmdBuf);
      btoldcmd = 1;
   } 
   else 
   {
      SFTmpFile ftmp(cperm.keeptmp);
      char *pszTmpFile = 0;

      // if -to outfile specified, OR collecting chain data
      if (pszOutFile || chain.coldata)
      {
         // prepare redirection of command output
         pszTmpFile = pszOutFile ? pszOutFile : ftmp.name();
         if (!pszTmpFile) return 9;
         long nlen = strlen(szRunCmdBuf);
         if (nlen > MAX_LINE_LEN-20)
            return 9+perr("command buffer overflow\n");
         // todo: detect > and print warn if -to used
         // todo: detect > within double quotes
         sprintf(&szRunCmdBuf[nlen], " >\"%s\"", pszTmpFile);
         // todo: detect 2> within double quotes
         if (!strstr(szRunCmdBuf, " 2>")) // AND " 2>>"
            strcat(szRunCmdBuf, " 2>&1");

         // create output directories on demand
         // uses: szLineBuf, abBuf
         long createOutDirTree(char *pszOutFile);
         if (pszOutFile)
            if (createOutDirTree(pszOutFile))
               return 9;

         // print pre-execution info
         if (cs.printcmd) {
            printf("%s\n", szRunCmdBuf);
            btoldcmd = 1;
         }
         else
         if (!cs.quiet) {
            info.setStatus("run", pszFileName); // temporary display
            // cmd is not yet permanently printed
         }
      }
      else
      if (!cs.quiet) {
         // non-chaining: command will dump it's output to terminal
         if (cs.printcmd) {
            printf("%s\n", szRunCmdBuf);
            btoldcmd = 1;
         } else {
            info.setStatus("run", pszFileName);
            info.printLine(1<<2);
            btoldcmd = 1;
         }
      }

      if (!cs.nonames && chain.coldata) {
         sprintf(szLineBuf3, ":file %s", pszFileName);
         // note: +view scans extended end of attribute line
         //       to identify 'f'ile header lines, therefore +2:
         setattr(szAttrBuf3, 'f', strlen(szLineBuf3)+2, MAX_LINE_LEN);
         chain.addLine(szLineBuf3, szAttrBuf3);
      }

      if (cs.intrun)
         iRC = runInternal(szRunCmdBuf);
      else
         iRC = system(szRunCmdBuf);

      if (chain.coldata && pszTmpFile) 
      {
         // chaining: collect redirected command output
         FILE *fin = fopen(pszTmpFile, "rb");
         if (!fin) return 9+perr("cannot read command output file: %s\n", pszTmpFile);
         myfgets_init();
         while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin))
         {
            szLineBuf[sizeof(szLineBuf)-10] = '\0';
            removeCRLF(szLineBuf);
            chain.addLine(szLineBuf, "");
            nclines++;
         }
         fclose(fin);
      }

      // by default, tmpfile is autodeleted here
   }

   if (!cs.quiet && !btoldcmd) {
      if (pszOutFile) {
         if (chain.coldata)
            sprintf(szAddInfo, "cached %ld lines, rc %ld", nclines, iRC);
         else
            sprintf(szAddInfo, "rc %ld", iRC);
         info.setStatus("wrote", pszOutFile, szAddInfo);
         info.printLine(1<<2);
         btoldrc = 1;
      }
      else
      if (chain.coldata) {
         sprintf(szAddInfo, "%ld lines, rc %ld", nclines, iRC);
         info.setStatus("run", pszFileName, szAddInfo);
         btoldrc = 1;
      }
   }

   // extra chain support:
   if (chain.colfiles) {
      // next chain step expects filename list
      if (!chain.usefiles || pszOutFile) {
         // there is either nothing to pass thru,
         // or the filenames changed on output, so create new list:
         if (pszOutFile) {
            Coi ocoi(pszOutFile, 0);
            chain.addFile(ocoi); // is copied
         } else {
            chain.addFile(*pcoi); // pass input file
         }
      }
   }

   if (cs.stoprc && iRC >= cs.stoprc) {
      perr("... rc %ld - stopping due to return code.\n",iRC);
      return 9;
   }
   else
   if (!cs.quiet && !cs.sim && !btoldrc) {
      if (iRC) {
         printf("... rc %d\n", iRC);
         fflush(stdout);
      }
   }

   return 0;
}

long execRunDir(Coi *pcoi, long lLevel, long &lFiles, long &lDirs, num &lBytes) 
{
   char *pszFileName = pcoi->name();

   if (!strcmp(pszFileName, "."))
      return 0;

   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   // copy command template to command buffer
   copyFormStr(szLineBuf, MAX_LINE_LEN, cs.runCmd, strlen(cs.runCmd), 0);

   bool bDoneAny = 0;
   char *psz1 = strchr(szLineBuf, '#');
   #ifdef SFK_BOTH_RUNCHARS
   if (!psz1) psz1 = strchr(szLineBuf, '$');
   #endif
   while (psz1)
   {
      long lTokenLen = 0;
      bool bQuoted   = false;
      bool bText     = false;
      switch (onRunExpression(psz1, lTokenLen, bQuoted, bText))
      {
         case erun_path:
         case erun_text:
         {
            // replace filename path
            memset(szLineBuf2, 0, sizeof(szLineBuf2));
            strncpy(szLineBuf2, szLineBuf, psz1-szLineBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf2, "\"");
             strcat(szLineBuf2, pszFileName);
            if (bQuoted) strcat(szLineBuf2, "\"");
            // remember position past insert
            psz1 = szLineBuf+strlen(szLineBuf2);
            // right
            strcat(szLineBuf2, psz2);
            // copy back result
            strncpy(szLineBuf, szLineBuf2, sizeof(szLineBuf));
            bDoneAny = 1;
            break;
         }

         default:
            psz1++;
            break;
      }

      // find next potential token, if any
      #ifdef SFK_BOTH_RUNCHARS
      if (strchr(psz1, '#'))
         psz1 = strchr(psz1, '#');
      else
         psz1 = strchr(psz1, '$');
      #else
      psz1 = strchr(psz1, '#');
      #endif
   }

   if (!bDoneAny && !cs.force)
      return 9+perr("no valid token in run command. type \"sfk run\" for help.\n");

   if (!cs.quiet && !cs.sim) {
      printf("%s\n", szLineBuf);
      fflush(stdout); 
   }

   int iRC = 0;

   if (cs.sim) {
      // special case: just dump resulting command to terminal
      printf("%s\n", szLineBuf);
   } else {
      if (cs.intrun)
         iRC = runInternal(szLineBuf);
      else
         iRC = system(szLineBuf);
   }

   if (!cs.quiet && !cs.sim) {
      if (iRC) {
         printf("... error, rc %d\n", iRC);
         fflush(stdout);
      }
   }

   // extra chain support:
   if (chain.colfiles) {
      // next chain step expects filename list
      if (!chain.usefiles) {
         // but there is nothing to pass thru, so create
         chain.addFile(*pcoi);
      }
   }

   return 0;
}

long execDirStat(Coi *pcoi, long lLevel, long lFiles, long lDirs, num lBytes, num &nLocalMaxTime, num &ntime2)
{__
   char *pszDir      = pcoi->name();
   char *pszOptRoot  = pcoi->root(1);  // returns 0 if none

   StringPipe *pout = 0;
   if (chain.coldata)
      pout = chain.outdata;

   if (nGlblListMode == 1)
   {
      int nIndent = (int)lLevel;
      if (nIndent > (long)strlen(pszGlblBlank)) nIndent = strlen(pszGlblBlank);
      if (nIndent > 10) nIndent = 10;
   
      if (!strncmp(pszDir, glblDotSlash, 2))
         pszDir += 2;
   
      long lMBytes = (lBytes / 1000000UL);

      if (cs.statonlysum)
      { }
      else
      if (cs.quiet) {
         if (lLevel == 0)
            oprintf(pout, "%5ld mb %s\n", lMBytes, pszDir);
      } else {
         if (lBytes < 0) // for sfk sel -withdirs ... +stat
         { } // print nothing, there are no stats.
         else
         if (lBytes < nGlblListMinSize)
         { } // print nothing, dir content too small to list.
         else
         {
            // dir content size can be listed
            if (lLevel <= cs.stathilitelevel) setTextColor(nGlblFileColor);
            switch (cs.listunit) {
               case 'b':
                  oprintf(pout, "%s, %5ld files, %.*s%s\n", numtoa_blank(lBytes, 12), lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
               case 'k':
                  oprintf(pout, "%s kb, %5ld files, %.*s%s\n", numtoa_blank(lBytes/1000, 10), lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
               default :
                  oprintf(pout, "%5ld mb, %5ld files, %.*s%s\n", lMBytes, lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
            }
            if (lLevel <= cs.stathilitelevel) setTextColor(-1);
         }
      }
   }
   else
   if (nGlblListMode == 2)
   {
      if ((cs.withdirs || cs.justdirs) && strcmp(pszDir, "."))
         listSingleFile(lLevel, pcoi, 0, 1, 0);
   }

   cs.dirs++;
   if (pcoi->isHidden())
      cs.numHiddenDirs++;

   return 0;
}

bool matchesCurrentRoot(char *pszDir)
{
   if (!glblFileSet.hasRoot(0)) return false;
   char *pszRoot = glblFileSet.getCurrentRoot();
   if (!pszRoot) { perr("internal 812064\n"); return false; }
   bool brc = equalFileName(pszDir, pszRoot);
   // printf("%d = mcr(%s)\n", brc, pszDir);
   return brc;
}

bool isEmptyDir(char *pszIn)
{
   bool bRC = 1;

   long lSize1       = strlen(pszIn);
   char *pszPattern  = new char[lSize1+10];
   char *pszBasePath = new char[lSize1+10];

   // pszIn might be
   // -  a directory, with or w/o slash at end
   // -  a pattern expression: dir\a*b??.cpp
   char *pszLastSlash = strrchr(pszIn, glblPathChar);

   if (!pszLastSlash) {
      strcpy(pszBasePath, pszIn);
      joinPath(pszPattern, lSize1+10, pszIn, (char*)glblAddWildCard);
   } else {
      joinPath(pszPattern, lSize1+10, pszIn, (char*)glblAddWildCard);
      strcpy(pszBasePath, pszIn);
   }

   #ifdef _WIN32 // --------- Windows directory walking code ----------

   #ifdef SFK_W64
   SFKFindData myfdat;
   intptr_t myfdh = _findfirst64(pszPattern, &myfdat);
   #else
    #ifndef _INTPTR_T_DEFINED
     typedef long intptr_t;
    #endif
   SFKFindData myfdat;
   intptr_t myfdh = _findfirst(pszPattern, &myfdat);
   #endif

   if (myfdh == -1) {
      delete [] pszPattern;
      delete [] pszBasePath;
      return 1; // yes, seems to be empty
   }

   do
   {

   #else // ----------- unix directory walking code -------------

   SFKFindData myfdat;

   DIR *myfdh = opendir(pszPattern);

   if (!myfdh) {
      delete [] pszPattern;
      delete [] pszBasePath;
      return 1;
   }

   while (1)
   {
      struct dirent *e = readdir(myfdh);
      if (e == NULL)
         break; // while

      memset(&myfdat, 0, sizeof(myfdat));
      myfdat.name   = e->d_name;
      myfdat.attrib = 0;

   #endif // _WIN32
   
      char *pszFile = myfdat.name;

      if (   !strcmp(pszFile, ".")
          || !strcmp(pszFile, ".."))
         continue;

      // first "real" file reached
      bRC = 0;
      break;
   }
   #ifdef _WIN32
    #ifdef SFK_W64
    while (!_findnext64(myfdh, &myfdat));
    #else
    while (!_findnext(myfdh, &myfdat));
    #endif
   _findclose(myfdh);
   #else
   closedir(myfdh);
   #endif

   delete [] pszPattern;
   delete [] pszBasePath;

   if (cs.verbose >= 2)
      printf("%d = isEmptyDir(%s)\n", bRC, pszIn);

   return bRC;
}

class AutoCoiDirClose {
public:
      AutoCoiDirClose (Coi *pcoi) { pClCoi = pcoi; }
     ~AutoCoiDirClose ( ) {
         if (pClCoi->isDirOpen()) {
            mtklog("auto-close coi %p", pClCoi);
            pClCoi->closeDir();
         }
      }
   Coi *pClCoi;
};

/*
class AutoCoiRelease {
public:
      AutoCoiRelease (Coi *pcoi) { pClCoi = pcoi; } // or NULL
     ~AutoCoiRelease ( ) {
         if (pClCoi)
            pClCoi->decref();
      }
   Coi *pClCoi;
};
*/

// NOTE: walkFiles does NOT accept stack-based AUTOMATIC Coi's!
//       whatever ptop is passed into here must've been created
//       with "new", otherwise the reference counting will fail.
long walkFiles(
   Coi *ptop, long lLevel,
   long &nGlobFiles, FileList &rParentDirFiles,
   long &lDirs, num &lBytes,
   num &nLocalMaxTime, num &nTreeMaxTime
 )
{__
   mtklog("walkFiles %s", ptop->name());

   // printf("wfl %s\n", ptop->name());

   if (bGlblEscape)
      return 0;

   long lRC = 0;

   // this function accepts
   // -  directory Cois   like c:\\thedir
   // -  single file Cois like c:\\thefile.txt

   Coi *psub = 0;

   // in case of a return, make sure dirs are closed:
   AutoCoiDirClose odirclose(ptop);

   bool bTravelTop = ptop->isTravelDir();

   #ifndef _WIN32
   // if on top level, reset the circle map, to avoid
   // unwanted blockings on multi-root dir commands:
   if (lLevel <= 0) {
      mtklog(" wfiles1.level0: resetting circle map");
      glblCircleMap.reset();
   }
   // check for circular (endless) travels:
   if (cs.usecirclemap && bTravelTop && ptop->haveFileID()) {
      if (glblCircleMap.isset(ptop->getFileID())) {
         if (cs.debug)
            pinf("fileid already set: %s\n", ptop->getFileID());
         if (cs.showdupdirs)
            pinf("skipping content, already done: %s\n", ptop->name());
         bTravelTop = 0;
      } else {
         // printf("node %lxh is not set: %s\n", (ulong)ptop->getNode(),ptop->name());
      }
   }
   #endif

   if (bTravelTop)
   {
      mtklog(" wfiles1.travel %s", ptop->name());
      // open dir for traversal
      if (ptop->openDir()) {
         if (cs.verbose > 1)
            printf("cannot read dir: %s\n", ptop->name());
         return 0;
      }
      // fetch first entry
      psub = ptop->nextEntry();
      mtklog(" wfiles1.get1st of coi %p sub %p", ptop, psub);
      // caller (we) MUST RELEASE COI after use!
      // if refcnt is zero then, we also DELETE it.
      if (!psub) {
         if (cs.verbose > 1)
            printf("empty dir: %s\n", ptop->name());
         return 0; // empty directory
      }
      #ifdef VFILEBASE
      // if top is virtual, cache it now, as the child members
      // may need the data. do not use ptop->name() to check
      // the cache, as a redirect may have renamed the coi.
      // NOTE: caching is the reason why automatic cois
      //       are strictly not allowed as ptop.
      if (ptop->isVirtual() && !ptop->isCached())
      {
         mtklog("vpar-register %s", ptop->orgName());
         glblVCache.put(ptop->orgName(), ptop, "wf");
         // ptop is now MANAGED BY CACHE.
         // cache has incremented the refcnt.
      }
      #endif // VFILEBASE
      #ifndef _WIN32
      // remember that we traveled this directory:
      if (ptop->haveFileID()) {
         // printf("node %lxh is stored: %s\n", (ulong)ptop->getNode(),ptop->name());
         glblCircleMap.put(ptop->getFileID());
      }
      #endif
   }
   else
   if (ptop->status() >= 9) {
      // non-existing filesystem object:
      if (lLevel < 1 || cs.verbose)
         pwarn("cannot read: %s\n", ptop->name());
      mtklog(" wfiles1.noread %s", ptop->name());
      return 0;
   } else {
      // process dir or file w/o traveling:
      mtklog(" wfiles1.any %s coi %p", ptop->name(), ptop);
      psub = ptop;
      // NOTE: WE DO NOT OWN psub NOW.
      // must check later if == ptop.
   }

   do
   {
     if (psub->isHidden() && !cs.hidden)
     {
         // hidden or system file or dir,
         // but inclusion of hidden not selected: skip
         if (psub->isAnyDir()) {
            mtklog(" wfiles2.hidden.dir %s", psub->name());
            cs.numHiddenDirsSkipped++;
         } else {
            mtklog(" wfiles2.hidden.file %s", psub->name());
            cs.numHiddenFilesSkipped++;
         }
     }
     else
     {
      if (psub->isAnyDir())
      {
         // subdirectory
         mtklog(" wfiles2.isdir %s", psub->name());

         // allowed to travel?
         bool bTravelSub = 0;

         if (psub == ptop) {
            bTravelSub = bTravelTop;
         } else {
            bTravelSub = psub->isTravelDir();
            #ifdef VFILEBASE
             #ifdef DEEP_FTP
             if (psub->isFtp()) { } else
             #endif
             if (psub->isNet()) bTravelSub = 0;
            #endif // VFILEBASE
         }

         FileList oLocDirFiles;
         long nTreeFileCnt = 0;
         long nDirDirs  = 0;
         num  nDirBytes = 0, nDirLocalMaxTime = 0, nDirTreeMaxTime = 0;

         bool bMatch = 1;

         #ifndef USE_SFK_BASE
         // some commands want to skip own meta dir
         if (cs.skipOwnMetaDir) {
            if (filedb.metaDir() && !mystricmp(filedb.metaDir(), psub->name()))
               bMatch = 0;
         }
         #endif // USE_SFK_BASE
 
         // normal match: temporary attach '\\' char for exact path comparison
         if (bMatch) {
            long nlen = strlen(psub->name());
            char *pcopy = new char[nlen+10];
            strcpy(pcopy, psub->name());
            strcat(pcopy, glblPathStr);
            bMatch = matchesDirMask(pcopy, !cs.subdirs);
            delete [] pcopy;
         }

         // general processing: recursion and the like
         if (bMatch)
         {
            char *pszRoot = glblFileSet.root(1); // returns 0 if none

            if (bTravelSub && cs.subdirs && !(psub->isLink() && cs.skipLinks)) 
            {
               mtklog(" wfiles2.walksub top=%p sub=%p %s", ptop, psub, psub->name());
               lRC = walkFiles(psub, lLevel+1, nTreeFileCnt, oLocDirFiles, nDirDirs, nDirBytes,
                               nDirLocalMaxTime, nDirTreeMaxTime);
            } else {
               lRC = 0;
            }

            lDirs++; // count directory as processed

            if (!cs.stopTree(lRC))
            {
               if (cs.debug) printf("] esd: %d %s files=%ld ts=%d sd=%d\n", lLevel, psub->name(), nTreeFileCnt, bTravelSub, cs.subdirs);
               lRC = execSingleDir(psub, lLevel+1, nTreeFileCnt, oLocDirFiles, nDirDirs, nDirBytes,
                                   nDirLocalMaxTime, nDirTreeMaxTime);
               if (cs.stopTree(lRC))
               {
                  nDirLocalMaxTime = 0;
                  break; // while
               }
               lRC = 0;
            }
            nDirLocalMaxTime = 0;

            // NOTE: local maxtime is NOT promoted, it was used w/in execSingleDir.
            //       we only promote the tree max time:
            if (nDirTreeMaxTime > nTreeMaxTime)
                nTreeMaxTime = nDirTreeMaxTime;

         }  // endif bmatch

         // add subdir stats to next higher level
         if (cs.flatdirstat) {
            cs.flatfilecnt += nTreeFileCnt;
            cs.flatdircnt  += nDirDirs ;
            cs.flatbytecnt += nDirBytes;
         } else {
            nGlobFiles += nTreeFileCnt;
            lDirs      += nDirDirs ;
            lBytes     += nDirBytes;
         }

         if (cs.stopTree(lRC))
            break; // while

         lRC = 0;
      }
      else
      if ((lLevel<1) && bGlblNoRootDirFiles && matchesCurrentRoot(ptop->name())) {
         mtklog(" wfiles2.skip %s", psub->name());
         // list -dir +simp +test: walk "." but do not process files,
         // we only want to filter the contained directories.
      }
      else
      {
         // normal file: check path mask (if any) against full file path
         bool bpmmatch = matchesPathMask(psub->name());

         // normal file: check mask against file name WITHOUT path
         if (bpmmatch && (matchesFileMask(psub->relName(), psub->name()) > 0))
         {
            mtklog(" wfiles2.match %s", psub->name());

            char *pszRoot = glblFileSet.root(1); // returns 0 if none

            // TODO: set psub->root here?
            if (cs.justdirs) {
               // since sfk 1.5.5, -justdirs counts the number of matching files
               // within a folder, but does not process any of those files.
               lRC = 0;
            } else {
               lRC = execSingleFile(psub, lLevel+1,
                           nGlobFiles, rParentDirFiles.clNames.numberOfEntries(),
                           lDirs, lBytes,
                           nLocalMaxTime, nTreeMaxTime);
            }
            
            if (cs.stopTree(lRC))
               break; // while
            else
            if (!lRC)
            {
               // count file as processed.
               nGlobFiles++;
               if (!cs.skipDirFileColl)
                  // TODO: add to a coi list here?
                  if (rParentDirFiles.addFile(psub->name(), glblFileSet.root(), psub->getTime(), psub->getSize()))
                     return 9; // shouldn't happen (outofmem)
            }
            lRC = 0;
         } else {
            mtklog(" wfiles2.miss  %s pmatch=%d", psub->name(), bpmmatch);
         }
      } // endelse dir or file
     } // endelse hidden

      // cleanup current sub entry:
      if (psub != ptop) {
         // decrement refcnt, and optionally delete
         if (!psub->decref())
            delete psub; // no refs remaining, not cached
         psub = 0;
      }

      if (userInterrupt())
         break;

      if (!bTravelTop)
         break;   // single dir or file processed

      psub = ptop->nextEntry();

      mtklog(" sub %p = wfiles2.getnext of coi %p", psub, ptop);
      mtklog(" (%s = wfiles2.getnext of coi %s)", psub ? psub->name():"", ptop ? ptop->name():"");
   }
   while (psub);

   // cleanup sub on loop break:
   if (psub && (psub != ptop)) {
      if (!psub->decref())
         delete psub; // no refs remaining, not cached
      psub = 0;
   }

   if (bTravelTop) {
      mtklog("top travel done, close coi %p", ptop);
      ptop->closeDir();
   }

   // mtklog("%ld = walkfiles.end", lRC);
   return lRC;
}

long dumpBlock(uchar *pCur, long lSize, long nmode)
{
   FILE *fout = fGlblOut;
   long i=0;
   switch (nmode) 
   {
      case 2:
      {
         bool bAddPad = ((lSize & 1) != 0);
         fprintf(fout, "\t\"");
         uchar u1, u2;
         for (i=0; i<lSize; i += 2) {
            // if input has uneven size, the very last byte
            // is not read from input, but filled with dummy 0xFF.
            u1 = pCur[i+0];
            if (i < lSize-2 || !bAddPad)
               u2 = pCur[i+1];
            else
               u2 = 0xFF;
            fprintf(fout, "\\u%02x%02x", u1, u2);
         }
         fprintf(fout, "\",");
      }
         break;

      case 1:
         for (i=0; i<lSize; i++) {
            if (pCur[i])
               fprintf(fout, "0x%x,", pCur[i]);
            else
               fprintf(fout, "0,", pCur[i]);
         }
         break;

      default:
         for (i=0; i<lSize; i++)
            fprintf(fout, "%u,", (unsigned int)pCur[i]);
         break;
   }
   fprintf(fout,"\n");
   return 0;
}

uchar *binPack(uchar *pIn, ulong nInSize, ulong &rnOutSize)
{
   ulong nOutSize = 0;
   uchar *pOut = 0;
   uchar *pMem = 0;
   uchar *pMax = pIn + nInSize;
   uchar *pCur = 0;
   uchar *pOld = 0;

   for (uchar npass=1; npass <= 2; npass++)
   {
      if (npass == 1)
         pOut = 0;
      else {
         pMem = new uchar[nOutSize];
         pOut = pMem;
      }

      pCur = pIn;
      pOld = pCur;

      while (pCur < pMax)
      {
         // detect repetition of patterns up to size 3
         uchar nbestsize = 0;
         uchar nbestgain = 0;
         uchar nbestrep  = 0;
         for (uchar isize = 1; isize <= 3; isize++) {
            uchar nrep  = 0;
            uchar bbail = 0;
            for (; (pCur+(nrep+1)*isize < pMax) && (nrep < 60) && !bbail; nrep++)
            {
               for (uchar i1=0; (i1<isize) && !bbail; i1++)
                  if (pCur[nrep*isize+i1] != pCur[i1])
                     bbail = 1;
               if (bbail)
                  break;
            }
            // this always results in nrep >= 1.
            uchar ngain = (nrep-1)*isize;
            if (ngain >= 3) {
               // there is a repetition, saving at least 3 bytes.
               // determine max savings accross all sizes.
               if (ngain > nbestgain) {
                  nbestgain = ngain;
                  nbestsize = isize;
                  nbestrep  = nrep;
               }
            }
         }
         // if (nbestrep > 0)
         //   printf("size %02u rep %02u gain %02u at %x\n", nbestsize, nbestrep, nbestgain, pCur-pIn);

         // if repeat pattern found,
         // OR if non-repeat exceeds maxsize
         if ( (nbestrep > 0) || ((pCur - pOld) >= 60) ) {
            // flush non-packable, if any
            if (pCur > pOld) {
               // printf("[flush non-pack %x]\n", pCur-pOld);
               uchar nDist = pCur-pOld;
               if (npass == 1) {
                  pOut++;
                  pOut += (pCur - pOld);
               } else {
                  *pOut++ = 0x00 | nDist;
                  while (pOld < pCur)
                     *pOut++ = *pOld++;
               }
               pOld  = pCur;
            }
            // flush packable, if any
            if (nbestrep > 0) {
               // printf("[pack %x %x]\n", nbestsize, nbestrep);
               if (npass == 1) {
                  pOut++;
                  pOut += nbestsize;
                  pCur += nbestsize;
               } else {
                  *pOut++ = (nbestsize << 6) | nbestrep;
                  for (uchar i1=0; i1<nbestsize; i1++)
                     *pOut++ = *pCur++;
               }
               pCur += (nbestrep-1)*nbestsize;
               pOld  = pCur;
            }
         } else {
            // count non-packable
            pCur++;
         }
      }

      // flush remainder, if any
      if (pCur > pOld) {
         // printf("[flush trailer %x]\n", pCur-pOld);
         uchar nDist = pCur-pOld;
         if (npass == 1) {
            pOut++;
            pOut += (pCur - pOld);
         } else {
            *pOut++ = 0x00 | nDist;
            while (pOld < pCur)
               *pOut++ = *pOld++;
         }
         pOld  = pCur;
      }

      if (npass == 1) {
         nOutSize = (ulong)(pOut - 0);
         // printf("packsize %u\n", nOutSize);
      }
   }

   rnOutSize = nOutSize;
   return pMem;
}

uchar *binUnpack(uchar *pIn, ulong nInSize, ulong &rnOutSize)
{
   ulong nOutSize = 0;
   uchar *pOut = 0;
   uchar *pMem = 0;
   uchar *pMax = pIn + nInSize;
   uchar *pCur = 0;
   uchar *pOld = 0;

   for (uchar npass=1; npass <= 2; npass++)
   {
      if (npass == 1)
         pOut = 0;
      else {
         pMem = new uchar[nOutSize];
         pOut = pMem;
      }

      pCur = pIn;
      pOld = pCur;

      while (pCur < pMax)
      {
         uchar ncmd = *pCur++;
         if (ncmd >= 64) {
            // unpack repeat block
            uchar nsiz = ncmd >> 6;
            uchar nrep = ncmd & 0x3F;
            // printf("[upack-rep %x %x (%x)]\n", nsiz, nrep, ncmd);
            // reproduce reference pattern nrep times
            if (npass == 1)
               pOut += nrep * nsiz;
            else
            for (; nrep > 0; nrep--)
               for (uchar i1=0; i1<nsiz; i1++)
                  *pOut++ = *(pCur+i1);
            // skip reference pattern
            pCur += nsiz;
         } else {
            // unpack skip block
            uchar nrep = ncmd;
            // printf("[upack-skip %x]\n", nrep);
            if (npass == 1) {
               pOut += nrep;
               pCur += nrep;
            }
            else
            for (; (nrep > 0) && (pCur < pMax); nrep--)
               *pOut++ = *pCur++;
         }
      }

      if (npass == 1) {
         nOutSize = (ulong)(pOut - 0);
         // printf("unpacksize %u\n", nOutSize);
      }
   }

   rnOutSize = nOutSize;
   return pMem;
}

long execBinToJava(uchar *pIn, long lInSize, bool bPack, char *pszNameBase, bool bClass, long nRecSize)
{
   FILE *fout = fGlblOut;

   if (bClass)
   fprintf(fout,
      "\n"
      "import java.io.*;\n"
      "\n"
      "public class %s {\n"
      "\n"
      "\tpublic static void main(String args[]) throws Throwable {\n"
      "\t\tbyte abData[] = %s_getBlock();\n"
      "\t\tFileOutputStream fout = new FileOutputStream(args[0]);\n"
      "\t\tfout.write(abData, 0, abData.length);\n"
      "\t}\n"
      "\n"
      ,pszNameBase,pszNameBase
      );

   fprintf(fout, 
      "\tpublic static int %s_BlockSize = %ld;\n"
      "\tstatic String %s_RawBlock[] = {\n"
      ,pszNameBase,lInSize,pszNameBase);

   long lRemain = lInSize;
   uchar *pCur  = pIn;
   while (lRemain > nRecSize) {
      dumpBlock(pCur, nRecSize, 2);
      lRemain -= nRecSize;
      pCur += nRecSize;
   }
   if (lRemain > 0)
      dumpBlock(pCur, lRemain, 2);

   fprintf(fout, "\t};\n\n");

   char *pname=pszNameBase;
   fprintf(fout,
      "\tpublic static byte[] %s_getBlock() {\n"
      "\t   int iout=0, nblen=%s_BlockSize;\n"
      "\t   char atmp[] = new char[%ld];\n"
      "\t   byte aout[] = new byte[nblen];\n"
      "\t   for (int i=0; i<%s_RawBlock.length; i++) {\n"
      "\t      String stmp = %s_RawBlock[i];\n"
      "\t      int nlen = stmp.length();\n"
      "\t      stmp.getChars(0,nlen,atmp,0);\n"
      "\t      for (int k=0; k<nlen; k++) {\n"
      "\t         char c = atmp[k];\n"
      "\t         byte bhi = (byte)(c >> 8);\n"
      "\t         byte blo = (byte)(c >> 0);\n"
      "\t         aout[iout++] = bhi;\n"
      "\t         if (iout < nblen)\n"
      "\t            aout[iout++] = blo;\n"
      "\t      }\n"
      "\t   }\n"
      "\t   return aout;\n"
      "\t}\n\n"
      ,pname,pname,nRecSize,pname,pname
      );

   if (bClass)
   fprintf(fout,
      "}\n\n"
      );

   return 0;
}

long execBinToCpp(uchar *pIn, long lInSize, bool bPack, char *pszNameBase, bool bHex)
{
   long lOldInSize = lInSize;

   if (bPack) {
      ulong nPackSize = 0;
      // binPack alloc's mem block with packed data
      pIn = binPack(pIn, lInSize, nPackSize);
      lInSize = (long)nPackSize;
   }

   fprintf(fGlblOut,"#define %s_BLOCK_SIZE %u\n\n", pszNameBase, lOldInSize);
   fprintf(fGlblOut,"static unsigned char %s_abRawBlock[%u] = {\n", pszNameBase, lInSize);
   long lRemain = lInSize;
   uchar *pCur  = pIn;
   while (lRemain > 32) {
      dumpBlock(pCur, 32, bHex ? 1 : 0);
      lRemain -= 32;
      pCur += 32;
   }
   if (lRemain > 0)
      dumpBlock(pCur, lRemain, bHex ? 1 : 0);
   fprintf(fGlblOut,"};\n");

   if (bPack) {
fprintf(fGlblOut,
   "\n"
   "// input : target buffer and buffer size.\n"
   "//         must have size >= %s_BLOCK_SIZE.\n"
   "// result: 0 if OK, 9 on buffer overflow.\n"
   "// note  : output data is not null terminated.\n"
   "long %s_getBlock(uchar *pOut, ulong nOutSize)\n",
   pszNameBase, pszNameBase
   );
fprintf(fGlblOut,
   "{\n"
   "   uchar *pCur    = %s_abRawBlock;\n"
   "   ulong nInSize  = %lu;\n"
   "   uchar *pMax    = pCur + nInSize;\n"
   "   uchar *pOutMax = pOut + nOutSize;\n"
   "   while (pCur < pMax)\n"
   "   {\n"
   "      uchar ncmd = *pCur++;\n"
   "      if (ncmd >= 64) {\n"
   "         uchar nsiz = ncmd >> 6;\n"
   "         uchar nrep = ncmd & 0x3F;\n"
   "         for (; nrep > 0; nrep--)\n"
   "            for (uchar i1=0; i1<nsiz; i1++) {\n"
   "               if (pOut >= pOutMax) return 9;\n"
   "               *pOut++ = *(pCur+i1);\n"
   "            }\n"
   "         pCur += nsiz;\n"
   "      } else {\n"
   "         uchar nrep = ncmd;\n"
   "         for (; (nrep > 0) && (pCur < pMax); nrep--) {\n"
   "            if (pOut >= pOutMax) return 9;\n"
   "            *pOut++ = *pCur++;\n"
   "         }\n"
   "      }\n"
   "   }\n"
   "   return 0;\n"
   "}\n",
   pszNameBase, lInSize
      );
      delete [] pIn;
   }

   return 0;
}

bool equalFileContent(char *pszFile1, char *pszFile2, uchar *psrcmd5=0, uchar *pdstmd5=0)
{
   if (psrcmd5) memset(psrcmd5, 0, 16);
   if (pdstmd5) memset(pdstmd5, 0, 16);
   uchar absum1[20];
   uchar absum2[20];
   if (getFileMD5(pszFile1, absum1)) return false;
   if (psrcmd5) memcpy(psrcmd5, absum1, 16);
   if (getFileMD5(pszFile2, absum2)) return false;
   if (pdstmd5) memcpy(pdstmd5, absum2, 16);
   if (!memcmp(absum1, absum2, 16))
      return 1; // equal
   return 0;
}

// uses szLineBuf. pOutBuf must be >= 16 bytes.
long getFuzzyTextSum(char *pszFile, uchar *pOutBuf)
{
   // this function reads a text file line by line, and
   // - strips line endings
   // - turns all \\ slashes into /
   // - ignores the SEQUENCE of lines
   // to make result files of sfk commands comparable
   // both accross platforms, and independent from the sequence
   // in which files happen to be read from the file system.
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+perr("cannot read: %s\n", pszFile);
   uchar abSum[16];
   memset(abSum, 0, sizeof(abSum));
   myfgets_init();
   while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin))
   {
      szLineBuf[sizeof(szLineBuf)-10] = '\0';
      removeCRLF(szLineBuf);
      ulong nLen = strlen(szLineBuf);
      // turn all non-/ slashes into /
      for (ulong i=0; i<nLen; i++)
         if (szLineBuf[i] == '\\')
             szLineBuf[i] = '/';
      if (cs.verbose) printf("sum: \"%s\"\n", szLineBuf);
      // build local checksum over line
      SFKMD5 md5;
      md5.update((uchar*)szLineBuf, nLen);
      // xor this with overall checksum
      unsigned char *pmd5 = md5.digest();
      for (ulong k=0; k<16; k++)
         abSum[k] ^= pmd5[k];
   }
   fclose(fin);
   memcpy(pOutBuf, abSum, 16);
   return 0;
}

ulong getLong(uchar ab[], ulong noffs) {
   return  (((ulong)ab[noffs+3])<<24)
          |(((ulong)ab[noffs+2])<<16)
          |(((ulong)ab[noffs+1])<< 8)
          |(((ulong)ab[noffs+0])<< 0);
}

ulong getShort(uchar ab[], ulong noffs) {
   return  (((ulong)ab[noffs+1])<< 8)
          |(((ulong)ab[noffs+0])<< 0);
}

time_t zipTimeToMainTime(num nZipTime)
{
   time_t now = time(NULL);
   struct tm *tm = 0;
   tm = localtime(&now);
   tm->tm_isdst = -1;

   tm->tm_year = ((int)(nZipTime >> 25) & 0x7f) + (1980 - 1900);
   tm->tm_mon  = ((int)(nZipTime >> 21) & 0x0f) - 1;
   tm->tm_mday = ((int)(nZipTime >> 16) & 0x1f);

   tm->tm_hour = (int)((unsigned)nZipTime >> 11) & 0x1f;
   tm->tm_min  = (int)((unsigned)nZipTime >>  5) & 0x3f;
   tm->tm_sec  = (int)((unsigned)nZipTime <<  1) & 0x3e;

   // rebuild main time
   time_t nTime = mktime(tm);

   // check for overflows
   #ifndef S_TIME_T_MAX
    #define S_TIME_T_MAX ((time_t)0x7fffffffUL)
   #endif

   #ifndef U_TIME_T_MAX
    #define U_TIME_T_MAX ((time_t)0xffffffffUL)
   #endif

   #define DOSTIME_2038_01_18 ((ulong)0x74320000L)
   if ((nZipTime >= DOSTIME_2038_01_18) && (nTime < (time_t)0x70000000L))
      nTime = U_TIME_T_MAX;

   if (nTime < (time_t)0L)
      nTime = S_TIME_T_MAX;

   return nTime;
}

// offsets taken from InfoZIP's UnZip 5.52:
#define L_VERSION_NEEDED_TO_EXTRACT_0  0 
#define L_VERSION_NEEDED_TO_EXTRACT_1  1 
#define L_GENERAL_PURPOSE_BIT_FLAG     2 
#define L_COMPRESSION_METHOD           4 
#define L_LAST_MOD_DOS_DATETIME        6 
#define L_CRC32                        10 
#define L_COMPRESSED_SIZE              14 // 32-bit 
#define L_UNCOMPRESSED_SIZE            18 
#define L_FILENAME_LENGTH              22 // 16-bit 
#define L_EXTRA_FIELD_LENGTH           24 // 16-bit

#define L_LOCAL_HEADER_SIZE (L_EXTRA_FIELD_LENGTH+2)

// build md5 over a zip file AND:
// -  read all it's filenames
// -  check them against provided list

// USES: szLineBuf2
long getZipMD5(char *pszFile, SFKMD5 &md5, FileList &rFileList, bool bMakeList=0)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;

   size_t nRead = 0;

   while (1)
   {
      uchar abLocHdrPre[4+4];
      uchar abLocHdrPreTpl[] = { 0x50, 0x4b, 0x03, 0x04 };
      uchar abCntDirHdrTpl[] = { 0x50, 0x4b, 0x01, 0x02 };
   
      // read local file header magic.
      nRead = fread(abLocHdrPre,1,4,fin);
      if (nRead <= 0)
         break;   // EOD
      if (nRead != 4) { fclose(fin); return 9; }

      md5.update(abLocHdrPre, 4);
      nGlblBytes += nRead;
      if (!memcmp(abLocHdrPre, abCntDirHdrTpl, 4))
         break;   // central directory begin: don't parse further
      if (memcmp(abLocHdrPre, abLocHdrPreTpl, 4)) { fclose(fin); return 8; }
   
      // local file header.
      uchar abLocHdr[L_LOCAL_HEADER_SIZE+4];
      if ((nRead = fread(abLocHdr,1,L_LOCAL_HEADER_SIZE,fin)) != L_LOCAL_HEADER_SIZE) { fclose(fin); return 9; }
      md5.update(abLocHdr, L_LOCAL_HEADER_SIZE);
      nGlblBytes += nRead;
   
      ulong nCmpSize     = getLong (abLocHdr, L_COMPRESSED_SIZE);
      ulong nFileNameLen = getShort(abLocHdr, L_FILENAME_LENGTH);
      ulong nExtraLen    = getShort(abLocHdr, L_EXTRA_FIELD_LENGTH);
      ulong nGenFlags    = getShort(abLocHdr, L_GENERAL_PURPOSE_BIT_FLAG);

      // if bit 3 of general purpose is set,
      bool bDataDesc = ((nGenFlags & (1<<3)) != 0);
      // then nCmpSize is null, and a data descriptor follows.

      // printf("bDataDesc %lx nCmpSize %lx\n", bDataDesc, nCmpSize);

      // PkZip format seems not to support 64-bit sizes and timestamps.
      // num nTimeStamp = getLong (abLocHdr, L_LAST_MOD_DOS_DATETIME);
      num nFileSize   = getLong (abLocHdr, L_UNCOMPRESSED_SIZE);
      num nZipDOSTime = getLong (abLocHdr, L_LAST_MOD_DOS_DATETIME);
      num nTimeStamp  = zipTimeToMainTime(nZipDOSTime);

      // filename.
      if (nFileNameLen > sizeof(szLineBuf2)-10) { fclose(fin); return 9; }
      if ((nRead = fread(szLineBuf2, 1, nFileNameLen, fin)) != nFileNameLen) { fclose(fin); return 9; }
      md5.update((uchar*)szLineBuf2, nFileNameLen);
      nGlblBytes += nRead;
   
      // printf("file: %.*s %ld\n", (int)nFileNameLen, szLineBuf2, nFileNameLen);

      szLineBuf2[nFileNameLen] = '\0';

      #ifdef _WIN32
      // convert path chars from zip format '/' to local
      char *psz1 = 0;
      while (psz1 = strchr(szLineBuf2, glblWrongPChar))
         *psz1 = glblPathChar;
      #endif

      if (bMakeList)
         rFileList.addFile(szLineBuf2, "", nTimeStamp, nFileSize);
      else {
         long lRC = rFileList.checkAndMark(szLineBuf2, nFileSize);
         if (lRC == 1) {
            static bool bInfoDone = 0;
            logError("info   : outdated file \"%s\" in archive \"%s\"", szLineBuf2, pszFile);
            if (!bInfoDone) {
               bInfoDone = 1;
               logError("info   : if you want to cleanup your archive tree later, see 10-stale-list.txt");
            }
            trackStaleZip(pszFile);
         }
         if (lRC == 2) {
            static bool bInfoDone2 = 0;
            logError("error  : size mismatch of \"%s\" in archive \"%s\"", szLineBuf2, pszFile);
            if (!bInfoDone2) {
               bInfoDone2 = 1;
               logError("error  : maybe the file is too large, empty, unaccessible, or not zip compatible.");
            }
         }
      }

      // skip to next local file header.
      num nRemain = nExtraLen + nCmpSize;
      while (nRemain > 0) {
         size_t nBlockLen = sizeof(abBuf)-10;
         if (nBlockLen > nRemain) nBlockLen = nRemain;
         nRead = fread(abBuf,1,nBlockLen,fin);
         if (nRead <= 0)
            break;
         md5.update(abBuf,nRead);
         nGlblBytes += nRead;
         nRemain -= nRead;
      }
   }

   // read remaining data (central dir) as black box
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      nGlblBytes += nRead;
   }

   // unsigned char *pmd5 = md5.digest();
   // for (int i=0; i<16; i++)
   //    fprintf(stdout,"%02x",pmd5[i]);
   // printf("\n");

   fclose(fin);
   return 0;
}

#ifndef NO_ZIP_LIST

#ifdef _WIN32
long mygetpos(FILE *f, num &rpos, char *pszFile)
{
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   rpos = (num)npos1;
   return 0;
}
long mysetpos(FILE *f, num pos, char *pszFile)
{
   fpos_t npos1 = (fpos_t)pos;
   if (fsetpos(f, &npos1))
      return 9+perr("setpos failed on %s\n", pszFile);
   return 0;
}
#else
long mygetpos(FILE *f, num &rpos, char *pszFile)
{
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   #ifdef MAC_OS_X
   rpos = (num)npos1;
   #else
   rpos = (num)npos1.__pos;
   #endif
   return 0;
}
long mysetpos(FILE *f, num pos, char *pszFile)
{
   // fetch "status" first
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   #ifdef MAC_OS_X
   npos1 = (fpos_t)pos;
   #else
   npos1.__pos = (__off_t)pos;
   #endif
   if (fsetpos(f, &npos1))
      return 9+perr("setpos failed on %s\n", pszFile);
   return 0;
}
#endif

long getZipList(char *pszFile, FileList &rFileList)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+perr("unable to open: %s\n", pszFile);
   
   long rc=0;
   ulong sig;
   fseek(fin, -18, SEEK_END);
   fread(&sig, 1, sizeof(sig), fin);

   #define ENDOFCDIR_SIZE 18
   #define EOCDIR_CDOFFS  12

   num g_diroff = 0; // offset of central directory

   while (1)
   {
      num npos2 = 0;
      if (mygetpos(fin, npos2, pszFile)) {
         fclose(fin);
         return 9;
      }
      if (npos2 <= 32)
         break;

      if (sig==0x06054b50) 
      {
         rc = fread(abBuf, 1, ENDOFCDIR_SIZE, fin);
         if (rc == ENDOFCDIR_SIZE)
            g_diroff = getLong(abBuf, EOCDIR_CDOFFS);
         break;
      } else {
         fseek(fin, -5, SEEK_CUR);
         fread(&sig, 1, sizeof(sig), fin);
      }
   }

   #define ZIPFHEAD_SIZE   42
   #define ZIPFNAMLEN_OFFS 24 // 2 bytes
   #define ZIPFCRC_OFFS    12 // 4 bytes
   #define ZIPFCMPS_OFFS   16 // 4 bytes
   #define ZIPFORGS_OFFS   20 // 4 bytes
   #define ZIPFEXTL_OFFS   26 // 2 bytes
   #define ZIPFREML_OFFS   28 // 2 bytes
   #define ZIPFIATTR_OFFS  32 // 4 bytes
   #define ZIPFEATTR_OFFS  34 // 4 bytes

   num npos1 = (num)g_diroff;
   if (mysetpos(fin, npos1, pszFile)) {
      fclose(fin);
      return 9;
   }

   rc = fread(&sig, 1, sizeof(sig), fin);

   while (rc > 3)
   {
      if (sig == 0x02014b50)
      {
         num npos1 = 0;
         if (mygetpos(fin, npos1, pszFile))
            break;

         num boo = (num)npos1;
   
         rc = fread(abBuf, 1, ZIPFHEAD_SIZE, fin);
         if (rc < ZIPFHEAD_SIZE)
            break;
   
         ulong nNameLen = getShort(abBuf, ZIPFNAMLEN_OFFS);
         if (nNameLen > MAX_LINE_LEN-10)
            break;
   
         rc = fread(szLineBuf, 1, nNameLen, fin);
         if (rc < (long)nNameLen)
            break;
         szLineBuf[nNameLen] = '\0';

         // under windows, convert slashes
         setSystemSlashes(szLineBuf);

         // directory of file entry?
         ulong nExtAttr = getLong(abBuf, ZIPFEATTR_OFFS);
         // NOTE: attributes are NOT given in JAR files.
         // bool  bIsDir   = (nExtAttr & (0040000UL << 16)) ? 1 : 0;
         // printf("attr %lxh dir=%d %s\n",nExtAttr,bIsDir,szLineBuf);
         bool  bIsDir   = endsWithPathChar(szLineBuf);

         // list dirs only if withdirs selected
         if (!bIsDir || cs.withdirs)
         {
            ulong nCRCSum  = getLong(abBuf, ZIPFCRC_OFFS );
            ulong nCmpSize = getLong(abBuf, ZIPFCMPS_OFFS);
            ulong nOrgSize = getLong(abBuf, ZIPFORGS_OFFS);
      
            ulong nExtLen  = getShort(abBuf, ZIPFEXTL_OFFS);
            ulong nRemLen  = getShort(abBuf, ZIPFREML_OFFS);
   
            #define ZIPTIME_OFFS ZIPFCRC_OFFS-4
            num nZipDOSTime = getLong (abBuf, ZIPTIME_OFFS);
            num nTimeStamp  = zipTimeToMainTime(nZipDOSTime);
   
            rFileList.addFile(szLineBuf, "", nTimeStamp, nOrgSize);
      
            if (nCmpSize) {
               if (fseek(fin, nExtLen+nRemLen, SEEK_CUR))
                  { perr("fseek err #3\n"); break; }
            } else {
               npos1 = (num)(boo+1);
               if (mysetpos(fin, npos1, pszFile))
                  break;
            }
         }
      }
      else {
         if (fseek(fin, -3, SEEK_CUR))
            { perr("fseek err #5\n"); break; }
      }  // endif
   
      rc = fread(&sig, 1, sizeof(sig), fin);
      if (rc < sizeof(sig))
         break;
   }  // endwhile

   fclose(fin);

   return 0;
}
#endif

#ifndef USE_SFK_BASE

long execMetaFileUpdate(char *pszFile)
{
   printf("upd: %s\n", pszFile);
   if (!filedb.updateFile(pszFile))
      cs.files++;
   return 0;
}

long execMetaDirUpdate(char *pszFile)
{
   filedb.updateDir(pszFile);
   return 0;
}

long execMetaFileCheck(char *pszSrc)
{
   cs.files++;

   char szAddInfo[200];
   long nVerOK     = filedb.numberOfVerifies();
   long nVerFailed = filedb.numberOfVerFailed();
   if (nVerFailed > 0)
      sprintf(szAddInfo, "%u files ok, %ld failed, %u mb %u kbs", nVerOK, nVerFailed, (ulong)(nGlblBytes/1000000UL), currentKBPerSec());
   else
      sprintf(szAddInfo, "%u files %u mb %u kbs", nVerOK, (ulong)(nGlblBytes/1000000UL), currentKBPerSec());
   info.setProgress(cs.files, filedb.numberOfFiles(), "files");
   info.setStatus("verfy", pszSrc, szAddInfo, eKeepProg);

   long nvrc = filedb.verifyFile(pszSrc);

   if (nvrc >= 9)
      perr("check failed: %s - content modified\n", pszSrc);
   else
   if (nvrc == 8)
      perr("%s - not found in database\n", pszSrc);
   return 0;
}

#endif // USE_SFK_BASE

long execMD5write(Coi *pcoi)
{
   SFKMD5 md5;
   if (getFileMD5(pcoi->name(), md5))
      return 9;

   char *pszRelName = pcoi->name();
   if (bGlblMD5RelNames)
      pszRelName = pcoi->rootRelName();

   unsigned char *pmd5 = md5.digest();
   for (int i=0; i<16; i++)
      fprintf(fGlblOut,"%02x",pmd5[i]);
   fprintf(fGlblOut," *%s\n",pszRelName); // md5sum similar

   glblFileCount.count();
   sprintf(szLineBuf, "%u files %u mb %u kbs", glblFileCount.value(), (ulong)(nGlblBytes/1000000UL), currentKBPerSec());
   info.setAddInfoWidth(strlen(szLineBuf));
   info.setStatus("read ", pszRelName, szLineBuf);

   return 0;
}

long execMD5check(char *pIn, char *pszRefDir)
{
   long nLine=0;
   long nError=0;
   char *pszLine=pIn;
   char *pszNext=0;
   ulong nListSize = strlen(pIn);
   if (nListSize==0) nListSize=1;   ulong nOldPerc = 0;
   long nSkipCnt = 0;
   long lRC = 0;

   // prerun: determine approx. number of targets
   ulong nLF = 0;
   for (ulong i=0; i<nListSize; i++)
      if (pIn[i] == '\n')
         nLF++;

   if (nGlblMD5Skip > 0) {
      ulong nCover = 100/(1+nGlblMD5Skip);
      if (!cs.quiet)
         printf("spot-checking %02u%% of files (skip=%u).\n", nCover, nGlblMD5Skip);
   }

   // check md5, optionally sped up through skips
   for (;pszLine;pszLine=pszNext)
   {
      pszNext = strchr(pszLine, '\n');
      if (pszNext) *pszNext++ = 0;
      strncpy(szLineBuf, pszLine, sizeof(szLineBuf)-10);
      nLine++;
      if (!strlen(szLineBuf))
         continue;
      if (nGlblMD5Skip > 0) {
         if (nSkipCnt <= 0) {
            nSkipCnt = nGlblMD5Skip;
            // and fall through
         } else {
            nSkipCnt--;
            continue;
         }
      }
      char *psz = strstr(szLineBuf, " *"); // md5sum format
      if (!psz) {
         perr("illegal format in line %d:\n\"%s\"\n",nLine,szLineBuf);
         nError++; 
         lRC = 9;
         continue;
      }
      *psz = 0;
      char *pszHex  = szLineBuf;
      if (*pszHex == '\\') pszHex++; // support for md5sum files
      char *pszFile = psz+2;  // skip " *"
      // fix filename ending and path chars
      if (psz = strchr(pszFile, '\r')) *psz = 0;
      if (psz = strchr(pszFile, '\n')) *psz = 0;
      fixPathChars(pszFile);

      char szAddInfo[200];
      if (nGlblMD5Skip > 0) {
         sprintf(szAddInfo, "%u files %u mb %u kbs skip %u", glblFileCount.value(), (ulong)(nGlblBytes/1000000UL), currentKBPerSec(), nGlblMD5Skip);
      } else {
         sprintf(szAddInfo, "%u files %u mb %u kbs", glblFileCount.value(), (ulong)(nGlblBytes/1000000UL), currentKBPerSec());
      }
      info.setAddInfoWidth(strlen(szAddInfo));
      info.setProgress(nLF, nLine, "files");
      info.setStatus("verfy", pszFile, szAddInfo, eKeepAdd);

      char *pszAbsName = pszFile;
      if (pszRefDir) {
         joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszRefDir, pszFile);
         pszAbsName = szRefNameBuf;
      }

      {
         SFKMD5 md5;      // auto instanciate
         // NOTE: this uses abBuf, so we shouldn't use abBuf here.
         if (getFileMD5(pszAbsName, md5)) {
            nError++;   // but continue
            if (lRC < 9) lRC |= 2;
         }
         else
         {
            unsigned char *pmd5 = md5.digest();
            char szBuf2[100];
            for (int i=0; i<16; i++)
               sprintf(szBuf2+i*2,"%02x",pmd5[i]);
            if (strcmp(pszHex,szBuf2)) {
               perr("MD5 mismatch: %s\n", pszAbsName); // ,*%s*,*%s*\n", pszFile, pszHex, szBuf2);
               nError++;
               if (lRC < 9) lRC |= 1;
            }            
         }
      }

      glblFileCount.count();

      if (userInterrupt())
         break;
   }
   if (nError) {
      perr("%lu files of %lu failed verification.\n", nError, glblFileCount.value());
      info.print("info : %lu files checked", glblFileCount.value());
   } else {
      info.print("OK. %lu files checked", glblFileCount.value());
   }
   if (!cs.quiet)
      info.print(", %lu mb, %lu sec, %lu kb/sec.\n", (ulong)(nGlblBytes/1000000UL), (ulong)(currentElapsedMSec()/1000), (ulong)currentKBPerSec());
   else
      info.print(".\n");
   fflush(stderr);
   fflush(stdout);
   return lRC;
}

long execJamIndex(char *pszFile)
{
   // strip ".\" at start, if any
   char *psz1 = pszFile;
   if (!strncmp(psz1, glblDotSlash, 2))
         psz1 += 2;
   fprintf(fGlblOut, ":# %s\n", psz1);

   // remember in array of targets
   if (nJamTargets < MAX_JAM_TARGETS-10)
      apJamTargets[nJamTargets++] = strdup(psz1);
   else
      return 9+perr("too many snapfile targets\n");

   return 0;
}

long execSnapAdd(char *pszFile)
{
   #ifndef USE_SFK_BASE
   // strip ".\" at start, if any
   char *psz1 = pszFile;
   if (!strncmp(psz1, glblDotSlash, 2))
         psz1 += 2;
   long lRC = glblMemSnap.addTarget(psz1);
   // if (lRC != 0) printf("ESA RC %d, continue\n", lRC);
   #endif // USE_SFK_BASE
   return 0; // continue scan!
}

// snapto dump of a single text line
long dumpJamLine(char *pszLine, long nLineLen, bool bAddLF) // len 0: zero-terminated
{
   long lRC = 0;

   if (pGlblJamLineCallBack)
      lRC = pGlblJamLineCallBack(pszLine, nLineLen, bAddLF);
   else
   if (nLineLen > 0)
      fprintf(fGlblOut, "%.*s%s", (int)nLineLen, pszLine, bAddLF?cs.addsnaplf:"");
   else {
      fputs(pszLine, fGlblOut);
      if (bAddLF) fputs(cs.addsnaplf, fGlblOut);
   }

   return lRC;
}

// simple check: if a file contains some nulls, it must be binary.
bool isBinaryFile(char *pszFile, long nCheckLen=4096)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 0;

   if (nCheckLen > sizeof(abBuf)-10)
       nCheckLen = sizeof(abBuf)-10;

   long nRead = fread(abBuf, 1, nCheckLen, fin);
   fclose(fin);

   for (long i=0; i<nRead; i++)
      if (abBuf[i] == 0x00)
         return 1;

   return 0;
}

bool isWhitespace(char *psz, long nlen)
{
   for (long i=0; psz[i] && (i<nlen); i++)
      if (!isspace(psz[i]))
         return 0;
   return 1;
}

const char *pGlblBlankBuf160 =
   "                                        "
   "                                        "
   "                                        "
   "                                        ";

#ifdef VFILEBASE
class AutoCacheDrop {
public:
    AutoCacheDrop (Coi *pcoi);
   ~AutoCacheDrop ( );
private:
   Coi *pClCoi;
};

AutoCacheDrop::AutoCacheDrop(Coi *pcoi) {
   pClCoi = pcoi; 
}

AutoCacheDrop::~AutoCacheDrop( ) {
   pClCoi->releaseContent(); // IF anything cached
}
#endif // VFILEBASE

void setAddSnapMeta(ulong nmask) { cs.addsnapmeta = nmask; }

long (*pGlblCallFileDir)(Coi *pcoi) = 0;

long execCallFileDir(Coi *pcoi)
{
   if (!pGlblCallFileDir) return 9;
   return pGlblCallFileDir(pcoi);
}

// snapto collect single file
long execJamFile(Coi *pcoi)
{__
   char *pPrefix = pszGlblJamPrefix ? pszGlblJamPrefix : (char*)":file:";
   char *pHeadLine = pPrefix;

   char szHeadBuf[250];
   mclear(szHeadBuf);

   #ifdef VFILEBASE
   // when adding file content to a collection,
   // we can always expect that the source data can be
   // dropped from cache afterwards, therefore:
   AutoCacheDrop odrop(pcoi);
   #endif // VFILEBASE

   mtklog("snap add file, %s", pcoi->name());

   bool bIsBinary = pcoi->isBinaryFile();

   if (cs.addsnapmeta)
   {
      bool baddtime = (cs.addsnapmeta & (1<<0)) ? 1 : 0;
      bool baddsize = (cs.addsnapmeta & (1<<1)) ? 1 : 0;
      bool baddcode = (cs.addsnapmeta & (1<<2)) ? 1 : 0;

      // prepare subfile header with time etc.     123456789012345678901234567890
      char szTimeInfo[50]; mclear(szTimeInfo);  // time=1234567890
      char szSizeInfo[50]; mclear(szSizeInfo);  // size=1000000000
      char szCodeInfo[50]; mclear(szCodeInfo);  // code=utf16le
      char szWebInfo[50];  mclear(szWebInfo);   // webrc=404_error_page

      long nMetaLen = 0;

      if (baddtime) {
         num nFileTime = pcoi->getTime();
         strcpy(szTimeInfo, " mtime=");
         numtoa(nFileTime,1,szTimeInfo+7);
         nMetaLen += strlen(szTimeInfo);
      }

      if (baddsize) {
         num nFileSize = pcoi->getSize();
         strcpy(szSizeInfo, " size=");
         numtoa(nFileSize,1,szSizeInfo+6);
         nMetaLen += strlen(szSizeInfo);
      }

      if (baddcode && pcoi->isUTF16()) {
         sprintf(szCodeInfo, " code=utf16%s", (pcoi->isUTF16()==0xFE)?"le":"be");
         nMetaLen += strlen(szCodeInfo);
      }

      #ifdef VFILEBASE
      char *pwebrc = pcoi->header("webrc");
      if (pwebrc) {
         long nwebrc = atol(pwebrc);
         if (nwebrc >= 400) {
            sprintf(szWebInfo, " content=%s_error_page", pwebrc);
            nMetaLen += strlen(szWebInfo);
         }
      }
      #endif // VFILEBASE

      long nPreLen  = strlen(pPrefix);
      if (nPreLen > 50) nPreLen = 50;

      long nPadLen  = 78 - nPreLen - nMetaLen;
      if (nPadLen < 0) nPadLen = 0;

      // construct padded headline with meta informations
      snprintf(szHeadBuf, sizeof(szHeadBuf), "%.50s%.*s%.40s%.40s%.40s%.40s",
         pPrefix, (int)nPadLen, pGlblBlankBuf160, szTimeInfo, szSizeInfo, szCodeInfo, szWebInfo);

      pHeadLine = szHeadBuf;
   }

   long lRC  = 0;

   if (cs.addsnapraw)
   {
      // raw mode:

      if (bIsBinary) {
         // skip all binaries
         if (glblFileCount.countSkip(pcoi->name())) {
            if (pGlblJamStatCallBack) {
               long nrc = pGlblJamStatCallBack(pcoi->name(), glblFileCount.value(), cs.lines, (ulong)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog("%ld = jam.stat.callback.5", nrc);
               lRC |= nrc;
            } else {
               info.setAddInfo("%lu files, %lu lines, %lu mb", (ulong)glblFileCount.value(), (ulong)cs.lines, (ulong)(nGlblBytes/1000000UL));
               info.setStatus("skip", pcoi->name(), 0, eKeepAdd);
            }
         }
         return lRC;
      }

      // add text files 1:1 keeping exactly the same size,
      // and skip all binary files. no conversions whatsoever.
      if (pcoi->open("rb"))
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      // write subfile header
      if (!bGlblJamPure)
      {
         lRC |= dumpJamLine(pHeadLine   , 0, 1);   // :file: mtime size
         lRC |= dumpJamLine(pcoi->name(), 0, 1);   // actual filename
      }

      while (true) 
      {
         num nRead  = pcoi->read(abBuf, sizeof(abBuf)-1000);
         if (nRead <= 0)
            break;

         if (cs.addsnapraw < 2) 
         {
            // replace (unexpected) NULL or EOF characters by '.'
            // also counting the lines
            for (long i=0; i<nRead; i++)
               switch (abBuf[i]) {
                  case 0: case 0x1A: abBuf[i] = '.'; break;
                  case '\n': cs.lines++; break;
               }
         } else {
            // just count the lines
            for (long i=0; i<nRead; i++)
               if (abBuf[i] == '\n')
                  cs.lines++;
         }

         num nWrite = myfwrite(abBuf, nRead, fGlblOut);
         if (nWrite != nRead) {
            perr("failed to fully write %ld bytes, possibly disk full\n", (long)nWrite);
            pcoi->close();
            return 9;
         }

         nGlblBytes += nRead;

         // check per block if stat update is required
         if (glblFileCount.checkTime())
         {
            if (pGlblJamStatCallBack) {
               long nrc = pGlblJamStatCallBack(pcoi->name(), glblFileCount.value(), cs.lines, (ulong)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog("%ld = jam.stat.callback.4", nrc);
               lRC |= nrc;
            } else {
               info.setAddInfo("%lu files, %lu mb", (ulong)glblFileCount.value(), (ulong)(nGlblBytes/1000000UL));
               info.setStatus("snap", pcoi->name(), 0, eKeepAdd);
            }
         }
   
         // STOP in-file processing on non-zero rc
         if (lRC) break;
      }

      pcoi->close();

      lRC |= dumpJamLine("", 0, 1);
   }
   else
   if (bIsBinary || cs.rewrap)
   {
      if (cs.rewrap) {
         mtklog("rewrap file, %d",cs.incbin);
      } else {
         mtklog("binary file, %d",cs.incbin);
      }

      // should the binary (or forced wrap) file be included?
      bool bProcess = cs.incbin;  // global switch, process all

      bProcess |= bGlblInSpecificProcessing; // within explicite file list

      // text in forced wrap mode: always include
      if (!bIsBinary && cs.rewrap) bProcess = 1;

      if (!bProcess) {
         char *pszRel = pcoi->relName();
         if (matchesFileMask(pszRel, pcoi->name()) & 0x6) // matches by extension list OR name pattern
            bProcess = 1;
      }

      // if not, skip
      if (!bProcess) {
         if (glblFileCount.countSkip(pcoi->name())) {
            if (pGlblJamStatCallBack) {
               long nrc = pGlblJamStatCallBack(pcoi->name(), glblFileCount.value(), cs.lines, (ulong)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog("%ld = jam.stat.callback.1", nrc);
               lRC |= nrc;
            } else {
               info.setAddInfo("%lu files, %lu lines, %lu mb", (ulong)glblFileCount.value(), (ulong)cs.lines, (ulong)(nGlblBytes/1000000UL));
               info.setStatus("skip", pcoi->name(), 0, eKeepAdd);
            }
         }
         return lRC;
      }

      // open binary for read
      if (pcoi->open("rb"))
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      // write subfile header
      lRC |= dumpJamLine(pHeadLine   , 0, 1);   // :file: mtime size
      lRC |= dumpJamLine(pcoi->name(), 0, 1);   // actual filename
      if (lRC)
         return lRC;

      // convert binary to text
      BinTexter bt(pcoi);
      lRC = bt.process(BinTexter::eBT_JamFile);
      pcoi->close();
      if (lRC)
         return lRC;

      // trailer
      lRC |= dumpJamLine("", 0, 1);
   }
   else
   if (pGlblJamFileCallBack)
   {
      num nLocalBytes = 0;
      num nLocalLines = 0;
      lRC = pGlblJamFileCallBack(pcoi->name(), nLocalLines, nLocalBytes);
      // should include header, trailer generation
      cs.lines   += nLocalLines;
      nGlblBytes += nLocalBytes;
   }
   else
   {
    // add file content, check for illegal entries
    if (pcoi->open("rb"))
      { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

    long nMaxLineLen = sizeof(szLineBuf)-10; // YES, szLineBuf
    memset(abBuf, 0, nMaxLineLen+2); // yes, abBuf is larger by far
    long nLocalLines = 0;
    bool bWrapMode = (cs.wrapcol > 0) ? 1 : 0;
    long nLineLen  = 0;
    bool bPassSnap = 0;

    // while (myfgets((char*)abBuf, nMaxLineLen, fin)) // yes, exact len
    while (pcoi->readLine((char*)abBuf, nMaxLineLen) > 0)
    {
      cs.lines++;
      nLocalLines++;

      nLineLen = strlen((char*)abBuf);
      if (nLineLen == nMaxLineLen)
         pwarn("max line length %d reached, splitting. file %s, line %d\n", nMaxLineLen, pcoi->name(), nLocalLines);

      // reading a snapfile or clusterfile content?
      if (startsLikeSnapFile((char*)abBuf))
      {
         // if not reading specific file list, skip this cluster
         if (!bGlblInSpecificProcessing)
            break;

         // but in single file mode, adapt it's content
         nLocalLines++; // skip == 1 check below, we use the file's internal header

         // accept file prefixes:
         bPassSnap = 1;
      }

      if (nLocalLines == 1)
      {
         // first local line: also write header
         if (!bGlblJamPure)
         {
            lRC |= dumpJamLine(pHeadLine   , 0, 1);   // :file: mtime size
            lRC |= dumpJamLine(pcoi->name(), 0, 1);   // actual filename
         }
      }

      // does the input contain unwanted file prefixes?
      if (!bPassSnap && strBegins((char*)abBuf, pPrefix) && nLineLen > 0) {
         // then insert a char to inactivate the prefix
         memmove(abBuf+1,abBuf+0,nLineLen-1); // keeping zero terminator
         abBuf[0] = '\'';
      }

      if (bWrapMode && ((long)strlen((char*)abBuf) > cs.wrapcol))
      {
         // auto-wrap input line into many smaller output lines
         char *psz1 = (char*)abBuf;
         char *pszOld = 0;
         while (*psz1)
         {
            pszOld = psz1;
            long icnt = 0;
            char *pszGap = 0;
            // step until overflow or eod, remember last whitespace
            while (*psz1 && (icnt < cs.wrapcol)) {
               char c = *psz1;
               switch (c) {
                  case ' ': case '\t': case ',':
                     pszGap = psz1;
                     break;
               }
               psz1++;
               icnt++;
            }
            // if overflow, go back past whitespace. if no whitespace,
            // make a word break at that point (splitting very long words).
            if (*psz1) {
               if (pszGap)
                  psz1 = pszGap+1;
            }
            int nLen = psz1-pszOld;
            if (nLen < 5 && isWhitespace(pszOld, nLen))
               { } // cut trailing whitespace
            else
               lRC |= dumpJamLine(pszOld, nLen, *psz1 ? 1 : 0);
            // continue past whitespace or word break.
         }
      } else {
         if (nLineLen > 0 && abBuf[nLineLen-1] == '\n')
            lRC |= dumpJamLine((char*)abBuf, 0, 0); // has own LF
         else
            lRC |= dumpJamLine((char*)abBuf, 0, 1);
      }

      nGlblBytes += strlen((char*)abBuf);
      abBuf[nMaxLineLen] = '\0';

      // check per line if stat update is required
      if (glblFileCount.checkTime())
      {
         if (pGlblJamStatCallBack) {
            long nrc = pGlblJamStatCallBack(pcoi->name(), glblFileCount.value(), cs.lines, (ulong)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
            mtklog("%ld = jam.stat.callback.2", nrc);
            lRC |= nrc;
         } else {
            info.setAddInfo("%lu files, %lu lines, %lu mb", (ulong)glblFileCount.value(), (ulong)cs.lines, (ulong)(nGlblBytes/1000000UL));
            info.setStatus("snap", pcoi->name(), 0, eKeepAdd);
         }
      }

      // STOP in-file processing on non-zero rc
      if (lRC) break;

    } // endwhile lines

    pcoi->close();

    // trailer
    lRC |= dumpJamLine("", 0, 1);
   } // endelse binary

   if (glblFileCount.count()) 
   {
      if (pGlblJamStatCallBack) {
         long nrc = pGlblJamStatCallBack(pcoi->name(), glblFileCount.value(), cs.lines, (ulong)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
         mtklog("%ld = jam.stat.callback.3", nrc);
         lRC |= nrc;
      } else {
         info.setAddInfo("%lu files, %lu lines, %lu mb", (ulong)glblFileCount.value(), (ulong)cs.lines, (ulong)(nGlblBytes/1000000UL));
         info.setStatus("snap", pcoi->name(), 0, eKeepAdd);
      }
   }

   return lRC;
}

Array glblRefDst("RefDst");
StringTable glblRefSrc;
StringTable glblRefDstNames;
uchar abGlblRefChars[256];   // map of chars used in destination names

long execRefColDst(Coi *pcoi)
{
   char *pszFile = pcoi->name();

   char szAddInfo[200];
   sprintf(szAddInfo, "%lu targets", glblRefDst.numberOfEntries(0)+1);
   info.setStatus("scan", pszFile, szAddInfo);

   if (cs.rootrelname)
      pszFile = pcoi->rootRelName();

   strncpy(szLineBuf, pszFile, sizeof(szLineBuf)-10);
   szLineBuf[sizeof(szLineBuf)-10] = '\0';

   // force path chars to system path char.
   // the same is done in the source contents to ease comparison.
   char *psz2 = szLineBuf;
   while (*psz2) {
      if (*psz2 == glblWrongPChar)
         *psz2 = glblPathChar;
      psz2++;
   }

   #ifdef _WIN32
   // create lowercase filename, we want to compare case-insensitive
   if (!cs.usecase) {
      char *psz1 = szLineBuf;
      while (*psz1) {
         if (isalpha(*psz1))
            *psz1 = tolower(*psz1);
         psz1++;
      }
   }
   #endif

   // create map of used chars in dest. names, for search optim
   for (uchar *psz5=(uchar*)szLineBuf; *psz5; psz5++)
      abGlblRefChars[*psz5] = 1;

   // RefDst Array (Table) structure
   // ==============================
   //    0     1     2     3     4     ...
   // dstName1 rcnt  src1  src2 ""     ...
   // dstName2 rcnt  src1  src2 src3   ...
   // dstName3 rcnt  src1  ""   ""     ...

   glblRefDst.addString(0, szLineBuf);
   glblRefDst.addLong(1, 0, __LINE__);
   for (long i=0; i<nGlblRefMaxSrc; i++)
      glblRefDst.addNull(2+i);

   return 0;
}

bool isFileNameChar(char c) {
   if (isalnum(c)) return true;
   switch (c) {
      case glblPathChar: return true;
      case glblWrongPChar: return true;
      case '_': return true;
      case ':': return true;
      case '.': return true;
      case '-': return true;
      case '#': return true;
   }
   return false;
}

long execRefColSrc(char *pszFile)
{
   cs.refsrccnt++;

   char szAddInfo[200];
   sprintf(szAddInfo, "%lu sources", cs.refsrccnt);
   info.setStatus("scan", pszFile, szAddInfo);

   // remember also list of source files
   glblRefSrc.addEntry(pszFile);

   // used when auto-including targets as internal sources
   if (cs.coldstnames)
      glblRefDstNames.addEntry(pszFile);

   return 0;
}

long execRefProcSrc(char *pszFile, char *pszOptRoot, long icur, long ntotal)
{
   if (userInterrupt())
      return 9;

   info.setAddInfo("%ld files of %ld",icur,ntotal);
   info.setProgress(ntotal, icur, "files");
   info.setStatus("scan", pszFile, 0, eKeepAdd|eKeepProg);

   if (cs.debug) {
      info.printLine(1<<2);
   }

   num nFileSize = getFileSize(pszFile);
   if (nFileSize <= 0)
      return 0;
   if (nFileSize >= nGlblMemLimit) {
      pwarn("file too large, skipping: %s\n", pszFile);
      return 0;
   }

   // load native file content
   char *pInFile = new char[nFileSize+10];
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) { 
      perr("cannot read: %s\n", pszFile); 
      delete [] pInFile; 
      return 0; 
   }
   unsigned long nRead = fread(pInFile, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      perr("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pInFile;
      return 0;
   }
   pInFile[nFileSize] = '\0';

   // convert content to allow strstr.
   // in case of windows prepare case-insensitive comparison.
   // force all path chars to use system path char.
   #ifdef _WIN32
   bool bCase = cs.usecase;
   #endif

   if (cs.refstripsrc)
   {
      // strip source file content from all characters
      // that have not appeared in target filenames.
      ulong i1=0, i2=0;
      ulong clast = 0xFFFF;
      for (; i1<nFileSize; i1++)
      {
         uchar c = (uchar)pInFile[i1];
   
         #ifdef _WIN32
         if (isalpha((char)c) && !bCase)
            c = (uchar)tolower((char)c);
         #endif
   
         if (!abGlblRefChars[c]) 
         {
            // flatten binary stuff 
            c = 0xFF;
            // reduce if possible
            if (c == clast) continue;
            pInFile[i2++] = (char)c;
            clast = c;
            continue;
         }
         clast = 0xFFFF;
   
         // copy-through readable text char
         if (c == (uchar)glblWrongPChar)
            pInFile[i2++] = glblPathChar;
         else
            pInFile[i2++] = (char)c;
      }
      if (i2 > nFileSize) return 9+perr("internal #278242039\n");
      pInFile[i2] = '\0'; // including offset nFileSize, as above
   }
   else
   {
      for (ulong i=0; i<nFileSize; i++) 
      {
         char c = pInFile[i];
         if (c == '\0')
            pInFile[i] = ' ';
         else
         if (c == glblWrongPChar)
            pInFile[i] = glblPathChar;
         #ifdef _WIN32
         else
         if (isalpha(c) && !bCase)
            pInFile[i] = tolower(c);
         #endif
      }
   }

   // for all dst entries
   for (long idst=0; idst<glblRefDst.numberOfEntries(0); idst++)
   {
      char *pszDstRaw = glblRefDst.getString(0, idst);
      char *pszDst    = pszDstRaw;

      // do NOT add our own name as a ref
      if (!strcmp(pszDstRaw, pszFile))
         continue;

      // check for any occurrence of relativized pszDst
      if (bGlblRefRelCmp) {
         char *pszRel = strrchr(pszDst, glblPathChar);
         if (pszRel) pszDst = pszRel+1;
         if (cs.debug) info.print("REL *%s* \n", pszDst);
      }

      // use only basename of pszDst?
      if (bGlblRefBaseCmp) {
         strncpy(szLineBuf, pszDst, sizeof(szLineBuf)-10);
         szLineBuf[sizeof(szLineBuf)-10] = '\0';
         char *pszDot = strrchr(szLineBuf, '.');
         if (pszDot) *pszDot = '\0';
         pszDst = szLineBuf;
         if (cs.debug) info.print("BAS *%s* \n", pszDst);
      }

      char *pszHit = 0;
      if (pszHit = strstr(pInFile, pszDst))
      {
         // increment reference count for target
         long iCnt = glblRefDst.getLong(1, idst, __LINE__);
         glblRefDst.setLong(1, idst, iCnt+1, __LINE__);

         // remember (some) source infos referencing this target
         char *pszPre = pszHit;
         while (pszPre > pInFile) {
            #ifdef _WIN32
            bool bColon = (*pszPre == ':');
            #endif
            if (!isFileNameChar(*(pszPre-1)))
               break;
            pszPre--;
            #ifdef _WIN32
            if (bColon)
               break;
            #endif
         }
         char *pszPost = pszHit;
         while (pszPost < pInFile+nFileSize-1) {
            if (!isFileNameChar(*(pszPost+1)))
               break;
            pszPost++;
         }

         // relativize name, to match in later recursive checks
         char *pszRel = pszFile;
         if (cs.rootrelname) {
            pszRel = rootRelativeName(pszRel, pszOptRoot);
            if (!pszRel) return 9;
         }

         long nBruttoLen = pszPost-pszPre+1;
         if (nBruttoLen != strlen(pszDst))
            sprintf(szLineBuf2, "%s\t%s\t[by text \"%s\" within \"%.*s\"]", pszRel, pszDstRaw, pszDst, (int)nBruttoLen, pszPre);
         else
            sprintf(szLineBuf2, "%s\t%s\t[by text \"%.*s\"]", pszRel, pszDstRaw, (int)nBruttoLen, pszPre);

         // we store up to n source infos in the extended rows
         if (iCnt < nGlblRefMaxSrc) {
            if (bGlblRefWideInfo)
               glblRefDst.setString(2+iCnt, idst, szLineBuf2);
            else
               glblRefDst.setString(2+iCnt, idst, pszFile); // pszRel?
         } else {
            bGlblRefLimitReached = 1;
         }
      }
      else {
         // printf("nohit %s: \n", pszFile);
         // sfkmem_hexdump(pInFile, (long)nFileSize);
      }
   }

   delete [] pInFile; 

   // printf("rps: %s done\n", pszFile);

   return 0;
}

bool nameListedIn(StringTable &rasrc, char *pszName)
{
   for (long isrcx=0; isrcx<rasrc.numberOfEntries(); isrcx++) {
      char *pszSrcX = rasrc.getEntry(isrcx, __LINE__);
      if (!strcmp(pszName, pszSrcX))
         return true;
   }
   return false;
}

long listDependencies(StringTable &rasrc, char *pszMixed, long nLevel, bool bPrintRoot, bool &rprinted)
{
   // pszMixed format:
   // EITHER root\tignore\t[remark]
   //     OR root
   char *p1 = pszMixed;
   char *p2 = strchr(p1, '\t');
   char szRoot[200];
   if (p2) {
      long nroot = p2-p1;
      if (nroot > sizeof(szRoot)-4) return 9+perr("buffer overflow #ld01 %ld %ld\n",sizeof(szRoot)-4,nroot);
      strncpy(szRoot, p1, nroot); szRoot[nroot] = '\0';
   } else {
      strcopy(szRoot, pszMixed);
   }

   if ((nLevel == 0) && (!bPrintRoot))
      { }
   else {
      // if filenames are collected
      if (cs.depsingle && chain.colfiles) {
         Coi ocoi(szRoot, 0);
         chain.addFile(ocoi); // is copied
      } else {
         chain.print(' ', 0, "%s", szRoot);
         rprinted |= 1;
      }
   }

   // remember we don't have to solve this root again
   char *pszRelRoot = szRoot;
   if (nLevel == 0 && cs.rootrelname) {
      pszRelRoot = rootRelativeName(pszRelRoot, 0);
      if (!pszRelRoot) return 9;
   }
   rasrc.addEntry(pszRelRoot);

   char szAnySrc[200];

   // recurse into dependencies of root
   long ncalled = 0;
   for (long idst=0; idst<glblRefDst.numberOfEntries(0); idst++)
   {
      // scan ANY target
      char *pszDst  = glblRefDst.getString(0, idst);
      long  nRefCnt = glblRefDst.getLong(1, idst, __LINE__);
      if (nRefCnt <= 0) continue;

      long nDump = nRefCnt;
      if (nDump > nGlblRefMaxSrc)
         nDump = nGlblRefMaxSrc;

      // enumerate sources for ANY target
      for (long isrc=0; isrc<nDump; isrc++) 
      {
         char *pszMixed = glblRefDst.getString(2+isrc, idst);
         if (!pszMixed) return 9+perr("internal: unexpected NULL in RefDst %ld %ld %ld\n",isrc,idst,nDump);

         // static long ntell=0;
         // while (ntell++ < 100)
         //    printf("mixed: %s\n", pszMixed);

         // holding anySource\ttargetForAnySource\t[remark]
         // INDEPENDENTLY from our current szRoot.
         p1 = pszMixed;
         p2 = strchr(p1, '\t'); if (!p2) return 9;
         long nsrc = p2-p1;
         if (nsrc > sizeof(szAnySrc)-4) return 9+perr("buffer overflow #ld02 %ld %ld\n",sizeof(szAnySrc)-4,nsrc);
         strncpy(szAnySrc, p1, nsrc); szAnySrc[nsrc] = '\0';

         // now holding szAnySrc -> pszDst dependency.
         // are WE the szAnySrc?
         if (strcmp(pszRelRoot, szAnySrc)) continue; // no

         // yes: found another forward dependency as pszDst
         if (nameListedIn(rasrc, pszDst)) continue; // but done this already

         // found a new dependency as pszDst
         if (rprinted & 1) {
            if (rprinted & 2)
               chain.print(' ', 0, "\t"); // after very first output
            else
               chain.print(' ', 0, " ");  // after all other outputs
            rprinted &= 0xFF - 3;   // clear both flags
         }
         listDependencies(rasrc, pszDst, nLevel+1, bPrintRoot, rprinted);

         break; // DONE with current anySrc
      }
   }

   return 0;
}

long execDeblank(char *pszPath)
{
   // replace blanks in (last part of) path by '_'
   strncpy(szLineBuf, pszPath, MAX_LINE_LEN);
   szLineBuf[MAX_LINE_LEN] = '\0';

   char *psz1 = strrchr(szLineBuf, glblPathChar);
   if (!psz1)
         psz1 = szLineBuf;

   bool bAny = 0;

   while (*psz1)
   {
      char craw = *psz1;
      char c = craw;

      if (cs.packalnum) 
      {
         // alnum reduction mode
         c = tolower(c);
         *psz1 = c;
         if (c != craw)
            bAny = 1;
         if (c == '.' || c == glblPathChar)
            { psz1++; continue; }
         if (c >= 'a' && c <= 'z')
            { psz1++; continue; }
         if (c >= '0' && c <= '9')
            { psz1++; continue; }
         // remove char from string
         int nlen = strlen(psz1);
         memmove(psz1,psz1+1,nlen); // INCLUDES zero term
         bAny = 1;
         continue; // staying at same psz1
      }

      // normal deblank mode
      if (c != ' ')
         { psz1++; continue; }
      // replace blank by underscore
      *psz1 = '_';
      psz1++;
      bAny = 1;
   }

   if (!bAny)
      return 0; // nothing to do

   if (!cs.quiet)
      printf("%s -> %s\n", pszPath, szLineBuf);

   if (cs.yes) {
      int nRC = rename(pszPath, szLineBuf);
      if (nRC) return 1+perr("rename failed on %s\n", pszPath);
   }

   return 0;
}

long sendLine(SOCKET hSock, char *psz, bool bQuiet=0);
long readLine(SOCKET hSock, char *pszLineBuf = szLineBuf, long nMode=0);

#ifdef WITH_TCP

long execFTPList(char *pszName)
{
   // list a single file OR directory.

   if (!strcmp(pszName, "."))
      return 0;

   long bIsDir    = 0;
   long bCanRead  = 1;
   long bCanWrite = 1;
   num  nFTimePre = 0;
   num  nFileSize = 0;
   getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFTimePre, nFileSize);

   // -rw-r--r-- 1 ftp ftp         102808 Nov 20  2005 lslr
   // -rw-r--r-- 1 ftp ftp              4 May 27 23:34 tmp1.dat

   mytime_t nFileTime   = (mytime_t)nFTimePre;   // may be 0xFFFF
   mytime_t nSysTime    = getSystemTime();       // may be 0xFFFF
   struct tm *pSysTime  = 0;
   struct tm *pFileTime = 0;
   ulong nSysYear = 0;

   #ifdef SFK_W64
   pSysTime  = _localtime64(&nSysTime);    // may be NULL
   nSysYear  = (pSysTime != 0) ? pSysTime->tm_year : 0;
   pFileTime = _localtime64(&nFileTime);   // OVERWRITES pSysTime!
   pSysTime  = 0;
   #else
   pSysTime  = localtime(&nSysTime);       // may be NULL
   nSysYear  = (pSysTime != 0) ? pSysTime->tm_year : 0;
   pFileTime = localtime(&nFileTime);      // OVERWRITES pSysTime!
   pSysTime  = 0;
   #endif

   char abTimeStamp[100];
   abTimeStamp[0] = '\0';

   // files of current year get time added on listing, else list year
   if (pFileTime != 0) {
      if (bGlblFTPListFlatTS) {
         char *pszFlat = timeAsString(nFTimePre, 1); // 1: flat
         if (pszFlat) strcopy(abTimeStamp, pszFlat);
      }
      else
      if (nSysYear == (ulong)pFileTime->tm_year)
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %H:%M", pFileTime);
      else
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %Y", pFileTime);
   } else {
      strcpy(abTimeStamp, "Dez 31 9999");
   }

   // binary or text file?
   bool cType = bIsDir ? 'd' : 'b';
   if (!bIsDir && !isBinaryFile(pszName, 10000))
        cType = 't';

   sprintf(szLineBuf2, "%c%s%c 1 ftp ftp %s %s ",
      bIsDir ? 'd' : '-',
      bGlblFTPReadWrite ? "rw-rw-rw-":"r--r--r--",
      cType,
      numtoa_blank(nFileSize), abTimeStamp);

   if (bGlblFTPListAsHTML) {
      strcat(szLineBuf2, "<a href=\"");
      strcat(szLineBuf2, pszName);
      strcat(szLineBuf2, "\">");
      strcat(szLineBuf2, pszName);
      strcat(szLineBuf2, "</a>");
   } else {
      strcat(szLineBuf2, pszName);
   }

   if (cs.debug)
      printf("< %s\n", szLineBuf2);

   if (sendLine(hGlblTCPOutSocket, szLineBuf2, 1)) // uses szLineBuf
      return 9;

   return 0;
}

long execFTPNList(char *pszFileName)
{
   return sendLine(hGlblTCPOutSocket, pszFileName, 1);
}

StringTable glblFTPRemList;
StringTable glblFTPLocList;

long execFTPLocList(char *pszFileName)
{
   return glblFTPLocList.addEntry(pszFileName);
}

#endif

long execSingleFile(Coi *pcoi, long lLevel, long &lFiles, long nDirFileCnt, long &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2)
{__
   mtklog("execSingleFile %s root %s", pcoi->name(), pcoi->root());

   // printf(" esf %s\n", pcoi->name());

   char *pszFile     = pcoi->name();
   char *pszOptRoot  = pcoi->root(1);  // raw, returns 0 if none
   char *pszOptRef   = pcoi->ref(1);   // raw, returns 0 if none

   if (userInterrupt())
      return 9;

   if (cs.walkFileDelay > 0) doSleep(cs.walkFileDelay);

   // make sure the file really exists.
   // make an exception for "run", as it may use "$text".
   if (nGlblFunc != eFunc_Run) {
      // if no meta info was read yet, do it now.
      if (!pcoi->status())
         pcoi->readStat();
      // if meta reading failed, the file cannot be processed.
      if (pcoi->status() >= 9) {
         if (!cs.quiet && !cs.nowarn)
            pwarn("[nopre] cannot read file status: %s\n",pcoi->name());
         return 0; // do NOT stop dirtree processing
      }
   }

   if (!pszOptRoot && glblFileSet.hasRoot(0))
        pszOptRoot = glblFileSet.getCurrentRoot();
   // optionally supplied root dir can still be NULL.

   info.cycle();

   // skip initial dot slash which might be returned by dir scanning
   if (!strncmp(pszFile, glblDotSlash, 2))
      pszFile += 2;

   // if set, exclude output filename from input fileset,
   // to avoid endless recursions e.g. on snapto function.
   // see also checks for FileCollectionStamp.
   if (pszGlblOutFile)
      if (equalFileName(pszGlblOutFile,pszFile))
         return 0;

   // -text: process only textfiles
   if (cs.textfiles || cs.binaryfiles) 
   {
      bool bbin = pcoi->isBinaryFile();
      bool binc = 1;
      char *ptxt1 = "", *ptxt2 = "";

      if (cs.textfiles && bbin)
         { binc=0; ptxt1="binary"; ptxt2="text"; }

      if (cs.binaryfiles && !bbin)
         { binc=0; ptxt1="text"; ptxt2="binary"; }

      if (!binc) {
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceExcColor);
            info.print("file-exclude: %s is %s\n", pszFile, ptxt1);
            setTextColor(-1);
         }
         return 0;
      } else {
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceIncColor);
            info.print("file-include: %s is %s\n", pszFile, ptxt2);
            setTextColor(-1);
         }
      }
   }

   // -since: process only files newer or equal than timestamp
   if (cs.sincetime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get file time: %s\n", pszFile);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime < cs.sincetime)
         return 0; // skip
   }

   // -before: process only files older or equal than timestamp
   if (cs.untiltime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get file time: %s\n", pszFile);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime >= cs.untiltime)
         return 0; // skip
   }

   // -sincedir: process only files newer than in reference dir
   long nSinceReason = 0;
   if (pszGlblSinceDir)
   {
      // build relative name of file to be processed
      char *pszRel = pszFile;
      if (!bGlblSinceDirIncRef)
         pszRel = pcoi->rootRelName();
      if (!pszRel) return 9;
      // proceed with -sincedir processing
      joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszGlblSinceDir, pszRel);
      if (cs.verbose > 1)
         printf("CMP src %s ref %s\n",pszFile,szRefNameBuf);
      mtklog("CMP src %s ref %s",pszFile,szRefNameBuf);
      // BEWARE OF MIXUP:
      //    sfk list -sincedir foo bar
      //       means for the user: FOO (szRefNameBuf) is the SOURCE.
      // so pszFile provided in here is actually the DESTINATION for compare.
      FileStat ofsSrc, ofsDst;
      if (ofsDst.readFrom(pszFile))       // the tree processing "target"
         return 9+perr("cannot read file time: %s\n",pszFile);
      if (ofsSrc.readFrom(szRefNameBuf))  // the -sincedir "source"
      {
         // file has been added, compared to source
         nSinceReason |= 4; // added
         if (!(nGlblSinceMode & 1)) {
            // added files not included:
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceExcColor);
               info.print("file-exclude: %s is added file, %s does not exist\n", pszFile, szRefNameBuf);
               setTextColor(-1);
            }
            cs.addedFilesSkipped++;
            return 0; // skip added files
         }
         // added files included:
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceIncColor);
            info.print("file-include: %s is added file, %s does not exist\n", pszFile, szRefNameBuf);
            setTextColor(-1);
         }
      }
      else
      {
         // both files exist

         // quick-check the size
         bool bDiffSize = 0;
         if (ofsSrc.getSize() != ofsDst.getSize())
            bDiffSize = 1;

         // compare times
         long nDiffReason = 0;
         if (!bGlblIgnoreTime) {
            if (!(nDiffReason = ofsSrc.differs(ofsDst, 0))) { // NOT same if older src
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s same time as %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               // if (!bDiffSize) // fall through on size mismatch
               return 0;
            } else {
               nSinceReason |= 1;
            }
         }

         // timestamp, attrib or exist difference: check also content
         if (bDiffSize)
            nSinceReason |= 2; // different size
         else
         if (!equalFileContent(szRefNameBuf, pszFile))
            nSinceReason |= 2; // file content difference

         if (nSinceReason & 2) 
         {
            // file content is different:
            if (cs.verbose)
               printf("differs by content: %s\n", pszFile);
   
            if (!(nGlblSinceMode & 2)) {
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s differs against %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               return 0; // skip differing files
            }

            // differing files included
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceIncColor);
               info.print("file-include: %s content differs against %s\n", pszFile, szRefNameBuf);
               setTextColor(-1);
            }
         }
         else
         {
            // have no content difference:
            if (!(nGlblSinceMode & 4)) {
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s time but no content diff against %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               return 0; // skip only-time diffs
            }

            // are we interested just in content diffs?
            if (bGlblIgnoreTime) {
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s just time diff against %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               return 0; // no content diff, no processing
            }

            // differing files included
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceIncColor);
               info.print("file-include: %s just time diff against %s\n", pszFile, szRefNameBuf);
               setTextColor(-1);
            }
         }
      }

      // sincedir checks passed: register reference
      pcoi->setRef(szRefNameBuf);

   }  // endif sincedir

   // -to specified? if so, build output filename.
   char *pszOutFile = 0;
   if (cs.tomask)
   {
      long nrc = renderOutMask(szOutNameBuf, pcoi, cs.tomask, cs.curcmd);
      // only rc 0 accepted: there MUST be replacements
      if (nrc >= 9) return nrc;
      if (nrc > 0) {
         perr("-to target name did not contain any patterns.\n");
         printx("<time>note : add or insert words like <run>file, <run>relfile, <run>base etc.<def>\n");
         printx("<time>note : type \"sfk run\" for a list of possible patterns.\n");
         return 9;
      }
      pszOutFile = szOutNameBuf;
   }

   switch (nGlblFunc) 
   {
      case eFunc_MD5Write  : return execMD5write(pcoi); break;
      case eFunc_JamFile   : return execJamFile(pcoi);  break;
      case eFunc_CallBack  : return execCallFileDir(pcoi);  break;
      case eFunc_Detab     : return execDetab(pszFile, pszOutFile); break;
      case eFunc_Scantab   : return execScantab(pszFile);    break;
      case eFunc_Entab     : return execEntab(pszFile);      break;
      case eFunc_JamIndex  : return execJamIndex(pszFile);   break;
      case eFunc_SnapAdd   : return execSnapAdd(pszFile);    break;
      case eFunc_FileStat  : return execFileStat(pcoi, lLevel, lFiles, lDirs, lBytes, nLocalMaxTime, ntime2, nSinceReason);  break;
      case eFunc_Grep      : return execGrep(pcoi);          break;
      case eFunc_Mirror    : return execFileMirror(pszFile, nLocalMaxTime, ntime2, nDirFileCnt); break;
      case eFunc_Run       : return execRunFile(pcoi, pszOutFile, lLevel, lFiles, lDirs, lBytes);  break;
      case eFunc_FormConv  : return execFormConv(pszFile, pszOutFile);   break;
      #ifdef WITH_FN_INST
      case eFunc_Inst      : return execInst(pszFile, lLevel, lFiles, lDirs, lBytes);  break;
      #endif
      case eFunc_RefColSrc : return execRefColSrc(pszFile);  break;
      case eFunc_RefColDst : return execRefColDst(pcoi);     break;
      case eFunc_Deblank   : return execDeblank(pszFile);    break;
      #ifdef WITH_TCP
      case eFunc_FTPList   : return execFTPList(pszFile);    break;
      case eFunc_FTPNList  : return execFTPNList(pszFile);   break;
      case eFunc_FTPLocList: return execFTPLocList(pszFile); break;
      #endif
      case eFunc_Hexdump   : return execHexdump(pszFile, 0, 0);   break;
      case eFunc_AliasList : return execAliasList(pszFile);  break;
      case eFunc_ReplaceFix: return execReplaceFix(pcoi);    break;
      case eFunc_ReplaceVar: return execReplaceVar(pcoi);    break;
      case eFunc_Filter    : return execFilter(pcoi, 0, 0, -1, pszOutFile); break;
      case eFunc_Delete    : return execDelFile(pszFile);    break;
      #ifndef USE_SFK_BASE
      case eFunc_Copy      : return execFileCopy(pcoi);      break;
      case eFunc_Cleanup   : return execFileCleanup(pszFile);     break;
      case eFunc_MetaUpd   : return execMetaFileUpdate(pszFile); break;
      case eFunc_MetaCheck : return execMetaFileCheck(pszFile); break;
      case eFunc_DupScan   : return execDupScan(pszFile);    break;
      #endif // USE_SFK_BASE
      case eFunc_Version   : return execVersion(pcoi); break;
      default: break;
   }

   return 0;
}

char szMirStatBuf[200];
void showMirrorStatus(const char *pszAction, const char *pszStatus,
   char *pszObject, bool bIsFile, long nCount, bool bLF=0)
{
   // if pszObject is a filename with path, show just path.

   int nLen = strlen(pszObject);
   if (bIsFile) {
      char *psz1 = strrchr(pszObject, glblPathChar);
      if (psz1) nLen = psz1-pszObject;
   }
   if (nLen > 40) { pszObject += (nLen-40); nLen = 40; }

   sprintf(szMirStatBuf, "% 4lu %4.4s %4.4s %03lu %.*s ",
      glblFileCount.value(),
      pszAction, pszStatus,
      nCount, nLen, pszObject
      );

   // fill up with blanks to 76 chars
   nLen = strlen(szMirStatBuf);
   while (nLen < 76)
      szMirStatBuf[nLen++] = ' ';
   szMirStatBuf[nLen] = '\0';

   if ((cs.verbose==2) && strcmp(pszAction, "scan") && strcmp(pszStatus, "----"))
      bLF = 1;

   printf("%s%c", szMirStatBuf, bLF ? '\n' : '\r');
   fflush(stdout);
}

#ifdef SFK_CCDIRTIME
StringTable glblCreatedDirs;
#endif

bool isNetDriveRoot(char *psz)
{
   #ifdef _WIN32
   if (strncmp(psz, "\\\\", 2)) return 0;
   #else
   if (strncmp(psz, "//", 2)) return 0;
   #endif
   // jump past \\, check if further dir is appended
   char *psz2 = strchr(psz+2, glblPathChar);
   if (!psz2) return 1;   // yes: e.g. \\foomachine
   // is it JUST a slash or something more?
   psz2++;
   if (!strlen(psz2)) return 1; // just the slash
   return 0; // no: e.g. \\foomachine\c$
}

// uses szLineBuf, abBuf
long createSubDirTree(char *pszDstRoot, char *pszDirTree, char *pszRefRoot=0)
{
   // create all needed target directories
   joinPath(szLineBuf, MAX_LINE_LEN, pszDstRoot, pszDirTree);

   char *psz1 = szLineBuf;
   char *psz2 = 0;
   if (strlen(psz1))
      psz2 = strchr(psz1+1, glblPathChar);
   while (psz2) 
   {
      strncpy((char*)abBuf, psz1, psz2-psz1);
      abBuf[psz2-psz1] = 0;
      char *pszDir = (char*)abBuf;

      #ifdef _WIN32
      if (strlen(pszDir)==2 && pszDir[1]==':')
      { } // don't create "c:"
      else
      #endif
      if (isNetDriveRoot(pszDir))
      { }
      else
      if (!isDir(pszDir)) 
      {
         if (cs.verbose) 
            printf("mkdir.1: %s\n", pszDir);
         #ifdef _WIN32
         if (_mkdir(pszDir))
         #else
         if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
         #endif
         {
            perr("cannot create dir: %s\n", pszDir);
            return 9;
         }
         // if ref root is given, copy it's timestamp
         // doesn't work here: file created afterwards updates the dir timestamp
         // trace created dir in global list
         #ifdef SFK_CCDIRTIME
         glblCreatedDirs.addEntry(pszDir);
         #endif
         // count created dir
         cs.dirs++;
      }
      psz2 = strchr(psz2+1, glblPathChar);
   }

   char *pszDir = szLineBuf;

   #ifdef _WIN32
   if (strlen(pszDir)==2 && pszDir[1]==':')
   { } // don't create "c:"
   else
   #endif
   if (isNetDriveRoot(pszDir))
   { }
   else
   if (!isDir(pszDir)) 
   {
      if (cs.verbose)
         printf("mkdir.2: %s\n", pszDir);
      #ifdef _WIN32
      if (_mkdir(pszDir))
      #else
      if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
      #endif
      {
         perr("cannot create dir: %s\n", pszDir);
         return 9;
      }
      #ifdef SFK_CCDIRTIME
      glblCreatedDirs.addEntry(pszDir);
      #endif
      cs.dirs++;
   }
   return 0;
}

// create dir tree required to write the specified filename.
// uses: szLineBuf, abBuf
// note: does NOT add to glblCreatedDirs
//       does not count created dirs.
long createOutDirTree(char *pszOutFile)
{
   // isolate path from filename
   // c:\foo\bar.txt -> c:\foo
   // c:foo\bar.txt -> c:\foo
   // c:bar.txt -> skip
   strcopy(szLineBuf, pszOutFile);
   char *psz = strrchr(szLineBuf, glblPathChar);
   if (!psz) return 0; // nothing to do
   *psz = '\0';

   char *psz1 = szLineBuf;
   char *psz2 = 0;
   if (strlen(psz1))
      psz2 = strchr(psz1+1, glblPathChar);
   while (psz2) 
   {
      strncpy((char*)abBuf, psz1, psz2-psz1);
      abBuf[psz2-psz1] = 0;
      char *pszDir = (char*)abBuf;
      #ifdef _WIN32
      if (strlen(pszDir)==2 && pszDir[1]==':')
      { } // don't create "c:"
      else
      #endif
      if (isNetDriveRoot(pszDir))
      { }
      else
      if (!isDir(pszDir)) 
      {
         if (cs.verbose) 
            printf("mkdir.3: %s\n", pszDir);
         #ifdef _WIN32
         if (_mkdir(pszDir))
         #else
         if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
         #endif
         {
            perr("cannot create dir: %s\n", pszDir);
            return 9;
         }
      }
      psz2 = strchr(psz2+1, glblPathChar);
   }

   char *pszDir = szLineBuf;

   #ifdef _WIN32
   if (strlen(pszDir)==2 && pszDir[1]==':')
   { } // don't create "c:"
   else
   #endif
   if (isNetDriveRoot(pszDir))
   { }
   else
   if (!isDir(pszDir)) 
   {
      if (cs.verbose)
         printf("mkdir.4: %s\n", pszDir);
      #ifdef _WIN32
      if (_mkdir(pszDir))
      #else
      if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
      #endif
      {
         perr("cannot create dir: %s\n", pszDir);
         return 9;
      }
   }
   return 0;
}

long execDirFreeze(char *pszName, long lLevel, FileList &oDirFiles, num &nLocalMaxTime, num &nTreeMaxTime)
{
   long nLocFiles = oDirFiles.clNames.numberOfEntries();

   // in: pszGlblSrcRoot, DstRoot, pszName
   if (!strncmp(pszName, glblDotSlash, 2))
      pszName += 2;

   if (!nLocFiles) {
      // zero files found: do not call zip
      if (cs.verbose)
         showMirrorStatus("zip ", "skip", pszName, 0, 0);
      return 0;
   }

   // create all needed target directories
   if (createSubDirTree(pszGlblDstRoot, pszName))
      return 9;

   // check file time maxima: any need to call zip?
   sprintf(szLineBuf, "%s%s%c01-arc-part.zip", pszGlblDstRoot, pszName, glblPathChar);
   num nZipTime = getFileTime(szLineBuf);

   // FIX: whole time comparison now OPTIONAL (bGlblMirrorByDate).
   //      if user installs old files, e.g. from an archive,
   //      he surely wants them back-uped as well, although
   //      they do NOT update the directory max time.

   // IF we want to fully optimize the backup process, we have to check
   // 1. if a directory contains files not yet listed there
   // 2. if the existing files have a different md5 checksum
   // but we shall NOT simply rely on the file times!

   bool bNoChange = 0;

   if (   // (nLocalMaxTime == 0) || // i.e. no files at all contained
       (bGlblMirrorByDate && (nZipTime != 0) && (nLocalMaxTime <= nZipTime))
      )
   {
      // skip, don't bother zip
   }
   else
   {
      // else create or update zip archive
      sprintf(szLineBuf, 
              "%s -u -D %s\"%s%s%c01-arc-part.zip\" \"%s\"%c* "
              "2>>%s09-freeze-log.txt",
              pszGlblZipCmd,
              cs.hidden ? "-S " : "",
              pszGlblDstRoot, pszName, glblPathChar,
              pszName,
              glblPathChar,
              pszGlblDstRoot
             );

      if (!cs.quiet) {
         if (cs.verbose >= 3)
            printf("%s\n", szLineBuf);
         else
         if (cs.verbose)
            showMirrorStatus("zip ", "----", pszName, 0, nLocFiles);
      }

      long lRC = 0;
      if (lRC = system(szLineBuf))
      {
         // zip RC 12, 3072: nothing to do
         if (lRC == 12 || lRC == 3072)
         {
            // if (nLocFiles > 0) {
            //    logError("warning: there seem to be %lu files, but ZIP says \"nothing to do\" in dir:", nLocFiles);
            //    logError("warning: %s", pszName);
            // }
            // return 0;
            bNoChange = 1;
         }
         else
         {
            // all other RC's: real error, like cannot access file
            logError("error: RC %d while running command:\n   %s", lRC, szLineBuf);
            // continue, list errors when finishing
            return 0;
         }
      }
   }

   // recreate target archive name
   if (!strcmp(pszName, "."))
      sprintf(szLineBuf, "%s01-arc-part.zip", pszGlblDstRoot);
   else
      sprintf(szLineBuf, "%s%s%c01-arc-part.zip", pszGlblDstRoot, pszName, glblPathChar);

   // 1. write single file entry:
   // not done here, but in execFileFreeze.

   // 2. write md5 of archive zip:
   SFKMD5 md5;
   // if (getFileMD5(szLineBuf, md5, 1))
   if (getZipMD5(szLineBuf, md5, oDirFiles))
   {
      // this is valid only if there are no files w/in dir.
      if (nLocFiles > 0) {
         nGlblFzMisArcFiles += nLocFiles;
         logError("warning: there seem to be %lu files, but ZIP created no archive for dir:", nLocFiles);
         logError("warning: %s", pszName);
      }
      // logError("error: no archive created:\n   %s", szLineBuf);
      if (cs.verbose)
         showMirrorStatus("zip ", "skip", pszName, 0, nLocFiles);
      return 0;
   }
   unsigned char *pmd5 = md5.digest();
   int i=0;
   for (i=0; i<16; i++)
      fprintf(fGlblMD5Arc,"%02x",pmd5[i]);
   fprintf(fGlblMD5Arc," *%s%c01-arc-part.zip\n", pszName, glblPathChar); // md5sum similar

   // 3. extend unpack batch:
   fprintf(fGlblBatch, "05-arc-tools%cunzip \"%s%c01-arc-part.zip\"\n", glblPathChar, pszName, glblPathChar);

   // remember dir maxtime in dir-times.txt
   char szTimeBuf[100];
   if (fGlblTimes != 0) {
      fprintf(fGlblTimes, "%s %s%c01-arc-part.zip\n", numtoa(nLocalMaxTime,15,szTimeBuf), pszName, glblPathChar);
      fflush(fGlblTimes);
   }

   // getZipMD5 matched the input filenamelist against the directory
   // within the zipfile. check if anything's remaining:
   long nNames = oDirFiles.clNames.numberOfEntries();
   for (i=0; i<nNames; i++) {
      char *psz = oDirFiles.clNames.getEntry(i, __LINE__);
      if (psz[0] != 0) {
         nGlblFzMisArcFiles++;
         logError("warning: file was not added to archive %s:", szLineBuf);
         logError("warning: %s", psz);
         logError("warning: maybe it was inaccessible, or using wrong zip version.");
      }
      else
         nGlblFzConArcFiles++;
   }
   nGlblFzConArchives++;

   if (bNoChange) {
      if (cs.verbose)
         showMirrorStatus("zip ", "-==-", pszName, 0, nLocFiles, 0);
   } else {
      showMirrorStatus("zip ", "done", pszName, 0, nLocFiles, 1);
   }

   return 0;
}

long execFileMirror(char *pszName, num &nLocalMaxTime, num &ntime2, long nDirFileCnt)
{
   if (glblFileSet.getDirCommand() == eCmd_CopyDir)
      return execFileXCopy(pszName, nLocalMaxTime, ntime2, nDirFileCnt);
   else
   if (glblFileSet.getDirCommand() == eCmd_FreezeDir)
      return execFileFreeze(pszName, nLocalMaxTime, ntime2, nDirFileCnt);
   return 9+perr("no command supplied for directory\n");
}

long execDirMirror(char *pszName, long lLevel, FileList &oDirFiles, num &nLocalMaxTime, num &ntime2)
{
   if (glblFileSet.getDirCommand() == eCmd_CopyDir)
      return execDirXCopy(pszName, lLevel, oDirFiles, nLocalMaxTime, ntime2);
   else
   if (glblFileSet.getDirCommand() == eCmd_FreezeDir)
      return execDirFreeze(pszName, lLevel, oDirFiles, nLocalMaxTime, ntime2);
   return 9+perr("no command supplied for directory\n");
}

long execFileFreeze(char *pszName, num &nLocalMaxTime, num &nTreeMaxTime, long nDirFileCnt)
{
   // doesn't actually freeze the single file, but

   // writes the file's md5 hash to md5org
   SFKMD5 md5;
   if (getFileMD5(pszName, md5)) {
      logError("error: failed to read:\n   %s", pszName);
      return 0;
   }
   unsigned char *pmd5 = md5.digest();
   for (int i=0; i<16; i++)
      fprintf(fGlblMD5Org,"%02x",pmd5[i]);
   fprintf(fGlblMD5Org," *%s\n",pszName); // md5sum similar

   // get file stats
   long bIsDir    = 0;
   long bCanRead  = 1;
   long bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize)) {
      logError("error: failed to stat:\n   %s", pszName);
      return 0;
   }

   // add file to global inventory
   char szTimeBuf[100];
   char szSizeBuf[100];
   fprintf(fGlblCont, "%s %s %s\n",
      numtoa(nFileTime, 15, szTimeBuf),
      numtoa(nFileSize, 15, szSizeBuf),
      pszName
      );

   // update maxtimes
   if (nFileTime > nLocalMaxTime)
       nLocalMaxTime = nFileTime;
   if (nFileTime > nTreeMaxTime)
       nTreeMaxTime = nFileTime;

   // show some stats
   if (glblFileCount.count()) {
      if (!cs.quiet)
         showMirrorStatus("scan", "----", pszName, 1, nDirFileCnt);
   }

   return 0;
}

long execDirXCopy(char *pszName, long lLevel, FileList &oDirFiles, num &nLocalMaxTime, num &nTreeMaxTime)
{
   long nLocFiles = oDirFiles.clNames.numberOfEntries();

   // copy current dir or whole subtree?
   bool bAnyMasksGiven = glblFileSet.dirMasks().isStringSet(0,0);
   char *pszMode = "";
   num  nMaxTime = nLocalMaxTime;

   if (bAnyMasksGiven)
   {
      if (!nLocFiles) {
         // zero files found: do not call xcopy
         if (cs.verbose)
            showMirrorStatus("copy", "skip", pszName, 0, 0);
         return 0;
      }
   }
   else
   {
      // running in whole-tree mode: only toplevel acts
      if (lLevel > 0)
         return 0;
      // tell xcopy to copy whole subtree:
      #ifdef _WIN32
      pszMode = " /S";
      #else
      pszMode = "-R";
      #endif
      nMaxTime = nTreeMaxTime;
   }

   // in: pszGlblSrcRoot, DstRoot, pszName
   if (!strncmp(pszName, glblDotSlash, 2))
      pszName += 2;

   // this uses szLineBuf:
   num nOldDirTime = getOldDirTime(pszName);

   // do we have to call xcopy at all?
   if (   // (nMaxTime == 0) || // i.e. no files at all contained
       (bGlblMirrorByDate && (nOldDirTime != 0) && (nMaxTime <= nOldDirTime))
      )
   {
      // skip, don't bother xcopy
   }
   else
   {
      // copy a dir, excluding subdirectories (NO /S option),
      // except if pszMode was set other above.
      #ifdef _WIN32
      sprintf(szLineBuf, "%s \"%s\" \"%s%s\" %s/I /R /K /Y /D%s",
              pszGlblXCopyCmd, pszName, pszGlblDstRoot, pszName,
              cs.hidden ? "/H " : "", pszMode
             );
      #else
      if (createSubDirTree(pszGlblDstRoot, pszName))
         return 9;

      sprintf(szLineBuf, "cp -p -d -u %s \"%s%c\"* \"%s%s\"",
              pszMode, pszName, glblPathChar, pszGlblDstRoot, pszName
             );
      #endif

      if (!cs.quiet) {
         if (cs.verbose)
            showMirrorStatus("copy", bAnyMasksGiven ? "dir " : "tree", pszName, 0, nLocFiles);
      }

      if (system(szLineBuf)) {
         logError("error: failed to fully execute command:\n   %s", szLineBuf);
         // continue anyway, list errors when finishing.
      }
   }

   // remember dir maxtime in dir-times.txt
   char szTimeBuf[100];
   if (fGlblTimes != 0) {
      fprintf(fGlblTimes, "%s %s\n", numtoa(nLocalMaxTime,15,szTimeBuf), pszName);
      fflush(fGlblTimes);
   }

   // VERIFY if all files do really exist in the target tree:
   long nFiles = oDirFiles.clNames.numberOfEntries();
   for (long i=0; i<nFiles; i++) 
   {
      char *pszInFileName = oDirFiles.clNames.getEntry(i, __LINE__);
      num nInFileSize = oDirFiles.clSizes.getEntry(i, __LINE__);

      sprintf(szLineBuf, "%s%s", pszGlblDstRoot, pszInFileName);

      long bIsDir    = 0;
      long bCanRead  = 1;
      long bCanWrite = 1;
      num  nFileTime = 0;
      num  nFileSize = 0;
      if (getFileStat(szLineBuf, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize)) {
         logError("error: archive not found after copy: %s", szLineBuf);
         nGlblFzMisCopFiles++;
      } else {
         if (nFileSize != nInFileSize) {
            logError("error: size mismatch after copy: %s", szLineBuf);
            nGlblFzMisCopFiles++;
         }
         else
            nGlblFzConCopFiles++;
      }
   }

   return 0;
}

long execFileXCopy(char *pszName, num &nLocalMaxTime, num &nTreeMaxTime, long nDirFileCnt)
{
   // this doesn't actually copy, but

   // writes the file's md5 hash
   SFKMD5 md5;
   if (getFileMD5(pszName, md5)) {
      logError("error: failed to read:\n   %s", pszName);
      return 0;
   }
   unsigned char *pmd5 = md5.digest();

   // BOTH to md5org ...
   int i=0;
   for (i=0; i<16; i++)
      fprintf(fGlblMD5Org,"%02x",pmd5[i]);
   fprintf(fGlblMD5Org," *%s\n",pszName); // md5sum similar

   // AND to md5arc to ensure everything's covered by verify batch.
   for (i=0; i<16; i++)
      fprintf(fGlblMD5Arc,"%02x",pmd5[i]);
   fprintf(fGlblMD5Arc," *%s\n",pszName); // md5sum similar

   // get file stats
   long bIsDir    = 0;
   long bCanRead  = 1;
   long bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize)) {
      logError("error: failed to stat:\n   %s", pszName);
      return 0;
   }

   // add file to global inventory
   char szTimeBuf[100];
   char szSizeBuf[100];
   fprintf(fGlblCont, "%s %s %s\n",
      numtoa(nFileTime, 15, szTimeBuf),
      numtoa(nFileSize, 15, szSizeBuf),
      pszName
      );

   // update max times
   if (nFileTime > nLocalMaxTime)
      nLocalMaxTime = nFileTime;
   if (nFileTime > nTreeMaxTime)
      nTreeMaxTime = nFileTime;

   // show some stats
   if (glblFileCount.count()) {
      if (!cs.quiet)
         showMirrorStatus("scan", "----", pszName, 1, nDirFileCnt);
   }

   return 0;
}

long execSingleDir(Coi *pcoi, long lLevel, long &nTreeFiles, FileList &oDirFiles, long &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2)
{
   char *pszName     = pcoi->name();
   char *pszOptRoot  = pcoi->root(1);  // raw, returns 0 if none

   if (cs.debug) printf("]  esdir: %s files=%ld\n", pszName, nTreeFiles);

   if (userInterrupt())
      return 9;

   if (cs.withdirs || cs.justdirs) 
   {
      // -justdirs: IF any non-"*" file mask is set,
      if (glblFileSet.anyFileMasks())
      {
         if (cs.debug) printf("]  esdir: using file masks\n");
         //  process dir only if any files within match
         if (!nTreeFiles) return 0; // skip
         // -justdirs: make sure the next-higher dir is not listed again
         nTreeFiles = 0;
      } else {
         if (cs.debug) printf("]  esdir: no file masks, process all\n");
      }
   }

   if (cs.walkDirDelay > 0) doSleep(cs.walkDirDelay);

   // skip initial dot slash which might be returned by dir scanning
   if (!strncmp(pszName, glblDotSlash, 2))
      pszName += 2;

   if (pszGlblSinceDir) 
   {
      // build relative name of file to be processed
      char *pszRel = pszName;
      if (!bGlblSinceDirIncRef)
            pszRel = rootRelativeName(pszName, pszOptRoot);
      if (!pszRel) return 9;

      // check if dirs for comparison both exist
      joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszGlblSinceDir, pszRel);
      if (!isDir(szRefNameBuf)) {
         // this is often a user error
         if (cs.verbose) {
            setTextColor(nGlblWarnColor);
            info.print("no reference dir: %s\n", szRefNameBuf);
            setTextColor(-1);
         }
         nGlblMissingRefDirs++;
      } else {
         nGlblMatchingRefDirs++;
      }
   }

   // -since: process only dirs newer or equal than timestamp,
   // relevant only on commands like list -withdirs -since ...
   if (cs.sincetime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get dir time: %s\n", pszName);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime < cs.sincetime)
         return 0; // skip
   }

   // -before: process only dirs older or equal than timestamp
   if (cs.untiltime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get dir time: %s\n", pszName);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime >= cs.untiltime)
         return 0; // skip
   }

   long lRC = 0;
   switch (nGlblFunc) 
   {
      case eFunc_FileStat:
           lRC = execDirStat(pcoi, lLevel, nTreeFiles, lDirs, lBytes, nLocalMaxTime, ntime2);
           break;
      case eFunc_CallBack:
           lRC = execCallFileDir(pcoi);
           break;
      case eFunc_Mirror  :
           lRC = execDirMirror(pszName, lLevel, oDirFiles, nLocalMaxTime, ntime2);
           break;
      case eFunc_Run     :
           if (cs.justdirs)
              lRC = execRunDir(pcoi, lLevel, nTreeFiles, lDirs, lBytes);
           break;
      case eFunc_Deblank :
           return execDeblank(pszName);
           break;
      #ifndef USE_SFK_BASE
      case eFunc_Copy    :
           return execDirCopy(pszName, oDirFiles);
      case eFunc_Cleanup :
           return execDirCleanup(pszName, oDirFiles);
      case eFunc_MetaUpd: execMetaDirUpdate(pszName); break;
      #endif // USE_SFK_BASE

      case eFunc_Grep:
           if (cs.subdirs) {
              info.setAddInfo("%lu files, %lu dirs", cs.filesScanned, cs.dirsScanned);
              info.setStatus("scan ", pszName, 0, eKeepAdd);
              cs.dirsScanned++;
           }
           break;

      case eFunc_Delete: 
            execDelDir(pszName, lLevel, nTreeFiles, oDirFiles, lDirs, lBytes, nLocalMaxTime, ntime2);
            break;

      #ifdef WITH_TCP
      case eFunc_FTPList :
            if (!bGlblFTPListAsHTML)
               return execFTPList(pszName);
            break;
      #endif

      default:
           break;
   }

   // localMaxTime was used w/in above methods, reset now
   // to avoid potential further use in other dir trees.
   nLocalMaxTime = 0;

   return lRC;
}

long checkMask(char *pszMask) {
   if (isWildStr(pszMask))
      return 1;
   if (   strchr(pszMask, glblWildChar)
       || strchr(pszMask, '*')
      ) 
   { 
      perr("no masks with %s supported, except \"%s\" alone.\n", glblWildInfoStr, glblWildInfoStr); 
      return 0; 
   }
   return 1;
}

long execTextJoinLines(char *pIn) {
   // join a text file with lines broken by mailing

   // 1. pre-scan for line length maximum
   char *psz = pIn;
   int nLineChars = 0;
   int nLineCharMax = 0;
   while (*psz)
   {
      char c = *psz++;
      if (c == '\r')
         continue;
      if (c == '\n') {
         if (nLineChars > nLineCharMax)
            nLineCharMax = nLineChars;
         nLineChars = 0;
         continue;
      }
      nLineChars++;
   }

   if (!cs.quiet)
      printf("[line break near %d]\n", nLineCharMax);

   // 2. join lines which are broken, pass-through others
   psz = pIn;
   nLineChars = 0;
   while (*psz)
   {
      char c = *psz++;

      if (c == '\r') // drop CR. LF-mapping is done by runtime.
         continue;

      if (c == '\n') {
         // line collected. what to do?
         if (   (nLineChars < nLineCharMax-1)
             || (nLineChars > nLineCharMax)
            )
         {
            fputc(c, fGlblOut);  // not near threshold: do not join
         }
         nLineChars = 0;
         continue;
      } else {
         fputc(c, fGlblOut);
      }

      nLineChars++;
   }
   
   return 0;
}

long hexToBin(char *pszHex, uchar *pBin, ulong nBinLen)
{
   long nBinRem = (long)nBinLen; // remaining out buffer
   char szBuf[10];
   memset(szBuf, 0, sizeof(szBuf));
   while (*pszHex && (nBinRem > 0)) {
      szBuf[0] = *pszHex++;
      if (!*pszHex) return 1;
      szBuf[1] = *pszHex++;
      if (!isxdigit(szBuf[0])) return 2;
      if (!isxdigit(szBuf[1])) return 2;
      *pBin++ = (uchar)strtol(szBuf, 0, 0x10);
      nBinRem--;
   }
   if (*pszHex || nBinRem)
      return 3;
   return 0;
}

uchar *memFind(uchar *pNeedle, num nNeedleSize, uchar *pHayStack, num nHaySize)
{
   num nRemain = nHaySize;
   uchar *pCur = pHayStack;
   uchar *pMax = pHayStack + nHaySize - nNeedleSize; // inclusive
   uchar c1    = *pNeedle;
   while (pCur <= pMax)
   {
      uchar *p1 = pCur;
      // seek to next potential start
      // while ((p1 <= pMax) && (*p1 != c1))
      //   p1++;
      p1 = (uchar*)memchr(p1, c1, pMax - p1 + 1); // +1: pMax is inclusive
      if (!p1 || (p1 > pMax))
         return 0;
      // compare
      if ((p1 <= pMax) && !memcmp(p1, pNeedle, nNeedleSize))
         return p1;  // hit
      // no hit, proceed
      pCur = p1+1;
   }
   return 0;
}

long  nGlblDumpCtx  = 0; // additional context bytes for dump
long  nBinRepExp    = 0; // no. of replacement expressions
uchar **apRepSrcExp = 0; // source expressions
long  *apRepSrcLen  = 0; // length of source expressions
uchar **apRepDstExp = 0; // dest. expressions
long  *apRepDstLen  = 0; // length of dest. expressions
long  *apRepFlags   = 0; // 0:is it text or binary, 1:was it found
num   *apRepOffs    = 0; // current offset in file to continue search

long execReplaceFix(Coi *pcoi)
{__
   char *pszFile = pcoi->name();

   // mtklog("erf: execReplaceFix %s", pszFile);

   if (!pcoi->existsFile())
      return 1+perr("unable to read: %s - skipping\n", pszFile);

   num nFileSize = pcoi->getSize();
   if (nFileSize < 0 ) return 1+perr("unable to read: %s - skipping\n", pszFile);
   if (nFileSize == 0) return 0+pwarn("empty file: %s - skipping\n", pszFile);

   FileInfo finf;
   if (finf.init(pszFile, 56, nFileSize)) return 9;

   long diffDump(uchar *p1, uchar *p2, num nlen, num nListOffset);

   long lRC = 0;

   if (cs.sim) {  // with hexfind, sim MUST be set
      if (pcoi->open("rb"))
         return 1+perr("failed to read: %s - skipping%s\n", pcoi->name(),pcoi->lasterr());
   } else {
      if (pcoi->open("r+b"))
         return 1+perr("failed to read+write: %s - skipping\n", pcoi->name(),pcoi->lasterr());
   }

   cs.files++; // no. of files read

   bool bFileChanged = 0;

   // reset hit flags etc.
   for (ulong i5=0; i5<nBinRepExp; i5++) {
      apRepFlags[i5] &= (0xFF ^ (1 << 1));
      apRepOffs[i5] = 0;
   }

   num nBlockPos  =  0;
   num nScanPos   =  0;
   num nBlockSize =  0;
   num nReplaced  =  0;
   bool bTold     =  0;
   long nPerc     =  0;
   long nLastPerc =  0;
   num  nLastOff  = -1;

   while (true)
   {
      if (userInterrupt())
         { lRC=2; break; }

      nPerc = (long)(nBlockPos * 100 / nFileSize);

      if (pcoi->seek(nBlockPos, SEEK_SET))
      {
         pcoi->close();
         if (bTold) printf("\n");
         perr("failed to seek within %s%s\n", pszFile, cs.sim ? "" : " - stopping write. file may be damaged.");
         lRC=1; break;
      }

      num nRead = pcoi->read(abBuf, sizeof(abBuf)-1000);

      // mtklog("erf: read %ld from %ld",(long)nRead,(long)nBlockPos);

      if (nRead <= 0) {
         if (nBlockPos == nFileSize)
            break; // OK, EOF reached
         pcoi->close();
         if (bTold) printf("\n");

         #ifdef VFILEBASE
          #ifndef VFILEMAX
         if (pcoi->isZipSubEntry()) {
            setTextColor(nGlblWarnColor);
            printf("... stopped reading at %ld bytes (demo limit).\n",(long)(nBlockPos-54));
            setTextColor(-1);
         }
         else
          #endif
         #endif // VFILEBASE
         perr("failed to fully read %s%s\n", pszFile, cs.sim ? "" : " - stopping write. file may be damaged.");

         lRC=1; break;
      }

      nBlockSize = nRead;
      bool bTouched = 0;

      // over all search expressions
      for (ulong iexp=0; iexp<nBinRepExp; iexp++) 
      {
         uchar *pExp = apRepSrcExp[iexp];
         long   nExpLen = apRepSrcLen[iexp];
         long   nExpFlags = apRepFlags[iexp];

         // in case of rep simulation or hexfind, the destination
         // expression length is NOT the same as ExpLen, but ZERO.
         long   nDstLen = apRepDstLen[iexp];

         // decide if comparison shall be done case-insensitive.
         bool   bBinary  = (nExpFlags & (1<<0)) ? 1 : 0;
         bool   bUseCase = bBinary || cs.usecase;
         if (cs.nocase) bUseCase = 0; // forced nocase on everything

         // is expression (repeatedly) contained in current block?
         // NOTE: blocks are read with overlapping areas, to avoid patterns
         //       getting lost on block boundaries. therefore nOffs is needed
         //       to avoid repeated hits on the same target, esp. in sim mode.
         num    nOffs = apRepOffs[iexp];
         num    nRel  = nOffs - nBlockPos; // last continue pos, w/in current block
         uchar *pSubCur = abBuf;
         if (nRel > 0) pSubCur += nRel; // don't rescan from start
         uchar *pSubMax = abBuf + nBlockSize - nExpLen;
         while (pSubCur <= pSubMax) 
         {
            num nRemain = nBlockSize - (pSubCur - abBuf);

            // if (!bBinary) { 
            //    mtklog("erf: find text \"%s\" len=%ld noff=%ld case=%d in:",pExp,nExpLen,(long)nOffs,bUseCase); 
            //    mtkdump("erf: ",pSubCur,nRemain);
            // }

            uchar *pHit = 0;
            if (bUseCase)
               pHit = memFind(pExp, nExpLen, pSubCur, nRemain);
            else
               pHit = memIFind(pExp, nExpLen, pSubCur, nRemain);
            if (!pHit)
               break;

            // yes: replace by dest. expression
            if ((cs.verbose >= 2) && !(apRepFlags[iexp] & (1<<0))) {
               int nslen = (int)nExpLen;
               printf("replace @%s: %.*s -> %.*s\n",numtohex(nBlockPos+(pHit-abBuf),10),nslen,pHit,nslen,apRepDstExp[iexp]);
            }

            if (cs.repDump) 
            {
               num nctx    = nGlblDumpCtx;
               num nAlign0 = bGlblHexDumpWide ? 16 :  8;
               num nAlign1 = bGlblHexDumpWide ? 32+nctx : 16+nctx;
               num nAlign2 = bGlblHexDumpWide ? 48+nctx : 18+nctx;
               num nHitRaw = pHit - abBuf;
               num nHitLow = nHitRaw;
               num nHitHi  = nHitLow + nExpLen;
               if (nHitLow > nAlign1) nHitLow -= nAlign1; else nHitLow = 0;
               if (nHitHi  < (nBlockSize - nAlign2)) {
                  nHitHi += nAlign2;
                  // align dump size to multiples of 16 or 32
                  num nDiff = nHitHi-nHitLow;
                  nDiff = ((num)(nDiff / nAlign0)) * nAlign0; // floor
                  nHitHi = nHitLow + nDiff;
               } else {
                  // near end of file: make sure to dump all bytes
                  nHitHi = nBlockSize;
               }
               num nDumpLen = nHitHi-nHitLow;
               if (nDumpLen < MAX_LINE_LEN) {
                  memcpy(szRefNameBuf, abBuf+nHitLow, nDumpLen);
                  // this is redundant to cpy below, but doesn't matter
                  if (nExpLen == nDstLen) // else hexfind or sim
                     memcpy(pHit, apRepDstExp[iexp], nExpLen);
                  else 
                  {
                     // hexfind or sim MUST have cs.sim set.
                     if (!cs.sim) return 9+perr("int. #58281821");
                     // dirty, but should work fine:
                     // mark the place of found expression by inverting
                     // the bytes in right-side (non-dumped) memory.
                     for (long k=0; k<nExpLen; k++)
                        pHit[k] ^= (uchar)0xFFU;
                  }
                  num nListOff = nBlockPos + nHitLow;
                  if (bTold) { bTold=0; finf.printBlankLine(78); }
                  // setTextColor(nGlblFileColor);
                  char szOffBuf1[60]; szOffBuf1[0] = '\0';
                  char szOffBuf2[60]; szOffBuf2[0] = '\0';
                  num nAbsOff = nHitRaw+nBlockPos;
                  sprintf(szOffBuf1, "at offset 0x%.20s", numtohex(nAbsOff));
                  if (cs.reldist && nLastOff >= 0) {
                     long nRelOff = (long)(nAbsOff - nLastOff);
                     sprintf(szOffBuf2, " reldist %lu (0x%lx)", nRelOff, nRelOff);
                  }
                  chain.print('f', 1, "%s : %s %s%s",pszFile,cs.sim?"hit":"change",szOffBuf1,szOffBuf2);
                  // setTextColor(-1);
                  diffDump((uchar*)szRefNameBuf, abBuf+nHitLow, nDumpLen, nListOff);
                  nLastOff = nAbsOff;
               }
            }
            // this cpy is done always, no matter if RepDump or not:
            if (nExpLen == nDstLen) // else hexfind or sim
               memcpy(pHit, apRepDstExp[iexp], nExpLen);
            bTouched = 1;
            nReplaced++;
            apRepFlags[iexp] |= (1 << 1);
            // proceed within block, after hit
            pSubCur = pHit + nExpLen;
            // also remember this position to avoid redundant hits, esp. on sim
            nOffs = nBlockPos + (pSubCur - abBuf);
            apRepOffs[iexp] = nOffs;
         }
      }

      // need to write block back?
      if (bTouched) 
      {
         bFileChanged = 1;

         if (chain.colfiles)
            chain.addFile(*pcoi);
      
         if (cs.sim) {
            if (finf.timeToTell()) {
               printf("%02ld%% %s%s : %s hits \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
               fflush(stdout);
               bTold = 1;
            }
         } else {
            if (pcoi->seek(nBlockPos, SEEK_SET)) {
               pcoi->close();
               if (bTold) printf("\n");
               esys("fseek", "failed to seek within %s - stopping write. file may be damaged.\n", pszFile);
               lRC=1; break;
            }
            num nWrite = pcoi->write(abBuf, nBlockSize);
            if (nWrite != nBlockSize) {
               pcoi->close();
               if (bTold) printf("\n");
               esys("fwrite", "failed to write to %s - stopping write. file may be damaged.\n", pszFile);
               lRC=1; break;
            }
            if (!cs.quiet) {
               printf("%02ld%% %s%s : %s changes \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
               fflush(stdout);
               bTold = 1;
            }
         }
      }

      // proceed with overlap, to catch expressions on block boundaries
      nBlockPos += nBlockSize;
      if (nBlockPos < nFileSize)
          nBlockPos -= (nBlockSize / 4);

      if (!cs.quiet && (nPerc != nLastPerc)) {
         printf("%02ld%% %s%s : %s %s \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced),cs.sim?"hits":"changes");
         bTold = 1;
      }
      nLastPerc = nPerc;
   }

   if (bFileChanged)
      cs.filesChg++;

   if (lRC) {
      pcoi->close();
      return lRC; 
   }

   // collect stats: all patterns found?
   long nTotPats = nBinRepExp;
   long nHitPats = 0;
   for (ulong i2=0; i2<nBinRepExp; i2++) 
   {
      if (apRepFlags[i2] & (1 << 1))
         nHitPats++;
      else
      if (cs.verbose) {
         printf("%s : pattern not found: ",pszFile);
         if (apRepFlags[i2] & (1 << 0)) {
            uchar *pBin = apRepSrcExp[i2];
            for (ulong i9=0; i9<apRepSrcLen[i2]; i9++)
               printf("%02X",pBin[i9]);
            printf(" [binary]\n");
         } else {
            printf("%s\n",apRepSrcExp[i2]);
         }
      }
   }
   long nNotPats = nTotPats - nHitPats;

   if (bTold)
      finf.printBlankLine(78);

   if (!cs.quiet) 
   {
      if (!nHitPats && !cs.verbose)
      { } // don't list files we wouldn't change
      else
      {
         char *pszPre = finf.prefix();
         char *pszShort = finf.shortName();
         chain.print(' ', 1, "[%03ld/%ld/%ld] %s%s",(long)nReplaced,(long)nHitPats,(long)nNotPats,pszPre,pszShort);
      }
   }

   pcoi->close();

   return 0;
}

void tellMemLimitInfo() {
   static bool btold = 0;
   if (!btold) { btold = 1;
      pinf("some file(s) are larger than the memory limit. see option -memlimit under \"sfk help opt\"\n");
   }
}

long execReplaceVar(Coi *pcoi)
{__
   char *pszFile = pcoi->name();

   if (!pcoi->existsFile())
      return 1+perr("unable to read: %s - skipping\n", pszFile);

   num nFileSize = pcoi->getSize();
   if (nFileSize < 0 ) return 1+perr("unable to read: %s - skipping\n", pszFile);
   if (nFileSize == 0) return 0+pwarn("empty file: %s - skipping\n", pszFile);

   FileInfo finf;
   if (finf.init(pszFile, 56)) return 9;

   long diffDump(uchar *p1, uchar *p2, num nlen, num nListOffset);

   long lRC = 0;

   if (nFileSize > nGlblMemLimit) {
      perr("file too large to load: %s, %s mbytes", pszFile, numtoa(nFileSize/1000000));
      tellMemLimitInfo();
      return 9;
   }

   num nFileSize2 = 0;
   uchar *praw = loadBinaryFile(pszFile, nFileSize2);
   if (!praw) return 9+perr("cannot load: %s\n", pszFile);
   if (nFileSize2 != nFileSize) {
      delete [] praw;
      return 9+perr("cannot load (2): %s\n", pszFile);
   }

   cs.files++; // no. of files read

   bool bFileChanged = 0;

   // reset hit flags etc.
   for (ulong i5=0; i5<nBinRepExp; i5++) {
      apRepFlags[i5] &= (0xFF ^ (1 << 1));
      apRepOffs[i5] = 0;
   }

   num nBlockPos  = 0;
   num nScanPos   = 0;
   num nBlockSize = nFileSize;
   num nReplaced  = 0;
   bool bTold     = 0;
   long nPerc     = 0;
   long nLastPerc = 0;
   bool bTouched  = 0;

   num nMaxSizeCur  = nFileSize; // temporary output buffer used size
   num nMaxSizePeak = 0;         // largest expansion reached by output buffer
   uchar *pMaxDat   = 0;         // alloc'ed using MaxSizePeak
   uchar *pMem      = praw;
   num    nMemSize  = nFileSize;
   bool   bGlobalExpand = 0;  // overall memory
   bool   bLocalExpand  = 0;  // current expression

   // NO RETURN W/O DELETE FROM HERE

   long npasses = cs.sim ? 1 : 2;

   for (long npass=0; npass<npasses; npass++)
   {
      if (userInterrupt())
         { lRC=2; break; }

      if (npass == 1) {
         if (nMaxSizePeak > nFileSize) {
            num nTotalUsage = nFileSize + nMaxSizePeak;
            if (nTotalUsage > nGlblMemLimit) {
               perr("memory limit exceeded: %s requires %s mbytes for processing\n", pszFile, numtoa(nTotalUsage/1000000));
               pinf("say \"sfk -memlimit=500m replace ...\" to change the limit to 500 mbytes.\n");
               delete [] praw;
               return 9;
            }
            pMaxDat = new uchar[nMaxSizePeak+1024];
            memset(pMaxDat, 0, nMaxSizePeak+1024);
            memcpy(pMaxDat, praw, nFileSize);
            pMaxDat[nMaxSizePeak] = 0xEE;
            bGlobalExpand = 1;
         } else {
            pMaxDat = praw;
            pMaxDat[nFileSize] = 0xEE; // extended bytes provided by loadBinaryFile
         }
         pMem    = pMaxDat;
         nMemSize= nFileSize; // initially, changes with replacements.
      }

      // over all search expressions
      for (ulong iexp=0; iexp<nBinRepExp; iexp++) 
      {
         if (userInterrupt())
            { lRC=2; break; }

         // get source pattern
         uchar *pSrc    = apRepSrcExp[iexp];
         long   nSrcLen = apRepSrcLen[iexp];
         long   nSrcFlags = apRepFlags[iexp];

         // decide if comparison shall be done case-insensitive.
         bool   bBinary  = (nSrcFlags & (1<<0)) ? 1 : 0;
         bool   bUseCase = bBinary || cs.usecase;
         if (cs.nocase) bUseCase = 0; // forced nocase on everything

         // get destination pattern
         uchar *pDst    = apRepDstExp[iexp];
         long   nDstLen = apRepDstLen[iexp];

         // get size diff for current pattern
         long   nSizeDiff = nDstLen - nSrcLen;

         bLocalExpand = (nSizeDiff > 0) ? 1 : 0;

         // scan whole data with current pattern
         uchar *pInCur  = pMem;
         uchar *pInMax  = pMem + nMemSize;

         while (pInCur < pInMax)
         {
            if (userInterrupt())
               { lRC=2; break; }

            num nRemain = nMemSize - (pInCur - pMem);
            uchar *pHit = 0;
            if (bUseCase)
               pHit = memFind(pSrc, nSrcLen, pInCur, nRemain);
            else
               pHit = memIFind(pSrc, nSrcLen, pInCur, nRemain);
            if (!pHit)
               break;

            // process hit
            if (npass < 1) {
               // first pass: calc target size.
               nMaxSizeCur += nSizeDiff;
               // find the global maximum size for pass2 allocation.
               if (nMaxSizeCur > nMaxSizePeak)
                   nMaxSizePeak = nMaxSizeCur;
               // else do NOT shrink the output size.
            } else {
               // 2nd pass: apply replacement
               num nHitRem = nMemSize - (pHit - pMem);
               // printf("apply replace, %ld\n", nSizeDiff);
               // printf("old: %.20s delta %ld size %ld\n", pHit, nSizeDiff, (long)(nHitRem-nSizeDiff));
               // sfkmem_hexdump(pHit-10, 32);
               if (bLocalExpand)
                  memmove(pHit+nSizeDiff, pHit, nHitRem+0); // memory EXPANDS by nSizeDiff.
               else
                  memmove(pHit, pHit-nSizeDiff, nHitRem+nSizeDiff);
               // printf("     move %p %p %lu bytes\n",pHit+nSizeDiff, pHit, (long)(nHitRem-nSizeDiff));
               if (nDstLen) memcpy(pHit, pDst, nDstLen);
               // printf("new: %.20s\n", pHit);
               // sfkmem_hexdump(pHit-10, 32);

               // overall size of memory changes:
               nMemSize += nSizeDiff;
            }

            if (   ( cs.sim && npass==0)
                || (!cs.sim && npass==1)
               )
            {
               bTouched = 1;
               nReplaced++;
               apRepFlags[iexp] |= (1 << 1);
            }

            // proceed within block, after hit
            if (npass == 0)
               pInCur = pHit + nSrcLen;   // there is no replace yet, skip hit
            else
               pInCur = pHit + nDstLen;   // continue search after replaced area

            // recalc max:
            pInMax = pMem + nMemSize;

            // tell progress:
            if (nMemSize) nPerc = (long)((pInCur-pMem) * 100 / nMemSize);
            if (!cs.quiet && (nPerc != nLastPerc) && finf.timeToTell()) {
               printf("%02ld%% %s%s : %s %s \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced),cs.sim?"hits":"changes");
               bTold = 1;
               nLastPerc = nPerc;
            }
         }
      }
   }

   // need to write everything back?
   if (!lRC && bTouched) 
   {
      bFileChanged = 1;

      if (chain.colfiles)
         chain.addFile(*pcoi);
   
      if (cs.sim) {
         if (finf.timeToTell()) {
            printf("%02ld%% %s%s : %s hits \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
            fflush(stdout);
            bTold = 1;
         }
      } else {
         // whole content is written in one go.
         // coi::write takes care of big block writing.
         if (pcoi->open("wb"))
            return 9+perr("cannot rewrite file: %s%s\n", pcoi->name(),pcoi->lasterr());
         num nWrite = pcoi->write(pMaxDat, nMemSize);
         pcoi->close();
         if (nWrite != nMemSize) {
            if (bTold) printf("\n");
            esys("fwrite", "failed to write to %s - stopping write. file may be damaged.\n", pszFile);
            lRC=1;
         }
         if (!cs.quiet) {
            printf("%02ld%% %s%s : %s changes \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
            fflush(stdout);
            bTold = 1;
         }
      }
   }

   // red zone check
   if (!cs.sim) {
      if (bGlobalExpand) {
         if (pMaxDat[nMaxSizePeak] != 0xEE)
            perr("internal: memory overwrite past target block, on expand\n");
      } else {
         if (pMaxDat[nFileSize] != 0xEE)
            perr("internal: memory overwrite past target block, on shrink\n");
      }
   }

   // NO RETURN W/O DELETE UNTIL HERE

   if (pMaxDat && (pMaxDat != praw)) delete [] pMaxDat;
   delete [] praw;

   if (bFileChanged)
      cs.filesChg++;

   if (lRC) return lRC;

   // collect stats: all patterns found?
   long nTotPats = nBinRepExp;
   long nHitPats = 0;
   for (long i2=0; i2<nBinRepExp; i2++) 
   {
      if (apRepFlags[i2] & (1 << 1))
         nHitPats++;
      else
      if (cs.verbose) {
         printf("%s : pattern not found: ",pszFile);
         if (apRepFlags[i2] & (1 << 0)) {
            uchar *pBin = apRepSrcExp[i2];
            for (ulong i9=0; i9<apRepSrcLen[i2]; i9++)
               printf("%02X",pBin[i9]);
            printf(" [binary]\n");
         } else {
            printf("%s\n",apRepSrcExp[i2]);
         }
      }
   }
   long nNotPats = nTotPats - nHitPats;

   if (bTold)
      finf.printBlankLine(78);

   if (!cs.quiet) 
   {
      if (!nHitPats && !cs.verbose)
      { } // don't list files we wouldn't change
      else
      {
         char *pszPre    = finf.prefix();
         char *pszShort  = finf.shortName();
         num   nSizeDiff = nMemSize - nFileSize;
         const char *pszSign = (nSizeDiff > 0) ? "+":"";
         printf("[%03ld/%ld/%ld] %s%s", (long)nReplaced,(long)nHitPats,(long)nNotPats,pszPre,pszShort);
         if (nSizeDiff) {
            setTextColor(nGlblTimeColor);
            printf("   %s%s bytes\n",pszSign,numtoa(nSizeDiff));
            setTextColor(-1);
         } else {
            printf("\n");
         }
      }
   }

   return 0;
}

long aGlblIndentStats[10];

long execScantab(char *pszFile)
{
   cs.files++;

   long i=0;

   long aind[100];
   memset(aind, 0, sizeof(aind));

   long amul[10]; // multiples of n counters
   memset(amul, 0, sizeof(amul));

   long nMaxMulIndex = 0;
   long nMaxMulCnt   = 0;
   bool bHaveTabs    = 0;
   
   // collect indent stats
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+perr("cannot read: %s\n", pszFile);

   bool bBinary = 0;

   myfgets_init();
   while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin, &bBinary))
   {
      // binary file detected?
      if (bBinary) {
         fclose(fin);
         if (cs.verbose)
            oprintf("binary  : %s\n", pszFile);
         return 0;
      }

      szLineBuf[sizeof(szLineBuf)-10] = '\0';
      removeCRLF(szLineBuf);
      long nLen = (long)strlen(szLineBuf);

      // any tabs contained?
      if (!bHaveTabs && strchr(szLineBuf, '\t')) {
         bHaveTabs = 1;
         if (!cs.scanIndent)
            break;
      }

      // analyze single line
      long nBlanks = 0;
      for (i=0; i<nLen; i++) {
         if (szLineBuf[i] == ' ') {
            if (++nBlanks >= 60)
               break;
         }
         else
            break;
      }

      // have no. of blanks at line start.
      aind[nBlanks]++;

      // nBlanks is a multiple of ...
      if (nBlanks)
      for (i=3; i<=8; i++) {
         if ( ((nBlanks / i) * i) == nBlanks ) {
            // create sorted stats
            amul[i]++;
            if (amul[i] > nMaxMulCnt) {
               nMaxMulCnt   = amul[i];
               nMaxMulIndex = i;
            }
         }
      }
   }
   fclose(fin);

   if (nMaxMulIndex >= 0 && nMaxMulIndex < 10)
      aGlblIndentStats[nMaxMulIndex]++;

   if (bHaveTabs)
      cs.tabFiles++;

   if (cs.indentFilt) {
      if (nMaxMulIndex != 0 && cs.indentFilt == nMaxMulIndex)
         oprintf("%s\n", pszFile);
      return 0;
   }

   if (bHaveTabs) {
      if (!cs.verbose && !cs.quiet) {
         if (cs.tabFiles==1 && !cs.pure)
            printf("list of files containing tabs:\n");
         if (!strncmp(pszFile, glblDotSlash, 2))
            pszFile += 2;
         setTextColor(nGlblFileColor);
         oprintf("%s\n", pszFile);
         setTextColor(-1);
      }
      if (chain.colfiles) {
         // chain mode: collect (new) filename list
         Coi ocoi(pszFile, glblFileSet.root());
         chain.addFile(ocoi); // is copied
      }
   }

   if (cs.verbose)
      oprintf("indent %ld: %s\n", nMaxMulIndex, pszFile);

   // dump indent stats
   if (cs.verbose >= 2) 
   {
      // for (i=1; i<100; i++)
      //   if (aind[i] > 0)
      //      printf("%2.2ld : %3.3ld times\n", i, aind[i]);
      // printf("\n");
   
      printf("   ");
      for (i=3; i<=8; i++)
         printf("%2.2ld/%3.3ld ", i, amul[i]);
      printf("\n");
   }

   return 0;
}

long execDelFile(char *pszName)
{
   cs.filesScanned++;
   bool bwaswp = 0;
   if (!cs.sim) {
      if (remove(pszName)) {
         // file is probably write protected
         if (setWriteEnabled(pszName))
            return 1+pwarn("cannot delete: %s\n", pszName);
         if (remove(pszName))
            return 1+pwarn("cannot delete: %s\n", pszName);
         bwaswp = 1;
         cs.filesDeletedWP++;
      }
   }
   if (!cs.quiet) {
      if (bwaswp) {
         oprintf("DEL : %s", pszName);
         printx("   <time>(was write protected)<def>\n");
      } else {
         oprintf("DEL : %s\n",pszName);
      }
   }
   cs.filesDeleted++;
   return 0;
}

long execDelDir(char *pszName, long lLevel, long &lGlobFiles, FileList &oDirFiles, long &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2)
{
   if (!cs.withdirs)
      return 0;

   cs.dirsScanned++;

   // every execDelFile with RC==0 (deleted successfully)
   // lead to an entry in the oDirFiles list.
   long nNumberOfDeletedFiles = oDirFiles.clNames.numberOfEntries();

   // alternatively, if the user supplied "*" as file mask,
   // delete all empty dirs.
   char *pfmask  = glblFileSet.firstFileMask();
   bool  bdelall = !strcmp(pfmask, "*") ? 1 : 0;

   // if this number is >0 AND the directory is NOW empty,
   // then it became empty due to a delete action.
   if (bdelall || nNumberOfDeletedFiles > 0)
   {
      if (isEmptyDir(pszName))
      {
         // todo: delete of readonly dirs
         bool bwaswp = 0;
         if (!cs.sim) {
            if (rmdir(pszName)) {
               // dir is probably write protected
               if (setWriteEnabled(pszName))
                  return 1+pwarn("cannot delete: %s\n", pszName);
               if (rmdir(pszName))
                  return 1+pwarn("cannot delete: %s\n", pszName);
               bwaswp = 1;
               cs.dirsDeletedWP++;
            }
         }
         if (!cs.quiet) {
            if (bwaswp) {
               oprintf("DEL : %s", pszName);
               printx("   <time>(was write protected)<def>\n");
            } else {
               oprintf("DEL : %s\n",pszName);
            }
         }
         cs.dirsDeleted++;
      } else {
         if (bdelall && !cs.sim)
            pinf("dir not empty, cannot delete: %s\n", pszName);
      }
   }

   return 0;
}

long execVersion(Coi *pcoi)
{__
   long nrc = 0;

   uchar *pdata = 0;
   num    nsize = 0;
   if (pcoi->getContent(&pdata, nsize))
      return 9+perr("cannot get version from: %s", pcoi->name());
   // data is managed BY COI.

   char szVerID[50];
   sprintf(szVerID, "$%s:", "version");

   // find version string within binary data
   uchar *ppat = (uchar*)szVerID;
   num    nlen = strlen((char*)ppat);
   uchar *pver = memFind(ppat,nlen, pdata,nsize);

   if (pver)
   {
      // calc max parse range
      num nmax = nsize - (pver - pdata);
      if (nmax <= 0) return 9+perr("int. #28281250");

      StringMap omap;
      if (parseVersion((char*)pver, (long)nmax, omap)) return -1;

      char *pnam = omap.get("name"  , "");
      char *ptyp = omap.get("type"  , "");
      char *pos  = omap.get("os"    , "");
      char *pnum = omap.get("vernum", "");
      char *pfix = omap.get("fix"   , "");
      char *ptit = omap.get("title" , "");
      char *pdat = omap.get("date"  , "");
      char *pinf = omap.get("info"  , "");

      // create integer from version string
      char *psz1 = pnum;
      long nVer = 0;
      long nDot = 3;
      while (*psz1) {
         char c = *psz1++;
         if (c == '.')
            { nVer = nVer * 10; nDot--; }
         else
            nVer = nVer + (c - '0');
      }
      while (nDot-- > 0)
         nVer = nVer * 10;

      if (chain.coldata) {
         chain.print("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s", pcoi->name(),
            pnam,ptyp,pos,pnum,pfix,ptit,pdat,pinf);
      } else {
         printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", pcoi->name(),
            pnam,ptyp,pos,pnum,pfix,ptit,pdat,pinf);
      }
   } else {
      if (cs.verbose)
         pwarn("no version found within: %s", pcoi->name());
      nrc = 1;
   }

   // TODO: not sure if to postpone this
   pcoi->releaseContent();

   return nrc;
}

void detabLine(char *pszIn, char *pszOut, ulong lMaxOut, long nTabSize)
{
   ulong nInsert=0, iout=0;
   for (int icol=0; (pszIn[icol]!=0) && (iout<lMaxOut-1); icol++)
   {
      char c1 = pszIn[icol];
      if (c1 == '\t') {
         nInsert = nTabSize - (iout % nTabSize);
         for (ulong i2=0; i2<nInsert; i2++)
            pszOut[iout++] = ' ';
      } else {
         pszOut[iout++] = c1;
      }
   }
   pszOut[iout] = '\0';
}

long execDetab(char *pszFile, char *pszOutFile)
{
   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut) pszOutFile = pszFile;

   char *pInFile = loadFile(pszFile);
   if (!pInFile) return 9;

   // NO RETURN W/O DELETE FROM HERE

   cs.files++;

   // any tabs at all contained?
   if (!strchr(pInFile, '\t')) {
      delete [] pInFile;
      return 0;
   }

   cs.tabFiles++;

   if (cs.scanTabs) {
      if (cs.tabFiles==1)
         printf("list of files containing tabs:\n");
      if (!strncmp(pszFile, glblDotSlash, 2))
         pszFile += 2;
      printx("<file>%s<def>\n", pszFile);
      delete [] pInFile;
      return 0;
   }

   // write output file:
   //   if different output is specified, also create directory structure.
   if (bHaveOut) {
      if (cs.yes && createOutDirTree(pszOutFile))
         return 9;
      info.setStatus("detab", pszOutFile);
   } else {
      info.setStatus("detab", pszFile);
   }

   FILE *fOut = 0;
   if (cs.yes) {
      if (!(fOut = fopen(pszOutFile, "w"))) {
         delete [] pInFile; 
         return 9+perr("cannot %swrite %s\n", bHaveOut?"":"over", pszOutFile); 
      }
   }

   char *pCur     = pInFile;
   int bBail      = 0;
   long nTabsDone = 0;
   while (!bBail && *pCur)
   {
      char *pNext = strchr(pCur, '\n');

      if (pNext)
         *pNext++ = 0; // remove LF on current line
      else
          bBail   = 1; // last line

      // truncate CR on current line, if any
      char *psz   = strchr(pCur, '\r');
      if (psz) *psz = 0;

      // detab a single line
      int nInsert=0, iout=0;
      for (int icol=0; pCur[icol]; icol++)
      {
         char c1 = pCur[icol];
         if (c1 == '\t') 
         {
            nInsert = cs.tabSize - (iout % cs.tabSize);
            for (int i2=0; i2<nInsert; i2++) {
               if (cs.yes) fputc(' ', fOut);
               iout++;
            }
            nTabsDone++;
            cs.tabsDone++;
         }
         else 
         {
            if (cs.yes) fputc(c1, fOut);
            iout++;
         }
      }

      if (cs.yes) fputc('\n', fOut);

      pCur = pNext;
   }

   if (cs.yes) fclose(fOut);

   // NO RETURN W/O DELETE UNTIL HERE

   delete [] pInFile;

   info.setAddInfo("% 5ld tabs", nTabsDone);
   info.printLine(1<<2);

   return 0;
}

long execEntab(char *pszFile)
{
   char *pInFile = loadFile(pszFile);
   if (!pInFile) return 9;

   cs.files++;
   cs.tabFiles++;

   printf("entab: %s\n", pszFile);

   FILE *fOut = 0;
   if (cs.yes)
      if (!(fOut = fopen(pszFile, "w")))
         return 9+perr("cannot overwrite %s\n", pszFile);

   char *pCur   = pInFile;
   int bBail    = 0;
   while (!bBail && *pCur)
   {
      char *pNext = strchr(pCur, '\n');

      if (pNext)
         *pNext++ = 0; // remove LF on current line
      else
          bBail   = 1; // last line

      // truncate CR on current line, if any
      char *psz   = strchr(pCur, '\r');
      if (psz) *psz = 0;

      // entab a single line
      int nInsert=0, iout=0, nblank=0, i;
      for (int icol=0; pCur[icol]; icol++)
      {
         char c1 = pCur[icol];
         if (c1 != ' ') {
            if (cs.yes) fputc(c1, fOut);
            continue;
         }
         // calc posn of next tab stop
         long itab  = ((icol / cs.tabSize) + 1) * cs.tabSize;
         // calc distance to this next tab stop
         long ndist = itab-icol;
         // if this distance is >= 2 chars
         if (ndist >= 1)
         {
            // and completely filled with blanks
            for (i=0; i<ndist; i++)
               if (!pCur[icol+i] || pCur[icol+i]!=' ')
                  break;
            if (i==ndist) {
               // then replace blanks by tab
               if (cs.yes) fputc('\t', fOut);
               icol += ndist-1; // MIND icol++
               cs.tabsDone++;
               continue;
            }
            // else fall through
         }
         // else copy-through current char
         if (cs.yes) fputc(c1, fOut);
      }

      if (cs.yes) fputc('\n', fOut);

      pCur = pNext;
   }

   if (cs.yes) fclose(fOut);

   delete [] pInFile;

   return 0;
}

long diffDump(uchar *p1, uchar *p2, num nlen, num nListOffset)
{__
   mtklog("diffdump %ld bytes, %p %p",(long)nlen,p1,p2);
   mtkdump("p1 ",p1,nlen);
   mtklog(" ");
   mtkdump("p2 ",p2,nlen);

   num nSubOff = 0;
   num nRemain = nlen;
   while (nRemain > 0)
   {
      num nBlockLen = nRemain;
      long *appos = 0;

      if (bGlblHexDumpWide) 
      {
      strcpy(szLineBuf,
      //  1                                    38               55                73                                   110
      //">00112233 44556677 00112233 44556677< 0123456789ABCDEF 0123456789ABCDEF >00112233 44556677 00112233 44556677< 0123456789ABCDEF");
        ">                                   <                                   >                                   <                 ");
      strcpy(szAttrBuf,
        "i                                   i                                   i                                   i                 ");
      //                          0  1   2   3   4
      static long aPosWide[] = {  1, 38, 55, 73, 110 };
      appos = aPosWide;
      if (nBlockLen > 16) nBlockLen = 16;
      }
      else 
      {
      strcpy(szLineBuf,
      //  1                  20       29        39                 58
      //">00112233 44556677< 01234567 01234567 >00112233 44556677< 0123456789ABCDEF");
        ">                 <                   >                 <                 ");
      strcpy(szAttrBuf,
        "i                 i                   i                 i                 ");
      //                          0  1   2   3   4
      static long aPosBase[] = {  1, 20, 29, 39, 58 };
      appos = aPosBase;
      if (nBlockLen > 8) nBlockLen = 8;
      }

      // create offset info
      char *pszHexOff = numtohex(nListOffset+nSubOff, 8);
      strcpy(szLineBuf+appos[4], pszHexOff); // ipos

      for (num i=0; i<nBlockLen; i++) 
      {
         // create hex info
         uchar uc1 = p1[nSubOff+i];
         uchar uc2 = p2[nSubOff+i];
         long iof1 = appos[0] + i * 2 + ((i>=4)?1:0) + ((i>=8)?1:0) + ((i>=12)?1:0);
         long iof2 = appos[3] + i * 2 + ((i>=4)?1:0) + ((i>=8)?1:0) + ((i>=12)?1:0);
         sprintf(szLineBuf+iof1, "%02X", uc1);
         sprintf(szLineBuf+iof2, "%02X", uc2);
         szLineBuf[iof1+2] = ' ';
         szLineBuf[iof2+2] = ' ';

         // create printable info
         long iof3 = appos[1] + i;  // ipos
         long iof4 = appos[2] + i;  // ipos

         if(isprint(uc1)) {
            szLineBuf[iof3] = (char)uc1;
            szAttrBuf[iof3] = 'i';
         } else
            szLineBuf[iof3] = '.';

         if(isprint(uc2)) {
            szLineBuf[iof4] = (char)uc2;
            szAttrBuf[iof4] = 'i';
         } else
            szLineBuf[iof4] = '.';

         // highlight different bytes
         if (uc1 != uc2) {
            strncpy(szAttrBuf+iof1, "ee", 2);
            strncpy(szAttrBuf+iof2, "ee", 2);
            szAttrBuf[iof3] = 'e';
            szAttrBuf[iof4] = 'e';
         }
      }
      szLineBuf[appos[1]-2] = '<'; // ipos
      szLineBuf[appos[4]-2] = '<'; // ipos

      // if in binfind mode, show just left part, appending offset
      if (cs.repDumpHalve) 
      {
         long iofm = appos[2];
         long iofo = appos[4];
         strcpy(szLineBuf+iofm, szLineBuf+iofo);
         strcpy(szAttrBuf+iofm, szAttrBuf+iofo);
      }

      if (chain.coldata) {
         chain.addLine(szLineBuf, szAttrBuf);
      } else {
         printColorText(szLineBuf, szAttrBuf);
      }

      nSubOff += nBlockLen;
      nRemain -= nBlockLen;
   }
   return 0;
}

long execHexdump(char *pszFile, uchar *pBuf, ulong nBufSize)
{
   num ntotal = 0;

   FILE *fin = 0;
   uchar *pBufCur = pBuf;
   long nBufRem = (long)nBufSize;
   if (!pBuf) {
      fin = fopen(pszFile, "rb");
      if (!fin) {
         // non-fatal, continue with other files
         return 1+pwarn("%s : cannot read - skipping\n", pszFile);
      }

      if (!cs.nonames) {
         if (chain.coldata) {
            sprintf(szLineBuf2, ":file %s", pszFile);
            // note: +view scans extended end of attribute line
            //       to identify 'f'ile header lines, therefore +2:
            setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
            chain.addLine(szLineBuf2, szAttrBuf2);
         } else {
            setTextColor(nGlblFileColor);
            printf("%s :\n", pszFile);
            setTextColor(-1);
         }
      }

      if (nGlblHexDumpOff) {
         if (myfseek(fin, nGlblHexDumpOff, SEEK_SET)) {
            fclose (fin);
            return 1+pwarn("%s : cannot seek - skipping\n", pszFile);
         }
         ntotal = nGlblHexDumpOff;
      }
   }

   long lOutLen2=0, lIndex=0, lIndex2=0;
   long lRelPos=0;
   uchar *pTmp = 0;
   uchar ucTmp;
   uchar abBlockBuf[100];

   long nbpl  = bGlblHexDumpWide ?  32 : 16; // bytes per line
   long itext = bGlblHexDumpWide ?  75 : 39; // text begin
   long ioffs = bGlblHexDumpWide ? 108 : 56; // offset begin
   long ieol  = ioffs + 20;

   num  nTotalMax = 0;
   if (nGlblHexDumpLen > 0)
        nTotalMax = nGlblHexDumpOff + nGlblHexDumpLen;

   if (cs.verbose) {
      printf("dump from %s ",numtoa(nGlblHexDumpOff));
      printf("to %s ",numtoa(nTotalMax));
      printf("a total of %s bytes\n",numtoa(nGlblHexDumpLen));
   }

   while (1)
   {
      long nread = 0;
      if (pBuf) {
         if (nBufRem <= 0)
            break;
         if (nbpl < nBufRem) nread = nbpl;
         else                nread = nBufRem;
         memcpy(abBlockBuf, pBufCur, nread);
         pBufCur += nread;
         nBufRem -= nread;
      } else {
         nread = fread(abBlockBuf, 1, nbpl, fin);
      }
      if (nread <= 0) break;
      pTmp = abBlockBuf;

      long lOutLen = nread;

      szLineBuf[0] = '\0';
      bool bshort  = 0;

      switch (nGlblHexDumpForm)
      {
         case 0:
            break; // fall through

         case 1: { // pure
            for (long i=0; i<lOutLen; i++)
               mystrcatf(szLineBuf,MAX_LINE_LEN,"%02X",pTmp[i]);
            strcat(szLineBuf,"\n");
            bshort = 1;
            break;
         }

         case 2: { // source, hex
            for (long i=0; i<lOutLen; i++)
               mystrcatf(szLineBuf,MAX_LINE_LEN,"0x%02X,",pTmp[i]);
            strcat(szLineBuf,"\n");
            bshort = 1;
            break;
         }

         case 3: { // source, dec
            for (long i=0; i<lOutLen; i++)
               mystrcatf(szLineBuf,MAX_LINE_LEN,"%lu,",(ulong)pTmp[i]);
            strcat(szLineBuf,"\n");
            bshort = 1;
            break;
         }

         case 4: { // flat, filtering control characters, skipping binary
            for (long i=0; i<lOutLen; i++) {
               uchar c = pTmp[i];
               if (!c) {
                  long nRemain = lOutLen - i;
                  mystrcatf(szLineBuf,MAX_LINE_LEN," [binary, skipping %lu bytes]\n", nRemain);
                  break; 
               }
               else
               if (c < 0x20 && (c != '\r' && c != '\n' && c != '\t'))
                  continue; // skip control characters except LF, TAB
               else
                  mystrcatf(szLineBuf,MAX_LINE_LEN,"%c",(char)c);
            }
            bshort = 1;
            break;
         }
      }

      if (bshort) {
         // dump short form created above
         if (chain.coldata)
            chain.addLine(szLineBuf, "", 0);
         else
            printf("%s",szLineBuf);
         // then continue with next chunk
         continue;
      }

      // else fall through to human-readable

      memset(szLineBuf, ' ', ieol);
      memset(szAttrBuf, ' ', ieol);
      szLineBuf[ieol] = '\0';
      szAttrBuf[ieol] = '\0';

      szLineBuf[1] = '>';
      szAttrBuf[1] = 'i';

      char *pszHexOff = numtohex(ntotal, 8);
      strcpy(&szLineBuf[ioffs], pszHexOff);
      // adds zero terminator after offset info!
      long ieol = strlen(szLineBuf);
      szAttrBuf[ieol] = '\0';

      lOutLen2 = lOutLen;

      for(lIndex = 2, lIndex2 = itext, lRelPos = 0;
          lOutLen2;
          lOutLen2--, lIndex += 2, lIndex2++
         )
      {
         ucTmp = *pTmp++;

         sprintf(szLineBuf + lIndex, "%02X ", (unsigned short)ucTmp);

         // optional: highlight CR and LF characters
         if (bGlblHexdumpShowLE)
            if (ucTmp == '\r' || ucTmp == '\n') {
               szAttrBuf[lIndex+0] = 'e';
               szAttrBuf[lIndex+1] = 'e';
               szAttrBuf[lIndex2 ] = 'e';
            }

         if(isprint(ucTmp))
            szAttrBuf[lIndex2] = 'i';  // mark printable text
         else
            ucTmp = '.'; // nonprintable char

         szLineBuf[lIndex2] = ucTmp;

         if (!(++lRelPos & 3))     // extra blank after 4 bytes
         {  lIndex++; szLineBuf[lIndex+2] = ' '; }
      }

      if (!(lRelPos & 3)) lIndex--;

      szLineBuf[lIndex  ]   = '<';
      szLineBuf[lIndex+1]   = ' ';
      szAttrBuf[lIndex ]   = 'i';

      if (chain.coldata) {
         chain.addLine(szLineBuf, szAttrBuf);
      } else {
         printColorText(szLineBuf, szAttrBuf);
      }

      ntotal += (num)nread;

      if (nTotalMax > 0)
         if (ntotal >= nTotalMax)
            break;
   }

   if (!pBuf)
      fclose(fin);

   return 0;
}

long testfwrite(char *pszFile, num nSize)
{
   if (nSize <= 0 || nSize > 1048576 * 500)
      return 9+perr("illegal size");

   uchar *ptmp = new uchar[nSize];
   if (!ptmp) return 9+perr("out of memory");
   memset(ptmp, 0, nSize);

   FILE *fout = fopen(pszFile, "wb");
      if (!fout) return 9+perr("cannot open");

   num nwrite = fwrite(ptmp, 1, nSize, fout);

   fclose(fout);

   delete [] ptmp;

   printf("expected / written: ");
   printf("%s " , numtoa(nSize));
   printf("%s\n", numtoa(nwrite));

   if (nwrite != nSize)
      printf("... block write failed\n");

   return 0;
}

#ifndef USE_SFK_BASE

#ifdef _WIN32
DWORD CALLBACK cbCopyFileProgress(
   LARGE_INTEGER TotalFileSize,
   LARGE_INTEGER TotalBytesTransferred,
   LARGE_INTEGER StreamSize,
   LARGE_INTEGER StreamBytesTransferred,
   DWORD dwStreamNumber,
   DWORD dwCallbackReason,
   HANDLE hSourceFile,
   HANDLE hDestinationFile,
   LPVOID lpData  // optional
 )
{
   if (userInterrupt(1))
      return 1; // PROGRESS_CANCEL;

   num nTotal =  (((num)TotalFileSize.HighPart) << 32)
               | (((num)TotalFileSize.LowPart ) <<  0);

   num nDone  =  (((num)TotalBytesTransferred.HighPart) << 32)
               | (((num)TotalBytesTransferred.LowPart ) <<  0);

   info.setAddInfo("%lu / %lu mb", (ulong)(nDone/1000000UL), (ulong)(nTotal/1000000UL));
   info.setProgress(nTotal, nDone, "bytes");

   return 0; // PROGRESS_CONTINUE;
}

long copyFileWin(char *pszSrc, char *pszDst, char *pszShDst, uchar *pWorkBuf, num nBufSize, ulong nflagsin)
{
   char *pszTell = chain.usefiles ? pszDst : pszSrc;
   if (cs.listTargets) pszTell = pszDst;

   if (cs.sim) {
      info.setStatus("", pszTell, "-----", eNoCycle);
      if (!cs.dostat)
         info.printLine(nGlblCopyStyle);
      cs.files++;
      return 0;
   }

   info.setAction("copy ", pszSrc, "00");

   DWORD nSysFlags = 0;

   // these are yet internal and completely untested
   if (cs.copyLinks)   nSysFlags |= 0x00000800UL; // COPY_FILE_COPY_SYMLINK;
   if (cs.copyNoBuf)   nSysFlags |= 0x00001000UL; // COPY_FILE_NO_BUFFERING;
   if (cs.copyDecrypt) nSysFlags |= 0x00000008UL; // COPY_FILE_ALLOW_DECRYPTED_DESTINATION;

   BOOL bcancel = 0;
   bool brc = CopyFileExA(pszSrc, pszDst, cbCopyFileProgress, 0, &bcancel, nSysFlags);

   if (!brc) {
      ulong nerr = GetLastError();
      switch (nerr) {
         case ERROR_ACCESS_DENIED:
            perr("copy failed, access denied (rc=%lu): %s\n", nerr, pszDst);
            pinf("make sure you have full access rights. maybe you have to be administrator.\n");
            break;
         case ERROR_REQUEST_ABORTED:
            pwarn("copy stopped by user.\n");
            break;
         default:
            perr("copy failed, rc=%lu: %s\n", nerr, pszDst);
            break;
      }
   } else {
      cs.files++;
      printCopyCompleted(pszTell, nflagsin);
   }

   return brc ? 0 : 9;
}
#endif // _WIN32

long copyFile(char *pszSrc, char *pszDst, char *pszShDst, uchar *pWorkBuf, num nBufSize, ulong nflags)
{
   char *pszTell = chain.usefiles ? pszDst : pszSrc;
   if (cs.listTargets) pszTell = pszDst;

   if (cs.sim) {
      info.setStatus("", pszTell, "-----", eNoCycle);
      if (!cs.dostat)
         info.printLine(nGlblCopyStyle);
      cs.files++;
      return 0;
   }

   long lRC = 0;
   uchar abMD5Src[20];
   bool  bmdsrcset = 0;
   memset(abMD5Src, 0, sizeof(abMD5Src));

   bool bDoneFile = 0;

   // try to copy the file, upto 3 times
   for (long ntry=1; ntry<=3; ntry++)
   {
      info.setAction("read ", pszSrc, "00");
   
      num nFileSize = getFileSize(pszSrc);
   
      FILE *fin = fopen(pszSrc, "rb");
      if (!fin) return 9+perr("cannot open input file %s   \n", pszSrc);
   
      FILE *fout = myfopen(pszDst, "wb");
      if (!fout) { 
         fclose(fin); 
         return 9+perr("cannot open output file %s   \n", pszDst); 
      }

      FILE *fsh = 0;
      if (   filedb.canUpdate() && nGlblCopyShadows && pszShDst
          && (!nGlblShadowSizeLimit || (nFileSize < nGlblShadowSizeLimit))
         )
      {
         fsh = fopen(pszShDst, "wb");
         if (!fsh)
            perr("cannot write shadow file %s   \n", pszShDst);
            // but continue, w/o shadow
      }
     
      num nTime1=0, nTime2=0, nReadTime=0, nWriteTime=0;
      num nReadBytes=0, nWriteBytes=0;
      ulong nkbsread=0, nkbswrite=0;
      SFKMD5 md5in;
      long nBlock = 0;
      while (!userInterrupt())
      {
         nTime1 = getCurrentTime();
         info.setStatus("read ", pszSrc, "00");
         size_t nRead = 0;
         if (cs.sim)
            nRead = nBufSize;
         else
            nRead = myfread(pWorkBuf, (size_t)nBufSize, fin, nFileSize, nReadBytes);
         nTime2 = getCurrentTime();
         if (nRead <= 0)
            break; // EOD
         nReadTime  += (nTime2-nTime1);
         nReadBytes += nRead;
   
         md5in.update(pWorkBuf, nRead);
   
         nTime1 = getCurrentTime();
         info.setStatus("write", pszDst, "00");
         size_t nWrite = myfwrite(pWorkBuf, nRead, fout, nFileSize, nWriteBytes);
         nTime2 = getCurrentTime();
         if (nWrite != nRead) {  
            lRC = 9;
            if (!bGlblEscape)
               esys("fwrite", "failed to write %s   \n", pszDst);
            break; 
         }
         nWriteTime  += (nTime2-nTime1);
         nWriteBytes += nWrite;

         // extra shadow write
         if (fsh) {
            nWrite = myfwrite(pWorkBuf, nRead, fsh, nFileSize, nWriteBytes);
            if (nWrite != nRead) {
               // shadow writing fails silently
               fclose(fsh);
               remove(pszShDst);
               fsh = 0;
               pszShDst = 0;
            }
         }
   
         nkbsread  = (nReadBytes  / (nReadTime  ? nReadTime : 1));
         nkbswrite = (nWriteBytes / (nWriteTime ? nWriteTime : 1));
   
         nBlock++;
      }

      if (fsh) {
         fclose(fsh);
         nflags |= 4; // shadow written
         cs.shadowsWritten++;
      }
      pszShDst = 0; // block 2nd writing of shadow
   
      myfclose(fout);
      fclose(fin);
   
      if (bGlblEscape) {
         remove(pszDst);
         return 9+perr("failed to write %s: user interrupt   \n", pszDst);
      }
   
      FileStat ofs;
      if (ofs.readFrom(pszSrc))
         return 9+perr("failed to read attributes: %s\n", pszSrc);
      if (ofs.writeTo(pszDst, __LINE__))
         return 9+perr("failed to write attributes: %s\n", pszDst);
      else
         cs.filesCloned++;

      uchar *pmd5in = md5in.digest();

      // remember source sum in case of late verify:
      if (cs.verifyLate) {
         num nsumlo=0, nsumhi=0;
         for (long i=0,b=64-8; i<8; i++) {
            nsumhi = nsumhi | (((num)pmd5in[0+i]&0xFF) << b);
            nsumlo = nsumlo | (((num)pmd5in[8+i]&0xFF) << b);
            b -= 8;
         }
         glblVerifier.remember(pszDst, nsumhi, nsumlo);
      }

      // remember src file md5 beyond this scope
      memcpy(abMD5Src, pmd5in, 16);
      bmdsrcset = 1;

      if (!cs.sim && cs.verifyEarly)
      {
         info.setAction("verfy", pszTell, "00");
   
         // run target verify
         uchar abmd5[20];
         long nrcsub = getFileMD5NoCache(pszDst, abmd5, 1);
   
         if (userInterrupt(1))
         {
            info.setAction("stop ", pszDst, 0, 4);
            info.printLine();
            break;
         }
         else
         if (nrcsub == 0)
         {
            if (memcmp(pmd5in, abmd5, 16)) {
               if (ntry < 3) {
                  pwarn("verify failed, file differs: %s - retrying write\n", pszDst);
                  // fall through, next retry
                  remove(pszDst);
               } else {
                  perr("verify failed, file differs: %s - giving up\n", pszDst);
                  remove(pszDst);
               }
            } else {
               // verify succeeded
               bDoneFile = 1;
               cs.files++;
               break;
            }
         }
      }
      else
      {
         // no verify selected
         bDoneFile = 1;
         cs.files++;
         break;
      }
   }  // endfor tries

   if (bDoneFile)
      printCopyCompleted(pszTell, nflags);

   if (lRC == 0) {
      if (!bmdsrcset) return 9+perr("internal #0505071820");
      filedb.updateFile(pszSrc, abMD5Src);
   }

   return lRC;
}

#endif // USE_SFK_BASE

// original src : thedir
// have now     : thedir/subdir/thefile.txt
// need relative:        subdir/thefile.txt
char *relName(char *pszRoot, char *pszAbs)
{
   bool bisurl = 0;
   #ifdef VFILEBASE
   bisurl = !strncmp(pszRoot, "ftp://", 6) || !strncmp(pszRoot, "http://", 7);
   // TODO: for now, block relativazation of all http: urls
   if (!strncmp(pszRoot, "http://", 7))
      return pszAbs;
   #endif // VFILEBASE
   if (!pszRoot || !strlen(pszRoot))
       return pszAbs;
   long nsrclen = strlen(pszRoot);
   if (!strcmp(pszRoot, "."))
       return pszAbs;
   if (!strcmp(pszRoot, pszAbs))
       return pszAbs + nsrclen;
   // have to compare copysrc WITH path separator char!
   if (endsWithPathChar(pszRoot, bisurl))
       nsrclen--;
   // first check name part
   if (strncmp(pszRoot, pszAbs, nsrclen)) {
       pwarn("%s not relative to %s (1)\n",pszAbs,pszRoot);
       return pszAbs; // no match
   }
   // then also path char
   #ifdef _WIN32
   // IF dir is not ending with ':'
   if (endsWithColon(pszRoot))
       return pszAbs + nsrclen;
   #endif
   if (bisurl && pszAbs[nsrclen] == '/')
     { }
   else
   if (pszAbs[nsrclen] != glblPathChar) {
       pwarn("%s not relative to \"%s\" (2) %c\n",pszAbs,pszRoot,pszAbs[nsrclen]);
       return pszAbs; // no match
   }
   char *pszRel = pszAbs + nsrclen + 1; // past separator
   // printf("REL %s => %s\n", pszAbs, pszRel);
   return pszRel;
}

// c:the\foo\bar.txt -> bar.txt
// c:bar.txt -> bar.txt
char *relativeFilename(char *pszPath)
{
   char *pszRel = strrchr(pszPath, glblPathChar);
   if (pszRel) return pszRel+1;

   #ifdef _WIN32
   pszRel = strrchr(pszPath, ':');
   if (pszRel) return pszRel+1;
   #endif

   return pszPath;
}

// returns NULL in case of error.
// returns same name if root doesn't match.
char *rootRelativeName(char *pszFileName, char *pszOptRoot)
{
   if (pszOptRoot)
      return relName(pszOptRoot, pszFileName);

   if (!glblFileSet.hasRoot(0))
      return pszFileName;

   char *pszRoot = glblFileSet.getCurrentRoot();
   if (!pszRoot) { perr("internal 812063\n"); return 0; }

   return relName(pszRoot, pszFileName);
}

#ifndef USE_SFK_BASE

// experimental
long execDirCopy(char *pszSrc, FileList &oDirFiles)
{
   // copy metadata of directory
   char *pszDstRaw = pszGlblCopyDst;

   // expect Src to contain a RELATIVE path, e.g.
   //    data\tmp1.txt  data\sub\tmp2.txt
   // strip the original base path, if any
   char *pszRelSrc = relName(pszGlblCopySrc, pszSrc);

   cs.dirsScanned++;
   sprintf(szLineBuf, "%lu files %lu dirs", cs.filesScanned, cs.dirsScanned);
   if (strlen(szLineBuf) > 20)
      info.setAddInfoWidth(strlen(szLineBuf));
   info.setStatus("scan ", pszRelSrc, szLineBuf);

   // build full target name: d:/tmp/subdir
   joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszDstRaw, pszRelSrc);
   // strip trailing / if any
   long nRefLen = strlen(szRefNameBuf);
   if ((nRefLen > 0) && (szRefNameBuf[nRefLen-1] == glblPathChar))
      szRefNameBuf[nRefLen-1] = '\0';

   // in case we have to copy EMPTY target directories:
   // if (createSubDirTree(szRefNameBuf, ""))
   //   return 9;

   // execFileCopy has created dir tree on demand,
   // so all dirs must exist, IF files have been copied.
   if (!isDir(szRefNameBuf)) {
      if (cs.verbose)
         info.print("%s : skip, no files copied.\n",szRefNameBuf);
      return 0; // no files have been copied in that dir.
   }

   char szReason[50];
   szReason[0] = '\0';

   // check if we really need to copy attributes

   // win: don't try to clone x: to y: etc.
   #ifdef _WIN32
   if (endsWithColon(pszSrc)) return 0;
   if (endsWithColon(szRefNameBuf)) return 0;
   #endif

   // BEWARE OF MIXUP:
   //    sfk list -sincedir foo bar
   //       means for the user: FOO (szRefNameBuf) is the SOURCE.
   // NO problem here, as in
   //    sfk copy foo bar
   //       the provided pszSrc in here IS actually the SOURCE.

   FileStat ofsSrc;
   FileStat ofsDst;
   if (ofsSrc.readFrom(pszSrc)) {
      perr("cannot read dir time: %s\n", pszSrc);
      return 9;
   }

   char *pszTell = pszSrc;
   if (cs.listTargets) pszTell = szRefNameBuf;

   // checked isDir(szRefNameBuf) above
   if (!ofsDst.readFrom(szRefNameBuf))
   {
      // copy the directory timestamp or not? during filecopy,
      // we may have created the dir on demand. in this case,
      // copy the dir timestamp unconditionally. ELSE copy it only
      // if the src is newer than the target.
      bool bOnlyOnNewSrc = 1;
      // this check is not at all beautiful, but it works
      // without restructuring the whole tree processing.
      #ifdef SFK_CCDIRTIME
      long ipos = glblCreatedDirs.find(szRefNameBuf);
      if (ipos >= 0) {
         // the dir was recently created: ignore it's new timestamp
         glblCreatedDirs.removeEntry(ipos);
         bOnlyOnNewSrc = 0;
      }
      #endif
      long ndif = ofsSrc.differs(ofsDst, bOnlyOnNewSrc);
      if (!ndif) {
         if (cs.verbose > 1)
            info.print("%s : no time / attrib change\n", szRefNameBuf);
         return 0;   // skip
      }
      if (cs.verbose > 0)
         info.print("%s : copying attribs, ndif %ld\n", szRefNameBuf, ndif);
      // sprintf(szReason, "%ld", ndif);
   }

   bool bDone = 0;
   if (bGlblUseCopyCache) {
      long lRes = glblCopyCache.process(pszSrc, szRefNameBuf, 0, 0);
      if (lRes == 0)
         bDone = 1;
   }

   if (!bDone)
   {
      if (cs.sim) {
         cs.dirsCloned++;
      } else {
         if (cloneAttributes(pszSrc, szRefNameBuf, __LINE__))
            return 1; // error, but skip and continue
         cs.dirsCloned++;
      }

      setTextColor(nGlblTimeColor);
      info.setStatus("", pszTell, "copy time", eNoCycle);
      info.printLine(nGlblCopyStyle);
      setTextColor(-1);
   }

   return 0;
}

long execFileCopySub(char *pszSrc, char *pszDst, char *pszShSrc=0, char *pszShDst=0);

// experimental
// USES:
//    szAttrBuf, szRefNameBuf, szLineBuf1/2 (indirectly)
long execFileCopy(Coi *pcoi)
{
   char *pszSrc      = pcoi->name();
   char *pszOptRoot  = pcoi->root(1); // null if not set

   cs.filesScanned++;

   // with input chaining, glblCopySrc will not be set.
   char *pszSrcRaw = pszGlblCopySrc;
   if (chain.usefiles) {
      if (cs.rootrelname)
         pszSrcRaw = pszOptRoot; // user selected relative names
      else {
         // autodetect: include source root into target name?
         if (cs.rootabsname || (pszOptRoot && !isAbsolutePath(pszOptRoot)))
            // source root is NOT absolute, or -abs specified: take it
            pszSrcRaw = "";
         else
            // source root IS absolute (e.g. C:\\) so strip it
            pszSrcRaw = pszOptRoot; // if null, produces error below
      }
   }
   if (!pszSrcRaw) return 9+perr("copy: missing source root dir. file=%s",pszSrc);

   // expect Dst to be a directory, e.g.
   //    x:    x:/   x:/tmp   x:/tmp/
   char *pszDstRaw = pszGlblCopyDst;

   // expect Src to contain a RELATIVE path, e.g.
   //    data\tmp1.txt  data\sub\tmp2.txt
   // strip the original base path, if any
   char *pszRelSrc = relName(pszSrcRaw, pszSrc);
 
   // build full target name: d:/tmp/subdir/thefile.txt
   // sprintf(szRefNameBuf, "%s%c%s", pszDstRaw, glblPathChar, pszRelSrc);
   joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszDstRaw, pszRelSrc);

   if (cs.debug)
      printf("copy.check %s => %s [root=%s]\n",pszSrc,szRefNameBuf,pszSrcRaw);

   char *pszShSrc = 0, *pszShDst = 0;
   if (filedb.canRead()) {
      // create source shadow path
      if (!joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2), pszSrcRaw, pszRelSrc))
         pszShSrc = szRefNameBuf2;
   } else {
      // create dest shadow path
      if (!joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2), pszDstRaw, pszRelSrc))
         pszShDst = szRefNameBuf2;
   }
 
   // prepare target directory(s), if any. first we need the full path,
   strcopy(szAttrBuf, szRefNameBuf);
   char *psz1 = strrchr(szAttrBuf, glblPathChar);
   #ifdef _WIN32
   if (!psz1) {
      // c:thefile.txt -> c:
      if ( (strlen(szAttrBuf) >= 2) && (szAttrBuf[1] == ':' ) )
         psz1 = &szAttrBuf[2];
   }
   #endif
   if (!psz1) return 9+perr("unexpected target name format: %s\n",szAttrBuf);
   *psz1 = '\0';
   // to check if it exists or not,
   if (!cs.sim && !isDir(szAttrBuf)) {
      // then we need to isolate the relative target dir path,
      sprintf(szAttrBuf, "%c%s", glblPathChar, pszRelSrc);
      psz1 = strrchr(szAttrBuf, glblPathChar);
      if (!psz1) return 9+perr("unexpected target name format: %s\n",szAttrBuf);
      *psz1 = '\0';
      // to allow better processing in createSubDirTree.
      if (createSubDirTree(pszDstRaw, szAttrBuf, pszSrcRaw))
         return 9;
   }
   // else we have some path like c:thefile.txt - no directories to create.

   // same for dest. shadow, if any
   if (filedb.canUpdate() && nGlblCopyShadows && pszShDst) 
   {
      strcopy(szAttrBuf, pszShDst);
      char *psz1 = strrchr(szAttrBuf, glblPathChar);
      #ifdef _WIN2
      if (!psz1) {
         // c:thefile.txt -> c:
         if ( (strlen(szAttrBuf) >= 2) && (szAttrBuf[1] == ':' ) )
            psz1 = &szAttrBuf[2];
      }
      #endif
      if (!psz1) return 9+perr("unexpected target name format: %s\n",szAttrBuf);
      *psz1 = '\0';
      // to check if it exists or not,
      if (!cs.sim && !isDir(szAttrBuf)) {
         // then we need to isolate the relative target dir path,
         sprintf(szAttrBuf, "%czz-shadow-01%s%s", glblPathChar, glblPathStr, pszRelSrc);
         psz1 = strrchr(szAttrBuf, glblPathChar);
         if (!psz1) return 9+perr("unexpected target name format: %s\n",szAttrBuf);
         *psz1 = '\0';
         // to allow better processing in createSubDirTree.
         if (createSubDirTree(pszDstRaw, szAttrBuf, pszSrcRaw))
            return 9;
      }
   }
 
   return execFileCopySub(pszSrc, szRefNameBuf, pszShSrc, pszShDst);
}

// does NOT create target subdirs. this is expected to be done by caller.
long execFileCopySub(char *pszSrc, char *pszDst, char *pszShSrc, char *pszShDst)
{__
   mtklog("fcopysub: %s -> %s",pszSrc,pszDst);

   char szReason[50];
   szReason[0] = '\0';

   // if we tell the filename, do we take src or dst file?
   char *pszTell = chain.usefiles ? pszDst : pszSrc;
   if (cs.listTargets) pszTell = pszDst;
 
   // check if we really need to copy

   // BEWARE OF MIXUP:
   //    sfk list -sincedir foo bar
   //       means for the user: FOO (szRefNameBuf) is the SOURCE.
   // NO problem here, because with
   //    sfk copy foo bar
   //       the pszSrc provided in here REALLY is the SOURCE.

   bool  bJustCopyTime = 0;
   bool  bSrcIsOlder = 0;
   ulong nflags = 0;

   FileStat ofsSrc;
   FileStat ofsDst;
   bool  bSrcUnreadable = 0;
   if (ofsSrc.readFrom(pszSrc)) {
      // filename exists in source, but file is unreadable:
      mtklog("copy: src unreadable");
      if (filedb.canRead() && pszShSrc) {
         // proceed, as we may use the shadow
         bSrcUnreadable = 1; // but don't issue same error twice
      } else {
         // printf("fatal, %d %p\n", filedb.canRead(), pszShSrc);
         return 9;
      }
   }
   num nFileSize = ofsSrc.getSize();
   if (fileExists(pszDst)) 
   {
      if (!ofsDst.readFrom(pszDst)) 
      {
         bool bSameIOS = cs.syncOlder ? 0 : 1;  // same if older src?
         long ndif = ofsSrc.differs(ofsDst, bSameIOS, &bSrcIsOlder);
         if (bSrcIsOlder) nflags |= (1<<3);
         if (!ndif && !bGlblIgnoreTime) {
            // only with copy, NOT with sync it may happen
            // that src is OLDER than target, skipping copy.
            // with sync, different times ALWAYS lead to copy.
            if (cs.syncFiles && bSrcIsOlder && !cs.noinfo) {
               if (bSrcIsOlder < 2) {
                  info.setStatus("skip", pszTell, "source is older");
                  info.printLine(1<<2);
               }
               // else dst jump, don't even tell notice
            }
            else
            if (cs.verbose)
               info.print("no diff, skip: %s\n", pszTell);
            if (filedb.canUpdate())
               filedb.updateFile(pszSrc, 0, true); // true:JustConfirm
            return 0;   // skip
         }
         // differs by timestamp (src is newer). but does it really mean
         // we have to copy the whole content?
         if (ofsSrc.getSize() == ofsDst.getSize()) {
            // compare file content
            uchar abMD5Src[20];
            if (equalFileContent(pszSrc, pszDst, abMD5Src)) {
               if (bGlblIgnoreTime) {
                  if (filedb.canUpdate())
                     filedb.updateFile(pszSrc, abMD5Src);
                  return 0; // same content, skip
               }
               bJustCopyTime = 1;
            }
            else
            if (!ndif && bGlblIgnoreTime) {
               long ndif2 = ofsSrc.differs(ofsDst, 0); // NOT same if older src
               if (!ndif2 && cs.sim) {
                  // critical: have file with same size and time, but dif. content
                  // this can be reached only through -ignoretime deep verify.
                  // if in simulation, create warning-like special listing
                  pwarn("same time/size, but content diff: %s\n", pszDst);
                  // indicates corrupted file - no filedb update here.
                  cs.files++;
                  return 0;
               }
            }
            if (cs.verbose)
               info.print("[%s : differs, rc %ld%s]\n", pszDst, ndif,
                  bJustCopyTime ? ", same content":", diff. content");
         } else {
            if (cs.verbose)
               info.print("[%s : differs, rc %ld]\n", pszDst, ndif);
         }
         // sprintf(szReason, "%ld", ndif);
      }
   }

   if (bJustCopyTime)
   {
      // this flag says that both files exist with same content.
      if (cs.sim) {
         cs.filesCloned++;
      } else {
         // copy timestamp and attributes, but not the content.
         if (ofsSrc.writeTo(pszDst, __LINE__))
            return 1; // error, skip but continue
         cs.filesCloned++;
      }

      setTextColor(nGlblTimeColor);
      info.setStatus("", pszTell, "copy time", eNoCycle);
      info.printLine(nGlblCopyStyle);
      setTextColor(-1);

      // remember src and dst for verify pass
      // glblVerifier.remember(pszSrc, pszDst);
   }
   else
   {
      // prepare copy of file
      if (filedb.canRead()) {
         // try to check source file if it's still intact
         long nvrc = filedb.verifyFile(pszSrc, pszShSrc, bSrcUnreadable);
         if (nvrc >= 9)
            return 0+perr("check failed: %s - content changed, skipping copy\n", pszSrc);
         else
         if (nvrc == 8)
            return 0+perr("%s - not found in metadb, skipping copy\n", pszSrc);
         else
         if (nvrc == 5) {
            pwarn("master file modified, using shadow: %s\n", pszShSrc);
            pszSrc = pszShSrc;
            cs.shadowFallbacks++;
            nflags |= 3; // with checksum, but shadow
         }
         else
         if (nvrc > 5) {
            // unexpected, issue general message
            return 0+perr("check failed: %s - skipping copy (%ld)\n", pszSrc, nvrc);
         } else {
            // rc < 5 is just informal, e.g. time difference
            nflags |= 1; // checksum verified
         }
      }

      // copy the actual file
      bool bDone = 0;
      if (!cs.sim && bGlblUseCopyCache) {
         long lRes = glblCopyCache.process(pszSrc, pszDst, pszShDst, nflags);
         if (lRes == 0)
            bDone = 1;
         if (lRes >= 9)
            return lRes; // fatal error
      }
    
      if (!bDone) 
      {
         #ifdef _WIN32
         if (!nGlblCopyShadows) {
            if (copyFileWin(pszSrc, pszDst, pszShDst, pGlblWorkBuf, nGlblWorkBufSize, nflags))
               return 9;
         }
         else
         #endif
         if (copyFile(pszSrc, pszDst, pszShDst, pGlblWorkBuf, nGlblWorkBufSize, nflags))
            return 9;
      }

      // count direct file size
      nGlblBytes += nFileSize;

      // count shadow size, if any
      if (   nGlblCopyShadows
          && (!nGlblShadowSizeLimit || (nFileSize < nGlblShadowSizeLimit))
         )
      {
         nGlblBytes += nFileSize;
         cs.shadowsWritten++;
      }
   }
 
   return 0;
}

// experimental
// USES:
//    szAttrBuf, szRefNameBuf, szLineBuf1/2 (indirectly)
long execFileCleanup(char *pszSrc)
{
   cs.filesScanned++;

   // expect Dst to be a directory, e.g.
   //    x:    x:/   x:/tmp   x:/tmp/
   char *pszDstRaw = pszGlblCopyDst;

   // expect Src to contain a RELATIVE path, e.g.
   //    data\tmp1.txt  data\sub\tmp2.txt
   // strip the original base path, if any
   char *pszRelSrc = relName(pszGlblCopySrc, pszSrc);
 
   // build full target name: d:/tmp/subdir/thefile.txt
   joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszDstRaw, pszRelSrc);
 
   // REORDER: currently, pszSrc is the TARGET file
   char *pszDst = pszSrc;
   pszSrc = szRefNameBuf;
   // NOW, pszSrc is the copy src, pszDst is the cleanup candidate.

   bool b1 = (bool)fileExists(pszSrc);
   bool b2 = (bool)fileExists(pszDst);

   if (!b1 && b2)
   {
      // old trash file, or backsync candidate?
      num nFileAge = getFileAge(pszDst);
      long nAgeDays = nFileAge / (24 * 3600);

      if (!cs.delStaleFiles && (nAgeDays < nGlblActiveFileAgeLimit))
      {
         long nRemain = nGlblActiveFileAgeLimit - nAgeDays;
         if (nRemain < 6)
            setTextColor(nGlblErrColor);
         else
            setTextColor(nGlblWarnColor);
         if (cs.verbose)
            info.print("stale: %s / %s - %ld days until deletion\n",pszDst,pszSrc,nRemain);
         else
            info.print("stale: %s - %ld days until deletion\n",pszDst,nRemain);
         setTextColor(-1);
         cs.filesStale++;
      }
      else
      {
         setTextColor(nGlblWarnColor);
         if (cs.verbose)
            info.print("DEL: %s / %s",pszDst,pszSrc);
         else
            info.print("DEL: %s",pszDst);
         setTextColor(-1);
   
         // NO LINEFEED FROM HERE
         if (!cs.sim && cs.yes) 
         {
            // delete primary stale file
            if (!canWriteFile(pszDst, 0))
               setWriteEnabled(pszDst);
            if (remove(pszDst)) {
               printf("\n");
               perr("failed to delete: %s", pszDst);
            } else {
               cs.filesDeleted++;
               if (filedb.canUpdate()) {
                  // remove file from filedb
                  filedb.removeFile(pszDst, 1);
               }
            }
            // delete shadow, if any
            if (nGlblCopyShadows && cs.skipOwnMetaDir && (strlen(filedb.metaDir()) > 0))
            {
               char *pszMeta = filedb.metaDir();
               if (!strstr(pszMeta, "zz-shadow-")) {
                  printf("\n"); perr("wrong metadb name: %s", pszMeta);
               } else {
                  joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszMeta, pszRelSrc);
                  char *pszShadow = szRefNameBuf;
                  if (fileExists(pszShadow)) {
                     if (!canWriteFile(pszShadow, 0))
                        setWriteEnabled(pszShadow);
                     if (remove(pszShadow)) {
                        printf("\n");
                        perr("failed to delete: %s", pszShadow);
                     } else {
                        printx("<time> +shadow<def>");
                     }
                  }
               }
            }
         } else {
            cs.filesDeleted++;
         }
         // NO LINEFEED UNTIL HERE

         printf("\n");
      }
   }
   else 
   if (b1 && b2)
   {
      // list touched files
      FileStat ofsSrc;
      FileStat ofsDst;
      if (ofsSrc.readFrom(pszDst))  // SWAPPED
         return 9;
      if (!ofsDst.readFrom(pszSrc)) {  // SWAPPED
         long ndif = ofsSrc.differs(ofsDst, 1); // same if older src
         if (!ndif) {
            if (cs.verbose)
               info.print("no diff, skip: %s\n", pszSrc);
            return 0;   // skip
         }
         if (cs.verbose)
            info.print("[%s : differs, rc %ld]\n", pszDst, ndif);
         // the target file was changed after copy
         cs.filesNewerInDst++;
         if (bGlblShowSyncDiff)
            info.print("DIF: %s   (%s)\n",pszDst,ofsSrc.diffReason(ndif));
      }
   }
 
   return 0;
}

// experimental
long execDirCleanup(char *pszSrc, FileList &oDirFiles)
{
   // copy metadata of directory
   char *pszDstRaw = pszGlblCopyDst;

   // expect Src to contain a RELATIVE path, e.g.
   //    data\tmp1.txt  data\sub\tmp2.txt
   // strip the original base path, if any
   char *pszRelSrc = relName(pszGlblCopySrc, pszSrc);

   cs.dirsScanned++;
   sprintf(szLineBuf, "%lu files %lu dirs", cs.filesScanned, cs.dirsScanned);
   if (strlen(szLineBuf) > 20)
      info.setAddInfoWidth(strlen(szLineBuf));
   info.setStatus("scan ", pszRelSrc, szLineBuf);

   // build full target name: d:/tmp/subdir
   joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszDstRaw, pszRelSrc);

   // strip trailing / if any
   long nRefLen = strlen(szRefNameBuf);
   if ((nRefLen > 0) && (szRefNameBuf[nRefLen-1] == glblPathChar))
      szRefNameBuf[nRefLen-1] = '\0';

   // REORDER: currently, pszSrc is the TARGET dir
   char *pszDst = pszSrc;
   pszSrc = szRefNameBuf;
   // NOW, pszSrc is the copy src, pszDst is the cleanup candidate.

   if (!isDir(pszSrc) && isDir(pszDst)) 
   {
      bool isEmptyDir(char *pszIn);
      if (isEmptyDir(pszDst))
      {
         setTextColor(nGlblWarnColor);
         info.print("DEL: %s\n", pszDst);
         setTextColor(-1);
         if (!cs.sim && cs.yes) {
            #ifdef _WIN32
            long nrc = _rmdir(pszDst);
            #else
            long nrc = rmdir(pszDst);
            #endif
            if (nrc)
               perr("failed to delete: %s\n", pszDst);
            else
               cs.dirsDeleted++;
         } else {
            cs.dirsDeleted++;
         }
      }
   }

   return 0;
}

#endif // USE_SFK_BASE

long execFormConv(char *pszFile, char *pszOutFile)
{
   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut) pszOutFile = pszFile;

   char *pInFile = loadFile(pszFile);
   if (!pInFile) return 9;

   cs.files++;

   // write output file:
   //   if different output is specified, also create directory structure.
   if (bHaveOut) {
      if (createOutDirTree(pszOutFile))
         return 9;
      if (!cs.quiet) info.setStatus(cs.curcmd, pszOutFile);
   } else {
      if (!cs.quiet) info.setStatus(cs.curcmd, pszFile);
   }

   FILE *fOut = fopen(pszOutFile, "wb");
   if (!fOut) {
      delete [] pInFile; 
      return 9+perr("cannot %swrite %s\n", bHaveOut?"":"over", pszOutFile); 
   }

   uchar abCRLF[] = { 0xD, 0xA };

   char *pCur   = pInFile;
   int   bBail  = 0;
   ulong nLines = 0;
   bool  berr   = 0;
   while (!bBail && *pCur)
   {
      char *pNext = strchr(pCur, '\n');

      if (!pNext) {
         // retry just with CR, for some malformatted files
         // that contain only CR as line ending.
         pNext = strchr(pCur, '\r');
      }

      if (pNext)
         *pNext++ = 0; // remove LF on current line
      else
          bBail   = 1; // last line

      // truncate CR on current line, if any
      char *psz   = strchr(pCur, '\r');
      if (psz) *psz = 0;

      // now we have a clean line. write in target format.
      long nlen = strlen(pCur);
      if (myfwrite((uchar*)pCur, nlen, fOut) != nlen)
         {  berr=1; break; }

      if (nGlblConvTarget & eConvFormat_LF) {
         if (myfwrite(&abCRLF[1], 1, fOut) != 1)
            {  berr=1; break; }
      }
      else
      if (nGlblConvTarget & eConvFormat_CRLF) {
         if (myfwrite(&abCRLF[0], 2, fOut) != 2)
            {  berr=1; break; }
      }

      nLines++;

      pCur = pNext;
   }

   fclose(fOut);

   delete [] pInFile;

   if (!cs.quiet) info.printLine(1<<2);

   if (berr)
      return 9+esys("fwrite", "failed to write %s   \n", pszOutFile);

   return 0;
}

long checkArgCnt(long argc, long lMinCnt) {
   if (argc < lMinCnt)
      return 9+perr("missing arguments. type \"sfk\" without parms for help.\n");
   return 0;
}

bool isWriteable(char *pszTmpFile) {
   FILE *fout = fopen(pszTmpFile, "w");
   if (!fout) return 0;
   fclose(fout);
   return 1;
}

// uses szLineBuf2, and szLineBuf indirectly, for result.
// RC: number of hits
long listPathAny(char *pszCmd, bool bSilent)
{
   long nhits = 0;

   #ifdef _WIN32

   // check PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH
   char *pszExt = getenv("PATHEXT");
   if (!pszExt) {
      char *psz = findPathLocation(pszCmd, 0);
      if (psz) { nhits++; if (!bSilent) printf("%s\n", psz); }
   } else {
      pszExt = strdup(pszExt);
      char *psz1 = pszExt;
      bool beod = 0;
      while (*psz1 && !beod) {
         // recombine base string with any extension like .exe, .cmd
         char *psz2 = psz1;
         while (*psz2 && *psz2 != ';')
            { *psz2 = tolower(*psz2); psz2++; }
         if (*psz2) *psz2++ = '\0';
         else beod = 1;
         // check is such a file is in path. if so, list it.
         sprintf(szLineBuf2, "%s%s", pszCmd, psz1);
         char *psz = findPathLocation(szLineBuf2, 0);
         if (psz) { nhits++; if (!bSilent) printf("%s\n", psz); }
         psz1 = psz2;
      }
      delete [] pszExt;
   }

   #else

   char *psz = findPathLocation(pszCmd, 0);
   if (psz) { nhits++; if (!bSilent) printf("%s\n", psz); }

   #endif

   return nhits;
}

// uses szLineBuf, also for result!
char *findPathLocation(char *pszCmd, bool bExcludeWorkDir)
{
   #ifdef _WIN32
   if (!bExcludeWorkDir) {
      // win only: check current dir first (implicite path inclusion)
      _getcwd(szLineBuf,MAX_LINE_LEN-10);
      strcat(szLineBuf,glblPathStr);
      strcat(szLineBuf,pszCmd);
      if (fileExists(szLineBuf)) {
         if (cs.debug)
            printf("hit: %s [cwd]\n", szLineBuf);
         return szLineBuf;
      }
   }
   #endif

   char *pszPath = getenv("PATH");
   if (!pszPath) { perr("no PATH variable found.\n"); return 0; }
   char *psz1 = pszPath;
   while (*psz1) 
   {
      char *psz2 = psz1;
      #ifdef _WIN32
      while (*psz2 && (*psz2 != ';'))
         psz2++;
      #else
      while (*psz2 && (*psz2 != ':'))
         psz2++;
      #endif
      // isolate single directory from path.
      int nLen = psz2-psz1;
      strncpy(szLineBuf, psz1, nLen);
      szLineBuf[nLen] = '\0';
      // now holding single dir in szLineBuf.
      if (!strcmp(szLineBuf, ".") && bExcludeWorkDir) {
         if (cs.debug)
            printf("skip: %s\n", szLineBuf);
      } else {
         if (cs.debug)
            printf("probe: %s\n", szLineBuf);
         stripTrailingBackSlashes(szLineBuf);
         strcat(szLineBuf, glblPathStr);
         strcat(szLineBuf, pszCmd);
         if (fileExists(szLineBuf)) {
            if (cs.debug)
               printf("hit: %s\n", szLineBuf);
            return szLineBuf;
         }
      }
      // step to next subpath
      if (*psz2)
         psz2++;
      psz1 = psz2;
   }
   return 0;
}

// uses szLineBuf
long checkXCopy(char *pszTmpFile, char *pszMask)
{
   char *pszCmd = findPathLocation("xcopy.exe");
   if (!pszCmd) return 9;
   pszGlblXCopyCmd = strdup(pszCmd);

   sprintf(szLineBuf, "%s /? >%s 2>&1", pszGlblXCopyCmd, pszTmpFile);
   if (cs.debug) printf("%s\n", szLineBuf);
   long lRC = system(szLineBuf);
   if (lRC) return lRC;

   // read status output of tool, search for mask
   lRC = 1;
   FILE *fin = fopen(pszTmpFile, "r");
   if (fin) {
      while (fgets(szLineBuf, sizeof(szLineBuf)-10, fin)) {
         removeCRLF(szLineBuf);
         if (strstr(szLineBuf, pszMask))
            lRC = 0;
      }
      fclose(fin);
   }

   return lRC;
}

#ifdef _WIN32
 #define STR_FROM_NUL "<nul"
#else
 #define STR_FROM_NUL ""
#endif

// uses szLineBuf
long checkZipVersion(char *pszTmpFile)
{
   char *pszCmd = findPathLocation("zip" EXE_EXT);
   if (!pszCmd) return 9+perr("no zip" EXE_EXT " found within PATH.\n");
   pszGlblZipCmd = strdup(pszCmd);

   // the following command will cause a proper zip 2.31
   // to really tell it's version. zip 2.0 however will
   // try to compress stdin, therefore the <nul.
   sprintf(szLineBuf, "%s -v " STR_FROM_NUL " >%s 2>&1", pszGlblZipCmd, pszTmpFile);
   long lRC = system(szLineBuf);
   if (lRC) {
      perr("ZIP RC: %ld - %s probably too old\n", lRC, pszGlblZipCmd);
      return lRC;
   }
 
   // read status output of tool, search for mask
   FILE *fin = fopen(pszTmpFile, "r");
   if (fin) {
      while (fgets(szLineBuf, sizeof(szLineBuf)-10, fin)) {
         removeCRLF(szLineBuf);
         if (!strncmp(szLineBuf, "This is Zip ", strlen("This is Zip "))) {
            char *pszVerHi = szLineBuf+strlen("This is Zip ");
            char *pszVerLo = pszVerHi;
            while (*pszVerLo && (*pszVerLo != '.'))
               pszVerLo++;
            if (*pszVerLo)
               pszVerLo++;
            nGlblZipVersionHi = atol(pszVerHi);
            nGlblZipVersionLo = atol(pszVerLo);
            break;
         }
      }
      fclose(fin);
   }

   if (nGlblZipVersionHi > 2)
      return 0; // OK: Zip 3.x or higher

   if (nGlblZipVersionHi < 2)
      return 9+perr("%s version too old (%ld.%ld)\n", pszGlblZipCmd, nGlblZipVersionHi, nGlblZipVersionLo);

   if (nGlblZipVersionLo >= 31)
      return 0; // OK: Zip 2.31

   // else below 2.31: too old
   return 9+perr("%s version too old (%ld.%ld)\n", pszGlblZipCmd, nGlblZipVersionHi, nGlblZipVersionLo);
}

// uses szLineBuf
long checkUnzipVersion(char *pszTmpFile)
{
   char *pszCmd = findPathLocation("unzip" EXE_EXT);
   if (!pszCmd) return 9+perr("no unzip" EXE_EXT " found within PATH.\n");
   pszGlblUnzipCmd = strdup(pszCmd);
 
   // the following command will cause a proper unzip 5.52 to tell it's version.
   sprintf(szLineBuf, "%s -v " STR_FROM_NUL " >%s 2>&1", pszGlblUnzipCmd, pszTmpFile);
   long lRC = system(szLineBuf);
   if (lRC) {
      perr("UNZIP RC: %ld - %s probably too old\n", lRC, pszGlblUnzipCmd);
      return lRC;
   }
 
   // read status output of tool, search for mask
   FILE *fin = fopen(pszTmpFile, "r");
   if (fin) {
      while (fgets(szLineBuf, sizeof(szLineBuf)-10, fin)) {
         removeCRLF(szLineBuf);
         if (!strncmp(szLineBuf, "UnZip ", strlen("UnZip "))) {
            char *pszVerHi = szLineBuf+strlen("UnZip ");
            char *pszVerLo = pszVerHi;
            while (*pszVerLo && (*pszVerLo != '.'))
               pszVerLo++;
            if (*pszVerLo)
               pszVerLo++;
            nGlblUnzipVersionHi = atol(pszVerHi);
            nGlblUnzipVersionLo = atol(pszVerLo);
            break;
         }
      }
      fclose(fin);
   }

   if (nGlblUnzipVersionHi > 5)
      return 0; // OK: Unzip 6.x or higher

   if (nGlblUnzipVersionHi < 5)
      return 9+perr("%s version too old (%ld.%ld)\n", pszGlblUnzipCmd, nGlblUnzipVersionHi, nGlblUnzipVersionLo);
      // NOK, stone-old unzip 4.x

   if (nGlblUnzipVersionLo >= 52)
      return 0; // OK: Unzip 5.52

   // else below 5.52: too old
   return 9+perr("%s version too old (%ld.%ld)\n", pszGlblUnzipCmd, nGlblUnzipVersionHi, nGlblUnzipVersionLo);
}

char *localPath(char *pAbsFile)
{
   static char szPath[500];
   strcopy(szPath, pAbsFile);
   for (char *p=szPath; *p; p++) {
      if (*p == glblWrongPChar)
          *p = glblPathChar;
   }
   return szPath;
}

#ifdef WITH_TCP

void setBlocking(SOCKET &hSock, bool bYesNo)
{
   // make accept non-blocking:
   unsigned long ulParm = bYesNo ? 0 : 1;
   ioctlsocket(hSock, FIONBIO, &ulParm);
}

bool hasData(SOCKET &hSock, long lTimeoutMS)
{
   #ifdef _WIN32
   struct timeval tv;
   tv.tv_sec  = 0;
   tv.tv_usec = lTimeoutMS * 1000;

   fd_set fds1, fds2, fds3;
   fds1.fd_count    = 1;
   fds1.fd_array[0] = hSock;
   fds2.fd_count    = 0;
   fds3.fd_count    = 0;

   return select(0, &fds1, &fds2, &fds3, &tv) == 1;
   #else
   struct timeval tv;
   tv.tv_sec  = 0;
   tv.tv_usec = lTimeoutMS * 1000;

   fd_set fds;
   FD_ZERO(&fds);
   FD_SET(hSock, &fds);

   int nrc = select(hSock+1, &fds, NULL, NULL, &tv);
   return nrc > 0;
   #endif
}

// by default, recv() returns as much bytes as there are.
// this function forces receival of full length block.
long receiveBlock(SOCKET hSock, uchar *pBlock, ulong nLen, char *pszInfo)
{
   long nRemain = nLen;
   long nCursor = 0;
   while (nRemain > 0) {
      long nRead = recv(hSock, (char*)pBlock+nCursor, nRemain, 0);
      if (nRead <= 0) {
         if (pszInfo) // else silent mode
            perr("failed to receive %s, %s\n", pszInfo, netErrStr());
         return -1;
      }
      nRemain -= nRead;
      nCursor += nRead;
   }
   return 0;
}

// uses szLineBuf
long sendLine(SOCKET hSock, char *psz, bool bQuiet)
{
   strncpy(szLineBuf, psz, MAX_LINE_LEN-10);
   szLineBuf[MAX_LINE_LEN-10] = '\0';
   strcat(szLineBuf, "\r\n");
   // if (!bQuiet && !cs.quiet) printf("< %s", szLineBuf);
   if (cs.verbose) printf("< %s", szLineBuf);
   long nSent = send(hSock, szLineBuf, strlen(szLineBuf), 0);
   if (nSent != strlen(szLineBuf)) return 9;
   return 0;
}

long readLineRaw(SOCKET hSock, char *pszLineBuf)
{
   long nCursor = 0;
   long nRemain = MAX_LINE_LEN;
   pszLineBuf[0] = '\0';
   while (nRemain > 10) {
      long nRead = recv(hSock, pszLineBuf+nCursor, 1, 0);
      if (nRead == 0) return 1; // eod
      if (nRead < 0)  return 9; // connection close
      nCursor += nRead;
      nRemain -= nRead;
      pszLineBuf[nCursor] = '\0';
      if (nCursor > 0 && pszLineBuf[nCursor-1] == '\n')
         break;
   }
   return 0;
}

long readLineSub(SOCKET hSock, char *pszLineBuf, long nMode)
{
   bool bAddToRemList = (nMode & 1) ? 1 : 0;
   bool bQuiet        = (nMode & 2) ? 1 : 0;
   bool bDirListMode  = (nMode & 4) ? 1 : 0;

  while (1)
  {
   long nCursor = 0;
   long nRemain = MAX_LINE_LEN;
   pszLineBuf[0] = '\0';
   // switching from readLine mode to readBinary is tricky,
   // therefore read char by char to exactly get the point
   // of CRLF, from which on we may switch to binary.
   while (nRemain > 10) {
      // recv blocks until at least 1 byte is available.
      long nRead = recv(hSock, pszLineBuf+nCursor, 1, 0);
      if (nRead <= 0) {
         // perr("readLine failed %ld %ld", nCursor, nRead);
         return 9;
      }
      nCursor += nRead;
      nRemain -= nRead;
      pszLineBuf[nCursor] = '\0';
      if (nCursor > 0 && pszLineBuf[nCursor-1] == '\n')
         break;
   }
   // reading a block of continued lines?
   if (pszLineBuf[3] == '-' || pszLineBuf[0] == '-') 
   {
      removeCRLF(pszLineBuf);
      // on replies to SLST: store list replies, don't print
      if (bAddToRemList) {
         // if (cs.debug)
         //   printf("> [store] %s\n", pszLineBuf);
         glblFTPRemList.addEntry(pszLineBuf);
      } else {
         if (bDirListMode || cs.verbose)
            printf("%s\n", pszLineBuf);
      }
      // and continue reading lines
   }
   else 
   {
      // any other record: print printable parts
      bool bskiprec = !strncmp(szLineBuf, "SKIP ", 5);
      // dump only if verbose, or on some error codes.
      long ncode = atol(szLineBuf);
      // dump all error codes from 500, except:
      bool blistcode = (ncode >= 500);
      switch (ncode) {
      // case 331: blistcode = 1; break; // pass required
         case 550: blistcode = 0; break; // no such file
      }
      if (!bskiprec && (cs.verbose || blistcode))
      {
         long nLen = strlen(szLineBuf);
         for (long i=0; i<nLen; i++)
            if (isprint(pszLineBuf[i]))
               printf("%c", pszLineBuf[i]);
         printf("\n");
         fflush(stdout);
      }
      // and stop reading, return record
      break;
   }
  }
   return 0;
}

// see also forward decl. for default parms
long readLine(SOCKET hSock, char *pszLineBuf, long nMode)
{
   bool bAddToRemList = (nMode & 1) ? 1 : 0;
   bool bQuiet = (nMode & 2) ? 1 : 0;

   long lRC = readLineSub(hSock, pszLineBuf, nMode);

   // sft101: optional skip records to enforce socket flushing
   if (!strncmp(szLineBuf, "SKIP ", 5)) 
   {
      // read intermediate skip record
      ulong nLen = (ulong)atol(szLineBuf+5);
      if (nLen > sizeof(abBuf)-10) nLen = sizeof(abBuf)-10;
      if (nLen) receiveBlock(hSock, abBuf, nLen, "SKIP");

      // now read the actual record
      lRC = readLineSub(hSock, pszLineBuf, nMode);
   }

   return lRC;
}

bool isPathTraversal(char *pszFile, bool bDeep)
{
   if (!strlen(pszFile)) return 1;
   if (!strncmp(pszFile, ".", 1)) return 1;
   if (strstr(pszFile, "..")) return 1;
   if (!bDeep) {
      if (strstr(pszFile, "/")) return 1;
      if (strstr(pszFile, "\\")) return 1;
   }
   return 0;
}

// uses abBuf
long readLong(SOCKET hSock, ulong &rOut, char *pszInfo)
{
   if (receiveBlock(hSock, abBuf, 4, pszInfo)) return 9;
   ulong nLen =   (((ulong)abBuf[3])<<24)
                | (((ulong)abBuf[2])<<16)
                | (((ulong)abBuf[1])<< 8)
                | (((ulong)abBuf[0])<< 0);
   rOut = nLen;
   return 0;
}

// uses abBuf
long sendLong(SOCKET hSock, ulong nOut, char *pszInfo)
{
   abBuf[3] = ((uchar)(nOut >> 24));
   abBuf[2] = ((uchar)(nOut >> 16));
   abBuf[1] = ((uchar)(nOut >>  8));
   abBuf[0] = ((uchar)(nOut >>  0));
   long nSent = send(hSock, (char*)abBuf, 4, 0);
   if (nSent != 4) return 9+perr("failed to send %s, %s\n", pszInfo, netErrStr());
   return 0;
}

// uses abBuf
long readNum(SOCKET hSock, num &rOut, char *pszInfo)
{
   if (receiveBlock(hSock, abBuf, 8, pszInfo)) return 9;
   num nOut = 0;
   for (long i=0; i<8; i++) {
      nOut <<= 8;
      nOut |= (ulong)abBuf[i];
   }
   rOut = nOut;
   return 0;
}

long readNum(uchar *pbuf, long &roff, num &rOut, char *pszInfo)
{
   num nOut = 0;
   for (long i=0; i<8; i++) {
      nOut <<= 8;
      nOut |= (ulong)pbuf[roff+i];
   }
   roff += 8;
   rOut = nOut;
   return 0;
}

// uses abBuf
long sendNum(SOCKET hSock, num nOut, char *pszInfo)
{
   // this may fail with num's >= 2 up 63.
   for (long i=7; i>=0; i--) {
      abBuf[i] = (uchar)(nOut & 0xFF);
      nOut >>= 8;
   }
   long nSent = send(hSock, (char*)abBuf, 8, 0);
   if (nSent != 8) return 9+perr("failed to send %s, %s\n", pszInfo, netErrStr());
   return 0;
}

long sendFileRaw(SOCKET hSock, char *pszFile, bool bQuiet=0, uchar *pmd5=0)
{
   num nLen = getFileSize(pszFile);
   if (nLen < 0) return 9+perr("cannot get size of %s\n", pszFile);

   SFKMD5 md5;

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+perr("cannot read %s\n", pszFile);

   bool bdoneprog = 0;

   num nLen2 = 0;
   num nTellStep = 10;
   num nTellNext = 0;
   while (nLen2 < nLen) 
   {
      int nRead = fread(abBuf, 1, sizeof(abBuf)-10, fin);
      if (nRead <= 0) return 9+perr("cannot fully read %s (1)\n", pszFile);

      if (send(hSock, (char*)abBuf, nRead, 0) != nRead) {
         perr("connection closed while sending %s %s\n", pszFile, netErrStr());
         perr("the file cannot be written at receiver.\n");
         return 9;
      }

      if (pmd5) md5.update(abBuf, nRead);

      nLen2 += nRead;

      if (nLen2 >= nTellNext) {
         nTellNext += nTellStep;
         nTellStep += nTellStep;
         if (nLen >= 0 && !cs.noprog && !cs.quiet) {
            printf("< %02d%% sending %s, %s bytes \r", (int)(nLen2 * 100 / (nLen+1)), pszFile, numtoa(nLen));
            fflush(stdout);
            bdoneprog = 1;
         }
      }
   }
   fclose(fin);

   if (pmd5) memcpy(pmd5, md5.digest(), 16);

   if (bdoneprog)
      printf("< %s sent, %s bytes.       \n", pszFile, numtoa(nLen2));

   return 0;
}

// send SKIP record to force socket flush on linux systems.
long sendSkipBlock(SOCKET hSock)
{
   // so far, no extra dummy data is appended.
   long nSkipSize = 0;
   if (nSkipSize) {
      if (sizeof(abBuf) < (nSkipSize+10000))
         return 9+perr("internal #201\n");
      memset(abBuf, 0xEE, nSkipSize);
      abBuf[nSkipSize-1] = '\n';
   }
   // the LF at the end of record should flush the socket.
   sprintf((char*)abBuf, "SKIP %ld\r\n", nSkipSize);
   int nLen = strlen((char*)abBuf)+nSkipSize;
   send(hSock, (char*)abBuf, nLen, 0);
   return 0;
}

long preScanFile(char *pszFile, uchar *pmd5out, ulong &nattrout)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;

   bool bbinary = 0;

   SFKMD5 md5;
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      if (!bbinary && memchr(abBuf, '\0', nRead))
         bbinary = 1;
      nGlblBytes += nRead;
   }

   fclose(fin);

   uchar *pmd5 = md5.digest();
   for (ulong k=0; k<16; k++)
      pmd5out[k] = pmd5[k];

   ulong nattrib = bbinary ? 1 : 0;

   nattrout = nattrib;

   return 0;
}

bool bdebug = 0;

long sendRaw(char *pszFile, FILE *fin, SOCKET hSock, num nLen, SFKMD5 &md5)
{
   num nLen2 = 0;
   while (nLen2 < nLen)
   {
      long nrem = nLen - nLen2;

      long nreqlen = sizeof(abBuf)-10;
      if (nreqlen > nrem) nreqlen = nrem;

      int nRead = fread(abBuf, 1, nreqlen, fin);
      if (nRead <= 0) return 9+perr("cannot fully read %s (2)\n", pszFile);

      if (send(hSock, (char*)abBuf, nRead, 0) != nRead) {
         perr("connection closed while sending %s %s.\n", pszFile, netErrStr());
         perr("the file cannot be written at receiver.\n");
         return 9;
      }

      md5.update(abBuf, nRead);

      nLen2 += nRead;
   }
   return 0;
}

// INCLUDES ackReceive past file send.
long putFileBySFT(SOCKET hSock, Coi *pcoi, long nSFTVer, bool bQuiet=0, bool bIgnoreAck=0, bool bBlockMode=0)
{
   char *pszFile = pcoi->name();

   num nLen   = pcoi->getSize();
   if (nLen < 0) return 9+perr("cannot read %s\n", pszFile);
   num nTime  = pcoi->getTime();
   num nFlags = 0;

   bool bdoneprog = 0;

   // sft <= 101: 8_size 16_md5_pre
   ulong nMetaSize = 8+16;

   // sft >= 102: 8_size 8_time 8_flags NO md5_pre
   if (nSFTVer >= 102) nMetaSize = 24;

   uchar abmd5[20]; mclear(abmd5);

   // build md5 before sending the file?
   if (nSFTVer < 102)
      if (getFileMD5(pszFile, abmd5))
         return 9;

   // drafted flags:
   //    bit 0 : is readable
   //    bit 1 : is writeable
   //    bit 2 : is executable   
   //    bit 3 : is directory
   //    bit 4 : symbolic link
   //    bit 5 : hidden file
   //    bit 6 : system file
   //    bit 7 : is text         \  if both zero,
   //    bit 8 : is binary       /  it is unknown
   //    bit 9 : wide char text     16-bit chars

   nFlags = (1 << 0);  // readable

   if (pcoi->isWriteable())   nFlags |= (1 << 1);
   if (pcoi->rawIsDir   ())   nFlags |= (1 << 3);
   if (pcoi->isLink     ())   nFlags |= (1 << 4);
   if (pcoi->isHidden   ())   nFlags |= (1 << 5);

   // TODO: binary, wide char flags

   if (sendLong(hSock, nMetaSize, "metalen")) return 9;

   // meta 1: filesize, timestamp, flags
   if (sendNum(hSock, nLen, "size")) return 9;

   if (nSFTVer >= 102) {
      if (sendNum(hSock, nTime , "time" )) return 9;
      if (sendNum(hSock, nFlags, "flags")) return 9;
   } else {
      if (!cs.quiet)
         printf("[using sft101 for compatibility.]\n");
   }

   if (nSFTVer < 102) {
      // meta 2: 16 bytes md5 BEFORE content
      long nSent = send(hSock, (char*)abmd5, 16, 0);
      if (nSent != 16) return 9+perr("failed to send md5, %s\n", netErrStr());
   }

   if (nSFTVer < 102) {
      // if receiver can't write file, this will fail.
      if (sendFileRaw(hSock, pszFile, bQuiet, abmd5))
         return 9;
   }
   else
   if (!bBlockMode) {
      // sft 102 bulk transfer, send all in one
      if (sendFileRaw(hSock, pszFile, bQuiet, abmd5))
         return 9;
      // 16 bytes md5 AFTER content
      long nSent = send(hSock, (char*)abmd5, 16, 0);
      if (nSent != 16)
         return 9+perr("failed to send md5, %s\n", netErrStr()); 
   }
   else
   {
      // sft 102 block transfer, triggered by peer

      FILE *fin = fopen(pszFile, "rb");
      if (!fin) return 9+perr("cannot read %s\n", pszFile);

      SFKMD5 md5;

      num nLen2 = 0;
      num nTellStep = 10;
      num nTellNext = 0;

      char szCmd[200];

      while (1)
      {
         if (bdebug) printf("> waiting for i/o commands.\n");

         // wait for SREAD, SSUM or SCLOSE.
         mclear(szCmd);
         long nRead = recv(hSock, szCmd, sizeof(szCmd)-10, 0);
         if (nRead <= 0) { 
            fclose(fin);
            return 9+perr("unexpected EOD or close, %s\n", netErrStr()); 
         }

         if (bdebug) printf("> got cmd: %s", szCmd);

         if (strBegins(szCmd, "SREAD ")) 
         {
            num nsendreq = atonum(&szCmd[6]);

            if (sendRaw(pszFile, fin, hSock, nsendreq, md5)) {
               fclose(fin);
               return 9+perr("failed to send requested %ld bytes\n",(long)nsendreq);
            }

            if (bdebug) printf("< sent %ld\n", (long)nsendreq);

            nLen2 += nsendreq;

            if (nLen2 >= nTellNext) {
               nTellNext += nTellStep;
               nTellStep += nTellStep;
               if (nLen >= 0 && !cs.noprog && !cs.quiet) {
                  printf("< %02d%% sending %s, %s bytes \r", (int)(nLen2 * 100 / (nLen+1)), pszFile, numtoa(nLen));
                  fflush(stdout);
                  bdoneprog = 1;
               }
            }

            continue;
         }

         if (strBegins(szCmd, "SSUM"))
         {
            // 16 bytes md5 AFTER content
            if (bdebug) printf("< sending sum\n");
            long nSent = send(hSock, (char*)md5.digest(), 16, 0);
            if (nSent != 16) { 
               fclose(fin); 
               return 9+perr("failed to send md5, %s\n", netErrStr());
            }
            continue;
         }

         if (strBegins(szCmd, "SCLOSE"))
            break;

      }  // endwhile content transfer

      fclose(fin);

      if (bdoneprog)
         printf("< %s sent, %s bytes.       \n", pszFile, numtoa(nLen2));
   }

   bool bSentSkip = 0;
   if (nSFTVer >= 101) {
      // flush the socket through an extra record.
      if (bdebug) printf("< send skip\n");
      sendSkipBlock(hSock);
      bSentSkip = 1;
   }

   // wait until receival of ack, to avoid transmission break by premature close.
   #ifndef _WIN32
   // known issue: bytes sent from linux may sometimes not receive other side
   //              until connection is closed, e.g. through CTRL+C.
   if (cs.quiet < 2) {
      printf("> waiting for ack. if this blocks, try CTRL+C. \r");
      fflush(stdout);
   }
   #endif

   if (bdebug) printf("> wait for ack\n");

   memset(abBuf, 0, 10);
   receiveBlock(hSock, abBuf, 4, 0); // 0 == silent mode

   if (bIgnoreAck) {
      // do not verify, receiver may have closed connection already.
      #ifndef _WIN32
      if (cs.quiet < 2) {
         printf("                                               \r");
         fflush(stdout);
      }
      #endif
   } else {
      // possible replies:
      //    OK\n\n   ok\n\n (older sft)
      //    EE\n\n
      if (   tolower((char)abBuf[0]) == 'o'
          && tolower((char)abBuf[1]) == 'k') {
      #ifndef _WIN32
      if (cs.quiet < 2) {
         printf("                                               \r");
         fflush(stdout);
      }
      #endif
      } else {
         perr("transfer or write of file failed: %s    (%s)\n", pszFile, abBuf);
      }
   }

   return 0;
}

// MODE 1: receive until END OF DATA (nMaxBytes < 0)
// MODE 2: receive until nMaxBytes   (nMaxBytes > 0)
long receiveFileRaw(SOCKET hSock, char *pszFile, num nMaxBytes, bool bQuiet=0, uchar *pmd5=0)
{
   FILE *fout = fopen(pszFile, "wb");
   if (!fout) return 9+perr("cannot write to \"%s\"\n", pszFile);

   SFKMD5 md5;
 
   num nLen2 = 0;
   num nTellStep = 10;
   num nTellNext = 0;
   num nRemain = nMaxBytes;
   long nRead = 0;

   // raw ftp uses variable length mode
   bool bvarmode = (nMaxBytes < 0);

   while (bvarmode || (nRemain > 0))
   {
      if (!bvarmode && (nLen2 >= nMaxBytes))
         break;
      long nBlockLen = sizeof(abBuf)-10;
      if (!bvarmode && (nBlockLen > nRemain))
         nBlockLen = nRemain;
      if ((nRead = recv(hSock, (char*)abBuf, nBlockLen, 0)) <= 0)
         break; // EOD
      nLen2 += nRead;
      nRemain -= nRead;

      if (myfwrite(abBuf, nRead, fout) != nRead) {
         esys("fwrite", "failed to write %s   \n", pszFile);
         // but no special rc, continue with other files.
         break;
      }

      if (pmd5) md5.update(abBuf, nRead);

      if (nLen2 >= nTellNext) {
         nTellNext += nTellStep;
         nTellStep += nTellStep;
         if (!cs.noprog && !cs.quiet) {
            if (nMaxBytes >= 0)
               printf("> %02d%% receiving %s, %s bytes \r", (int)(nLen2 * 100 / (nMaxBytes+1)), pszFile, numtoa(nMaxBytes));
            else
               printf("> receiving %s, %s bytes \r", pszFile, numtoa(nLen2));
            fflush(stdout);
         }
      }
   }
   fclose(fout);

   if (pmd5) memcpy(pmd5, md5.digest(), 16);
 
   if (cs.quiet < 2)
      printf("> %s received, %s bytes.       \n", pszFile, numtoa(nLen2));
 
   return 0;
}

// INCLUDES ack send past file transfer
long getFileBySFT(SOCKET hSock, char *pszFile, long nSFTVer, bool bQuiet=0, bool bBlockMode=0)
{
   // read variable-length header with meta info
   uchar abHead[512+10]; mclear(abHead);

   ulong nMetaSize = 0;
   if (readLong(hSock, nMetaSize, "metalen")) return 9;
   if (nMetaSize > sizeof(abHead)-10)
      return 9+perr("unsupported SFT protocol version\n");
   if (receiveBlock(hSock, abHead, nMetaSize, "head")) return 9;

   // take from header what we need
   long ioff = 0;

   // meta 1: 8bytes_size [time flags]
   num nLen = 0, nTime = 0, nFlags = 0;
   if (readNum(abHead, ioff, nLen, "size")) return 9;

   if (nGlblTCPMaxSizeMB)
      if (nLen > nGlblTCPMaxSizeMB * 1000000)
         return 9+perr("illegal length received, %s\n", numtoa(nLen));

   if (nSFTVer >= 102) {
      if (readNum(abHead, ioff, nTime , "time" )) return 9;
      if (readNum(abHead, ioff, nFlags, "flags")) return 9;
   }

   uchar abMD5Remote[20]; mclear(abMD5Remote);
   uchar abMD5Local[20];  mclear(abMD5Local);

   if (nSFTVer < 102) {
      // meta 2: 16 bytes md5 BEFORE content
      if (nSFTVer == 105) ioff += 20;
      memcpy(abMD5Remote, abHead+ioff, 16);
      ioff += 16;
   }

   if (nSFTVer < 102) {
      // if this fails, return w/o ack, connection will be dropped.
      if (receiveFileRaw(hSock, pszFile, nLen, bQuiet, abMD5Local))
         return 9;
   }
   else
   if (!bBlockMode) {
      // sft 102 bulk transfer, receive all in one
      if (receiveFileRaw(hSock, pszFile, nLen, bQuiet, abMD5Local))
         return 9;
      if (receiveBlock(hSock, abMD5Remote, 16, "md5"))
         return 9;
   }
   else
   {
      // sft 102 block transfer, we trigger the peer

      FILE *fout = fopen(pszFile, "wb");
      if (!fout) return 9+perr("cannot write to \"%s\"\n", pszFile);

      // sft receive file

      SFKMD5 md5;

      num nLen2      =    0;
      num nRemain    = nLen;
      num nMaxBytes  = nLen;
      num nTellStep  =   10;
      num nTellNext  =    0;
      long nRead     =    0;

      char szCmd[200];

      while (nRemain > 0)
      {
         // request next block from server
         long nBlockLen = sizeof(abBuf)-10;

         if (nBlockLen > nRemain)
            nBlockLen = nRemain;

         if (bdebug) printf("< sread %ld, remain=%ld\n",nBlockLen,(long)nRemain);

         sprintf(szCmd, "SREAD %ld\n", nBlockLen);
         long nsent = send(hSock, szCmd, strlen(szCmd), 0);
         if (nsent != strlen(szCmd)) {
            fclose(fout);
            return 9+perr("failed to send SREAD for \"%s\" %s\n", pszFile, netErrStr());
         }

         if (receiveBlock(hSock, abBuf, nBlockLen, "data")) {
            fclose(fout);
            return 9+perr("failed to fully receive \"%s\"\n", pszFile);
         }
         nRead = nBlockLen;

         nLen2 += nRead;
         nRemain -= nRead;

         if (myfwrite(abBuf, nRead, fout) != nRead) {
            fclose(fout);
            return 9+perr("failed to fully write, probably disk full: \"%s\"\n", pszFile);
         }

         md5.update(abBuf, nRead);

         if (nLen2 >= nTellNext) {
            nTellNext += nTellStep;
            nTellStep += nTellStep;
            if (!cs.noprog && !cs.quiet) {
               if (nMaxBytes >= 0)
                  printf("> %02d%% receiving %s, %s bytes \r", (int)(nLen2 * 100 / (nMaxBytes+1)), pszFile, numtoa(nMaxBytes));
               else
                  printf("> receiving %s, %s bytes \r", pszFile, numtoa(nLen2));
               fflush(stdout);
            }
         }
      }

      fclose(fout);

      if (cs.quiet < 2)
         printf("> %s received, %s bytes.       \n", pszFile, numtoa(nLen2));

      sprintf(szCmd, "SSUM\n");
      long nsent = send(hSock, szCmd, strlen(szCmd), 0);
      if (nsent != strlen(szCmd))
         return 9+perr("failed to receive checksum, %s\n", netErrStr());

      if (bdebug) printf("> wait for sum\n");

      if (receiveBlock(hSock, abMD5Remote, 16, "md5")) return 9;

      if (bdebug) printf("send close\n");

      sprintf(szCmd, "SCLOSE\n");
      nsent = send(hSock, szCmd, strlen(szCmd), 0);
      if (nsent != strlen(szCmd))
         return 9+perr("failed to send close, %s\n", netErrStr());

   }  // endif nSFTVer

   if (bdebug) printf("wait for skip\n");

   // expect and receive SKIP record of any length
   recv(hSock, (char*)abBuf, sizeof(abBuf)-100, 0);

   if (nSFTVer >= 102 && !cs.noclone) {
      // update file's timestamp and attributes
      FileStat ofs;
      if (ofs.readFrom(pszFile)) {
         pinf("cannot read file time: %s\n", pszFile);
      } else {
         if (nTime) {
            ofs.src.nMTime = nTime;
            ofs.src.nCTime = nTime;
            #ifdef _WIN32
            ofs.src.nHaveWFT = 0;
            #endif
         }
         ofs.writeTo(pszFile, __LINE__);
         // printf("time set: %ld %s\n",(long)nTime,pszFile);
      }
   }

   // sender will wait now until we confirm successful transfer.

   if (!cs.fast) {
      // default: re-read the local file after write,
      // to be sure it was written completely.
      SFKMD5 md5;
      if (getFileMD5(pszFile, md5)) {
         send(hSock, (char*)"EE\n\n", 4, 0);
         return 9;
      }
      memcpy(abMD5Local, md5.digest(), 16);
   }

   if (memcmp(abMD5Local, abMD5Remote, 16)) {
      send(hSock, (char*)"EE\n\n", 4, 0);
      perr("md5 mismatch - transfered file corrupted.\n");
      if (cs.verbose) {
         printf("local: %02X %02X %02X %02X\n",abMD5Local[0],abMD5Local[1],abMD5Local[2],abMD5Local[3]);
         printf("remot: %02X %02X %02X %02X\n",abMD5Remote[0],abMD5Remote[1],abMD5Remote[2],abMD5Remote[3]);
      }
      pinf("check if the file is in use by another process.\n");
      return 9;
   }

   // send short confirmation, so client can safely close socket.
   long nSent = send(hSock, (char*)"OK\n\n", 4, 0);
   if (nSent != 4) return 9+perr("failed to send reply, %ld, %s\n", nSent, netErrStr());

   return 0;
}

long ftpLogin(char *pszHost, ulong nPort, SOCKET &hSock, bool &bSFT, long &nOutSFTVer, char *pszPW)
{
   prepareTCP();

   long nSFTVer = 102; // may be downgraded below
 
   struct hostent *pTarget;
   struct sockaddr_in sock;
   hSock = socket(AF_INET, SOCK_STREAM, 0);
   if (hSock == INVALID_SOCKET) return 9+perr("cannot create socket\n");

   if ((pTarget = sfkhostbyname(pszHost)) == NULL)
      return 9+perr("cannot get host, rc=%d\n", netErrno());

   memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
   sock.sin_family = AF_INET;
   sock.sin_port = htons((unsigned short)nPort);

   if ((connect(hSock, (struct sockaddr *)&sock, sizeof(sock))) == -1) {
      perr("cannot connect to %s:%lu, %s\n", pszHost, nPort, netErrStr());
      return 9;
   }

   char szBuf1[200];

   // SFT: first handle FTP handshake
   if (readLine(hSock)) return 9; // 220
   char *psz1 = strstr(szLineBuf, ". sft ");
   if (psz1) {
      long nSFTVer = atol(psz1+6);
      if (nSFTVer >= 100) {
         bSFT = 1;
         printf("> server speaks sft %ld. mget, mput enabled.\n", nSFTVer);
         nOutSFTVer = nSFTVer;
      } else {
         printf("> unexpected sft info \"%s\"\n", psz1);
      }
   }

   if (sendLine(hSock, "USER anonymous")) return 9;
   if (readLine(hSock)) return 9; // 331

   if (bSFT) {
      // login at sfk ftpserv: password after '@'
      if (!pszPW) pszPW = "";
      snprintf(szBuf1, sizeof(szBuf1)-10, "PASS sft%ld@%s", nSFTVer, pszPW);
      if (sendLine(hSock, szBuf1)) return 9;
   } else {
      // login at any ftp server: either password or dummy info
      if (pszPW)
         snprintf(szBuf1, sizeof(szBuf1)-10, "PASS %s", pszPW);
      else
         snprintf(szBuf1, sizeof(szBuf1)-10, "PASS sft%ld@", nSFTVer);
      if (sendLine(hSock, szBuf1)) return 9;
   }
   if (readLine(hSock)) return 9; // 230 login done
   if (strBegins(szLineBuf, "500 ")) return 9;

   if (sendLine(hSock, "TYPE I")) return 9;
   if (readLine(hSock)) return 9; // 200 OK

   return 0;
}

long connectSocket(char *pszHost, ulong nPort, struct sockaddr_in &ClntAdr, SOCKET &hSock, char *pszInfo);

long setPassive(SOCKET &hSock, struct sockaddr_in &SoAdr, SOCKET &hData)
{
   if (hData != INVALID_SOCKET)
      return 0; // already done, reuse hData

   if (sendLine(hSock, "PASV")) return 9;
   if (readLine(hSock)) return 9;
   // 227 Entering Passive Mode (127,0,0,1,117,246)
   char *psz = strchr(szLineBuf, '(');
   if (!psz) return 9;
   psz++; 
   uchar n[6];
   for (int i=0; i<6; i++) {
      n[i] = (uchar)atol(psz);
      psz = strchr(psz+1, ',');
      if (psz) psz++; else break;
   }
   char szIP[50];
   sprintf(szIP, "%d.%d.%d.%d",n[0],n[1],n[2],n[3]);
   ulong nPort = (((ulong)n[4])<<8)|((ulong)n[5]);
   if (connectSocket(szIP, nPort, SoAdr, hData, "pasv data")) return 9;

   return 0;
}

bool canSkipFile(SOCKET hSock, char *pszFileName, num ndsttime, bool bput)
{
   bool bskip = 0;

   // check if target file at server has different time.
   // so far works only with SFT, as normal ftp servers
   // may return UTC time which is of no help here.
   sprintf(szLineBuf2, "MDTM %s", pszFileName);
   if (sendLine(hSock, szLineBuf2)) return 0;
   if (readLine(hSock)) return 0; // 213 TimeString, 500 Error
   // may return: 550 no such file
   if (!strncmp(szLineBuf, "213 ", 4)) {
      char *ptime = szLineBuf+4;  // 20060604111037
      num   nfartime = 0;
      removeCRLF(ptime);
      if (!timeFromString(ptime, nfartime)) {
         num nowntime = ndsttime;
         num ndiff = bput ? (nfartime - nowntime) : (nowntime - nfartime);
         if (cs.verbose)
            printf("time: local=%lu far=%lu diff=%ld\n",(ulong)nowntime,(ulong)nfartime,(long)ndiff);
         if (ndiff >= 0)
            bskip = 1;
      }
   }
   return bskip;
}

long ftpClient(char *pszHost, ulong nPort, char *pszCmd, char *pszAuthPW, bool bChained)
{
   SOCKET hSock = 0;
   bool bSFT = 0;
   long nSFTVer = 0;
   if (ftpLogin(pszHost, nPort, hSock, bSFT, nSFTVer, pszAuthPW)) return 9;

   struct sockaddr_in DataAdr;
   SOCKET hData = INVALID_SOCKET;

   for (bool bLoop=1; bLoop;)
   {
      if (pszCmd) {
         strcpy(szLineBuf, pszCmd);
         bLoop = 0;
      } else {
         printf("> ");
         fflush(stdout);
         if (!(fgets(szLineBuf, sizeof(szLineBuf)-10, stdin)))
            break;
         removeCRLF(szLineBuf);
      }

      if (!strcmp(szLineBuf, "?"))
      {
         printf("available commands:\n");
         printf("dir put get cd bye\n");
         if (bSFT)
         printf("mput mget\n");
      }
      else
      if (!strncmp(szLineBuf, "cd ", 3)) {
         char *pszDir = strdup(szLineBuf+3);
         CharAutoDel odel(pszDir);
         sprintf(szLineBuf2, "CWD %s", pszDir);
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock)) break; // 200 OK
      }
      else
      if (!strcmp(szLineBuf, "dir")) {
         if (!bSFT) {
            // either create pasv connection or reuse existing
            if (setPassive(hSock, DataAdr, hData)) break;
            if (sendLine(hSock, "LIST")) break;
            if (readLine(hSock)) break; // 150 Listing
            while (readLine(hData, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
            if (readLine(hSock)) break; // 226 Closing
            closesocket(hData); hData = INVALID_SOCKET;
         } else {
            sendLine(hSock, "SLST");
            while (readLine(hSock, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
         }
      }
      else
      if (!strncmp(szLineBuf, "!", 1)) {
         // run local command
         system(szLineBuf+1);
      }
      else
      if (!strncmp(szLineBuf, "run ", 4)) {
         char *pszCmd = strdup(szLineBuf+4);
         CharAutoDel odel(pszCmd);
         // try to run remote command. requires -run option set at server.
         if (!bSFT) {
            printf("cannot run, remote server speaks no SFT.\n");
         } else {
            sprintf(szLineBuf2, "SRUN %s", pszCmd);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 200 OK, 500 Error
            // keep socket open.
         }
      }
      else
      if (strBegins(szLineBuf, "put ")) {
         char *pszFileName = strdup(szLineBuf+4);
         CharAutoDel odel(pszFileName);
         if (!bSFT) {
            if (setPassive(hSock, DataAdr, hData)) break;
            sprintf(szLineBuf2, "STOR %s", pszFileName);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Receiving
            if (sendFileRaw(hData, localPath(pszFileName))) break;
            closesocket(hData); hData = INVALID_SOCKET;         
            if (readLine(hSock)) break; // 226 Closing
         } else {
            Coi *pcoi = new Coi(localPath(pszFileName), 0);
            CoiAutoDelete odel(pcoi, 0); // no decref
            sprintf(szLineBuf2, "SPUT %s", pszFileName);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 200 OK, 500 Error
            if (!strncmp(szLineBuf, "200", 3))
               if (putFileBySFT(hSock, pcoi, nSFTVer))
                  break;
            // ack receive was done above. keep socket open.
         }
      }
      else
      if (!bChained && strBegins(szLineBuf, "mput"))
      {
         // direct multi file put (not chained)
         char szParmBuf[300]; mclear(szParmBuf);

         bool bupdate = 0; // bSFT;
         bool bbail   = 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;

         char *pparms = szLineBuf+strlen("mput");
         skipWhite(&pparms);
         strcopy(szParmBuf, pparms);
         cs.sim = !cs.yes;

         char *pszMask = szParmBuf;
         if (!*pszMask) {
            perr("missing mask. supply a name fragment or just \"*\"\n");
            continue;
         }

         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         long lFiles=0, lDirs=0, lRC=0;
         num nBytes=0;
         glblFTPLocList.resetEntries();
         walkAllTrees(eFunc_FTPLocList, lFiles, lDirs, nBytes);

         // now ALL local files are listed in glblFTPLocList
         long i=0, nSent=0, nSkipped=0, nFailed=0, nskip=0;
         for (; i<glblFTPLocList.numberOfEntries(); i++) 
         {
            char *pszFile = glblFTPLocList.getEntry(i, __LINE__);
            if (isWildStr(pszMask) || matchesName(pszFile, pszMask))
            {
               num ndsttime = getFileTime(pszFile);

               if (   bupdate && (ndsttime > 0)
                   && canSkipFile(hSock, pszFile, ndsttime, 1))
               {
                  if (cs.verbose)
                     printf("skip: %s - unchanged. (or use -all)\n", pszFile);
                  nskip++;
                  continue;
               }
               if (cs.sim) {
                  if (!cs.quiet)
                     printf("< %s\n", pszFile);
                  nSent++;
                  continue; 
               }

               if (!bSFT) {
                  if (setPassive(hSock, DataAdr, hData)) break;
                  sprintf(szLineBuf2, "STOR %s", pszFile);
                  if (sendLine(hSock, szLineBuf2)) break;
                  if (readLine(hSock)) break; // 150 Receiving
                  if (sendFileRaw(hData, localPath(pszFile))) break;
                  closesocket(hData); hData = INVALID_SOCKET;         
                  if (readLine(hSock)) break; // 226 Closing
               } else {
                  sprintf(szLineBuf2, "SPUT %s", pszFile);
                  if (sendLine(hSock, szLineBuf2, 1)) break;
                  if (readLine(hSock, szLineBuf , 2)) break; // 200 OK, 500 Error
                  if (strncmp(szLineBuf, "200", 3)) {
                     printf("\n");
                     perr("%s: %s", pszFile, szLineBuf); // no LF. readLine was QUIET
                     nFailed++; // but continue
                  } else {
                     Coi *pcoi = new Coi(pszFile, 0);
                     CoiAutoDelete odel(pcoi, 0); // no decref
                     if (putFileBySFT(hSock, pcoi, nSFTVer, 1))
                        break;
                  }
               }
               // ack receive was done above. keep socket open.
               nSent++;
            } else {
               // printf("nomatch: %s/%s\n", pszMask, pszFile);
               nSkipped++;
            }
         }

         if (i < glblFTPLocList.numberOfEntries())
            bLoop = 0; // fatal, server probably closed connection
         if (nFailed > 0)
            printf("%ld files sent, %ld failed.\n", nSent, nFailed);
         else
            printf("%ld files %ssent.\n", nSent, cs.sim?"would be ":"");

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");
      }
      else
      if (bChained && strBegins(szLineBuf, "mput"))
      {
         // chained multi file put (after select)

         // with SFT, update is default.
         // with FTP, update isn't supported.
         // simulate is always default.

         bool bupdate = 0; // bSFT;
         bool bbail   = 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;

         char *pparms = szLineBuf+strlen("mput");
         skipWhite(&pparms);
         cs.sim = !cs.yes;

         long nfiles = chain.numberOfInFiles();
         long ifile  = 0;

         if (nfiles < 1)
            { printf("ftp: have no filenames from previous commands.\n"); break; }
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         long nskip = 0;
         long ndone = 0;
         for (ifile=0; ifile<nfiles; ifile++) 
         {
            Coi *pcoi = chain.getFile(ifile);
            if (!pcoi) return 9+perr("int. #204292351\n");
            char *pszFileName = pcoi->name();
            num ndsttime = pcoi->getTime();

            if (   bupdate && bSFT && (ndsttime > 0)
                && canSkipFile(hSock, pszFileName, ndsttime, 1))
            {
               if (cs.verbose)
                  printf("skip: %s - unchanged. (or use -all)\n", pszFileName);
               nskip++;
               continue;
            }
            if (cs.sim) {
               if (!cs.quiet)
                  printf("< %s\n", pszFileName);
               ndone++;
               continue; 
            }

            if (!bSFT) {
               if (setPassive(hSock, DataAdr, hData)) break;
               sprintf(szLineBuf2, "STOR %s", pszFileName);
               if (sendLine(hSock, szLineBuf2)) break;
               if (readLine(hSock)) break; // 150 Receiving
               if (sendFileRaw(hData, localPath(pszFileName))) break;
               closesocket(hData); hData = INVALID_SOCKET;         
               if (readLine(hSock)) break; // 226 Closing
               ndone++;
            } else {
               Coi *pcoi = new Coi(localPath(pszFileName), 0);
               CoiAutoDelete odel(pcoi, 0); // no decref
               // transmit file
               sprintf(szLineBuf2, "SPUT %s", pszFileName);
               if (sendLine(hSock, szLineBuf2)) break;
               if (readLine(hSock)) break; // 200 OK, 500 Error
               if (!strncmp(szLineBuf, "200", 3))
                  if (putFileBySFT(hSock, pcoi, nSFTVer))
                     break;
               // ack receive was done above. keep socket open.
               ndone++;
            }
         }  // endfor files
         if (!cs.quiet) {
            if (cs.sim) {
               if (bupdate)
                  printf("would send %ld files, skip %ld unchanged.\n", ndone, nskip);
               else
                  printf("would send %ld files.\n", ndone);
            }
            else
            if (nskip)
               printf("%ld files sent, %ld unchanged skipped.\n", ndone, nskip);
            else
               printf("%ld files sent.\n", ndone);
         }
         if (cs.sim && !cs.nohead) {
            printx("$[add -yes to execute.]\n");
         }
         if (ifile < nfiles)
            break;
      }
      else
      if (!strncmp(szLineBuf, "get ", 4)) {
         char *pszFileName = strdup(szLineBuf+4);
         CharAutoDel odel(pszFileName);
         if (!bSFT) {
            if (setPassive(hSock, DataAdr, hData)) break;
            sprintf(szLineBuf2, "RETR %s", pszFileName);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Sending
            if (strBegins(szLineBuf, "150")) {
               createOutDirTree(localPath(pszFileName));
               if (receiveFileRaw(hData, localPath(pszFileName), -1)) break;
               if (readLine(hSock)) break; // 226 Closing
            } else {
               if (!cs.verbose) printf("%s", szLineBuf);
            }
            closesocket(hData); hData = INVALID_SOCKET;         
         } else {
            sprintf(szLineBuf2, "SGET %s", pszFileName);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 200 OK
            if (!strncmp(szLineBuf, "200", 3)) {
               createOutDirTree(localPath(pszFileName));
               if (getFileBySFT(hSock, localPath(pszFileName), nSFTVer))
                  break;
            }
            // ack send was done above. keep socket open.
         }
      }
      else
      if (!bChained && strBegins(szLineBuf, "mget"))
      {
         // direct multi file get (not chained)
         char szParmBuf[300]; mclear(szParmBuf);

         bool bupdate = 0; // bSFT;
         bool bbail   = 0;

         char *pparms = szLineBuf+strlen("mget");
         skipWhite(&pparms);
         strcopy(szParmBuf, pparms);
         cs.sim = !cs.yes;

         char *pszMask = szParmBuf;
         if (!*pszMask) {
            perr("missing mask. supply a name fragment (without *), or just \"*\"\n");
            continue;
         }

         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         glblFTPRemList.resetEntries();
         if (!bSFT) {
            if (setPassive(hSock, DataAdr, hData)) break;
            if (sendLine(hSock, "LIST")) break;
            if (readLine(hSock)) break; // 150 Listing
            while (readLine(hData, szLineBuf, 1) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
            if (readLine(hSock)) break; // 226 Closing
            closesocket(hData); hData = INVALID_SOCKET;
         } else {
            sendLine(hSock, "SLST");
            while (readLine(hSock, szLineBuf, 1) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
         }

         if (cs.debug)
            printf("> received %ld filenames\n",glblFTPRemList.numberOfEntries());

         char *apcol[20];
         memset(apcol, 0, sizeof(apcol));

         // now ALL remote files are listed in glblFTPRemList
         // in a RAW format:
         // -rw-rw-rw- 1 ftp ftp        30353 Sep 08 13:47   readme.txt
         //    0       1  2   3          4    5   6   7      8
         // -rw-rw-rw- 1 ftp ftp        30353 20061231235959 readme.txt
         //    0       1  2   3          4    5              6
         long i=0, nRecv=0, nSkipped=0, nFailed=0, nskip=0;
         for (; i<glblFTPRemList.numberOfEntries(); i++) 
         {
            char *pszFileRaw = glblFTPRemList.getEntry(i, __LINE__);

            // parse raw line
            long ncol = 0;
            strcopy(szRefNameBuf, pszFileRaw);
            char *psz1 = szRefNameBuf;
            while (ncol < 15) {
               // store column start
               apcol[ncol++] = psz1;
               // find end of column
               skipToWhite(&psz1);
               if (!*psz1) break;
               *psz1++ = '\0';
               // find start of next column
               skipWhite(&psz1);
               if (!*psz1) break;
            }

            bool bIsDir = 0;
            char *pattr = apcol[0];
            if (pattr && (pattr[0] == 'd'))
                 bIsDir = 1;

            char *pszMonTS = apcol[5]; // month or timestamp
            bool bHaveFlatTime = 0;
            if (pszMonTS && isdigit(*pszMonTS))
                 bHaveFlatTime = 1;

            long iName = 8;
            if (bHaveFlatTime) {
               if (ncol < 7)
                  {  pwarn("wrong format: %s - skipping\n", pszFileRaw); continue; }
               iName = 6;
            }
            else
            if (ncol < 9)
               {  pwarn("wrong format: %s - skipping\n", pszFileRaw); continue; }

            // always take filename from original buffer,
            // blanks may have been replaced by zeros in RefNameBuf.
            char *pszFile = pszFileRaw + (apcol[iName]-szRefNameBuf);
            char *pszSize = apcol[4];

            num nFileTime = 0;

            if (bGlblFTPSetAttribs) {
               if (bHaveFlatTime) {
                  timeFromString(pszMonTS, nFileTime);
               } else {
                  if (apcol[5] && apcol[6] && apcol[7]) {
                     sprintf(szLineBuf, "%s %s %s",apcol[5],apcol[6],apcol[7]);
                     timeFromString(szLineBuf, nFileTime);
                  }
               }
            }

            num nFileSize = atonum(pszSize);
            if (nFileSize <= 0) {
               printf("] skip, size=%s: %s\n", pszSize, pszFile);
               continue;
            }

            if (!bIsDir && (isWildStr(pszMask) || matchesName(pszFile, pszMask)))
            {
               num ndsttime = getFileTime(pszFile);

               if (   bupdate && (ndsttime > 0)
                   && canSkipFile(hSock, pszFile, ndsttime, 0))
               {
                  if (cs.verbose)
                     printf("skip: %s - unchanged. (or use -all)\n", pszFile);
                  nskip++;
                  continue;
               }
               if (cs.sim) {
                  if (!cs.quiet)
                     printf("> %s, %s bytes.\n", pszFile, numtoa(nFileSize));
                  nRecv++;
                  continue; 
               }

               if (!isWriteable(pszFile)) {
                  perr("cannot write: %s\n", pszFile);
                  nFailed++;
                  continue;
               }

               if (!bSFT) {
                  if (setPassive(hSock, DataAdr, hData)) break;
                  sprintf(szLineBuf2, "RETR %s", pszFile);
                  if (sendLine(hSock, szLineBuf2)) break;
                  if (readLine(hSock)) break; // 150 Sending
                  createOutDirTree(localPath(pszFile));
                  if (receiveFileRaw(hData, localPath(pszFile), -1)) break;
                  if (readLine(hSock)) break; // 226 Closing
                  closesocket(hData); hData = INVALID_SOCKET;         
               } else {
                  sprintf(szLineBuf2, "SGET %s", pszFile);
                  if (sendLine(hSock, szLineBuf2, 1)) break;
                  if (readLine(hSock, szLineBuf , 2)) break; // 200 OK
                  if (strncmp(szLineBuf, "200", 3)) {
                     printf("\n");
                     perr("%s", szLineBuf); // no LF. readLine was QUIET
                  } else {
                     if (getFileBySFT(hSock, pszFile, nSFTVer, 1))
                        break;
                     if (bGlblFTPSetAttribs) {
                        // experimental: try to set file time
                        FileStat ofs;
                        ofs.readFrom(pszFile);
                        ofs.src.nMTime = nFileTime;
                        #ifdef _WIN32
                        ofs.src.nHaveWFT = 0; // no windows filetime
                        #endif
                        long lRCT = ofs.writeTo(pszFile, __LINE__);
                        printf("] filetime set: %s, %ld\n", timeAsString(nFileTime), lRCT);
                     }
                  }
               }

               // ack receive was done above. keep socket open.
               nRecv++;
            } else {
               nSkipped++;
            }
         }

         if (i < glblFTPRemList.numberOfEntries())
            bLoop = 0; // fatal, server probably closed connection
         if (nFailed > 0)
            printf("%ld files received, %ld failed.\n", nRecv, nFailed);
         else
            printf("%ld files %sreceived.\n", nRecv, cs.sim?"would be ":"");

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");
      }
      else
      if (bChained && strBegins(szLineBuf, "mget"))
      {
         // chained multi file get (after select)

         // with SFT, update is default.
         // with FTP, update isn't supported.
         // simulate is always default.
         char szParmBuf[300]; mclear(szParmBuf);
         char szDstBuf[400];  mclear(szDstBuf);

         bool bupdate = 0; // bSFT;
         bool bbail   = 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;

         char *pparms = szLineBuf+strlen("mget");
         skipWhite(&pparms);
         strcopy(szParmBuf, pparms);
         cs.sim = !cs.yes;

         if (!szParmBuf[0]) {
            perr("missing target directory.\n");
            break;
         }

         long nfiles = chain.numberOfInFiles();
         long ifile  = 0;

         if (nfiles < 1)
            { printf("ftp: have no filenames from previous commands.\n"); break; }
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         long nskip = 0;
         long ndone = 0;
         for (ifile=0; ifile<nfiles; ifile++) 
         {
            // the reference coi, e.g. mydir/foo.txt
            Coi *pcoi = chain.getFile(ifile);
            if (!pcoi) return 9+perr("int. #204292352\n");

            char *pszFileName = pcoi->name();
            char *pszLocFile  = localPath(pszFileName);
            snprintf(szDstBuf, sizeof(szDstBuf), "%s%c%s", szParmBuf, glblPathChar, pszLocFile);

            // the destination coi, e.g. dstdir/mydir/foo.txt
            // this coi's time is checked against the remote time.
            Coi *pcoidst = new Coi(szDstBuf, 0);
            CoiAutoDelete odel(pcoidst, 0); // no decref
            num  ndsttime = pcoidst->getTime(); // if any

            if (   bupdate && bSFT && (ndsttime > 0)
                && canSkipFile(hSock, pszFileName, ndsttime, 0))
            {
               if (cs.verbose)
                  printf("skip: %s - unchanged. (or use -all)\n", pszFileName);
               nskip++;
               continue;
            }
            if (cs.sim) {
               if (!cs.quiet)
                  printf("> %s\n", szDstBuf);
               ndone++;
               continue; 
            }

            if (!bSFT) {
               if (setPassive(hSock, DataAdr, hData)) break;
               sprintf(szLineBuf2, "RETR %s", pszFileName);
               if (sendLine(hSock, szLineBuf2)) break;
               if (readLine(hSock)) break; // 150 Sending
               createOutDirTree(szDstBuf);
               if (receiveFileRaw(hData, szDstBuf, -1)) break;
               if (readLine(hSock)) break; // 226 Closing
               closesocket(hData); hData = INVALID_SOCKET;
               ndone++;
            } else {
               sprintf(szLineBuf2, "SGET %s", pszFileName);
               if (sendLine(hSock, szLineBuf2)) break;
               if (readLine(hSock)) break; // 200 OK
               if (!strncmp(szLineBuf, "200", 3)) {
                  createOutDirTree(szDstBuf);
                  if (getFileBySFT(hSock, szDstBuf, nSFTVer))
                     break;
                  ndone++;
               }
               // ack send was done above. keep socket open.
            }
         }
         if (!cs.quiet) {
            if (cs.sim) {
               if (bupdate)
                  printf("would receive %ld files, skip %ld unchanged.\n", ndone, nskip);
               else
                  printf("would receive %ld files.\n", ndone);
            }
            else
            if (nskip)
               printf("%ld files received, %ld unchanged skipped.\n", ndone, nskip);
            else
               printf("%ld files received.\n", ndone);
         }
         if (cs.sim && !cs.nohead) {
            printx("$[add -yes to execute.]\n");
         }
         if (ifile<nfiles)
            break;
      }
      else
      if (!strcmp(szLineBuf, "bye")) {
         break;
      }
      else {
         if (sendLine(hSock, szLineBuf)) break;
         if (readLine(hSock)) break; // 200 OK, 500 Error
      }
   }

   if (!pszCmd)
      printf("connection closed.\n");

   closesocket(hSock);

   #ifdef _WIN32
   WSACleanup();
   #endif

   return 0;
}

long makeServerSocket(
   ulong  &nNewPort,                // i/o parm
   struct sockaddr_in &ServerAdr,   // i/o parm
   SOCKET &hServSock,
   char  *pszInfo,
   ulong  nAltPort=0                // e.g. 2121 for ftp
   )
{
   ulong nPort = nNewPort;

   socklen_t nSockAdrSize = sizeof(sockaddr_in);

   ServerAdr.sin_family      = AF_INET;
   ServerAdr.sin_addr.s_addr = htonl(INADDR_ANY);
   ServerAdr.sin_port        = htons((unsigned short)nPort);

   hServSock = socket(AF_INET, SOCK_STREAM, 0);
   if (hServSock == INVALID_SOCKET)
      return 9+perr("cannot create %s (%lu)\n", pszInfo, nPort);

   int nOnVal = 1;
   setsockopt(hServSock, SOL_SOCKET, SO_REUSEADDR, (char *)&nOnVal, sizeof(nOnVal));

   int nrc = bind(hServSock, (struct sockaddr *)&ServerAdr, sizeof(sockaddr_in));

   if (nrc == SOCKET_ERROR && nAltPort > 0)
   {
      pinf("cannot bind on port %lu, using alternative port %ld.\n", nPort, nAltPort);
      nPort = nAltPort;
      ServerAdr.sin_port = htons((unsigned short)nPort);
      nrc = bind(hServSock, (struct sockaddr *)&ServerAdr, sizeof(sockaddr_in));
   }

   if (nrc == SOCKET_ERROR)
   {
      perr("cannot bind %s (%lu)\n", pszInfo, nPort);
      fprintf(stderr, "info : maybe a different app is running, or firewall blocks access.\n");
      fprintf(stderr, "info : you may retry with a different port, e.g. -port=30199.\n");
      return 9; 
   }

   int nerr = getsockname(hServSock, (struct sockaddr *)&ServerAdr, &nSockAdrSize);
   if (nerr == SOCKET_ERROR)
      return 9+perr("getsockname failed, %d\n", netErrno());

   bool bTell = (nPort == 0);
   nPort    = (ulong)ntohs(ServerAdr.sin_port);
   nNewPort = nPort;
   if (bTell)
      printf("< local port %lu (%lu, %lu)\n", nPort, (nPort>>8), nPort&0xFF);

   // make accept non-blocking:
   setBlocking(hServSock, 0);

   if (listen(hServSock, 4) == SOCKET_ERROR)
      return 9+perr("cannot listen on %s (%lu)\n", pszInfo, nPort);

   return 0;
}

long connectSocket(char *pszHost, ulong nPort, struct sockaddr_in &ClntAdr, SOCKET &hSock, char *pszInfo)
{
   hSock = socket(AF_INET, SOCK_STREAM, 0);
   if (hSock == INVALID_SOCKET)
      return 9+perr("cannot create %s\n", pszInfo);

   struct hostent *pTarget = 0;
   if ((pTarget = sfkhostbyname(pszHost)) == NULL)
      return 9+perr("cannot get host for %s\n", pszInfo);

   memcpy(&ClntAdr.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
   ClntAdr.sin_family = AF_INET;
   ClntAdr.sin_port = htons((unsigned short)nPort);
   if (cs.verbose)
      printf("< connect to %s:%lu\n", pszHost, nPort);
   if ((connect(hSock, (struct sockaddr *)&ClntAdr, sizeof(struct sockaddr_in))) == -1)
      return 9+perr("cannot establish connection for %s\n", pszInfo);

   return 0;
}

long udpAnyServ(ulong nPort, char *pszForward, long nForward, bool bEcho)
{
   prepareTCP();

   struct sockaddr_in oOwnAddr; mclear(oOwnAddr);
   oOwnAddr.sin_family      = AF_INET;
   oOwnAddr.sin_addr.s_addr = htonl(INADDR_ANY);
   oOwnAddr.sin_port        = htons(nPort);

   SOCKET nsock = socket(AF_INET, SOCK_DGRAM, 0);

   int bon = 1;
   setsockopt(nsock, SOL_SOCKET, SO_REUSEADDR, (const char *)&bon, sizeof(bon));

   do
   {
      if (bind(nsock, (struct sockaddr *)&oOwnAddr, sizeof(oOwnAddr)) != 0)
      {
         perr("cannot bind UDP socket to port %ld (%d %s).\n", nPort, netErrno(), netErrStr());
         break;
      }

      listen(nsock, 10);

      // if (listen(nsock, 10))
      //    {  perr("listen failed (%d %s).\n", netErrno(), netErrStr()); break; }

      printf("[waiting on port %ld for data.]\n", nPort);

      struct timeval tv;
      fd_set fdvar;

      while (1)
      {
         tv.tv_sec  = 0;
         tv.tv_usec = 0;
   
         FD_ZERO(&fdvar);
         FD_SET(nsock, &fdvar);
   
         if (select(nsock+1, &fdvar, 0, 0, &tv) > 0)
         {
            struct sockaddr_in inAddr;

            #ifdef _WIN32
            int nadrlen = sizeof(inAddr);
            #else
            socklen_t nadrlen = sizeof(inAddr);
            #endif

            long nRead = recvfrom(nsock, (char*)abBuf, sizeof(abBuf)-100, 0, (struct sockaddr *)&inAddr, &nadrlen);

            if (!cs.nohead && !cs.quiet)
               printf("[received %ld bytes:]\n",nRead);
            execHexdump(0, abBuf, nRead);

            if (bEcho)
            {
               if (!cs.nohead && !cs.quiet)
                  printf("[echoing back]\n");
               sendto(nsock, (char*)abBuf, nRead, 0, (struct sockaddr*)&inAddr, nadrlen);
            }

            if (pszForward)
            {
               // forward message to given host, port
               struct sockaddr_in saDstAddr;
               memset((char *)&saDstAddr, 0,sizeof(saDstAddr));

               saDstAddr.sin_family      = AF_INET;
               saDstAddr.sin_addr.s_addr = inet_addr(pszForward);
               saDstAddr.sin_port        = htons((int)nForward);

               if (!cs.nohead && !cs.quiet)
                  printf("[forwarding to %s:%ld]\n", pszForward, nForward);
               sendto(nsock, (char*)abBuf, nRead, 0, (struct sockaddr*)&saDstAddr, sizeof(saDstAddr));
            }
         }
         else
         {
            doSleep(1);
         }
      }
   }
   while (0);

   return 0;
}

int dumpUDPResponses(int nsocket)
{
   uchar abBuffer[2000+100];

   struct timeval tv;
   fd_set fdvar;
   struct sockaddr addrIncoming;
   int iBytes = 0;

   for (;;)
   {
      memset(abBuffer, 0, sizeof(abBuffer));

      #ifdef _WIN32
      int clilen = sizeof(addrIncoming);
      #else
      socklen_t clilen = sizeof(addrIncoming);
      #endif

      tv.tv_sec  = 0;
      tv.tv_usec = 100;

      FD_ZERO(&fdvar);
      FD_SET(nsocket, &fdvar);

      if (select( nsocket+1, &fdvar, 0, 0, &tv) <= 0)
         { doSleep(10); continue; }

      if ((iBytes = recvfrom(nsocket, (char*)abBuffer, sizeof(abBuffer), 0, &addrIncoming, &clilen)) <= 0)
         return -1;

      if (!cs.nohead && !cs.quiet)
        chain.print("[received %d bytes, %s]\n", iBytes, netErrStr());
      execHexdump(0, abBuffer, iBytes);

      break;
   }

   return 0;
}

long udpClient(char *phost, long ndstport, long nlisten, long nownport, uchar *abMsg, long nMsg, num nTimeout)
{
   prepareTCP();

   // setup own port for receive

   struct sockaddr_in saOwnAddr;

   memset((char *)&saOwnAddr, 0,sizeof(saOwnAddr));
   saOwnAddr.sin_family      = AF_INET;
   saOwnAddr.sin_addr.s_addr = htonl(INADDR_ANY);
   saOwnAddr.sin_port        = htons(nownport);

   int nsocket = socket(AF_INET, SOCK_DGRAM, 0);

   if (nownport >= 0) 
   {
      if (!nlisten) nlisten = 1;
      if (bind(nsocket, (struct sockaddr *)&saOwnAddr, sizeof(saOwnAddr)) != 0)
         return 9+perr("UDP socket failed to bind to port %ld, %s\n", nownport, netErrStr());
   }

   // send data to target server

   struct sockaddr_in saServerAddr;

   struct hostent *pTarget;
   if ((pTarget = sfkhostbyname(phost)) == NULL)
      return 9+perr("cannot get host %s, rc=%d\n", phost, netErrno());

   memcpy(&saServerAddr.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
   saServerAddr.sin_family      = AF_INET;
   saServerAddr.sin_port        = htons((int)ndstport);

   int n = sendto(nsocket, (char*)abMsg, nMsg, 0, (struct sockaddr*)&saServerAddr, sizeof(saServerAddr));

   if (!cs.nohead && !cs.quiet)
      chain.print("[sent %d bytes, %s]\n", n, netErrStr());
   if (cs.quiet < 2)
      execHexdump(0, abMsg, nMsg);

   // receive and dump replies

   if (nlisten)
   {
      num nstart = getCurrentTime();

      struct timeval tv;
      fd_set fdvar;
   
      for (long ndone=0; nlisten<0 || ndone<nlisten;)
      {
         tv.tv_sec  = 0;
         tv.tv_usec = 0;
   
         FD_ZERO(&fdvar);
         FD_SET(nsocket, &fdvar);
   
         if (select( nsocket+1, &fdvar, 0, 0, &tv) > 0)
         {   
            dumpUDPResponses(nsocket);
            ndone++;
            continue;
         }

         num nelaps = getCurrentTime() - nstart;

         if (nTimeout > 0 && nelaps >= nTimeout) {
            chain.print("[timeout]\n");
            break;
         }

         doSleep(10);
      }
   }

   return 0;
}

long tcpAnyServ(ulong nPort, char *pszForward, long nForward)
{
   prepareTCP();

   struct sockaddr_in ServerAdr;
   struct sockaddr_in ClientAdr;
   struct sockaddr_in FrontAdr;
   socklen_t nSoLen = sizeof(sockaddr_in);
   SOCKET hServer   = INVALID_SOCKET;
   SOCKET hBack     = INVALID_SOCKET;
   SOCKET hFront    = INVALID_SOCKET;
   if (makeServerSocket(nPort, ServerAdr, hServer, "server main port")) return 9;

   printf("waiting on port %lu for connections", nPort);
   if (pszForward) printf(", to forward to %s:%ld", pszForward, nForward);
   if (cs.timeOutAutoSelect)
      printf(".\n");
   else
      printf(". timeout is %ld milliseconds.\n", cs.timeOutMSec);

   // http autodetect:
   bool bFirstReq = 1;
   bool bHttp     = 0;

   long lRC = 0;
   while (!userInterrupt())
   {
      hBack = accept(hServer, (struct sockaddr *)&ClientAdr, &nSoLen);
      if (hBack == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(500); continue; }
         perr("accept on server main port failed\n");
         lRC = 9;
         break;
      }
      setBlocking(hBack, 0);

      // forward-connect
      if (pszForward) {
         if (!cs.quiet) {
            printf("[got connection, trying forward-connect]\r");
            fflush(stdout);
         }
         hFront = socket(AF_INET, SOCK_STREAM, 0);
         if (hFront == INVALID_SOCKET) return 9+perr("cannot create forward socket\n");
         static struct hostent *pTarget = 0;
         if (!pTarget) {
            pTarget = sfkhostbyname(pszForward);
            if (!pTarget) return 9+perr("cannot get host: %s\n", pszForward);
            memcpy(&FrontAdr.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
            FrontAdr.sin_family = AF_INET;
            FrontAdr.sin_port = htons((unsigned short)nForward);
         }
         if ((connect(hFront, (struct sockaddr *)&FrontAdr, sizeof(FrontAdr))) == -1) {
            perr("cannot connect to %s:%lu, %s\n", pszForward, nForward, netErrStr());
            return 9;
         }
         printf("[forward-connected to %s:%ld]       \n",pszForward,nForward);
         setBlocking(hFront, 0);
      } else {
         printf("[got connection]\n");
      }

      num nLastTime = getCurrentTime();

      // outer loop: try to repeat data forwarding for 30 secs
      while (!userInterrupt())
      {
         // any data from back?
         long nRead = recv(hBack, (char*)abBuf, sizeof(abBuf)-10, 0);
         // NOTE: non-blocking receives may return -1 inbetween,
         //       but the connection stays open.
         if (nRead > 0) 
         {
            // autodetect http protocol on first request
            abBuf[nRead] = '\0';
            if (bFirstReq) {
               bFirstReq = 0;
               // isolate first line of first request
               char *psz = strchr((char*)abBuf, '\n');
               if (psz) {
                  long nlen = psz-(char*)abBuf;
                  memcpy(szLineBuf, abBuf, nlen);
                  szLineBuf[nlen] = '\0';
                  if (   (!strncmp(szLineBuf, "GET ", 4) || !strncmp(szLineBuf, "POST ", 5))
                      && (strstr(szLineBuf, "HTTP") != 0)
                     )
                  {
                     bHttp = 1;
                     if (cs.timeOutAutoSelect)
                         cs.timeOutMSec = 10000;
                  }
               }
            }
            if (nGlblHexDumpForm == 4 && memchr(abBuf, '\0', nRead)) {
               // pure form: skip binary record
               printf("[received request from back: binary, %ld bytes]\n",nRead);
            } else {
               printf("[received request from back with %ld bytes:]\n",nRead);
               execHexdump(0, abBuf, nRead);
            }
            nLastTime = getCurrentTime();
            // forward to front
            if (pszForward) {
               long nSend = send(hFront, (char*)abBuf, nRead, 0);
               // ignore no. of actually sent bytes
               if (nSend == nRead)
                  printf("[forwarded %ld bytes]\n", nSend);
               else
                  pwarn("[forwarded %ld bytes of %ld - incomplete]\n", nSend, nRead);
            }
         }

         // any data from front?
         if (pszForward)
         {
            long nRead = recv(hFront, (char*)abBuf, sizeof(abBuf)-10, 0);
            if (nRead > 0) {
               if (nGlblHexDumpForm == 4 && memchr(abBuf, '\0', nRead)) {
                  // pure form: dump start of binary, but not all
                  long nHexLimit = 1000;
                  if (nRead > nHexLimit) {
                     printf("[received reply from front with binary, %ld bytes. dumping first %ld:]\n", nRead, nHexLimit);
                     long nCurForm = nGlblHexDumpForm;
                     nGlblHexDumpForm = 0;
                     execHexdump(0, abBuf, nHexLimit);
                     nGlblHexDumpForm = nCurForm;
                  } else {
                     printf("[received reply from front with binary, %ld bytes:]\n", nRead);
                     execHexdump(0, abBuf, nRead);
                  }
               } else {
                  printf("[received reply from front:]\n");
                  execHexdump(0, abBuf, nRead);
               }
               nLastTime = getCurrentTime();
               // backward reply
               long nSend = send(hBack, (char*)abBuf, nRead, 0);
               if (nSend == nRead)
                  printf("[backwarded %ld bytes]\n", nSend);
               else
                  pwarn("[backwarded %ld bytes of %ld - incomplete]\n", nSend, nRead);
            }
         }

         // no data at all over timeout?
         if (getCurrentTime() > nLastTime + cs.timeOutMSec) {
            printf("[timeout, no data over %ld msec]\n", cs.timeOutMSec);
            break;
         }

         {
            doSleep(500);
            char *pszCircle = ". ";
            static long nCircle = 0;
            num nElapse = getCurrentTime() - nLastTime;
            if (!cs.quiet) {
               printf("[%c waiting for input, %ld/%ld sec]\r",pszCircle[(nCircle++)%2],(long)(nElapse/1000),cs.timeOutMSec/1000);
               fflush(stdout);
            }
         }

      } // end outer loop

      if (pszForward) {
         printf("[closing forward connection]\n");
         closesocket(hFront);
      }

      printf("[client disconnected]\n");
      closesocket(hBack);
   }

   closesocket(hServer);

   #ifdef _WIN32
   WSACleanup();
   #endif

   return 0;
}

char *pUploadForm =
   "<p>"
   "<form method=\"POST\" enctype=\"multipart/form-data\" action=\"zz-sfk-upload.cgi\">\n"
   "<table><tr><td>\n"
   "<input type=\"file\" name=\"filename\"/>\n"
   "</td><td>\n"
   "<input type=\"submit\" value=\"upload\"/>\n"
   "</td></tr></table>\n"
   "</form>\n";

long recvHead(SOCKET hBack, char *pbuf, long nrem)
{
   bool bbail = 0;
   long nhead = 0;
   while (1) {
      long nread = recv(hBack, pbuf+nhead, 1, 0);
      if (nread <= 0) { bbail=1; break; }
      nhead++;
      // scan for \r\n\r\n
      if (nhead > 4 && !strncmp(pbuf+nhead-4, "\r\n\r\n", 4))
         break;
      // scan for \n\n
      if (nhead > 2 && !strncmp(pbuf+nhead-2, "\n\n", 2))
         break;
   }
   pbuf[nhead] = '\0';
   return bbail ? -1 : nhead;
}

// used mainly by file upload of http server
long senderr(SOCKET hSock, char *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   strcat(szErrBuf, "\r\n");

   sendLine(hSock, "HTTP/1.1 500 server error");
   sendLine(hSock, "Server: Swiss File Knife " SFK_VERSION " " VER_STR_OS);
   sendLine(hSock, "Content-Type: text/html");
   sendLine(hSock, "");

   sendLine(hSock, "<html><body>");
   send(hSock, szErrBuf, strlen(szErrBuf), 0);
   sendLine(hSock, "</body></html>");

   num nstart = getCurrentTime();

   // browser tries to upload data, so we have to dummy-receive
   // them for a while, otherwise it will show a connection abort
   // instead of the error message.

   setBlocking(hSock, 0);
   long nread = 0;
   while ((nread = recv(hSock, (char*)abBuf, sizeof(abBuf)-10, 0)) > 0)
      if (getCurrentTime() - nstart > 3000)
         break;
   setBlocking(hSock, 1);

   if (cs.quiet < 2)
      printf("< ERROR: %.80s\n", szErrBuf);

   return 0;
}

long httpServ(ulong nPort, ulong nPort2, bool bDeep, bool bNoList, bool bRW)
{__
   prepareTCP();

   struct sockaddr_in ServerAdr;
   struct sockaddr_in ClientAdr;
   socklen_t nSoLen = sizeof(sockaddr_in);
   SOCKET hServer   = INVALID_SOCKET;
   SOCKET hBack     = INVALID_SOCKET;
   if (makeServerSocket(nPort, ServerAdr, hServer, "server main port", nPort2)) return 9;

   printf("SFK Instant HTTP Server. For help, type \"sfk httpserv -help\".\n");

   // get own ip
   int   namount = 0;
   char *pownip  = ownIPList(namount, (nPort==80) ? 0 : nPort);
   struct in_addr addr;

   if (strlen(pownip)) {
      if (namount == 1) {
         printf("Waiting on port %lu. Try http://%s/ in your browser.\n", nPort, pownip, nPort);
      } else {
         printf("Waiting on port %lu. Try http://%s in your browser.\n", nPort, pownip, nPort);
      }
   } else {
      printf("Waiting on port %lu.\n", nPort);
   }
 
   char szClientIP[50]; mclear(szClientIP);
   char szStatus[200];  mclear(szStatus);

   long lRC = 0;
   while (!userInterrupt())
   {
      hBack = accept(hServer, (struct sockaddr *)&ClientAdr, &nSoLen);
      if (hBack == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(500); continue; }
         perr("accept on server main port failed\n");
         lRC = 9;
         break;
      }
      setBlocking(hBack, 1);

      // list IP of client machine whenever it changes
      memcpy(&addr,&ClientAdr.sin_addr,sizeof(struct in_addr));
      char *premip = inet_ntoa(addr);
      if (strcmp(szClientIP, premip)) {
         strcopy(szClientIP, premip);
         printf("> connect from %s\n", premip);
      }

      char szFile[SFK_MAX_PATH+50]; mclear(szFile);

      mclear(szStatus);

      do
      {
         // read header line by line
         long nhead = recvHead(hBack, (char*)abBuf, sizeof(abBuf)-10);
         if (nhead < 0) break;

         // GET /favicon.ico HTTP/1.1
         char *preq = (char*)abBuf;

         mtklog("http: req: \"%.200s\"", preq);

         if (strBegins(preq, "POST /zz-sfk-upload.cgi ")) 
         {
            // ===== single file upload =====

            // printf("req: %s\n", preq);

            // separate content from header
            char *pcont = strstr(preq, "\r\n\r\n");
            if (!pcont) pcont = strstr(preq, "\n\n");
            if (!pcont) { senderr(hBack, "wrong POST format"); break; }
            *pcont = '\0';
            pcont += 4;

            // parse header lines:

            // szLineBuf3 contains boundary.
            mclear(szLineBuf3);
            num nContLen = -1;

            bool bfirst = 1;
            char *psz1 = preq;
            while (psz1 && *psz1)
            {
               char *psz2 = strchr(psz1, '\n');
               if (psz2) *psz2++ = '\0';
               removeCRLF(psz1);
               if (bfirst)
                  { bfirst=0; printf("> %s\n",psz1); }

               mtklog("http: post.head: %s", psz1);

               if (   striBegins(psz1, "content-type")
                   && mystrstri(psz1, "multipart/form-data")
                  )
               {
                  char *psz3 = strstr(psz1, "boundary=");
                  if (!psz3)
                     { senderr(hBack, "wrong content-type: %s",psz1); break; }
                  psz3 += strlen("boundary=");
                  char *psz4 = psz3;
                  skipToWhite(&psz4);
                  long nlen = psz4-psz3;
                  if (nlen > MAX_LINE_LEN-100)
                     { senderr(hBack, "content-boundary too long"); break; }
                  snprintf(szLineBuf3, MAX_LINE_LEN, "\r\n--%.*s--\r\n", (int)nlen, psz3);
               }
               if (striBegins(psz1, "content-length")) {
                  num nlen = -1;
                  char *psz3 = strchr(psz1, ':');
                  if (psz3) {
                     psz3++;
                     skipWhite(&psz3);
                     nlen = atonum(psz3);
                  }
                  if (nlen < 0) { senderr(hBack, "wrong content-length: %s",psz1); break; }
                  nContLen = nlen;
               }
               psz1 = psz2;
            }

            if (!szLineBuf3[0]) { senderr(hBack, "missing boundary header"); break; }
            if (nContLen < 0)   { senderr(hBack, "missing content length"); break; }

            mtklog("http: post.bound \"%s\"", szLineBuf3);
            mtklog("http: post.clen %ld", (long)nContLen);

            // get first part header
            long nhead2 = recvHead(hBack, (char*)abBuf, sizeof(abBuf)-10);
            if (nhead2 < 0) break;
            abBuf[nhead2] = '\0';

            mtklog("http: post.firsthead: \"%.300s\"", abBuf);

            char *pname = strstr(preq, "filename=\"");
            if (!pname) { senderr(hBack, "missing filename"); break; }
            pname += strlen("filename=\"");
            char *psz3 = strchr(pname, '\"');
            if (!psz3) { senderr(hBack, "missing quote"); break; }
            *psz3 = '\0';

            mtklog("http: post.filename \"%s\"", pname);

            // c:\the\dir\foo.txt -> foo.txt
            char *pnameraw = pname;
            if (strrchr(pname, '/'))  pname = strrchr(pname, '/') + 1;
            if (strrchr(pname, '\\')) pname = strrchr(pname, '\\') + 1;
            strcopy(szFile, localPath(pname));
            // printf("> %s -> %s\n",pnameraw,pname);

            // receive file data
            if (isPathTraversal(szFile, 0))
               { senderr(hBack, "path traversal not allowed: %s", szFile); break; }

            FILE *fout = fopen(szFile, "wb");
            if (!fout)
               { senderr(hBack, "cannot write: %s",szFile); break; }

            char *pbnd = szLineBuf3;
            long  nbnd = strlen(pbnd);

            // mtkdump("http: post.bnd: ",pbnd,nbnd);

            num nTotal  = 0;

            // requires overlapping read with boundary search
            char *pbuf    = (char*)abBuf;
            long  nused   = 0;
            long  nbufmax = sizeof(abBuf)-10;

            SFKMD5 md5;

            while (nTotal < nContLen)
            {
               long nbufrem =  nbufmax  - nused;
               num  ntotrem = (nContLen - nTotal) - nused;

               if (ntotrem < 0) {
                  senderr(hBack, "int. error during POST read, %ld %ld %ld",(long)nContLen,(long)nTotal,(long)nused);
                  break;
               }

               if (nbufrem > ntotrem) nbufrem = (long)ntotrem;

               // if (nbufrem < 1000) { mtkdump("http: buf: ", pbuf, nused); }

               mtklog("http: post.wait: rem=%ld used=%ld total=%ld clen=%ld", nbufrem, nused, (long)nTotal, (long)nContLen);

               long nread = recv(hBack, pbuf+nused, nbufrem, 0);
               if (nread <= 0) break;

               nused += nread;
               pbuf[nused] = '\0'; // safety

               mtklog("http:  post.read: len=%ld used=%ld total=%ld", nread, nused, (long)nTotal);

               // another boundary?
               char *phit = 0; // (char*)memFind((uchar*)pbnd, nbnd, (uchar*)pbuf, nused);

               if (nused >= nbnd)
                  if (!strncmp(pbuf+nused-nbnd, pbnd, nbnd))
                      phit = pbuf+nused-nbnd;

               if (phit) {
                  long nlen = phit - pbuf;
                  myfwrite((uchar*)pbuf, nlen, fout);
                  md5.update((uchar*)pbuf, nlen);
                  nTotal += nlen;
                  char *ppost = phit + nbnd;
                  char *pend  = strstr(ppost, "\r\n\r\n");
                  if (!pend) pend = ppost;
                  // printf("sub: \"%s\"\n", phit);
                  ppost = pend;
                  long nlen2 = ppost - pbuf;
                  long nrem2 = nused - nlen2;
                  memmove(pbuf, ppost, nrem2);
                  nused = nrem2;
                  mtklog("http:  post.hitblock: take %ld, move %ld",nlen,nused);
                  break;
               }

               // normal processing: write halve of buffer
               long nlen = nused / 2;

               mtklog("http:  post.nblk: take %ld",nlen);

               myfwrite((uchar*)pbuf, nlen, fout);
               md5.update((uchar*)pbuf, nlen);
               nTotal += nlen;
               char *ppost = pbuf + nlen;
               long nrem2 = nused - nlen;
               memmove(pbuf, ppost, nrem2);
               nused = nrem2;
            }

            fclose(fout);

            char szmd5[100];
            uchar *pmd5 = md5.digest();
            for (long i=0; i<16; i++)
               sprintf(szmd5+i*2, "%02x", pmd5[i]);

            snprintf(szStatus, sizeof(szStatus)-10, "saved : %s (%s bytes) md5=%s",szFile,numtoa(nTotal),szmd5);
            printf("> %s\n", szStatus);

            mtklog("http: post: %s", szStatus);

            strcpy((char*)abBuf, "GET / HTTP/1.1\r\n\r\n");

            // fall through to index listing, with szStatus being displayed.

         }  // endif POST

         // isolate first line
         char *plf = strchr(preq, '\r');
         if (!plf) plf = strchr(preq, '\n');
         if (plf) *plf = '\0';
         printf("> %s\n", preq);

         bool bget  = strBegins(preq, "GET ");
         bool bhead = strBegins(preq, "HEAD ");

         if (!bget && !bhead)
         {
            senderr(hBack, "500 unsupported command: %.200s", preq);
            break;
         }

         char *psz1 = preq + (bget ? 4 : 5);
         if (*psz1=='/') psz1++;
         char *psz2 = psz1;
         skipToWhite(&psz2);
         long nlen = psz2 - psz1;
         if (nlen > SFK_MAX_PATH) nlen = SFK_MAX_PATH;
         memcpy(szFile, psz1, nlen);
         szFile[nlen] = '\0';

         // requested file is now in szFile
         if (!szFile[0] && bNoList) {
            strcpy(szFile, "index.html");
         }

         if (!szFile[0]) 
         {
            // list files of current dir
            hGlblTCPOutSocket = hBack;
            sendLine(hBack, "HTTP/1.1 200 OK");
            sendLine(hBack, "Server: Swiss File Knife " SFK_VERSION " " VER_STR_OS);
            sendLine(hBack, "Content-Type: text/html");
            sendLine(hBack, "Cache-Control: no-cache");
            sendLine(hBack, ""); // plus added \r\n

            if (bget)
            {
               sendLine(hBack, "<html><body>");
               sendLine(hBack, "Swiss File Knife Instant HTTP Server, " SFK_VERSION ", " VER_STR_OS);
   
               sendLine(hBack, "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"/\">refresh</a>");
   
               if (bRW) sendLine(hBack, pUploadForm);
   
               sendLine(hBack, "<pre>");
   
               if (szStatus[0]) {
                  snprintf(szLineBuf2, MAX_LINE_LEN, "%s\n", szStatus);
                  sendLine(hBack, szLineBuf2);
               }
   
               long lFiles=0,lDirs=0;
               num  nBytes=0;
               bGlblFTPListFlatTS = 1;
               bGlblFTPListAsHTML = 1;
               lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
   
               sendLine(hBack, "</pre></body></html>");
               if (!cs.quiet)
                  printf("< sent content listing.\n");
            }
            break;
         }

         // block any ".." etc.
         if (isPathTraversal(szFile, bDeep)) {
            senderr(hBack, "path traversal not allowed: %s", szFile);
            break;
         }

         // all other files
         Coi *pcoi = new Coi(localPath(szFile), 0);
         CoiAutoDelete odel(pcoi, 0); // no decref

         if (!pcoi->existsFile()) {
            sendLine(hBack, "HTTP/1.1 404 no such file");
            sendLine(hBack, "");
            sprintf(szLineBuf2, "404 no such file: %.200s", szFile);
            sendLine(hBack, szLineBuf2);
            break;
         }

         bool bbin  = pcoi->isBinaryFile();
         num  nsize = pcoi->getSize();

         sendLine(hBack, "HTTP/1.1 200 OK");

         char *pctype = "application/octet-stream";

         if (bbin) {
            if (strstr(szFile, ".jp"))  pctype = "image/jpg";
            if (strstr(szFile, ".png")) pctype = "image/png";
            if (strstr(szFile, ".gif")) pctype = "image/gif";
         } else {
            pctype = "text/plain";
            if (strstr(szFile, ".htm"))
               pctype = "text/html";
         }
         sprintf(szLineBuf2, "Content-Type: %s", pctype);
         sendLine(hBack, szLineBuf2);

         sprintf(szLineBuf2, "Content-Length: %s", numtoa(nsize));
         sendLine(hBack, szLineBuf2);

         sendLine(hBack, "");

         if (bget)
         {
            if (pcoi->open("rb")) {
               if (strcmp(szFile, "favicon.ico"))
                  senderr(hBack, "failed to open: \"%s\"", pcoi->name());
               break; 
            }
   
            long nread = 0;
            num  ndone = 0;
            while ((nread = pcoi->read(abBuf, sizeof(abBuf)-1000)) > 0)
            {
               if (cs.verbose>1) printf("< [%ld bytes data]\n", (long)nread);
               long nsent = send(hBack, (char*)abBuf, nread, 0);
               ndone += nsent;
               if (nsent != nread)
                  { perr("failed to send data (%ld/%ld) %s\n",nsent,nread,netErrStr()); break; }
            }
   
            pcoi->close();
   
            if (!cs.quiet) {
               if (ndone == nsize)
                  printf("< sent %s bytes, content-type: %s\n",numtoa(ndone),pctype);
               else
                  printf("< transfer incomplete.\n");
            }
         }

         // connection close after every request
      }
      while (0);

      // not sure when we can close connection safely
      doSleep(500);

      closesocket(hBack);

   }  // endwhile accept loop

   closesocket(hServer);

   #ifdef _WIN32
   WSACleanup();
   #endif

   return 0;
}

long ftpServ(ulong nPort, bool bRW, bool bRun, char *pszPath, char *pszAuthPW, char *pszRunPW, bool bDeep, ulong nPort2)
{
   prepareTCP();

   if (!pszRunPW)
        pszRunPW = pszAuthPW; // if any

   bGlblFTPReadWrite = bRW;

   struct sockaddr_in ServerAdr;
   struct sockaddr_in PasServAdr;
   struct sockaddr_in ClientAdr;
   struct sockaddr_in DataAdr;
   socklen_t nSoLen = sizeof(sockaddr_in);
   SOCKET hServer   = INVALID_SOCKET;
   SOCKET hClient   = INVALID_SOCKET;
   SOCKET hPasServ  = INVALID_SOCKET;
   SOCKET hData     = INVALID_SOCKET;
   ulong  nPasPort  = 0;

   char *ppreip = "";
   char *pownip = "";
   char *pposip = ". ";
   struct in_addr addr;

   int   namount = 0;
   pownip = ownIPList(namount, 0);

   if (strlen(pownip))
   {
      ppreip = ", IP ";
      pposip = " - ";
      // on multiple ip's, create another line
      if (strlen(pownip) > 20)
         pposip = ".\n";
   }

   long nDefSFTVer = 102;

   if (makeServerSocket(nPort, ServerAdr, hServer, "server main port", nPort2)) return 9;

   printf("SFK Instant FTP %ld. For help, type \"sfk ftpserv -help\".\n", nDefSFTVer);
   if (bRW)
      printf("waiting on port %lu%s%s%swrite allowed, %lu MB limit per file. ", nPort, ppreip, pownip, pposip, nGlblTCPMaxSizeMB);
   else
      printf("waiting on port %lu%s%s%sonly read allowed. ", nPort, ppreip, pownip, pposip);
   printf("%ld sec timeout.\n",cs.timeOutMSec / 1000);

   long lRC = 0;
   while (!userInterrupt())
   {
      hClient = accept(hServer, (struct sockaddr *)&ClientAdr, &nSoLen);
      if (hClient == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(500); continue; }
         perr("accept on server main port failed\n");
         lRC = 9;
         break;
      }
      setBlocking(hClient, 1);

      // default for SFT version, may be downgraded:
      long nSFTVer = nDefSFTVer;

      // list IP of client machine
      struct in_addr addr;
      memcpy(&addr,&ClientAdr.sin_addr,sizeof(struct in_addr));
      char *premip = inet_ntoa(addr);
      printf("> connect from %s\n", premip);

      // login, pseudo-authentication
      sprintf(szLineBuf2, "220 sfk instant ftp, %ld sec timeout. sft %ld.", cs.timeOutMSec / 1000, nSFTVer);
      if (sendLine(hClient, szLineBuf2)) { closesocket(hClient); continue; }
      if (readLine(hClient)) { closesocket(hClient); continue; } // > USER username

      // expecting: "USER username".
      // if client uses a wrong protocol, we should detect it now.
      bool startsLikeHttpCommand(char *psz);
      if (startsLikeHttpCommand(szLineBuf)) {
         sendLine(hClient, "500 wrong protocol (http), please use ftp://");
         shutdown(hClient, SHUT_WR);
         closesocket(hClient); continue;
      }
      // assume "USER username", so far we don't enforce it.
      if (sendLine(hClient, "331 User name ok, need password")) { closesocket(hClient); continue; }
      if (readLine(hClient)) { closesocket(hClient); continue; } // > PASS passwd

      char szClientPW[100];
      mclear(szClientPW);
      removeCRLF(szLineBuf);
      if (!strncmp(szLineBuf, "PASS sft", 8)) {
         long nClientSFT = atol(szLineBuf+8);
         if (cs.quiet < 2)
            printf("> client speaks sft: %ld\n", nClientSFT);
         char *pszPW = strchr(szLineBuf+8, '@');
         if (pszPW) strcopy(szClientPW, pszPW+1);
         // auto-adapt to client SFT version
         if (nClientSFT >= 101)
            nSFTVer = nClientSFT;
      }
      else
      if (!strncmp(szLineBuf, "PASS ", 5))
         strcopy(szClientPW, szLineBuf+5);
      if (pszAuthPW)
      {
         // requiring client authentication
         if (!szClientPW[0]) {
            sendLine(hClient, "500 missing authentication.");
            continue;
         }
         if (strcmp(szClientPW, pszAuthPW)) {
            sendLine(hClient, "500 wrong authentication.");
            doSleep(1000);
            continue;
         }
         if (cs.quiet < 2)
            printf("> client is authenticated.\n");
      }
      // the pszRunPW, if any, is checked later.

      if (sendLine(hClient, "230 User logged in")) { closesocket(hClient); continue; }
      if (cs.quiet == 1)
         printf("> client connected.\n");

      // read client commands
      long nbail = 0;
      while (nbail < 3)
      {
         long lTimeout = cs.timeOutMSec;
         num t1 = getCurrentTime();
         while (getCurrentTime() < t1 + lTimeout)
         {
            if (hasData(hClient, 500))
               break;
            if (userInterrupt())
               break;
            doSleep(500);
         }
         if (userInterrupt())
            break;
         if (getCurrentTime() >= t1 + lTimeout) {
            sprintf(szLineBuf2, "500 inactivity timeout (%ld sec)", lTimeout/1000);
            sendLine(hClient, szLineBuf2);
            if (cs.quiet == 1)
               printf("> client disconnected (timeout).\n");
            break;
         }

         // use readline without implicite skip processing
         if (readLineSub(hClient, szLineBuf, 0)) break;
         removeCRLF(szLineBuf);

         if (!strncmp(szLineBuf, "SYST", 4)) { nbail=0;
            if (sendLine(hClient, "215 UNIX emulated by SFK.")) break;
            continue;
         }
         else
         if (!strncmp(szLineBuf, "TYPE ", 5)) { nbail=0;
            if (sendLine(hClient, "200 Command OK")) break;
            continue;
         }
         else
         if (!strncmp(szLineBuf, "PWD", 3)) { nbail=0;
            if (sendLine(hClient, "257 \"/\" is current directory.")) break;
            continue;
         }
         else
         if (!strncmp(szLineBuf, "SIZE ", 5)) { nbail=0;
            char *pszFile = szLineBuf+5;
            if (pszFile[0] == '/')
                pszFile++;
            if (!isPathTraversal(pszFile, bDeep)) {
               num nFileSize = getFileSize(localPath(pszFile));
               sprintf(szLineBuf2, "213 %s", numtoa(nFileSize));
               if (sendLine(hClient, szLineBuf2)) break;
            } else {
               if (sendLine(hClient, "550 File not found")) break;
            }
            continue;
         }
         else
         if (!strncmp(szLineBuf, "MDTM ", 5)) { nbail=0;
            // MDTM 20060604111037
            char *pszFile = szLineBuf+5;
            if (pszFile[0] == '/')
                pszFile++;
            if (!isPathTraversal(pszFile, bDeep)) {
               num nFileTime = getFileTime(localPath(pszFile));
               // printf("time: %ld %s localPath: %s\n",(long)nFileTime,timeAsString(nFileTime, 1),localPath(pszFile));
               if (nFileTime <= 0)
                  sprintf(szLineBuf2, "550 no such file");
               else
                  sprintf(szLineBuf2, "213 %s", timeAsString(nFileTime, 1));
               if (sendLine(hClient, szLineBuf2)) break;
            } else {
               if (sendLine(hClient, "550 File not found")) break;
            }
            continue;
         }
         else
         if (!strcmp(szLineBuf, "RETR /")) { nbail=0;
            if (sendLine(hClient, "550 File not found")) break;
            closesocket(hData); hData = INVALID_SOCKET;
            continue;
         }
         else
         if (!strncmp(szLineBuf, "CWD ", 4)) { nbail=0;
            char *pszPath = szLineBuf+4;
            if (!strcmp(pszPath, "/")) {
               if (sendLine(hClient, "250 CWD OK")) break;
            } else {
               if (sendLine(hClient, "500 Not allowed")) break;
            }
            continue;
         }
         else
         if (!strncmp(szLineBuf, "PASV", 4))
         {
            nbail=0;
            // establish passive data connection server on demand
            if (hPasServ == INVALID_SOCKET) {
               nPasPort = 0; // find new local port
               if (makeServerSocket(nPasPort, PasServAdr, hPasServ, "passive server port"))
                  break;
            }
            sprintf(szLineBuf2, "227 Entering Passive Mode (127,0,0,1,%u,%u)",(nPasPort>>8),(nPasPort&0xFF));
            if (sendLine(hClient, szLineBuf2)) break;
            if (hData != INVALID_SOCKET)
               closesocket(hData);

            if (cs.quiet < 2)
               printf("> wait for accept\n");
            long k=0;
            for (k=0; k<6; k++)
            {
               nSoLen = sizeof(sockaddr_in);
               hData  = accept(hPasServ, (struct sockaddr *)&ClientAdr, &nSoLen);
               if (hData == INVALID_SOCKET) {
                  int nerr = netErrno();
                  if (nerr == WSAEWOULDBLOCK) { doSleep(500); continue; }
                  perr("accept on passive port failed\n");
                  break;
               }
               else
                  break;
            }
            if (k==6) { perr("accept timeout for passive port\n"); break; }
            setBlocking(hData, 1);
            if (cs.quiet < 2)
               printf("> accept done\n");

            if (hData == INVALID_SOCKET)
               { perr("passive accept failed\n"); break; }
         }
         else
         if (!strncmp(szLineBuf, "PORT ", 5)) 
         {
            nbail=0;
            // establish active data connection
            uchar n[6];
            char *psz = szLineBuf+strlen("PORT ");
            for (int i=0; i<6; i++) {
               n[i] = (uchar)atol(psz);
               psz = strchr(psz+1, ',');
               if (psz) psz++; else break;
            }
            char szIP[50];
            sprintf(szIP, "%d.%d.%d.%d",n[0],n[1],n[2],n[3]);
            ulong nPort = (((ulong)n[4])<<8)|((ulong)n[5]);
            if (connectSocket(szIP, nPort, DataAdr, hData, "active data")) break;
            if (sendLine(hClient, "200 Okay")) break;
         }
         else
         if (!strncmp(szLineBuf, "LIST", 4))
         {
            nbail=0;
            if (hData == INVALID_SOCKET) {
               sendLine(hClient, "500 internal error 1");
               continue;
            }
            // path is ignored. list only current dir.
            strcpy(szLineBuf2, szLineBuf);
            if (sendLine(hClient, "150 Listing Directory")) break;
            long lFiles=0, lDirs=0, lRC=0;
            num nBytes=0;
            // if (strlen(szLineBuf2) > 8)
            //    sendLine(hData, "Path ignored - listing only current dir.");
            // sendLine(hData, "300: ftp://localhost/");
            // sendLine(hData, "200: filename"); // content-length last-modified");
            hGlblTCPOutSocket = hData;
            lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
            closesocket(hData); hData = INVALID_SOCKET;
            if (cs.quiet < 2)
               printf("dir done, RC %ld, %ld files.\n", lRC, lFiles);
            if (sendLine(hClient, "226 Closing data connection")) break; // 226, 250
         }
         else
         if (!strcmp(szLineBuf, "NLST *"))
         {
            nbail=0;
            if (hData == INVALID_SOCKET) {
               sendLine(hClient, "500 internal error 1");
               continue;
            }
            // path is ignored. list only current dir.
            strcpy(szLineBuf2, szLineBuf);
            if (sendLine(hClient, "150 Listing Directory")) break;
            long lFiles=0, lDirs=0, lRC=0;
            num nBytes=0;
            hGlblTCPOutSocket = hData;
            lRC = walkAllTrees(eFunc_FTPNList, lFiles, lDirs, nBytes);
            closesocket(hData); hData = INVALID_SOCKET;
            if (cs.quiet < 2)
               printf("dir done, RC %ld, %ld files.\n", lRC, lFiles);
            if (sendLine(hClient, "226 Closing data connection")) break; // 226, 250
         }
         else
         if (!strncmp(szLineBuf, "RETR ", 5)) 
         {
            nbail=0;
            if (hData == INVALID_SOCKET) {
               sendLine(hClient, "500 internal error 1");
               continue;
            }
            // send file
            strcpy(szLineBuf2, szLineBuf);
            if (sendLine(hClient, "150 Sending File")) break;
            char *pszFile = szLineBuf2+5;
            if (pszFile[0] == '/')
                pszFile++;
            if (isPathTraversal(pszFile, bDeep)) {
               sendLine(hClient, "500 forbidden path");
            } else {
               if (cs.quiet < 2)
                  printf("send file: \"%s\"\n", pszFile);
               long lRC = sendFileRaw(hData, localPath(pszFile));
               if (cs.quiet < 2)
                  printf("send file done, RC %ld\n", lRC);
            }
            closesocket(hData); hData = INVALID_SOCKET;
            if (sendLine(hClient, "226 Closing data connection")) break; // 226, 250
         }
         else
         if (!strncmp(szLineBuf, "STOR ", 5)) 
         {
            nbail=0;
            if (hData == INVALID_SOCKET) {
               sendLine(hClient, "500 internal error 1");
               continue;
            }
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW)
               sendLine(hClient, "500 write forbidden");
            else {
               // receive file
               char *pszFile = szLineBuf2+5;
               if (isPathTraversal(pszFile, bDeep)) {
                  sendLine(hClient, "500 forbidden path");
               } else {
                  if (sendLine(hClient, "150 Receiving File")) break;
                  if (cs.quiet < 2)
                     printf("recv file: \"%s\"\n", pszFile);
                  long lRC = receiveFileRaw(hData, localPath(pszFile), -1);
                  if (cs.quiet < 2)
                     printf("recv file done, RC %ld\n", lRC);
               }
            }
            closesocket(hData); hData = INVALID_SOCKET;
            if (sendLine(hClient, "226 Closing data connection")) break; // 226, 250
         }
         else
         if (!strncmp(szLineBuf, "QUIT", 4)) { nbail=0;
            break;
         }
         else
         if (   strBegins(szLineBuf, "SGET ")
             || strBegins(szLineBuf, "SOPEN ")
            )
         { 
            nbail = 0;

            bool bBlockMode = 0;

            // save linebuf as it's reused below
            strcpy(szLineBuf2, szLineBuf);
            char *pszFile = szLineBuf2+5;

            if (strBegins(szLineBuf, "SOPEN ")) {
                 bBlockMode = 1;
                 pszFile = szLineBuf2+6;
            }

            // sft file retrieve, within control connection
            char *pszLocFile = localPath(pszFile);
            if (isPathTraversal(pszFile, bDeep)) {
               sendLine(hClient, "500 forbidden path");
            }
            else 
            if (!fileExists(pszLocFile)) {
               sendLine(hClient, "500 no such file, or unreadable");
            } else {
               sendLine(hClient, "200 OK, data follows");
               if (cs.quiet < 2)
                  printf("< send sft file: \"%s\" %s\n", pszFile, bBlockMode ? "[block mode]":"");
               // sending a file from server to client by SFT: here, the ack "OK\n\n"
               // is often overhauled by connection close from client, therefore server
               // doesn't verify it. should there be errors, then they're shown at client only.
               Coi *pcoi = new Coi(pszLocFile, 0);
               CoiAutoDelete odel(pcoi, 0); // no decref
               long lRC = putFileBySFT(hClient, pcoi, nSFTVer, 0, 1, bBlockMode); // not quiet, ignore ack
               if (cs.quiet < 2 && lRC > 0)
                  printf("send sft file done, RC %ld\n", lRC);
            }
         }
         else
         if (!strncmp(szLineBuf, "SPUT ", 5)) { nbail=0;
            if (!bRW)
               sendLine(hClient, "500 write forbidden");
            else {
               // sft receive file, via control connection
               strcpy(szLineBuf2, szLineBuf);
               char *pszFile = szLineBuf2+5;
               char *pszLocFile = localPath(pszFile);
               if (isPathTraversal(pszFile, bDeep)) {
                  sendLine(hClient, "500 forbidden path");
                  break; // block potential content coming
               }
               if (bDeep)
                  createOutDirTree(pszLocFile);
               if (!isWriteable(pszLocFile)) {
                  sendLine(hClient, "500 cannot write file");
                  // break;
               } else {
                  sendLine(hClient, "200 OK, send data");
                  if (cs.quiet < 2)
                     printf("> recv sft file: \"%s\"\n", pszFile);
                  long lRC = getFileBySFT(hClient, pszLocFile, nSFTVer);
                  if (cs.quiet < 2 && lRC > 0)
                     printf("recv sft file done, RC %ld\n", lRC);
                  if (lRC) break; // block potential content remainder
               }
            }
            // getFileBySFT includes ack send
         }
         else
         if (!strncmp(szLineBuf, "SLST", 4)) 
         { 
            nbail=0;
            // path is ignored. list only current dir.
            strcpy(szLineBuf2, szLineBuf);
            if (sendLine(hClient, "150 Listing Directory")) break;
            long lFiles=0, lDirs=0, lRC=0;
            num nBytes=0;
            if (strlen(szLineBuf2) > 7)
            {
               // client wants to list a specific dir tree
               #ifdef DEEP_FTP
               char *pszTree = szLineBuf2 + 5;
               // strip trailing slash
               long nlen = strlen(pszTree);
               if (nlen > 0 && pszTree[nlen-1]=='/' || pszTree[nlen-1]=='\\')
                  pszTree[nlen-1] = '\0';
               long nLocalDirs  = 0, nLocalFiles = 0;
               num  nLocalBytes = 0;
               FileList oDirFiles;
               num nLocalMaxTime = 0, nTreeMaxTime = 0;
               char *pszRoot = glblFileSet.root(1); // or null
               Coi *pcoi = 0;
               #ifdef VFILEBASE
               if (pcoi = glblVCache.get(pszTree)) {
                  mtklog("wat: ... reusing root from vcache");
               }
               else
               #endif // VFILEBASE
               {
                  pcoi = new Coi(pszTree, pszRoot);
                  pcoi->incref("slst");
               }
               CoiAutoDelete odel(pcoi, 1); // with decref
               hGlblTCPOutSocket = hClient;
               bGlblFTPListFlatTS = 1;
               nGlblFunc = eFunc_FTPList;
               lRC = walkFiles(pcoi, 0, nLocalFiles, oDirFiles, nLocalDirs, nLocalBytes, nLocalMaxTime, nTreeMaxTime);
               #else
               sendLine(hClient, "Path ignored - listing only current dir.");
               hGlblTCPOutSocket = hClient;
               bGlblFTPListFlatTS = 1;
               lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
               #endif
            }
            else
            {
               hGlblTCPOutSocket = hClient;
               // we're talking SFT with an sfk client, therefore we can send
               // an sfk-style dir listing with full, flat timestamps.
               bGlblFTPListFlatTS = 1;
               lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
            }
            if (cs.quiet < 2)
               printf("dir done, RC %ld, %ld files.\n", lRC, lFiles);
            if (sendLine(hClient, "226 Listing Done")) break; // 226, 250
         }
         else
         if (!strncmp(szLineBuf, "SRUN", 4)) { nbail=0;
            // execute user command, IF -run option was set
            if (!bRun)
               sendLine(hClient, "500 run forbidden");
            else 
            if (!szClientPW[0] || !pszRunPW)
               sendLine(hClient, "500 run requires authentication");
            else
            if (strcmp(szClientPW, pszRunPW)) {
               printf("/%s/%s/\n",szClientPW, pszRunPW);
               sendLine(hClient, "500 wrong authentication");
            }
            else
            {
               strcpy(szLineBuf2, szLineBuf);
               // if (sendLine(hClient, "150 Running Command")) break;
               char *pszCmd = szLineBuf2+5;
               lRC = system(pszCmd);
               sprintf(szLineBuf2, "200 Run Done, RC %ld", lRC);
               if (sendLine(hClient, szLineBuf2)) break; // 226, 250
            }
         }
         else
         if (!strncmp(szLineBuf, "SKIP ", 5)) { nbail=0;
            // dummy record follows, to enforce line flush.
            // should be far smaller than abBuf.
            ulong nLen = (ulong)atol(szLineBuf+5);
            if (nLen > sizeof(abBuf)-10) nLen = sizeof(abBuf)-10;
            if (nLen) receiveBlock(hClient, abBuf, nLen, "SKIP");
            // no ack sending
         }
         else {
            if (sendLine(hClient, "500 not supported")) break;
            // count invalid command, maybe connection is out of control:
            nbail++;
            // on 3rd invalid command, connection will be dropped.
         }
      }  // endwhile

      if (cs.quiet < 2)
         printf("disconnecting client\n");
      closesocket(hClient);
   }

   closesocket(hServer);

   #ifdef _WIN32
   WSACleanup();
   #endif

   return 0;
}

#endif // WITH_TCP

#ifndef USE_SFK_BASE

class TestDB
{
public:
   TestDB   (char *pszFile);
  ~TestDB   ( );
   long     load     (bool bSilent);
   long     write    ( );
   void     shutdown ( );

   long     update   (char *pszInKey, char *pszInVal);
   char    *getValue (char *pszInKey);

private:
   char  *pszClFile;
   StringTable clKeys;
   StringTable clVals;
};

TestDB::TestDB(char *pszFile)
{
   pszClFile = strdup(pszFile);
}

TestDB::~TestDB() { shutdown(); }

void TestDB::shutdown() {
   if (pszClFile) { delete [] pszClFile; pszClFile = 0; }
}

// uses szLineBuf
long TestDB::load(bool bSilent) {
   FILE *fin = fopen(pszClFile, "r");
   if (!fin) {
      if (!bSilent)
         perr("unable to load %s\n", pszClFile); 
      return 9; 
   }
   long nLine = 0;
   while (fgets(szLineBuf, sizeof(szLineBuf)-10, fin)) {
      nLine++;
      removeCRLF(szLineBuf);
      char *psz = strchr(szLineBuf, ':');
      if (!psz) {
         perr("wrong record format in %s line %ld\n", pszClFile, nLine); 
         fclose(fin);
         return 9; 
      }
      *psz = '\0';
      char *pszVal = psz+1;
      char *pszKey = szLineBuf;
      clKeys.addEntry(pszKey);
      clVals.addEntry(pszVal);
   }
   fclose(fin);
   return 0;
}

long TestDB::write() {
   FILE *fout = fopen(pszClFile, "w");
   if (!fout) return 9+perr("unable to write %s\n", pszClFile);
   long nRec = clKeys.numberOfEntries();
   for (long i=0; i<nRec; i++) {
      char *pszKey = clKeys.getEntry(i, __LINE__);
      char *pszVal = clVals.getEntry(i, __LINE__);
      if (!pszKey || !pszVal) { fclose(fout); return 9; }
      fprintf(fout, "%s:%s\n", pszKey, pszVal);
   }
   fclose(fout);
   return 0;
}

long TestDB::update(char *pszInKey, char *pszInVal) {
   long nRec = clKeys.numberOfEntries();
   for (long i=0; i<nRec; i++) {
      char *pszKey = clKeys.getEntry(i, __LINE__);
      char *pszVal = clVals.getEntry(i, __LINE__);
      if (!pszKey || !pszVal) return 9;
      if (!strcmp(pszKey, pszInKey)) {
         clVals.setEntry(i, pszInVal);
         return 0;
      }
   }
   // not yet contained:
   clKeys.addEntry(pszInKey);
   clVals.addEntry(pszInVal);
   return 0;
}

char *TestDB::getValue(char *pszInKey) {
   long nRec = clKeys.numberOfEntries();
   for (long i=0; i<nRec; i++) {
      char *pszKey = clKeys.getEntry(i, __LINE__);
      char *pszVal = clVals.getEntry(i, __LINE__);
      if (!pszKey || !pszVal) return 0;
      if (!strcmp(pszKey, pszInKey))
         return pszVal;
   }
   return 0;
}

#endif // USE_SFK_BASE

#ifndef USE_SFK_BASE
extern int patchMain(int argc, char *argv[], int noffs);
#endif // USE_SFK_BASE

static bool skipspace(char **ppsz) {
   char *psz = *ppsz;
   while (*psz && isspace(*psz))
      psz++;
   *ppsz = psz;
   return (*psz != 0);
}

static bool skipto(char **ppsz, char c) {
   char *psz = *ppsz;
   while (*psz && *psz != c)
      psz++;
   *ppsz = psz;
   return (*psz != 0);
}

long copyFormStr(char *pszDst, long nMaxDst, char *pszSrc, long nSrcLen, ulong nflags)
{
   // flags: bit 0: convert also \, to ,

   // printf("copyFormStr \"%.*s\" %ld\n",(int)nSrcLen,pszSrc,nflags);

   char *pszin = pszSrc;
   long iout = 0;
   while (*pszin && (nSrcLen > 0))
   {
      if (iout >= nMaxDst-10)
         return 9+perr("format string too long: \"%s\"\n", pszSrc);

      if (!cs.spat)
         { } // skip all following interpretations
      else
      if (nSrcLen>=4 && !strncmp(pszin, "\\x", 2)) {
         // \xnn - any character with hex code nn
         pszin+=2; nSrcLen-=2; // skip \x
         long nhex = getTwoDigitHex(pszin);
         if (nhex <= 0) return 9+perr("illegal value for \\xnn in format string. use 01 to FF, e.g. \\x09\n");
         pszin+=2; nSrcLen-=2; // skip nn
         pszDst[iout++] = (char)nhex;
         continue;
      }
      else
      if (nSrcLen>=2) {
         if (!strncmp(pszin, "\\\\", 2))
            { pszDst[iout++] = '\\'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\t", 2))
            { pszDst[iout++] = '\t'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\q", 2))
            { pszDst[iout++] = '"'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\n", 2))
            { pszDst[iout++] = '\n'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\r", 2))
            { pszDst[iout++] = '\r'; pszin+=2; nSrcLen-=2; continue; }
         else
         if ((nflags & 1) && !strncmp(pszin, "\\,", 2))
            { pszDst[iout++] = ','; pszin+=2; nSrcLen-=2; continue; }
      }
      pszDst[iout++] = *pszin++; 
      nSrcLen--;
   }
   pszDst[iout] = '\0';
   // printf("-> \"%s\"\n",pszDst);
   return 0;
}

#ifndef USE_SFK_BASE

class Phraser;

class Symbol
{
public:
   Symbol   (char *pszName, Phraser *parent);
   void     collect(char *pszContent);
   char    *name() { return szClName; }
   char    *solve(char *pout, long nmaxout, long nlevel);
private:
   char     szClName[100];
   char     szClOpt[100];
   char     szClCont[1024];
   char     szClBuf[100];
   char     szClBuf2[200];
   Phraser  *phraser;
};

class Phraser
{
public:
   Phraser  ();
   long     load(char *pszFile);
   char    *solve(char *psz);
   long     add(Symbol *p);
   Symbol  *get(char *pszName);
   void     reset();
private:
   void     fetch(char *pbuf, char *psrc, long nlen);
   char     *pszClFilename;
   char     szClBuf1[200];
   char     szClOut[10000];
   Symbol   *psym[1000];
   long     nsym;
};

Symbol::Symbol(char *pszName, Phraser *parent)
{
   szClOpt[0] = '\0';
   if (cs.debug)
      printf(" create symbol: %s\n", pszName);
   char *pszopt = strchr(pszName, ',');
   if (pszopt) {
      strncpy(szClName, pszName, pszopt-pszName);
      szClName[pszopt-pszName] = '\0';
      strcopy(szClOpt, pszopt);
   } else {
      strcopy(szClName, pszName);
   }
   memset(szClCont, 0, sizeof(szClCont));
   phraser = parent;
}

void Symbol::collect(char *pszContent)
{
   if (cs.debug)
      printf("   %s collects \"%s\"\n", szClName, pszContent);
   strcat(szClCont, pszContent);
   // replace escaped ,, by internal replacement code
   char *psz = szClCont;
   while (psz = strstr(psz, ",,")) {
      *psz++ = 0x01;
      memmove(psz, psz+1, strlen(psz)); // incl. zero term.
   }
   if (cs.debug)
      printf("   %s now holds \"%s\"\n", szClName, szClCont);
}

char *Symbol::solve(char *pout, long nmaxout, long nlevel)
{
   if (cs.debug)
      printf(" %s solves \"%s\"\n", szClName, szClCont);

   char *pcont = szClCont;

   // if comma-separated phrases are given,
   // which are not escaped like \,
   bool biscsep = 0;
   char clast = 0;
   char *psz = 0;
   for (psz=pcont; *psz; psz++) {
      if (*psz == ',' && clast != '\\')
         {  biscsep=1; break; }
      clast = *psz;
   }

   if (biscsep)
   {
      // then random-select phrase

      // count phrases
      long nwords = 0;
      char *psz1 = pcont;
      for (clast=0; *psz1; psz1++) {
         if (*psz1 == ',' && clast != '\\')
            nwords++;
         clast = *psz1;
      }
      nwords++;

      // select a phrase
      long itarg = rand() % nwords;
      long iword = 0;
      psz1 = pcont;
      while (psz1 && *psz1) 
      {
         char *psz2 = psz1;
         for (clast=0; *psz2; psz2++) {
            if (*psz2 == ',' && clast != '\\')
               break;
            clast = *psz2;
         }
         if (iword == itarg) {
            mystrcopy(szClBuf2, psz1, psz2-psz1+1);
            if (cs.debug)
               printf("   sel \"%s\"\n", szClBuf2);
            pcont = szClBuf2;
            break;
         }
         iword++;
         if (*psz2 == ',') psz2++;
         while (*psz2 == ' ') psz2++;
         psz1 = psz2;
      }
      if (pcont == szClCont) {
         perr("syntax error: probably too many commas in line: %s\n",szClCont);
         return 0;
      }
   }

   long iout = strlen(pout);

   if (!strchr(pcont, '$')) {
      // solve terminal
      strcat(pout, pcont);
   } else {
      // solve non-terminal
      char *psz1 = pcont;
      while (psz1 && *psz1) 
      {
         char *psz2 = psz1;
         // find next sub symbol call, if any
         while (*psz2 && *psz2 != '$') psz2++;
         if (*psz2 == '$') 
         {
            // flush pre-symbol content
            if (psz2 > psz1) {
               mystrcopy(szClBuf, psz1, psz2-psz1+1);
               if (cs.debug)
                  printf("   cat \"%s\"\n", szClBuf);
               strcat(pout, szClBuf);
            }
            // then solve sub symbol
            char *psz3 = psz2+1;
            while (*psz3 && *psz3 != ' ' && *psz3 != 0x01 && !ispunct(*psz3)) psz3++;
            mystrcopy(szClBuf, psz2, psz3-psz2+1); // +1 for mystrcopy
            if (cs.debug)
               printf("  call \"%s\"\n", szClBuf);
            Symbol *psub = phraser->get(szClBuf);
            if (!psub) { perr("no such symbol: %s\n", szClBuf); return 0; }
            if (!psub->solve(pout, nmaxout, nlevel+1)) return 0;
            psz1 = psz3;
            if (cs.debug)
               printf("   now on \"%s\"\n",psz1);
            // strcat(pout, " ");
            continue;
         }
         // none found: flush rest of line
         if (cs.debug)
            printf("   cat \"%s\"\n", psz1);
         strcat(pout, psz1);
         // strcat(pout, " ");
         break;
      }
   }

   // post-process output:
   // printf("%02ld appended \"%s\" at offs %ld\n",nlevel,pout+iout,iout);

   // apply options, if any
   long nlen = strlen(pout);
   if (strstr(szClOpt, "upper") || strstr(szClOpt, "anycase"))
   {
      // random-vary word casing
      long ncase = 0;
      if (strstr(szClOpt, "anycase")) ncase = rand() % 4;
      if (strstr(szClOpt, "upper2"))  ncase = rand() % 2;
      // printf("%02ld MIXCASE %ld %c of %.30s\n",nlevel,ncase,pout[iout],pout+iout);
      long i=0;
      switch (ncase) {
         case 0: pout[iout] = toupper(pout[iout]); break;
         case 1:
            for (i=iout; i<nlen; i++)
               pout[i] = toupper(pout[i]);
            break;
         case 2: pout[iout] = tolower(pout[iout]); break;
         case 3:
            for (i=iout; i<nlen; i++)
               pout[i] = tolower(pout[i]);
            break;
         // case 4: break; // leave as it is
      }
   }

   // convert format strings
   for (psz=pout+iout; *psz; psz++) {
      char brep=0;
      if (clast == '\\')
       switch (*psz) {
         case ',' : brep=',' ; break;
         case 't' : brep='t' ; break;
         case 'n' : brep='n' ; break;
         case '\\': brep='\\'; break;
       }
      if (brep) {
         // standing on "," of "\,"
         psz--;
         memmove(psz, psz+1, strlen(psz+1)+1);
         clast = 0;
         *psz = brep;
      } else {
         clast = *psz;
      }
   }

   return pout;
}

Phraser::Phraser()
{
   pszClFilename = 0;
   memset(szClBuf1, 0, sizeof(szClBuf1));
   memset(psym, 0, sizeof(psym));
   nsym = 0;
}

void Phraser::reset()
{
   for (long i=0; i<nsym; i++)
      delete psym[i];
   nsym = 0;
}

long Phraser::add(Symbol *p)
{
   if (nsym > (sizeof(psym)/sizeof(Symbol*))-5)
      return 9+perr("too many symbols\n");
   psym[nsym++] = p;
   return 0;
}

Symbol *Phraser::get(char *pszName)
{
   for (long i=0; i<nsym; i++) {
      if (!psym[i])
         return 0;
      if (!strcmp(psym[i]->name(), pszName))
         return psym[i];
   }
   return 0;
}

void Phraser::fetch(char *pbuf, char *psrc, long nlen) {
   if (nlen > sizeof(szClBuf1)-4)
      {  perr("buffer overflow.1\n"); exit(9); }
   strncpy(pbuf, psrc, nlen);
   pbuf[nlen] = '\0';
}

long Phraser::load(char *pszFile)
{
   FILE *fin = fopen(pszFile, "r");
   if (!fin) return 9+perr("cannot read: %s\n", pszFile);

   char *pszSymb = 0;
   Symbol *ps = 0;
   long nstate = 1, nline = 0;
   while (fgets(szLineBuf, sizeof(szLineBuf)-10, fin))
   {
      // symbol: word1 word2 $symbol word4
      //         word5 $symbol word6 ...
      removeCRLF(szLineBuf);
      nline++;

      if (cs.debug)
         printf("LINE \"%s\"\n", szLineBuf);

      char *psz1 = szLineBuf;

      while (psz1 && *psz1)
      {
         if (cs.debug)
            printf("state %ld on \"%s\"\n", nstate, psz1);
         char *psz2 = psz1;
         switch (nstate) 
         {
            case 1:  // expect new symbol name
               if (!skipto(&psz2, ':'))
                  return 9+perr("syntax error: missing \"symbol:\" in line %ld\n", nline);
               fetch(szClBuf1, psz1, psz2-psz1);
               pszSymb = szClBuf1;
               psz1 = psz2+1;
               nstate = 2;
               break;

            case 2:  // expect content in symbol name line
               if (!skipspace(&psz2))
                  return 9+perr("syntax error: missing content after \"%s:\"\n", pszSymb);
               ps = new Symbol(pszSymb, this);
               if (add(ps)) return 9;
            case 4:
               if (!skipspace(&psz2))
                  return 9+perr("syntax error in line %ld\n",nline);
               ps->collect(psz2);
               psz1 = 0;
               nstate = 3;
               break;

            case 3:  // either additional content, or new symbol name
               if (*psz2 == ' ') {
                  // additional content
                  ps->collect("\n");
                  nstate = 4;
                  continue;
               } else {
                  // new symbol name
                  nstate = 1;
                  continue;
               }
         }
      }
   }

   fclose (fin);
   return 0;
}

char *Phraser::solve(char *pszName)
{
   // e.g. solving "all"
   Symbol *proot = get(pszName);
   if (!proot) return 0;
   szClOut[0] = '\0';
   char *pres = proot->solve(szClOut, sizeof(szClOut)-10, 0);
   // convert ,, replacement code back to printable ,
   if (pres) {
      char *psz = pres;
      while (psz = strchr(psz, 0x01))
         *psz++ = ',';
   }
   return pres;
}

#endif // USE_SFK_BASE

long encodeUrl(char *pszSrcIn, char *pszDstIn, long nMaxDst)
{
    char *pszSrc = pszSrcIn;
    char *pszDst = pszDstIn;

    // mtklog("ENCODE \"%s\"\n",pszSrc);

    static const char *pszUnsafe = "\"<>%\\^[]`+$,@:;/!#?=&";
    long nrem = nMaxDst-2;
    for (; *pszSrc; pszSrc++)
    {
        uchar uc = (uchar)*pszSrc;
        if (    strchr(pszUnsafe, (char)uc)
            ||  uc <= 32
            ||  uc >= 123
            )
        {
            if (nrem < 4) {
                *pszDst = '\0'; 
                // mtklog("OFLOW: \"%s\", \"%s\"", pszSrcIn, pszDstIn);
                return 9+perr("encodeUrl buffer overflow\n"); 
            }
            sprintf(pszDst, "%%%02X", uc);
            pszDst += 3;
            nrem   -= 3;
        }
        else {
            *pszDst++ = (char)uc;
            nrem--;
        }
    }
    *pszDst = '\0';
    return 0;
}

long decodeUrl(char *pszInOut, long nMaxDst)
{
    char *psz = pszInOut;
    while (*psz) {
        if (    *psz == '%'
            &&  isxdigit(*(psz+1))  // also catches terminator
            &&  isxdigit(*(psz+2))  // also catches terminator
           )
        {
            char ahex[10];
            ahex[0] = *(psz+1);
            ahex[1] = *(psz+2);
            ahex[2] = '\0';
            uchar abin[10];
            if (hexToBin(ahex, abin, 1)) {
                if (!cs.quiet)
                    pwarn("wrong url entity code: %%%s\n", ahex);
                psz++;
            } else {
                *psz = (char)abin[0];
                psz++;
                memmove(psz, psz+2, strlen(psz+2)+1); // incl. terminator
            }
        }
        else
            psz++;
    }
    return 0;
}

// -------- base64 en/decoding ----------

static const char aenc64[] = 
   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
   "0123456789+/";

void encodeSub64(uchar in[3], uchar out[4], int nlen)
{
   out[0] = aenc64[in[0] >> 2];
   out[1] = aenc64[((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
   out[2] = (uchar)(nlen > 1 ? aenc64[((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6)] : '=');
   out[3] = (uchar)(nlen > 2 ? aenc64[in[2] & 0x3f ] : '=');
}

// rc  0: ok
// rc >0: error
long encode64(uchar *psrc, int nsrc, uchar *pdst, int nmaxdst, int nlinechars)
{
   uchar in[3], out[4];
   int i=0, nlen=0, nchars = 0;

   uchar *pmaxsrc = psrc + nsrc;
   uchar *pmaxdst = pdst + nmaxdst;
   
   while (psrc < pmaxsrc)
   {
      nlen = 0;
      for (i = 0; i < 3; i++ ) 
      {
         if (psrc < pmaxsrc) {
            in[i] = *psrc++;
            nlen++;
         } else {
            in[i] = 0;
         }
      }
      if (nlen) {
         encodeSub64(in, out, nlen);
         for (i = 0; i < 4; i++ ) {
            if (pdst >= pmaxdst-1)
               return 9;   // output buffer overflow
            *pdst++ = out[i];
         }
         nchars++;
      }
      if (nchars >= (nlinechars/4) || (psrc >= pmaxsrc)) {
         if (nchars) {
            if (pdst < pmaxdst-3) {
               *pdst++ = '\r';
               *pdst++ = '\n';
            }
         }
         nchars = 0;
      }
   }

   // zero terminate output as it's a string
   *pdst = '\0';

   return 0;
}

void decodeSub64(uchar in[4], uchar out[3])
{   
   out[0] = (uchar)(in[0] << 2 | in[1] >> 4);
   out[1] = (uchar)(in[1] << 4 | in[2] >> 2);
   out[2] = (uchar)(((in[2] << 6) & 0xc0) | in[3]);
}

// return valid value+1, or 0 if it is noise.
uchar mapchar(char ch)
{
   if ((ch >= 'A') && (ch <= 'Z'))
      return (uchar)(ch - 'A')+1;
   else if ((ch >= 'a') && (ch <= 'z'))
      return (uchar)(ch - 'a' + 26)+1;
   else if ((ch >= '0') && (ch <= '9'))
      return (uchar)(ch - '0' + 52)+1;
   else if (ch == '+')
      return 62+1;
   else if (ch == '/')
      return 63+1;
   return 0;
}

// result: number of bytes decoded, or -1 on error
long decode64(uchar *psrc, int nsrc, uchar *pdst, int nmaxdst)
{
   uchar in[4], out[3], v;
   int i=0, nlen=0;
   
   uchar *pmaxsrc = psrc + nsrc;
   uchar *pmaxdst = pdst + nmaxdst;
   uchar *pdstraw = pdst;

   while (psrc < pmaxsrc) {
      for (nlen=0, i=0; i < 4 && (psrc < pmaxsrc); i++ ) {
         v = 0;
         while ((psrc < pmaxsrc) && v == 0) {
            v = *psrc++;
            v = mapchar(v);
         }
         if (psrc < pmaxsrc) {
            nlen++;
            if (v) in[i] = v - 1;
         } else {
            in[i] = 0;
         }
      }
      if (nlen) {
         decodeSub64(in, out);
         for (i=0; i<nlen-1; i++) {
            if (pdst >= pmaxdst)
               return -1;
            *pdst++ = out[i];
         }
      }
   }

   // no zero termination as it's a binary

   return pdst - pdstraw;
}

// convert "*pattern" or "pattern*" to pattern with left/right flags isolated.
long copyMatchPattern(char *pszDst, long nMaxDst, char *pszSrc, long &rSrcLen,
   bool &rFromLeft, bool &rToRight, bool &rForceRepeat
   )
{
   rFromLeft = 0;
   rToRight  = 0;
   long icopyoff  = 0;
   long nSrcLen   = rSrcLen;
   long ncopylen  = nSrcLen;
   if (cs.wpat && pszSrc[0] == '*') {
      rFromLeft = 1;
      rForceRepeat = 1;
      icopyoff++;
      ncopylen--;
   }
   if (cs.wpat && ncopylen > 0 && pszSrc[nSrcLen-1] == '*') {
      long nslash = 0;
      if (cs.spat) {
         // the '*' might be escaped, as in \\\\\*
         // if there is an EVEN (or zero) no. of slashes before '*',
         // then '*' really is an active wildcard.
         for (long k=nSrcLen-2; k>=0; k--) {
            if (pszSrc[k] == '\\')
               nslash++;
            else
               break;
         }
      }
      if (!(nslash & 1)) {
         rToRight = 1;
         rForceRepeat = 1;
         ncopylen--;
      }
   }
   if (ncopylen > nMaxDst-1) return 9+perr("buffer overflow: pattern too large: \"%s\"\n", pszSrc);
   memcpy(pszDst, pszSrc+icopyoff, ncopylen);
   pszDst[ncopylen] = '\0';
   rSrcLen = ncopylen;
   return 0;
}

long reperr(char *pszMsg, char *pszObj, long nLine=-1)
{
   if (nLine >= 0)
      perr("%s: %s [line %ld]\n", pszMsg, pszObj, nLine);
   else
      perr("%s: %s\n", pszMsg, pszObj);
   pinf("patterns must look like _src_dst_ or \"/from/ to /\"\n");
   pinf("if \"%s\" is a single filename, specify it as first parameter.\n", pszObj);
   if (strchr(pszObj, '\"')) {
      pinf("surround your expression by two double quotes \"\n");
      pinf("escape inner quotes as \\\" or \\q (with -spat option)\n");
   }
   pinf("say -dir ... -file ... to specify multiple target files.\n");
   nGlblError = 1; // disable memory leak listing on parameter errors
   return 9;
}

// io: szLineBuf. also uses szLineBuf2.
// io: szAttrBuf. also uses szAttrBuf2.
long applyReplace(char *pszPat, long &rHitCnt, bool blstart, bool blend)
{
   // _src_dest_
   char szSrc[200];
   char szDst[200];

   // isolate source and destination.
   char *psz1 = pszPat;
   char cbnd = '\0'; // boundary char
   if (*psz1) cbnd = *psz1++;
   char *pszSrc1 = psz1;
   while (*psz1 && (*psz1 != cbnd))
      psz1++;
   if (!*psz1) return 9+perr("illegal replacement string \"%s\"\n", pszPat);
   char *pszSrc2 = psz1;
   psz1++;
   char *pszDst1 = psz1;
   while (*psz1 && (*psz1 != cbnd))
      psz1++;
   if (!*psz1) return 9+perr("illegal replacement string \"%s\"\n", pszPat);
   char *pszDst2 = psz1;
   long nSrcLen = pszSrc2-pszSrc1;
   int nDstLen = pszDst2-pszDst1;
   if (nSrcLen < 1) return 9+perr("source pattern is empty\n");
   if (nSrcLen > sizeof(szSrc)-10) return 9+perr("source pattern too large \"%.*s\"\n", nSrcLen, pszSrc1);
   if (nDstLen > sizeof(szDst)-10) return 9+perr("destination pattern too large \"%.*s\"\n", nDstLen, pszDst1);
   psz1++; // step past final cbnd
   if (*psz1) {
      perr("wrong replacement string syntax \"%s\"\n", pszPat);
      pinf("if \"%c\" is the delimiter then \"%s\" is unexpected.\n",cbnd,psz1);
      return 9;
   }

   if (cs.debug)
      printf("aprep: input src %.*s\n", (int)nSrcLen, pszSrc1);

   // if source starts or ends with *
   bool bFromLeft    = 0;
   bool bToRight     = 0;
   bool bForceRepeat = 0;  // repeat replace although *\\ etc supplied
   if (copyMatchPattern(szSrc, sizeof(szSrc)-10, pszSrc1, nSrcLen, bFromLeft, bToRight, bForceRepeat))
      return 9;
   // -> sets szSrc, nSrcLen, bFromLeft, bToRight.

   if (nSrcLen < 1)
      return 9+perr("wrong source pattern. try \\%c or option -literal to replace %c\n",glblWildChar,glblWildChar);

   // convert \\ \t \n \r \x in destination
   if (copyFormStr(szDst, sizeof(szDst)-10, pszDst1, nDstLen))
      return 9;
   // if (cs.debug) printf("replace dst \"%.*s\" => \"%s\" len %ld => %ld\n",(int)nDstLen,pszDst1,szDst,nDstLen,strlen(szDst));
   nDstLen = strlen(szDst); // adapt to \t, \x conversions

   long nflags = cs.usecase ? eMatchCase : 0;
   long ifirst=0, ihitlen=0;

   if (cs.debug)
      printf("aprep: fromleft %d toright %d szsrc %s\n", bFromLeft, bToRight, szSrc);

   // apply replacements
   psz1 = szLineBuf;
   long ibase   = 0; // used ONLY for single line end replacing
   long ntmplen = strlen(szLineBuf); // ditto
   while (1)
   {
      ifirst=0; ihitlen=0;
      if (!matchstr(psz1+ibase, szSrc, nflags, ifirst, ihitlen))
         break;

      // replace start of line?
      if (blstart) {
         if (ifirst != 0)
            break; // no hit
         // else fall through. there is no further loop cycle.
      }

      // replace end of line?
      if (blend) {
         if ((ibase+ifirst+ihitlen) != ntmplen) {
            // no hit as it's not (yet) at line end:
            // step-thru by incrementing ibase
            ibase += ifirst+ihitlen;
            continue;
         }
         // found hit: fix ifirst, as rest is ignoring ibase
         ifirst += ibase;
         // fall through. there is no further loop cycle.
      }

      if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
      if (bToRight)   { ihitlen = strlen(psz1+ifirst); }

      psz1   += ifirst;    // to 1st char of hit
      nSrcLen = ihitlen;

      // left part, before hit
      long nLenLeft = psz1-szLineBuf;
      strncpy(szLineBuf2, szLineBuf, nLenLeft);
      szLineBuf2[nLenLeft] = '\0';
      strncpy(szAttrBuf2, szAttrBuf, nLenLeft);
      szAttrBuf2[nLenLeft] = '\0';
      if (cs.debug) printf("rleft \"%s\" ifirst %ld\n",szLineBuf2,ifirst);

      // replace middle part, check output length
      long nLenRep  = strlen(szDst);
      char *pszSrcRite = psz1+nSrcLen;
      long nLenRite = strlen(pszSrcRite);
      if (nLenLeft + nLenRep + nLenRite >= MAX_LINE_LEN) {
         perr("buffer overflow during replace");
         pinf("input lines might be too long, or too many changes per line.\n");
         pinf("if input is stream text, you may try filter -wrap +filter ...\n");
         return 9;
      }
      strcat(szLineBuf2, szDst);
      memset(&szAttrBuf2[nLenLeft], 'a', nLenRep);
      szAttrBuf2[nLenLeft+nLenRep] = '\0';
      if (cs.debug) printf("rmid  \"%s\"\n",szDst);

      // step continue position to post-insert
      psz1 = szLineBuf+strlen(szLineBuf2);

      // right part, after hit
      strcat(szLineBuf2, pszSrcRite);
      strcat(szAttrBuf2, szAttrBuf+nLenLeft+nSrcLen);
      if (cs.debug) printf("rrite \"%s\"\n",pszSrcRite);

      // copy back result
      strcpy(szLineBuf, szLineBuf2);
      strcpy(szAttrBuf, szAttrBuf2);
      if (cs.debug) printf("rout: \"%s\"\n",szLineBuf);

      rHitCnt++;

      // if replacing linestart or lineend
      if (bFromLeft || bToRight)
         if (!bForceRepeat)
            break; // after first hit

      // replacing line start or end is a single operation
      if (blstart || blend)
         break;
   }
   return 0;
}

char aMaskSep[200];
bool isMaskSep(char c) {
   if (strchr(aMaskSep, c))
      return true;
   return false;
}

#define WITH_EVAL

#ifdef WITH_EVAL
static char szGlblFormEvalBuf[MAX_LINE_LEN+100];

// evaluate inner content of "$(column+100)"
int evalFormBlock(char *pfrom, char *pto,
   StringTable &oCol,
   long nSrcLine,
   long nDstLine
   )
{
   char szword[100]; szword[0] = '\0';
   char szform[100]; szform[0] = '\0';

   long ncurval = 0; bool bcurval = 0;
   long nmixval = 0; bool bmixval = 0;
   char ccurop  = '\0';
   bool bquoted = 0;

   static char szFormTmpBuf[MAX_LINE_LEN+100];

   szGlblFormEvalBuf[0] = '\0';
   szFormTmpBuf[0] = '\0';

   char *pOutBuf = szFormTmpBuf;

   int ntype = 0; // 1:string 2:int

   char *psz1 = pfrom;
   char *psz2 = 0;
   for (; *psz1 && (psz1 < pto); psz1=psz2)
   {
      // format spec as first word?
      char *pszf = psz1;
      if (!ntype && !szform[0]) 
      {
         bool bfirst = 1;
         while (*pszf) {
            char c = *pszf;
            if (isdigit(c) || (c=='-' && bfirst) || c=='.' || c=='q')
               pszf++;
            else
               break;
            bfirst = 0;
         }
         // if directly followed by an op, it's not a format
         switch (*pszf) {
            case '+': case '-':
               pszf = psz1;
               break;
         }
         if (pszf > psz1) {
            int nlen = pszf-psz1;
            if (nlen > sizeof(szform)-10)
               return 11+perr("format overflow: %s", psz1);
            memcpy(szform, psz1, nlen);
            szform[nlen] = '\0';
            // check and strip quotation
            bquoted = 0;
            if (nlen > 0 && szform[nlen-1] == 'q') {
               bquoted = 1;
               szform[nlen-1] = '\0';
            }
            psz1 = pszf;
            // if followed by a ':', force as format and skip ':'
            if (*psz1 == ':')
               psz1++;
         }
      }

      // operator or word?
      if (!isalnum(*psz1)) {
         switch (*psz1) {
            case '+':
            case '-':
               ccurop = *psz1;
               psz2 = psz1+1;
               continue;
            default:
               return 6+perr("unexpected: %s", psz1);
         }
      }

      psz2 = psz1;
      while (isalnum(*psz2)) psz2++;

      int nlen = psz2-psz1;
      if (nlen < 1 || nlen > sizeof(szword)-10)
         return 8;
      memcpy(szword, psz1, nlen);
      szword[nlen] = '\0';

      // printf("WORD: %s ntype=%d ccurop=%c\n",szword,ntype,ccurop);

      if (strBegins(szword, "col"))
      {
         // parse column number
         long ncol = atol(szword+3);
         if (ncol < 1 || ncol-1 >= oCol.numberOfEntries()) {
            // non-existing column: leave empty
            // TODO: optionally issue a notice
         } else {
            // use column text
            char *pszcol = oCol.getEntry(ncol-1, __LINE__);
            int nlen = strlen(pszcol);
            int nrem = MAX_LINE_LEN - strlen(pOutBuf);
            // what to do with this column content?
            switch (ntype) {
               default:
                  // string mode: simply append
                  if (nrem < nlen)
                     return 10+perr("string buffer overflow");
                  strcat(pOutBuf, pszcol);
                  ntype = 1;
                  break;
               case 2:
                  // int mode: convert string to int
                  if (!isdigit(*pszcol))
                     return 12+perr("not a number: %s", pszcol);
                  ncurval = atol(pszcol);
                  // int processing is done below
                  break;
            }
         }
      }
      else
      if (!strcmp(szword, "line")) { 
         ncurval = nSrcLine;
         ntype = 2;
      }
      else
      if (!strcmp(szword, "count")) {
         ncurval = nDstLine;
         ntype = 2;
      }
      else
      if (isdigit(szword[0])) {
         ncurval = atol(szword);
         ntype = 2;
      }

      if (ntype == 2)
         switch (ccurop) {
            case '+': nmixval += ncurval; break;
            case '-': nmixval -= ncurval; break;
            default : nmixval += ncurval; break;
         }
   }

   // auto-convert result?
   if (ntype == 2)
      sprintf(pOutBuf, "%ld", nmixval);

   // copy and reformat result
   if (szform[0]) {
      // "-10.10col1" -> "%-10.10s"
      char szform2[50];
      const char *pquot = bquoted ? "\"" : "";
      snprintf(szform2, sizeof(szform2)-10, "%s%%%ss%s", pquot, szform, pquot);
      snprintf(szGlblFormEvalBuf, MAX_LINE_LEN, szform2, pOutBuf);
   } else {
      strcopy(szGlblFormEvalBuf, pOutBuf);
   }

   return 0;
}
#endif

// io: szLineBuf. also uses szLineBuf2.
long applyForm(char *pszPat, bool bBlockSep, long nLineNum, long nOutLineNum)
{
   StringTable oCol;

   // parse szLineBuf, split into columns
   char *psz1 = szLineBuf;
   char *psz2 = 0;

   if (bBlockSep)
      while (*psz1 && isMaskSep(*psz1))
         psz1++;

   while (*psz1)
   {
      psz2 = psz1;
      while (*psz2 && !isMaskSep(*psz2))
         psz2++;

      // have column from psz1 to psz2
      strncpy(szLineBuf2, psz1, psz2-psz1);
      szLineBuf2[psz2-psz1] = '\0';
      oCol.addEntry(szLineBuf2);

      // continue past separator, find next token
      if (bBlockSep) {
         // treat adjacent separators as one
         while (*psz2 && isMaskSep(*psz2))
            psz2++;
      } else {
         if (isMaskSep(*psz2))
            psz2++;
      }

      psz1 = psz2;
   }

   // oCol now holds all columns. apply mask.
   psz1 = pszPat;
   szLineBuf[0] = '\0';
   long iOut = 0;
   char *psz3 = 0;
   char szFormat1[100];
   char szFormat2[100];
   while (*psz1) 
   {
      psz2 = 0;

      if (*psz1==glblRunChar) 
      {
         // parse format info, if any
         psz2 = psz1+1;
         while (*psz2 && !strBegins(psz2, "col") && !strBegins(psz2, "line")
                 && !strBegins(psz2, "count") && !strBegins(psz2, "(")
               )
         {
            // let only -n.q pass as format prefixes
            char c = *psz2;
            if (isdigit(c) || c=='-' || c=='.' || c=='q')
               psz2++;
            else {
               psz2 = 0;
               break; 
            }
         }
      }

      if (psz2 && *psz2)
      {
         long nFormLen = psz2-psz1-1;
         if (nFormLen > sizeof(szFormat1)-10)
            break;
         strncpy(szFormat1, psz1+1, nFormLen);
         szFormat1[nFormLen] = '\0';
         // quoted format prefix?
         bool bquoted = 0;
         if (nFormLen > 0 && szFormat1[nFormLen-1] == 'q') {
            bquoted = 1;
            szFormat1[nFormLen-1] = '\0';
         }
         if (!strncmp(psz2, "col", 3)) 
         {
            // parse column number
            psz2 += 3;
            psz3 = szLineBuf2;
            while (*psz2 && isdigit(*psz2))
               *psz3++ = *psz2++;
            *psz3 = '\0';
            long ncol = atol(szLineBuf2);
            if (ncol < 1 || ncol-1 >= oCol.numberOfEntries()) {
               static bool btold = 0;
               if (!btold) {
                  btold = 1;
               }
            } else {
               // add column
               if (bquoted) strcat(szLineBuf, "\"");
               if (strlen(szFormat1)) {
                  // use specified printf-like format.
                  // we cannot check this - user must know.
                  sprintf(szFormat2, "%%%ss", szFormat1);
                  char *pszcol = oCol.getEntry(ncol-1, __LINE__);
                  sprintf(szLineBuf2, szFormat2, pszcol);
                  strcat(szLineBuf, szLineBuf2);
               } else {
                  char *pszcol = oCol.getEntry(ncol-1, __LINE__);
                  strcat(szLineBuf, pszcol);
               }
               if (bquoted) strcat(szLineBuf, "\"");
            }
         }
         else
         if (!strncmp(psz2, "line", 4)) 
         {
            // insert input line number, counting from 1
            psz2 += 4;
            char szNum[30];
            sprintf(szNum, "%lu", (ulong)nLineNum);
            char *pszcol = szNum;
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, pszcol);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, pszcol);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         else
         if (strBegins(psz2, "count"))
         {
            // insert output line number, counting from 1
            psz2 += strlen("count");
            char szNum[30];
            sprintf(szNum, "%lu", (ulong)nOutLineNum);
            char *pszcol = szNum;
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, pszcol);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, pszcol);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         #ifdef WITH_EVAL
         else
         if (strBegins(psz2, "("))
         {
            psz2++;
            char *pfrom = psz2;
            psz2 = strchr(psz2, ')');
            if (!psz2)
               return 9+perr("missing ')' on expression: %s", psz1);
            char *pto = psz2; // exclusive
            psz2++;
            int nrc = evalFormBlock(pfrom, pto, oCol, nLineNum, nOutLineNum);
            if (nrc)
               return 9+perr("cannot evaluate: %s (rc=%d)", pfrom, nrc);
            // result is in szGlblFormEvalBuf
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, szGlblFormEvalBuf);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, szGlblFormEvalBuf);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         #endif
         else
         if (strBegins(psz2, "(count"))
         {
            // insert output line number, counting from 1
            psz2 += strlen("(count");
            long nCntOffset = atol(psz2);
            psz2 = strchr(psz2, ')');
            if (!psz2)
               return 9+perr("(count not closed by ')'");
            psz2++;
            char szNum[30];
            sprintf(szNum, "%ld", (long)(nOutLineNum+nCntOffset));
            char *pszcol = szNum;
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, pszcol);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, pszcol);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         iOut = strlen(szLineBuf);
         // continue past token, including separator
         psz1 = psz2;
      } else {
         // apply \\t and \\xnn replacements, else copy
         if (cs.spat && !strncmp(psz1, "\\\\", 2)) {
            szLineBuf[iOut++] = '\\';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\t", 2)) {
            szLineBuf[iOut++] = '\t';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\q", 2)) {
            szLineBuf[iOut++] = '"';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\n", 2)) {
            szLineBuf[iOut++] = '\n';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\r", 2)) {
            szLineBuf[iOut++] = '\r';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\x", 2)) {
            long n = getTwoDigitHex(psz1+2);
            if (n <= 0) return 9+perr("wrong syntax or not supported: %s\n", psz1);
            szLineBuf[iOut++] = (char)n;
            psz1 += 4;
         }
         else
            szLineBuf[iOut++] = *psz1++;
         szLineBuf[iOut] = '\0';
      }
   }

   return 0;
}

struct FilterParms 
{
   char  **argv;
   long  iPat;
   long  nPat;
   bool  bVerb;
   bool  bLNum;
   bool  bCnt;
   bool  bReWrite;
   bool  bDumpLF;
   bool  bSingleFile;
   bool  bSkipBinaries;
   bool  bFilenames;
   bool  bPassHitFiles;
   long  nTotalRC;
   char *pBlockMark;
   long  nprecon;
   long  npostcon;
   char  cprecolor;
   char  cpostcolor;
   char *pPreConMark;
   char *pPostConMark;
}
gfilter; // global filter settings

#define MAX_CONTEXT_LINES 105
class FilterContextLines
{
public:
      FilterContextLines   ( );
      void  shutdown       ( );

   void  putLine  (char *psz);
   char *getLine  (int   iPreIndex);
   void  reset    ( );

   char  szClLineTmp [MAX_LINE_LEN+100];
   char  szClAttrTmp [MAX_LINE_LEN+100];

private:
   char *aClLines [MAX_CONTEXT_LINES+4];
   char  aClValid [MAX_CONTEXT_LINES+4];
   int   iClIndex;
}
gfiltPreContext;

FilterContextLines::FilterContextLines( )
   { memset(this, 0, sizeof(*this)); }

void FilterContextLines::shutdown( ) 
{
   for (int i=0; i<MAX_CONTEXT_LINES; i++)
      if (aClLines[i])
         delete [] aClLines[i];
}

void FilterContextLines::reset( )
   { mclear(aClValid); }

void FilterContextLines::putLine(char *psz) 
{
   if (!aClLines[iClIndex])
      if (!(aClLines[iClIndex] = new char[MAX_LINE_LEN+100]))
         return;
   mystrcopy(aClLines[iClIndex], psz, MAX_LINE_LEN);
   aClValid[iClIndex] = 1;
   iClIndex = (iClIndex + 1) % MAX_CONTEXT_LINES;
}

// In : pre index >= 1
// Out: pre context line, or NULL if n/a
char *FilterContextLines::getLine(int iPreIndex) 
{
   if (iPreIndex < 1) return 0;
   int iCurIndex = iClIndex;
   for (int i=0; i<iPreIndex; i++) {
      if (--iCurIndex < 0)
         iCurIndex = MAX_CONTEXT_LINES-1;
      if (!aClValid[iCurIndex])
         return 0;
   }
   if (aClValid[iCurIndex])
      return aClLines[iCurIndex];
   return 0;
}

int getContextParms(char *psz, long &rlines, char &rcolor, char **ppConMark, int nlimit=0)
{
   rlines = atol(psz);
   if (nlimit > 0 && rlines > nlimit) {
      perr("-(pre)context supports only up to %d lines\n",nlimit);
      return 9;
   }
   while (*psz && isdigit(*psz))
      psz++;
   if (*psz==':' || *psz==',') 
   {
      // parse color
      char szcol[50];   
      char *pszs = ++psz;
      while (isalpha(*psz)) psz++;
      int nlen = psz - pszs;
      if (nlen > sizeof(szcol)-10) return 0;
      memcpy(szcol, pszs, nlen);
      szcol[nlen] = '\0';
      if (szcol[0])
         rcolor = attribFromHumanColor(szcol, ' ');

      // parse marker
      if (*psz!=':' && *psz!=',')
         return 0;

      psz++;
      *ppConMark = psz;
   }
   return 0;
}

long setFilterParms(
   char *argv[], long argc, long iPat, long &nPat,
   struct FilterParms &rparms,
   char  **pszInFile,
   int   *iDir = 0,     // if dir parms are found
   int   *iChain = 0    // if further chaining is found
   )
{
   // valid options w/o parameters
   char *pszValFilt1[] = {
      "-+","-ls+","-le+","++","+ls+",
      "-!", "-ls!", "-le!", // accept win specific form
      "-:", "-ls:", "-le:", // and ux specific as well
      "-no-empty-lines", "-no-blank-lines",
      "-unique"
   };

   // valid options with one or more parameters
   char *pszValFilt2[] = {
      "1-pat", "1-notpat",
      "3-inc", "3-ex", "3-cut", "1-addmark",
   };

   // valid processing options w/o parms
   char *pszValOpt1[] = {
      "-encode-", "-decode-",
      "-ansitodos", "-todos", "-dostoansi",
   };

   // valid processing options with one parameter
   char *pszValOpt2[] = {
      "-rep","-lsrep","-lerep",
      "-sep","-blocksep","-form","-noop",
      "-where","-lswhere","-lewhere",
      "-within","-lswithin","-lewithin",
   };

   // set processing options, check syntax
   bool bHadProc = 0;
   bool bHadFilt = 0;
   for (int iPat2=iPat; iPat2<argc; iPat2++)
   {
      char *pszOpt = argv[iPat2];
      if (!strcmp(pszOpt, "-lnum"))
         { rparms.bLNum = 1; continue; }
      if (!strcmp(pszOpt, "-count") || !strcmp(pszOpt, "-cnt"))
         { rparms.bCnt = 1; continue; }
      if (!strcmp(pszOpt, "-c")) // -case done in setGeneralOption
         { cs.usecase = 1; continue; }
      if (!strcmp(pszOpt, "-join"))
         { rparms.bDumpLF = 0; continue; }
      if (!strncmp(pszOpt, "-bin", 4))
         { rparms.bSkipBinaries = 0; continue; }
      if (!strncmp(pszOpt, "-nofile", 7))
         { rparms.bFilenames = 0; continue; }
      if (!strcmp(pszOpt, "-hitfiles"))
         { rparms.bPassHitFiles = 1; continue; }

      if (strBegins(pszOpt, "-precontext="))
         { if (getContextParms(pszOpt+12, rparms.nprecon, rparms.cprecolor, &rparms.pPreConMark, MAX_CONTEXT_LINES-5)) return 9; continue; }
      if (strBegins(pszOpt, "-precon="))
         { if (getContextParms(pszOpt+8, rparms.nprecon, rparms.cprecolor, &rparms.pPreConMark, MAX_CONTEXT_LINES-5)) return 9; continue; }

      if (strBegins(pszOpt, "-postcontext="))
         { getContextParms(pszOpt+13, rparms.npostcon, rparms.cpostcolor, &rparms.pPostConMark); continue; }
      if (strBegins(pszOpt, "-postcon="))
         { getContextParms(pszOpt+9, rparms.npostcon, rparms.cpostcolor, &rparms.pPostConMark); continue; }

      if (strBegins(pszOpt, "-context=")) {
         if (getContextParms(pszOpt+9, rparms.nprecon, rparms.cprecolor, &rparms.pPostConMark, MAX_CONTEXT_LINES-5)) return 9;
         rparms.npostcon = rparms.nprecon;
         rparms.cpostcolor = rparms.cprecolor;
         continue; 
      }

      long i=0;

      // check for filter options w/o parms
      for (i=0; i<sizeof(pszValFilt1)/sizeof(char*); i++)
         if (!strncmp(pszOpt, pszValFilt1[i], strlen(pszValFilt1[i])))
            break;
      if (i < sizeof(pszValFilt1)/sizeof(char*)) {
         if (bHadProc) {
            perr("selection options (%s) are not allowed after processing options.\n", pszOpt);
            perr("say +filter %s instead.\n", pszOpt);
            return 9;
         }
         bHadFilt=1;
         continue;
      }

      // check for filter options w/ parms
      long nParms = 0;
      for (i=0; i<sizeof(pszValFilt2)/sizeof(char*); i++) {
         char *psz = pszValFilt2[i];
         // 1st char is no. of parms
         if (strBegins(pszOpt, psz+1)) {
            nParms = *psz - '0';
            break;
         }
      }
      if (nParms) {
         if (bHadProc) {
            perr("selection options (%s) are not allowed after processing options.\n", pszOpt);
            perr("say +filter %s instead.\n", pszOpt);
            return 9;
         }
         if (strBegins(pszOpt, "-addmark") && (iPat2+1 < argc))
            gfilter.pBlockMark = argv[iPat2+1];
         iPat2 += nParms;  // skip additional parameter
         if (iPat2 >= argc) return 9+perr("missing parameter(s) after %s\n",pszValFilt2[i]);
         bHadFilt=1;
         continue;
      }

      // check for highlight
      if (   !strncmp(pszOpt, "-high", 5)
          || !strncmp(pszOpt, "-lshigh", 7) || !strncmp(pszOpt, "-lehigh", 7)
         )
      {
         // if (bHadProc) {
         //    perr("%s is not allowed after processing options.\n", pszOpt);
         //    perr("say +filter %s instead.\n", pszOpt);
         //    return 9;
         // }
         iPat2 += 2;  // skip additional parameters
         if (iPat2 >= argc) return 9+perr("missing parameter(s) after %s\n",pszOpt);
         // bHadFilt=1;
         continue;
      }

      // check for processing opts w/o parms
      for (i=0; i<sizeof(pszValOpt1)/sizeof(char*); i++)
         if (!strncmp(pszOpt, pszValOpt1[i], strlen(pszValOpt1[i])))
            break;
      if (i < sizeof(pszValOpt1)/sizeof(char*))
         { bHadProc=1; continue; }
      
      // check for processing opts w/ one parm
      for (i=0; i<sizeof(pszValOpt2)/sizeof(char*); i++)
         if (isxopt(pszOpt, pszValOpt2[i]))
            break;
      if (i < sizeof(pszValOpt2)/sizeof(char*)) {
         iPat2++;  // skip additional parameter
         if (iPat2 >= argc) {
            perr("missing parameter after %s\n",pszOpt);
            #ifndef _WIN32
            pinf("try to use quotes \"\" with %s parameters.\n",pszOpt);
            #endif
            return 9;
         }
         // typical mistake: -sep -form w/o separator patterns
         if (  (isxopt(pszOpt, "-sep") || isxopt(pszOpt, "-blocksep"))
             && isxopt(argv[iPat2], "-form")
            )
            return 9+perr("%s must be followed by separator characters, e.g. %s \"; \"\n",pszOpt,pszOpt);
         bHadProc=1;
         continue;
      }
      else
      if (!strncmp(pszOpt, "-write", 6) || !strcmp(pszOpt, "-rewrite")) {
         rparms.bReWrite = 1;
         if (!strcmp(pszOpt, "-writeall"))
            cs.writeall = 1;
         continue; 
      }

      if (   strncmp(pszOpt, "-", 1)
          && strncmp(pszOpt, "+", 1)
         )
      {
         // non-option: assume single input file
         if (*pszInFile) {
            perr("unexpected parameter: %s\n", pszOpt);
            if (pszOpt[0] == '<' || pszOpt[0] == '>') {
               pinf("if you try to redirect output, there might be a quote count problem.\n");
               pinf("try using -spat ... and \\q instead of \\\"\n");
            } else {
               pinf("filter does not support short dir+file selection syntax.\n");
               pinf("specify a single input file, or -dir ... -file ... format.\n");
            }
            return 9;
         }

         *pszInFile = pszOpt;
         continue;
         
         /*
         if (iPat2 == iPat) {
            // non-option on first position: single input file
            *pszInFile = pszOpt;
            continue;
         } else {
            // non-option later: short form directory parm
            // due to this, NEXT CHAIN START MAY NOT BE FOUND HERE.
            *iDir = iPat2;
            return 0;
         }
         */
      }

      if (!strncmp(pszOpt, "-", 1))
         if (isDirParm(pszOpt)) {
            *iDir = iPat2;
            return 0;
         }

      if (isChainStart(pszOpt, argv, argc, iPat2, iChain)) {
         nPat = iPat2 - iPat;
         if (cs.verbose)
            printf("[filter npats=%ld before %s]\n", nPat, pszOpt);
         // tell caller that there is another chain cmd:
         // was done in isChainStart via iChain
         return 0; // pdp will process chaining further
      }

      if (setGeneralOption(argv, argc, iPat2))
         continue;

      return 9+perr("unknown option: %s\n", pszOpt);
   }

   if (bHadFilt && rparms.bReWrite && !cs.force && !cs.noinfo && !cs.yes) {
      pinf("line selection option(s) AND -write may cause massive changes.\n");
   }
   else
   if ((rparms.bLNum || rparms.bCnt) && rparms.bReWrite && !cs.force && !cs.noinfo && !cs.yes) {
      pinf("-lnum or -count AND -write will change all selected files.\n");
   }

   if (cs.wrapcol && (rparms.bReWrite || pszGlblSaveTo))
      return 9+perr("-wrap together with -write is not supported.\n");

   return 0;
}

// filter -unique support:
KeyMap glblFilterDups;

// filter test matrix: used with -test
#define FILT_MAXTESTMASKS 50
struct FilterTestStat {
   char *apPosMasks  [FILT_MAXTESTMASKS+4];
   long  anPosHits   [FILT_MAXTESTMASKS+4];
   char *apNegMasks  [FILT_MAXTESTMASKS+4];
   long  anNegHits   [FILT_MAXTESTMASKS+4];
}  ftest;

// io: szLineBuf. also uses szLineBuf2.
// io: szAttrBuf. also uses szAttrBuf2.
// rc: 0 if line is included, 1 if excluded, >1 on error.
long selectTextLine(char *argv[], long iPat, long nPat, bool bVerb,
   long &rIncCnt, long &rExCnt, char *pCurFile, long nCurLineNum
   )
{
   bool bHasPositive = 0;
   bool bHasNegative = 0;
   bool bHavePosFilt = 0;
   bool bHaveNegFilt = 0;
   bool bDumpLF = 1;
   long nOptState = 0;
   long nHitIndex = 0;
   long nHitLen   = 0;
   bool bUseColor = bGlblUseColor;
   bool bCase = cs.usecase;
   bool bForceExclude = 0;
   bool bForceInclude = 0;
   bool bHaveIncCmd   = 0;
   bool bDoneSingleIC = 0; // done a single inc/cut in this line

   for (int i=0; i<nPat; i++) 
   {
      char *pszPat = argv[iPat+i];
      if (!strncmp(pszPat, "-+", 2)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " %s\"%s\"", (i>0)?"OR ":"OPTIONAL ", pszPat+2);
         // if (mystrhit(szLineBuf, pszPat+2, bCase, &nHitIndex)) {
         long nflags = bCase ? eMatchCase : 0;
         long nlen = strlen(szLineBuf);
         for (long ibase=0; ibase<nlen;)
         {
            if (cs.test && i<FILT_MAXTESTMASKS)
               ftest.apPosMasks[i] = pszPat;
            if (!matchstr(szLineBuf+ibase, pszPat+2, nflags, nHitIndex, nHitLen))
               break; // no further hit
            bHasPositive = 1;
            if (ibase+nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[ibase+nHitIndex], 'i', nHitLen);
            // continue to highlight ALL occurrences
            ibase += nHitIndex+nHitLen;
            if (cs.test && i<FILT_MAXTESTMASKS)
               ftest.anPosHits[i]++;
         }
      }
      else
      if (!strncmp(pszPat, "-ls+", 4)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " %sLINE START \"%s\"", (i>0)?"OR ":"",pszPat+4);
         // if (!mystrncmp(szLineBuf, pszPat+4, strlen(pszPat)-4, bCase)) {
         long nflags = (bCase ? eMatchCase : 0) | eMatchHead;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasPositive = 1;
            if (nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
         }
      }
      else
      if (!strncmp(pszPat, "-le+", 4)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         long nPatLen = strlen(pszPat)-4;
         long nBufLen = strlen(szLineBuf);
         long nIndex  = nBufLen-nPatLen;
         if (nIndex < 0) nIndex = 0;
         if (bVerb) fprintf(stderr, " %sLINE END \"%s\"", (i>0)?"OR ":"",pszPat+4);
         long nflags = (bCase ? eMatchCase : 0) | eMatchTail;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasPositive = 1;
            if (nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
         }
      }
      else
      if (!strncmp(pszPat, "++", 2)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " %s\"%s\"", (i>0)?"AND ":"", pszPat+2);
         // if (mystrhit(szLineBuf, pszPat+2, bCase, &nHitIndex)) {
         long nflags = bCase ? eMatchCase : 0;
         long nlen = strlen(szLineBuf);
         bool bLocalPos = 0;
         for (long ibase=0; ibase<nlen;)
         {
            if (!matchstr(szLineBuf+ibase, pszPat+2, nflags, nHitIndex, nHitLen))
               break;
            bLocalPos = 1;
            if (ibase+nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[ibase+nHitIndex], 'i', nHitLen);
            ibase += nHitIndex+nHitLen;
         }
         if (bLocalPos) 
            bHasPositive = 1;
         else
            bHasNegative = 1;
      }
      else
      if (!strncmp(pszPat, "+ls+", 4)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " LINE MUST START \"%s\"", pszPat+4);
         // if (!mystrncmp(szLineBuf, pszPat+4, strlen(pszPat)-4, bCase)) {
         long nflags = (bCase ? eMatchCase : 0) | eMatchHead;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasPositive = 1;
            if (nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
         } else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strncmp(pszPat, "-!", 2) || !strncmp(pszPat, "-:", 2))
      {
         if (cs.test && (i<FILT_MAXTESTMASKS))
            ftest.apNegMasks[i] = pszPat;
         if (nOptState) { nOptState=2; break; }
         bHaveNegFilt = 1;
         if (bVerb) fprintf(stderr, " NOT \"%s\"", pszPat+2);
         // if (mystrhit(szLineBuf, pszPat+2, bCase, &nHitIndex))
         long nflags = bCase ? eMatchCase : 0;
         if (matchstr(szLineBuf, pszPat+2, nflags, nHitIndex, nHitLen)) {
            bHasNegative = 1;
            if (cs.test && (i<FILT_MAXTESTMASKS))
               ftest.anNegHits[i]++;
         }
      }
      else
      if (!strncmp(pszPat, "-ls!", 4) || !strncmp(pszPat, "-ls:", 4))
      {
         if (nOptState) { nOptState=2; break; }
         bHaveNegFilt = 1;
         if (bVerb) fprintf(stderr, " NOT \"%s\"", pszPat+4);
         // if (!mystrncmp(szLineBuf, pszPat+4, strlen(pszPat)-4, bCase)) {
         long nflags = (bCase ? eMatchCase : 0) | eMatchHead;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strncmp(pszPat, "-le!", 4) || !strncmp(pszPat, "-le:", 4))
      {
         if (nOptState) { nOptState=2; break; }
         bHaveNegFilt = 1;
         long nPatLen = strlen(pszPat)-4;
         long nBufLen = strlen(szLineBuf);
         long nIndex  = nBufLen-nPatLen;
         if (nIndex < 0) nIndex = 0;
         if (bVerb) fprintf(stderr, " NOT \"%s\"", pszPat+4);
         // if (!mystrncmp(&szLineBuf[nIndex], pszPat+4, nPatLen, bCase)) {
         long nflags = (bCase ? eMatchCase : 0) | eMatchTail;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strcmp(pszPat, "-no-empty-lines")) {
         if (strlen(szLineBuf))
            bHasPositive = 1;
         else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strcmp(pszPat, "-no-blank-lines")) {
         char *psz = szLineBuf;
         while (*psz && isspace(*psz))
            psz++;
         if (*psz) // landed on non-space
            bHasPositive = 1;
         else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strcmp(pszPat, "-unique")) {
         char *psz = szLineBuf;
         if (!glblFilterDups.isset(psz)) {
            glblFilterDups.put(psz);
            bHasPositive = 1;
         } else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strncmp(pszPat, "-inc", 4)) {
         // -inc[lude] "foo*begin" to  "foo*end"
         // -inc-      "foo*begin" to  "foo*end"
         //  i+0        i+1        i+2  i+3
         if (nPat < 4) return 9; // should've been checked before
         char *pfrom = argv[iPat+i+1];
         char *plito = argv[iPat+i+2];
         char *pto   = argv[iPat+i+3];
         if (strcmp(plito, "to"))
            return 9+perr("filter -inc: missing \"to\" keyword");
         bool bStripBnd = (strlen(pszPat) >= 5 && pszPat[4] == '-');
         long nflags = bCase ? eMatchCase : 0;
         long nlen = strlen(szLineBuf);
         if (!strcmp(pfrom, "*") || !strcmp(pto, "*")) 
         {
            // -inc single block mode with one open end
            if (bDoneSingleIC) {
               perr("filter %s: only one -inc or -cut with * allowed", pszPat);
               pinf("... you may try \"+filter %s\" instead of \"%s\".\n", pszPat, pszPat);
               return 9;
            }
            if (!strcmp(pfrom, "*")) {
               // inc from first line until "to" marker
               switch (rIncCnt) {
                  case  0:
                     // keep default to include line
                     if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) {
                        rIncCnt = -1; // boundary hit
                        if (bStripBnd) bForceExclude = 1; // exclude boundary
                     }
                     break;
                  case -1:
                     bForceExclude = 1;
                     break;
               }
            } else {
               // inc from "from" marker until last line
               switch (rIncCnt) {
                  case  0:
                     if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) {
                        rIncCnt = -1; // boundary hit
                        if (bStripBnd) bForceExclude = 1; // exclude boundary
                     }
                     else
                        bForceExclude = 1;
                     break;
                  case -1:
                     // keep default to include line
                     break;
               }
            }
            bDoneSingleIC = 1;
         }
         else 
         {
            // -inc multi block mode with precise boundaries
            bHaveIncCmd = 1;
            if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) 
            {
               // ex start boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               rIncCnt++; // include active
               if (bStripBnd) bForceExclude = 1; // but exclude boundary
            }
            else
            if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) 
            {
               // ex end boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               if (rIncCnt > 0) {
                  rIncCnt--; // include inactive
                  if (!bStripBnd) // if boundary exclude is not active
                     bForceInclude = 1; // then include this line
               } 
               else
               if (!cs.nocheck) {
                  perr("filter -inc: found end of block without start: %s", szLineBuf);
                  pinf("file %s line %ld\n",pCurFile,nCurLineNum);
                  pinf("add option -nocheck to ignore unexpected block endings.\n");
                  return 9;
               }
            }
         }
      }
      else
      if (   strBegins(pszPat, "-cut")
          || strBegins(pszPat, "-ex")
         ) 
      {
         // -ex[clude] "foo*begin" to  "foo*end"
         //  i+0        i+1        i+2  i+3
         if (nPat < 4) return 9; // should've been checked before
         char *pfrom = argv[iPat+i+1];
         char *plito = argv[iPat+i+2];
         char *pto   = argv[iPat+i+3];
         if (strcmp(plito, "to"))
            return 9+perr("filter %s: missing \"to\" keyword", pszPat);
         bool bStripBnd = !strcmp(pszPat, "-cut-");
         long nflags = bCase ? eMatchCase : 0;
         long nlen = strlen(szLineBuf);
         if (!strcmp(pfrom, "*") || !strcmp(pto, "*")) 
         {
            // -cut single block mode with one open end
            if (bDoneSingleIC) {
               perr("filter %s: only one -inc or -cut with * allowed", pszPat);
               pinf("... you may try \"+filter %s\" instead of \"%s\".\n", pszPat, pszPat);
               return 9;
            }
            if (!strcmp(pfrom, "*")) {
               // cut from first line until "to" marker
               switch (rExCnt) {
                  case  0:
                     if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) {
                        rExCnt = -1; // boundary hit
                        if (!bStripBnd) bForceExclude = 1;
                     }
                     else
                        bForceExclude = 1;
                     break;
                  case -1:
                     // keep default to include line
                     break;
               }
            } else {
               // cut from "from" marker until last line
               switch (rExCnt) {
                  case  0:
                     // keep default to include line
                     if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) {
                        rExCnt = -1;       // boundary hit
                        if (!bStripBnd) bForceExclude = 1;
                     }
                     break;
                  case -1:
                     bForceExclude = 1;
                     break;
               }
            }
            bDoneSingleIC = 1;
         }
         else 
         {
            // -cut multi block mode with precise boundaries
            if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) 
            {
               // ex start boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               rExCnt++; // exclude active
               // exclude boundary from cutting?
               if (bStripBnd) bForceInclude = 1;
            }
            else
            if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) 
            {
               // ex end boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               if (rExCnt > 0) {
                  rExCnt--; // exclude inactive
                  if (!bStripBnd) bForceExclude = 1; // but still exclude the current line
               }
               else
               if (!cs.nocheck) {
                  perr("filter %s found end of block without start: %s", pszPat, szLineBuf);
                  pinf("file %s line %ld\n",pCurFile,nCurLineNum);
                  pinf("add option -nocheck to ignore unexpected block endings.\n");
                  return 9;
               }
            }
         }
      }

   }  // endfor nPat

   if (bVerb) {
      if (bHavePosFilt || bHaveNegFilt)
         fprintf(stderr, "]\n");
      else
         fprintf(stderr, " ALL LINES: no filters given.]\n");
   }

   // block include/exclude active?
   if (rExCnt > 0 && !bForceInclude) return 1; // no match
   if (bForceExclude) return 1;
   if (bHaveIncCmd && !rIncCnt && !bForceInclude) return 1;

   bool bMatch = 0;

   // if ANY positive filter is given, matches MUST contain this.
   if (bHavePosFilt && bHasPositive && !bHasNegative)
      bMatch = 1;

   // if NO positive filter is given, ANYTHING matches,
   // except if there is a negative filter match.
   if (!bHavePosFilt && !bHasNegative)
      bMatch = 1;

   return bMatch ? 0 : 1;   
}

static char szPatBuf[MAX_LINE_LEN+100];
static char szSaveBuf[MAX_LINE_LEN+100];
static char szSaveAttr[MAX_LINE_LEN+100];
static char szJoinBuf[MAX_LINE_LEN+100];

// io: szLineBuf. also uses szLineBuf2.
// io: szAttrBuf. also uses szAttrBuf2.
long processTextLine(char *argv[], long iPat, long nPat,
   long &nReplaced, bool &bUseColor, long nLineNum, long nOutLineNum
   )
{
   bool bCase = cs.usecase;
   aMaskSep[0]     = '\0';
   bool bBlockSep  = 0;
   bool bWhereMode = 0; // a -where is active
   bool bWhereHit  = 0; // the current line matches active -where
   bool bSkipWhere = 0; // if set, -rep etc. must be skipped

   for (int i=0; i<nPat; i++)
   {
      char *pszPat = argv[iPat+i];

      if (   isxopt(pszPat, "-within")
          || isxopt(pszPat, "-lswithin") || isxopt(pszPat, "-lewithin")
         )
      {
         if (i+3 >= nPat) return 9+perr("missing arguments after %s\n", pszPat);

         bool blstart = strstr(pszPat, "lswithin") ? 1 : 0;
         bool blend   = strstr(pszPat, "lewithin") ? 1 : 0;
         bool bshow   = !strstr(pszPat, "-noshow");

         char *psz     = argv[iPat+i+1];
         char *pRepCmd = argv[iPat+i+2];
         if (!strBegins(pRepCmd, "-rep"))
            return 9+perr("missing -replace after %s\n", pszPat);
         char *pszRep  = argv[iPat+i+3];

         // -within "{*}" -replace /foo/bar/
         // if pattern starts or ends with * is ignored
         bool bFromLeft = 0;
         bool bToRight  = 0;
         bool bForceRep = 0;
         long nPatLen   = strlen(psz);
         if (copyMatchPattern(szPatBuf, MAX_LINE_LEN, psz, nPatLen, bFromLeft, bToRight, bForceRep))
            return 9;
         // -> sets szPatBuf, nPatLen, bFromLeft, bToRight.
         long nflags = bCase ? eMatchCase : 0;
         // determine if current line matches the [ls/le]within expression
         long nlen = strlen(szLineBuf);
         for (long ibase=0; ibase<nlen;)
         {
            long ifirst=0, ihitlen=0;
            if (!matchstr(szLineBuf+ibase, szPatBuf, nflags, ifirst, ihitlen))
               break; // no further hit
            if (blstart && (ibase+ifirst) != 0)
               break; // no hit as it's not at line start
            if (blend && (ibase+ifirst+ihitlen) != nlen) {
               // no hit as it's not (yet) at line end
               ibase += ifirst+ihitlen;
               continue;
            }
            bWhereHit = 1;
            if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
            if (bToRight)   { ihitlen = strlen(szLineBuf+ibase+ifirst); }

            // isolate selected part of line:
            //  from ibase+ifirst over ihitlen chars
            strcpy(szSaveBuf , szLineBuf);
            memmove(szLineBuf, szLineBuf+ibase+ifirst, ihitlen);
            szLineBuf[ihitlen] = '\0';

            strcpy(szSaveAttr, szAttrBuf);
            memmove(szAttrBuf, szAttrBuf+ibase+ifirst, ihitlen);
            szAttrBuf[ihitlen] = '\0';

            // mark the selected area as blue:
            memset(szAttrBuf, 't', ihitlen);

            // in+out: szLineBuf. also uses szLineBuf2.
            // changes szAttrBuf contents.
            if (applyReplace(pszRep, nReplaced, 0, 0)) return 9;

            // rebuild line text
            char *pleft = szSaveBuf;
            long  nleft = ibase+ifirst;
            char *pmid  = szLineBuf;
            long  nmid  = strlen(pmid);
            char *prite = szSaveBuf+nleft+ihitlen;
            long  nrite = strlen(prite);

            if (nleft+nmid+nrite > MAX_LINE_LEN-10)
               return 9+perr("buffer overflow on %s ...", pszPat);

            memcpy(szJoinBuf, pleft, nleft);
            memcpy(szJoinBuf+nleft, pmid, nmid);
            memcpy(szJoinBuf+nleft+nmid, prite, nrite);
            szJoinBuf[nleft+nmid+nrite] = '\0';
            strcpy(szLineBuf, szJoinBuf);

            // rebuild attributes
            pleft = szSaveAttr;
            nleft = ibase+ifirst;
            pmid  = szAttrBuf;
            nmid  = strlen(pmid);
            prite = szSaveAttr+nleft+ihitlen;
            nrite = strlen(prite);

            memcpy(szJoinBuf, pleft, nleft);
            memcpy(szJoinBuf+nleft, pmid, nmid);
            memcpy(szJoinBuf+nleft+nmid, prite, nrite);
            szJoinBuf[nleft+nmid+nrite] = '\0';
            strcpy(szAttrBuf, szJoinBuf);

            // continue searching after replaced part
            ibase = nleft+nmid;
            nlen = strlen(szLineBuf);
         }

         // skip over all -within parms, then continue
         i += 3;
         continue;
      }
      else
      if (   isxopt(pszPat, "-where")
          || isxopt(pszPat, "-lswhere") || isxopt(pszPat, "-lewhere")
         )
      {
         bool blstart = !strcmp(pszPat, "-lswhere");
         bool blend   = !strcmp(pszPat, "-lewhere");
         bool bshow   = !strstr(pszPat, "-noshow");

         bWhereMode = 1;
         bWhereHit  = 0;
         bSkipWhere = 0;

         // -where "??:??:??" -replace /foo/bar/
         i++;
         if (i >= nPat) return 9+perr("missing argument after %s\n", pszPat);
         char *psz = argv[iPat+i];
         // if pattern starts or ends with * is ignored
         bool bFromLeft = 0;
         bool bToRight  = 0;
         bool bForceRep = 0;
         long nPatLen   = strlen(psz);
         if (copyMatchPattern(szLineBuf2, MAX_LINE_LEN, psz, nPatLen, bFromLeft, bToRight, bForceRep))
            return 9;
         // -> sets szLineBuf2, nPatLen, bFromLeft, bToRight.
         long nflags = bCase ? eMatchCase : 0;
         // determine if current line matches the [ls/le]where expression
         long nlen = strlen(szLineBuf);
         for (long ibase=0; ibase<nlen;)
         {
            long ifirst=0, ihitlen=0;
            if (!matchstr(szLineBuf+ibase, szLineBuf2, nflags, ifirst, ihitlen))
               break; // no further hit
            if (blstart && (ibase+ifirst) != 0)
               break; // no hit as it's not at line start
            if (blend && (ibase+ifirst+ihitlen) != nlen) {
               // no hit as it's not (yet) at line end
               ibase += ifirst+ihitlen;
               continue;
            }
            bWhereHit = 1;
            if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
            if (bToRight)   { ihitlen = strlen(szLineBuf+ibase+ifirst); }
            char cattr = 'i';
            if (bshow)
               if (ibase+ifirst+ihitlen < MAX_LINE_LEN)
                  memset(&szAttrBuf[ibase+ifirst], cattr, ihitlen);
            // continue searching after current hit
            ibase += ifirst+ihitlen;
         }
         // -rep etc. will follow, using bWhere... flags
         if (!bWhereHit)
            bSkipWhere = 1;
      }
      else
      if (isxopt(pszPat, "-rep") || isxopt(pszPat, "-lsrep") || isxopt(pszPat, "-lerep"))
      {
         bool blstart = isxopt(pszPat, "-lsrep");
         bool blend   = isxopt(pszPat, "-lerep");

         // next argument is a sed-like replacement pattern
         i++;
         if (i >= nPat) return 9+perr("-rep must be followed by a pattern\n");
         char *pszRep = argv[iPat+i];
         // execute at all?
         if (bSkipWhere)
            continue;
         // in+out: szLineBuf. also uses szLineBuf2.
         if (applyReplace(pszRep, nReplaced, blstart, blend)) return 9;
      }
      else
      if (isopt(pszPat, "-noop")) // skip a parameter
      {
         // next argument contains something that should be skipped
         if (i >= nPat-1) return 9+perr("-noop must be followed by a parameter (which is ignored)\n");
         i++;
         continue;
      }
      else
      if (isxopt(pszPat, "-high") || isxopt(pszPat, "-lshigh") || isxopt(pszPat, "-lehigh"))
      {
         bool blstart = isxopt(pszPat, "-lshigh");
         bool blend   = isxopt(pszPat, "-lehigh");

         // -highlight red "POST * HTTP/"
         char *pcol = "";
         i++;
         if (i >= nPat) return 9+perr("missing argument after %s\n", pszPat);
         pcol = argv[iPat+i];
         i++;
         if (i >= nPat) return 9+perr("missing argument after %s\n", pszPat);
         char *psz = argv[iPat+i];
         // execute at all?
         if (bSkipWhere)
            continue;
         // if pattern starts or ends with *
         bool bFromLeft = 0;
         bool bToRight  = 0;
         bool bForceRep = 0;
         long nPatLen   = strlen(psz);
         if (copyMatchPattern(szLineBuf2, MAX_LINE_LEN, psz, nPatLen, bFromLeft, bToRight, bForceRep))
            return 9;
         // -> sets szLineBuf2, nPatLen, bFromLeft, bToRight.
         long nflags = bCase ? eMatchCase : 0;
         // mark ALL hits within current line
         long nlen = strlen(szLineBuf);
         for (long ibase=0; ibase<nlen;)
         {
            long ifirst=0, ihitlen=0;
            if (!matchstr(szLineBuf+ibase, szLineBuf2, nflags, ifirst, ihitlen))
               break; // no further hit
            if (blstart && (ibase+ifirst) != 0)
               break; // no hit as it's not at line start
            if (blend && (ibase+ifirst+ihitlen) != nlen) {
               // no hit as it's not (yet) at line end
               ibase += ifirst+ihitlen;
               continue;
            }
            if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
            if (bToRight)   { ihitlen = strlen(szLineBuf+ibase+ifirst); }
            // map human color to attribute code
            char cattr = attribFromHumanColor(pcol);
            if (ibase+ifirst+ihitlen < MAX_LINE_LEN)
               memset(&szAttrBuf[ibase+ifirst], cattr, ihitlen);
            // continue searching after current hit
            ibase += ifirst+ihitlen;
         }
      }
      else
      if (isxopt(pszPat, "-sep") || isxopt(pszPat, "-blocksep"))
      {
         // parse user-defined separators for format input.
         // blocksep takes several separators as a single one.
         bBlockSep = (!strcmp(pszPat, "-blocksep")) ? 1 : 0;
         i++;
         if (i >= nPat) return 9+perr("-sep must be followed by separators, e.g. -sep ;\n");
         char *pszStrForm = argv[iPat+i]; // e.g. "; \t"
         // execute at all?
         if (bSkipWhere)
            continue;
         // "-sep -form" user error is checked in setFilterParms.
         // "\t" is NOT replaced by sprintf (belongs to preprocessor),
         // so we have to replace it by native 0x09 here.
         long iout=0;
         char *pszin=pszStrForm;
         while (*pszin && (iout < sizeof(aMaskSep)-10)) 
         {
            if (cs.spat && !strncmp(pszin, "\\\\", 2))
               { aMaskSep[iout++] = '\\'; pszin += 2; continue; }
            else
            if (cs.spat && !strncmp(pszin, "\\t", 2))
               { aMaskSep[iout++] = '\t'; pszin += 2; continue; }
            else
            if (cs.spat && !strncmp(pszin, "\\q", 2))
               { aMaskSep[iout++] = '"'; pszin += 2; continue; }
            else
            if (cs.spat && !strncmp(pszin, "\\x", 2)) {
               // \xnn - any character with hex code nn
               pszin += 2; // skip \x
               long nhex = getTwoDigitHex(pszin);
               if (nhex <= 0) return 9+perr("illegal value for \\xnn in -sep. use 01 to FF, e.g. \\x09\n");
               pszin += 2; // skip nn
               aMaskSep[iout++] = (char)nhex;
               continue;
            }
            else
               aMaskSep[iout++] = *pszin;
            pszin++;
         }
         aMaskSep[iout] = '\0';
         // printf("masksep: %02x %02x %02x %s\n",aMaskSep[0],aMaskSep[1],aMaskSep[2],pszStrForm);
         continue;
      }
      else
      if (isxopt(pszPat, "-form"))
      {
         // bUseColor = 0;
         // split lines into whitespace-separated columns, selecting some.
         i++;
         if (i >= nPat) return 9+perr("-form must be followed by %ccol1 etc., e.g. -form \"%ccol2 %ccol5\"\n", glblRunChar, glblRunChar, glblRunChar);
         char *pszMask = argv[iPat+i];
         // execute at all?
         if (bSkipWhere)
            continue;
         // in+out: szLineBuf. also uses szLineBuf2.
         if (applyForm(pszMask, bBlockSep, nLineNum, nOutLineNum)) return 9;
         // form change was really applied:
         nReplaced++;
         // -form does not yet support attributes, therefore reset them.
         memset(szAttrBuf, ' ', MAX_LINE_LEN-10);
         szAttrBuf[MAX_LINE_LEN-10] = '\0';
         continue;
      }
      else
      if (isopt(pszPat, "-encode-perc")) {
         if (encodeUrl(szLineBuf, szLineBuf2, MAX_LINE_LEN))
            return 9;
         strcpy(szLineBuf, szLineBuf2);
      }
      else
      if (isopt(pszPat, "-decode-perc")) {
         decodeUrl(szLineBuf, MAX_LINE_LEN); // ignore rc
      }
      else
      if (   !strcmp(pszPat, "-ansitodos")
          || !strcmp(pszPat, "-todos"))
      {
         ansiToDos(szLineBuf);
      }
      else
      if (!strcmp(pszPat, "-dostoansi")) {
         dosToAnsi(szLineBuf);
      }
   }
   return 0;
}

class FileCloser {
public:
    FileCloser  (Coi *pcoi); // can be NULL
   ~FileCloser  ( );
private:
    Coi *pClCoi;
};

FileCloser::FileCloser(Coi *pcoi) {
   pClCoi = pcoi;
}
FileCloser::~FileCloser() { 
   if (pClCoi && pClCoi->isFileOpen())
      pClCoi->close();
}

// dump szLineBuf/szAttrBuf to output.
// also uses szLineBuf2/3 and szAttrBuf2/3.
long dumpFilterLine
 (
   bool     bReWrite,
   SFKMD5    &md5out,
   StringTable &oOut,   // used by rewrite
   long       &nLine,
   long        &nCnt,   // output line counter
   char    *paddmark,
   char     *abLFBuf,
   bool bDumpedFileName
 )
{
   bool  bLNum      = gfilter.bLNum;
   bool  bCnt       = gfilter.bCnt;
   bool  bDumpLF    = gfilter.bDumpLF;
   bool  bFilenames = gfilter.bFilenames;
   bool  bUseColor  = bGlblUseColor;

   char  *pszLine   = szLineBuf;
   char  *pszAttr   = szAttrBuf;

   if (bReWrite)
   {
      // create cache line. have to do this always, in case.
      szLineBuf2[0] = '\0';
      char *psz1 = szLineBuf2;
      if (bLNum) { sprintf(psz1, "%03u ",nLine); psz1 += strlen(psz1); }
      if (bCnt ) { sprintf(psz1, "%03u ",nCnt ); psz1 += strlen(psz1); }
      long nRem = MAX_LINE_LEN - (psz1 - szLineBuf2);
      mystrcopy(psz1, pszLine, nRem-10);
      if (oOut.addEntry(szLineBuf2))
         return 9+perr("out of memory\n");
      long nLineLen2 = strlen(szLineBuf2);
      if (!nLineLen2)
         md5out.update((uchar*)abLFBuf, 1);
      else
         md5out.update((uchar*)szLineBuf2, nLineLen2);
      nCnt++; // output line counter

      // append extra line after block inclusion?
      if (paddmark) {
         oOut.addEntry(paddmark); // ignore rc
         md5out.update((uchar*)paddmark, strlen(paddmark));
         nCnt++;
      }
   }
   else
   {
      // now holding one large output line in pszLine / pszAttr.
      if (cs.wrapcol > 0)
      {
         long nWrapCol = cs.wrapcol;
         if (bLNum) nWrapCol -= 4;
         if (bCnt ) nWrapCol -= 4;

         // -wrap selected: create multiple output lines
         char *psz1 = pszLine;
         char *pszOld = 0;
         while (*psz1)
         {
            pszOld = psz1;
            long icnt = 0;
            char *pszGap = 0;
            // step until overflow or eod, remember last whitespace
            while (*psz1 && (icnt < nWrapCol)) {
               char c = *psz1;
               switch (c) {
                  case ' ': case '\t': case ',':
                     pszGap = psz1;
                     break;
               }
               psz1++;
               icnt++;
            }
            // if overflow, go back past whitespace. if no whitespace,
            // make a word break at that point (splitting very long words).
            if (*psz1) {
               if (pszGap)
                  psz1 = pszGap+1;
            }
            ulong noff = pszOld - pszLine;
            ulong nlen = psz1 - pszOld;

            // isolate section
            memcpy(szLineBuf2, pszLine+noff, nlen);
            szLineBuf2[nlen] = '\0';
            memcpy(szAttrBuf2, pszAttr+noff, nlen);
            szAttrBuf2[nlen] = '\0';

            // then dump
            if (chain.coldata)
            {
               szLineBuf3[0] = '\0';
               szAttrBuf3[0] = '\0';

               if (bFilenames && bDumpedFileName)
                  strcat(szLineBuf3, "   ");
               if (bLNum) mystrcatf(szLineBuf3, 0, "%03u ", nLine);
               if (bCnt ) mystrcatf(szLineBuf3, 0, "%03u ", nCnt );
               padBuffer(szAttrBuf3, MAX_LINE_LEN, ' ', strlen(szLineBuf3));

               mystrcatf(szLineBuf3, 0, "%s", szLineBuf2);
               mystrcatf(szAttrBuf3, 0, "%s", szAttrBuf2);

               if (bDumpLF) {
                  chain.addLine(szLineBuf3, szAttrBuf3, 1); // 1: splitByLF
               } else {
                  chain.addToCurLine(szLineBuf3, szAttrBuf3);
               }

               if (paddmark) { chain.addLine(paddmark, ""); nCnt++; }
            } else {
               if (bFilenames && bDumpedFileName)
                  printf("   ");
               if (bLNum) printx("<prefix>%03u<def> ", nLine);
               if (bCnt ) printx("<prefix>%03u<def> ", nCnt );
               if (!bUseColor)
                  printf("%s%s", szLineBuf2, bDumpLF ? "\n":"");
               else
                  printColorText(szLineBuf2, szAttrBuf2, bDumpLF);

               if (paddmark) { printf("%s\n", paddmark); nCnt++; }

               fflush(stdout);
            }
            nCnt++; // output line counter
         }
      }
      else
      {
         // dump whole line in one step
         if (chain.coldata)
         {
            szLineBuf3[0] = '\0';
            szAttrBuf3[0] = '\0';

            if (bFilenames && bDumpedFileName)
               strcat(szLineBuf3, "   ");
            if (bLNum) mystrcatf(szLineBuf3, 0, "%03u ", nLine);
            if (bCnt ) mystrcatf(szLineBuf3, 0, "%03u ", nCnt );
            padBuffer(szAttrBuf3, MAX_LINE_LEN, ' ', strlen(szLineBuf3));

            mystrcatf(szLineBuf3, 0, "%s", pszLine);
            mystrcatf(szAttrBuf3, 0, "%s", pszAttr);

            if (bDumpLF) {
               chain.addLine(szLineBuf3, szAttrBuf3, 1); // 1: splitByLF
            } else {
               chain.addToCurLine(szLineBuf3, szAttrBuf3);
            }

            if (paddmark) { chain.addLine(paddmark, ""); nCnt++; }
         } else {
            if (bFilenames && bDumpedFileName)
               printf("   ");
            if (bLNum) printf("%03u ", nLine);
            if (bCnt ) printf("%03u ", nCnt );
            // printf("ucl %d\nlbuf %s\nattr %s\n",bUseColor,pszLine,pszAttr);
            if (!bUseColor)
               printf("%s%s", pszLine, bDumpLF ? "\n":"");
            else
               printColorText(pszLine, pszAttr, bDumpLF);
            if (paddmark) { printf("%s\n", paddmark); nCnt++; }
            fflush(stdout);
         }
         nCnt++; // output line counter
      }
   }

   return 0;
}

void mirrorAttrBuf(char ccolin)
{
   int nNewLen = strlen(szLineBuf);
   char ccol = ccolin ? ccolin : ' ';
   memset(szAttrBuf, ccol, nNewLen);
   szAttrBuf[nNewLen] = '\0';
}

// caller supplies either pszInFile or fin.
long execFilter(Coi *pcoi, FILE *fin, StringPipe *pInData, long nMaxLines, char *pszOutFile)
{__
   // only for display etc., not for fopen:
   char *pszInFile = pcoi ? pcoi->name() : 0;

   mtklog("execFilter %s skipbin=%d", pszInFile ? pszInFile : "", gfilter.bSkipBinaries);

   char  **argv   = gfilter.argv;
   long  iPat     = gfilter.iPat;
   long  nPat     = gfilter.nPat;
   bool  bVerb    = gfilter.bVerb;
   bool  bReWrite = gfilter.bReWrite;
   bool  bFilenames = gfilter.bFilenames;
   bool  bDoClose = 0;

   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut && pcoi && pcoi->isWriteable())
      pszOutFile = pcoi->name();

   // in case that -unique is used:
   glblFilterDups.reset(); // reset per file
   glblFilterDups.setcase(cs.usecase);

   // INPUT FILE CLOSES AUTOMATICALLY.
   FileCloser fcin(pcoi); // does nothing if pcoi == NULL

   FILE *fsave = 0; // used with -saveto
   if (pszGlblSaveTo) bReWrite = 1;

   if (pcoi) 
   {
      if (gfilter.bSkipBinaries && pcoi->isBinaryFile()) 
      {
         cs.binariesSkipped++;
         if (cs.verbose) {
            setTextColor(nGlblWarnColor);
            oprintf("skipping binary file: %s\n", pcoi->name());
            setTextColor(-1);
         }
         return 0;
      }
      if (gfilter.bReWrite) {
         num nFileSize = pcoi->getSize();
         if (nFileSize > nGlblMemLimit)
            return 9+perr("input file too large: %s (adjust -memlimit)\n", pcoi->name());
         if (!pcoi->isWriteable())
            return 9+perr("readonly file, cannot overwrite: %s\n", pcoi->name());
      }
      if (pcoi->open("rb"))
         return 9+perr("cannot read file: %s%s\n", pcoi->name(),pcoi->lasterr());
      if (cs.verbose) {
         info.setStatus("scan", pcoi->name(), 0);
      }
   } else {
      if (bReWrite)
         return 9+perr("-write requires a filename.\n");
   }
 
   StringTable oOut; // in case bReWrite is used
   SFKMD5 md5in;
   SFKMD5 md5out;

   long nMaxLineLen = sizeof(szLineBuf)-10;
   long nLine = 0, nCnt = 1;
   long nHitPosition = 0;
   long nMatchingLines = 0;
   long nReplaced = 0;
   bool bUseColor = bGlblUseColor;
   bool bCase = cs.usecase;
   bool bDumpedFileName = 0;
   bool bCollectedFileName = 0;   
   bool bSave = 0;
   bool bSaveChainOut = 0;
   long lRC = 0;
   bool bSnapFile = 0;
   bool bGrabSubFileName = 0;
   long nSubFiles = 0;
   num  nInputBytes = 0;
   long ncheckcnt = 0;
   long ninccnt = 0;  // block include counter
   long nexcnt  = 0;  // block exclude counter
   long nPostConCnt = 0; // post context down counter

   char abLFBuf[5];
   abLFBuf[0] = '\n';
   abLFBuf[1] = '\0';

   char szSnapPre[50];  // snapfile prefix
   char szSubFile[300]; // current subfile
   strcpy(szSnapPre, ":file:"); // default
   szSubFile[0] = '\0';

   myfgets_init();
   while (1)
   {
      // always provide an attrib buf in the same length
      // of input text, to allow replacements, highlight etc.
      // including the attribs.
      memset(szAttrBuf, ' ', MAX_LINE_LEN-10);
      szAttrBuf[MAX_LINE_LEN-10] = '\0';

      long nRead = 0;

      if (pInData) {
         // take line from stringpipe
         if (pInData->eod()) {
            mtklog("filt: indata.eod");
            break;
         }
         char *pattr = 0;
         char *psz = pInData->read(&pattr);
         // mtklog("filt: indata.read \"%.100s\"", psz);
         mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
         strcat(szLineBuf, "\n"); // force LF
         long nlen = strlen(szLineBuf);
         if (pattr) {
            mystrcopy(szAttrBuf, pattr, MAX_LINE_LEN);
            // attrib lines are guaranteed to be as long as text
            if ((long)strlen(szAttrBuf) < nlen-1) {
               memset(szAttrBuf, ' ', nlen);
               szAttrBuf[nlen] = '\0';
            }
         }
         nRead = nlen;
         // nRead includes LF
      } else if (pcoi) { // native or virtual file
         nRead = pcoi->readLine(szLineBuf, nMaxLineLen);
         // nRead includes CRLF
      } else if (fin)  { // probably stdin
         nRead = myfgets(szLineBuf, nMaxLineLen, fin, 0, szAttrBuf);
         // nRead includes CRLF
      }
      if (!nRead) {
         mtklog("filt: nread=0 EOD");
         break; // EOD
      }

      // allow interrupt while processing very large files:
      if ((++ncheckcnt > 100000) && ((ncheckcnt & 65535)==0))
         if (userInterrupt())   // costs a bit of time
            {  lRC=9; break;  } // stop by escape

      nInputBytes += nRead;

      szLineBuf[nRead] = '\0';
      szAttrBuf[nRead] = '\0';
      nLine++;
      removeCRLF(szLineBuf);

      if (cs.usesnap && (nLine == 1)) {
         // identify snapfile by header line.
         if (strBegins(szLineBuf, ":snapfile sfk,")) {
            bSnapFile = 1;
            char *pszpre = strstr(szLineBuf, "lprefix=");
            if (pszpre) {
               pszpre += strlen("lprefix=");
               strcopy(szSnapPre, pszpre);
            }
            continue; // don't filter the header line
         }
      }
      if (cs.usesnap && bSnapFile) {
         // indentify subfile headers within a snapfile.
         if (bGrabSubFileName) {
            bGrabSubFileName = 0;
            strcopy(szSubFile, szLineBuf);
            pszInFile = szSubFile;
            bDumpedFileName = 0; // dump this name on first match
            nSubFiles++;
            if (cs.verbose) {
               long nMB = (long)(nInputBytes / 1000000);
               info.setAddInfo("%ld mb, %ld subfiles", nMB, nSubFiles);
               info.setStatus("scan", szSubFile, 0, eKeepAdd);
            }
            if (!cs.usesnapfiltname)
               continue;
         }
         else
         if (strBegins(szLineBuf, szSnapPre)) {
            bGrabSubFileName = 1;
            continue; // don't filter prefix itself
         }
      }

      long nLineLen = strlen(szLineBuf);
      if (!nLineLen)
         md5in.update((uchar*)abLFBuf, 1); // include empty lines
      else
         md5in.update((uchar*)szLineBuf, nLineLen);

      bool bVerb = 0;
      if (cs.verbose > 1 && nLine == 2) {
         // issue verbose infos on 2nd line, 1st is for syntax checks.
         bVerb = 1;
         if (pszInFile)
            fprintf(stderr, "[read file %s, find:", pszInFile);
         else
            fprintf(stderr, "[read stdin, find:");
      }

      long noldinc = ninccnt;
      long noldex  = nexcnt;
      bool beoblk  = 0; // end of inclusion block reached

      long nsc = selectTextLine(argv, iPat, nPat, bVerb,
         ninccnt, nexcnt, pszInFile ? pszInFile : (char*)"", nLine);
      if (nsc > 1) { lRC = nsc; break; }

      // append extra line after block inclusion?
      char *paddmark = 0;
      if (gfilter.pBlockMark) {
         // end of included block?
         if (noldinc && !ninccnt)
            paddmark = gfilter.pBlockMark;
         // end of excluded block?
         if (noldex && !nexcnt && nsc==1) {
            // create pseudo match line,
            // but do NOT set paddmark.
            nsc = 0;
            strcopy(szLineBuf, gfilter.pBlockMark);
            long nlen = strlen(szLineBuf);
            memset(szAttrBuf, 'i', nlen);
            szAttrBuf[nlen] = '\0';
         }
      }

      if (nsc == 0 || nPostConCnt > 0) // if match
      {
         // text line is selected within stream.

         // this means there is a matching file.
         if (gfilter.bPassHitFiles && chain.colfiles && !bCollectedFileName)
         {
            bCollectedFileName = 1;
            // chain mode: collect filenames with hits
            if (!pszInFile) {
                perr("wrong chaining mode: filter collects text but not filenames.\n");
                pinf("try to insert +ttf or +texttofilenames.\n");
                return 9;
            }
            // just scan for word hits: return on first hit
            if (!bReWrite) {
               if (!pcoi) return 9+perr("int. #141271849");
               chain.addFile(*pcoi);
               break;
            }
            // replace and save: do name chaining later
            bSaveChainOut = 1; // later masked by bSave
         }

         nMatchingLines++;

         // print the filename?
         if (   pszInFile && !bReWrite
             && !gfilter.bSingleFile && bFilenames
             && !cs.nonames && !bDumpedFileName
            )
         {
            bDumpedFileName = 1;
            if (!strncmp(pszInFile, glblDotSlash, 2))
               pszInFile += 2;
            if (chain.coldata) {
               sprintf(szLineBuf2, ":file %s", pszInFile);
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
               chain.addLine(szLineBuf2, szAttrBuf2);
            }
            else
            if (chain.colfiles) { } // done above
            else {
               setTextColor(nGlblFileColor);
               info.print("%s :\n", pszInFile);
               setTextColor(-1);
            }
         }

         // dump pre context lines, if any
         if (gfilter.nprecon) 
         {
            bool bcached = 0;

            if (gfilter.pPreConMark && !nPostConCnt) 
            {
               bcached = 1;
               strcpy(gfiltPreContext.szClLineTmp, szLineBuf);
               strcpy(gfiltPreContext.szClAttrTmp, szAttrBuf);
               strcopy(szLineBuf, gfilter.pPreConMark);
               mirrorAttrBuf(' ');
               if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, 0, abLFBuf, bDumpedFileName))
                  return 9;
            }

            for (long i=gfilter.nprecon; i>=1; i--) 
            {
               char *pszPreLine = gfiltPreContext.getLine(i);
               if (!pszPreLine) continue;

               // dump current pre context line. this requires
               // to place it temporarily into szLine/AttrBuf.
               if (!bcached) {
                  bcached = 1;
                  strcpy(gfiltPreContext.szClLineTmp, szLineBuf);
                  strcpy(gfiltPreContext.szClAttrTmp, szAttrBuf);
               }

               // prepare a precontext line
               strcpy(szLineBuf, pszPreLine);
               mirrorAttrBuf(gfilter.cprecolor);

               // post-process the precontext line (replace, highlight etc.)
               if (processTextLine(argv, iPat, nPat, nReplaced, bUseColor, nLine, nCnt))
                  return 9;

               // dump the precontext line
               if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, 0, abLFBuf, bDumpedFileName))
                  return 9;
            }

            if (bcached) {
               strcpy(szLineBuf, gfiltPreContext.szClLineTmp);
               strcpy(szAttrBuf, gfiltPreContext.szClAttrTmp);
            }
         }

         // handle post context lines
         bool bPostConElapsed = 0;
         if (gfilter.npostcon > 0) 
         {
            // why was the current line selected?
            if (!nsc) {
               // if was a true content match: reset postcnt
               // to make sure following context is dumped
               nPostConCnt = gfilter.npostcon;
            } else {
               // it was part of post context.
               mirrorAttrBuf(gfilter.cpostcolor);
               if (nPostConCnt > 0)
                  if (--nPostConCnt == 0)
                     bPostConElapsed = 1;
            }
         }

         // post-process the selected line (replace, highlight etc.)
         if (processTextLine(argv, iPat, nPat, nReplaced, bUseColor, nLine, nCnt))
            return 9;

         // dump current szLineBuf/szAttrBuf to output.
         if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, paddmark, abLFBuf, bDumpedFileName))
            return 9;

         // do we want to save the file content?
         // - if anything replaced
         // - or if found filter matches, and -force specified
         if (cs.writeall || nReplaced || (cs.force && nMatchingLines))
            bSave = 1;

         // if pre context is selected, reset cached precontext.
         gfiltPreContext.reset();

         // if post content was completed, show a marker?
         if (bPostConElapsed && gfilter.pPostConMark) 
         {
            strcopy(szLineBuf, gfilter.pPostConMark);
            mirrorAttrBuf(' ');
            if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, 0, abLFBuf, bDumpedFileName))
               return 9;
         }
      }
      else
      {
         // no match, text line is removed from stream.
         nReplaced++;
         bSave = 1;

         // if pre context is selected, remember dropped line.
         if (gfilter.nprecon)
            gfiltPreContext.putLine(szLineBuf);
      }

      if (nMaxLines > -1 && nLine >= nMaxLines)
         break;

   }  // endwhile myfgets

   char *pszChainOutFile = pszInFile;

   if (bReWrite && bSave)
   {
      uchar *pmd5in  = md5in.digest();
      uchar *pmd5out = md5out.digest();

      // save only on changes, or if -writeall selected
      if (cs.writeall || memcmp(pmd5in, pmd5out, 16))
      {
         if (cs.sim) {
            // simulating write
            info.setStatus("write", pszOutFile);
            info.setAddInfo("% 5ld changes", nReplaced);
            info.printLine(1<<2);
         } else {
            // if different output is specified, create directory structure.
            if (bHaveOut)
               if (createOutDirTree(pszOutFile))
                  return 9;
            info.setStatus("write", pszOutFile);
            info.setAddInfo("% 5ld changes", nReplaced);
            info.printLine(1<<2);
   
            FILE *fout = fopen(pszOutFile, "w");
            if (!fout) return 9+perr("failed to write to: %s\n", pszOutFile);
   
            long nLines = oOut.numberOfEntries();
            for (long i=0; i<nLines; i++)
               fprintf(fout, "%s\n", oOut.getEntry(i, __LINE__));
            fclose(fout);
         }
         gfilter.nTotalRC = 1;
         // use save filename as chain out
         pszChainOutFile = pszOutFile;
      }
   } else {
      if (nMatchingLines > 0)
         gfilter.nTotalRC = 1;
   }

   if (!cs.nocheck) {
      if (ninccnt > 0) {
         perr("%ld filter -inc block(s) open at end of: %s", ninccnt, pszInFile ? pszInFile : "");
         pinf("one or more blocks starts were not followed by a block end.\n");
         pinf("add option -nocheck to ignore missing block endings.\n");
         lRC = 5;
      }
      if (nexcnt > 0) {
         perr("%ld filter -cut block(s) open at end of: %s", nexcnt, pszInFile ? pszInFile : "");
         pinf("one or more block starts were not followed by a block end\n");
         pinf("add option -nocheck to ignore missing block endings.\n");
         lRC = 5;
      }
   }

   if (bSaveChainOut && bSave) {
      Coi ocoi(pszChainOutFile, 0);
      chain.addFile(ocoi); // is copied
   }

   return lRC;
}

#ifndef USE_SFK_BASE

num nGlblCheckDiskHits = 0;
num nGlblCDWriteBytes  = 0;
num nGlblCDWriteTime   = 0;
num nGlblCDReadBytes   = 0;
num nGlblCDReadTime    = 0;

long writeDiskSlice(char *pszPath, num nSliceBytes, uchar *pBuf, long nBufSize)
{
   // 1. write slice
   num nTime1 = getCurrentTime();
   FILE *fout = fopen(pszPath, "wb");
   if (!fout) return 9+perr("unable to open test file %s\n", pszPath);
   srand(1);
   num nRemain = nSliceBytes;
   long nBlockSize = nBufSize-10;
   while (nRemain > 0)
   {
      long nWriteSize = nBlockSize;
      if (nWriteSize > nRemain)
          nWriteSize = nRemain;
      for (long i=0; i<nWriteSize; i++)
         pBuf[i] = (uchar)rand();
      long nWriteSize2 = myfwrite(pBuf, nWriteSize, fout);
      if (nWriteSize2 != nWriteSize) {
         fclose(fout);
         return 9+esys("fwrite", "unable to fully write test file %s\n", pszPath);
      }
      nRemain -= nWriteSize;
   }
   fclose(fout);
   num nTime2 = getCurrentTime();

   nGlblCDWriteBytes += nSliceBytes;
   nGlblCDWriteTime  += (nTime2-nTime1);

   return 0;
}

long readDiskSlice(char *pszPath, num nSliceBytes, uchar *pBuf, long nBufSize)
{
   // 2. read and check slice
   num nTime1 = getCurrentTime();
   FILE *fin = fopen(pszPath, "rb");
   if (!fin) return 9+perr("unable to re-read test file %s\n", pszPath);
   srand(1); // reproduce same pseudo-random sequence
   num nRemain = nSliceBytes;
   long nBlockSize = nBufSize-10;
   num nHits = 0;
   while (nRemain > 0) 
   {
      long nReadSize = nBlockSize;
      if (nReadSize > nRemain)
          nReadSize = nRemain;
      long nReadSize2 = fread(pBuf, 1, nReadSize, fin);
      if (nReadSize2 != nReadSize) {
         fclose(fin);
         return 9+perr("unable to re-read test file %s\n", pszPath);
      }
      nRemain -= nReadSize;
      for (long i=0; i<nReadSize; i++)
         if (pBuf[i] != (uchar)rand())
            nHits++;
   }
   fclose(fin);
   num nTime2 = getCurrentTime();

   nGlblCDReadBytes += nSliceBytes;
   nGlblCDReadTime  += (nTime2-nTime1);

   nGlblCheckDiskHits += nHits;

   if (nHits > 0)
      return 1;

   return 0;
}

// uses szLineBuf
long checkDisk(char *pszPath, long nRangeMB)
{
   num nTotal=0, nFree=0;
   char szFSName[200];
   char szVolID[200];

   if (getFileSystemInfo(pszPath, nTotal, nFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10))
      return 9;

   num nBrutto = 0;
   num nNetto  = 0;

   if (nRangeMB == -1) {
      nRangeMB = nFree / 1000000;
      nBrutto = (num)nRangeMB * 1000000;
      nNetto  = (num)nBrutto * 9 / 10;
   } else {
      nBrutto = (num)nRangeMB * 1000000;
      nNetto  = nBrutto;
   }

   printf("Testing Volume %s, FileSystem %s, over %lu mbytes.\n", szVolID, szFSName, (ulong)(nNetto/1000000));

   if (nNetto > nFree)
      return 9+perr("test range too large: volume has only %ld free mbytes\n", nFree);

   num nSliceBytes = nNetto / 100;
   printf("Writing 100 temporary files of %s mbytes each. Press ESC to stop.\n", numtoa(nSliceBytes/1000000));

   char abStat[100+10];
   memset(abStat, '.', sizeof(abStat));
   abStat[100] = '\0';

   // for USB stick write performance, we MUST use the largest I/O blocks possible.
   // a large buffer makes I/O about 10 times(!) faster.
   long nWorkBufSize = 1048675 * 50; // yes, 50 megabytes
   uchar *pWorkBuf = new uchar[nWorkBufSize];
   if (!pWorkBuf)
      return 9+perr("out of memory, cannot allocate working buffer.\n");

   memset(pWorkBuf, 0xFF, nWorkBufSize);

   // NO RETURN FROM HERE!

   num nWritten = 0;
   num nTimeW1  = getCurrentTime();
   long i;
   for (i=0; i<100; i++)
   {
      if (userInterrupt())
         break;

      sprintf(szLineBuf, "%s%stmp-test-%02lu.dat", pszPath, endsWithPathChar(pszPath)?"":glblPathStr, i);
      long lRC = writeDiskSlice(szLineBuf, nSliceBytes, pWorkBuf, nWorkBufSize);

      if (lRC) abStat[i] = 'E';
      else     abStat[i] = '_';

      if (i < 49) {
         printf("%03lu%% > %.50s < \r", i+1, abStat);
         fflush(stdout);
      }
      if (i == 49) {
         printf("%03lu%% > %.50s < - 1st half written.\n", i+1, abStat);
      }
      if (i > 49 && i < 99) {
         printf("%03lu%% > %.50s < \r", i+1, &abStat[50]);
         fflush(stdout);
      }
      if (i == 99) {
         printf("%03lu%% > %.50s < - 2nd half written.\n", i+1, abStat);
      }

      nWritten += nSliceBytes;
   }
   long nCheck  = i;
   num nTimeW2  = getCurrentTime();
   num nWElapse = nTimeW2-nTimeW1;

   ulong nkbswrite = (ulong)(nWritten / (nWElapse?nWElapse:1));
   printf("Write done at %lu kbytes/sec.%.40s\n", nkbswrite, pszGlblBlank);

   memset(pWorkBuf, 0xFF, nWorkBufSize);

   printf("Reading and verifying temporary files.\n");

   memset(abStat, '.', sizeof(abStat));
   abStat[100] = '\0';

   num nFirstHits  = 0;
   num nSecondHits = 0;
   num nReadBytes  = 0;
   num nTimeR1  = getCurrentTime();
   // read and check file system
   for (i=0; i<nCheck; i++)
   {
      // if (userInterrupt())
      //   break;

      sprintf(szLineBuf, "%s%stmp-test-%02lu.dat", pszPath, endsWithPathChar(pszPath)?"":glblPathStr, i);
      long lRC = readDiskSlice(szLineBuf, nSliceBytes, pWorkBuf, nWorkBufSize);

      if (lRC) abStat[i] = 'E';
      else     abStat[i] = '_';

      if (i < 49) {
         printf("%03lu%% > %.50s < \r", i+1, abStat);
         fflush(stdout);
      }
      if (i == 49) {
         nFirstHits = nGlblCheckDiskHits;
         printf("%03lu%% > %.50s < - %s \n", i+1, abStat, nFirstHits ? "1st half contains Errors." : "1st half OK.");
      }
      if (i > 49 && i < 99) {
         printf("%03lu%% > %.50s < \r", i+1, &abStat[50]);
         fflush(stdout);
      }
      if (i == 99) {
         nSecondHits = nGlblCheckDiskHits - nFirstHits;
         printf("%03lu%% > %.50s < - %s \n", i+1, abStat, nSecondHits ? "2nd half contains Errors." : "2nd half OK.");
      }

      nReadBytes += nSliceBytes;
   }
   num nTimeR2  = getCurrentTime();
   num nRElapse = nTimeR2-nTimeR1;

   ulong nkbsread = (ulong)(nReadBytes / (nRElapse?nRElapse:1));
   printf("Read done at %lu kbytes/sec.%.40s\n", nkbsread, pszGlblBlank);

   // NO RETURN UNTIL HERE.

   delete [] pWorkBuf;
   pWorkBuf = 0;

   // cleanup: delete all files without errors.
   long nKept = 0;
   for (i=0; i<100; i++)
   {
      if (abStat[i] != 'E') {
         sprintf(szLineBuf, "%s%stmp-test-%02lu.dat", pszPath, endsWithPathChar(pszPath)?"":glblPathStr, i);
         printf("%02lu%% cleanup test files ... \r", i);
         fflush(stdout);
         remove(szLineBuf);
      } else {
         nKept++;
      }
   }

   if (nGlblCheckDiskHits) {
      printf("%s mb of file system checked, errors detected:\n", numtoa(nReadBytes/1000000));
      printf("%s bytes failed to re-read after write.\n", numtoa(nGlblCheckDiskHits));
      printf("%lu test files with bad sectors are left over, to cover the bad areas.\n", nKept);
   } else {
      printf("%s mb of file system successfully written and re-read.\n", numtoa(nReadBytes/1000000));
   }

   return 0;
}

#endif // USE_SFK_BASE

#ifdef _WIN32
long putClipboard(char *pszStr)
{
   if (!OpenClipboard(0)) // GetDesktopWindow()))
      return 9+perr("clipboard #1\n");
   if (!EmptyClipboard())
      return 9+perr("clipboard #2\n");

   long nStrLen = strlen(pszStr);

   HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, nStrLen+10);
   if (hMem == NULL) return 9+perr("clipboard #3\n");

   LPTSTR pCopy = (char*)GlobalLock(hMem);
   if (pCopy)
   {
      memcpy(pCopy, pszStr, nStrLen);
      pCopy[nStrLen] = 0;
   }
   GlobalUnlock(hMem);

   HANDLE hData = SetClipboardData(CF_TEXT, hMem);
   if (hData == NULL)
   {
      CloseClipboard();
      return 9+perr("clipboard #4\n");
   }

   // System is now owner of hMem.

   CloseClipboard();

   return 0;
}
#endif

long execJoin(char *pszFirstInput, char *pszDst, bool bTest, char *pszMD5Write)
{
   long nWorkMB = 100;
   num nWorkBufSize = nWorkMB * 1000000;
   uchar *pWorkBuf = new uchar[nWorkBufSize+1000];
   if (!pWorkBuf) return 9+perr("out of memory, cannot allocate working buffer.\n");

   // NO RETURN W/O DELETE FROM HERE

   // x.part1
   strcopy(szLineBuf, pszFirstInput);
   char *pszBaseName = szLineBuf;
   char *pszPartExt  = strrchr(szLineBuf, '.');
   if (!pszPartExt || strcmp(pszPartExt, ".part1")) {
      delete [] pWorkBuf;
      return 9+perr("expecting input filename ending with .part1\n");
   }

   // check if first input exists
   if (!fileExists(szLineBuf))
      return 9+perr("first input file not found: %s\n", szLineBuf);

   // cut ".part1" in szLineBuf
   *pszPartExt = '\0';

   // and use this as output filename
   if (!pszDst)
      pszDst = szLineBuf;

   FILE *fout = 0;

   if (!bTest)
   {
      if (fileExists(pszDst) && !cs.force && !cs.yes)
         while (1) {
            printf("%s output file exists, overwrite? (y/n) ",pszDst);
            fflush(stdout);
            char nReply = getYNAchar();
            if (nReply == 'y') break;
            if (nReply == 'n') { delete [] pWorkBuf; return 5; }
            // printf("\n");
         }
   
      fout = fopen(pszDst, "wb");
      if (!fout) {
         delete [] pWorkBuf;
         return 9+perr("cannot write output file: %s\n",pszDst);
      }
   }

   num ntotal = 0;
   SFKMD5 md5;

   long nin = 1;
   bool bbail = 0;
   while (!bbail)
   {
      sprintf(szLineBuf2, "%s.part%ld", pszBaseName, nin);
      char *pszSrc = szLineBuf2;

      FILE *fpart = fopen(pszSrc, "rb");
      if (!fpart)
         break;   // (probably) all done

      if (cs.debug) printf("open.read: %s   \n", pszSrc);

      nin++;

      while (!bbail)
      {
         num nTotalMB = ntotal / 1000000;

         if (pszMD5Write) {
            printf("verifying part %ld, %s mb done [Esc to skip] \r", nin-1, numtoa(nTotalMB));
            fflush(stdout);
            if (userInterrupt(1)) {
               printf("verify skipped.                               \n");
               fclose(fpart);
               bbail = 1;
               break;
            }
         } else {
            printf("reading part %ld, %s mb done \r", nin-1, numtoa(nTotalMB));
            fflush(stdout);
         }

         long nread = myfread(pWorkBuf, nWorkBufSize, fpart);

         if (cs.debug) printf("read.blck: %ld maxbuf=%ld  \n", nread, nWorkBufSize);

         if (nread <= 0)
            break; // EOD

         if (!bTest)
         {
            long nwrite = myfwrite(pWorkBuf, nread, fout);

            if (cs.debug) printf("writ.blck: %ld   \n", nwrite);

            if (nwrite != nread) {
               delete [] pWorkBuf;
               fclose(fout); fclose(fpart);
               remove(pszDst); // cleanup incomplete output
               return 9+esys("fwrite", "failed to write %s   \n", pszDst);
            }
         }

         md5.update(pWorkBuf, nread);

         ntotal += nread;
      }

      if (cs.debug) printf("clos.read: %s totalDone=%ld   \n", pszSrc, ntotal);

      fclose(fpart);
   }
 
   if (!bTest)
      fclose(fout);

   delete [] pWorkBuf;

   // NO RETURN W/O DELETE UNTIL HERE

   if (bbail)
      return 0;

   if (bTest) {
      if (!pszMD5Write)
         printf("tested join of %ld files, %s total bytes.\n", nin-1, numtoa(ntotal));
   } else {
      printf("%s created from %ld files, %s total bytes.\n", pszDst, nin-1, numtoa(ntotal));
   }

   char szMD5Read[100];

   uchar *pmd5 = md5.digest();
   for (long i=0; i<16; i++)
      sprintf(&szMD5Read[i*2], "%02x", pmd5[i]);
   printf("md5 = %s   %s ", szMD5Read, pszMD5Write ? "[verify]" : "");

   if (pszMD5Write) {
      if (strcmp(pszMD5Write, szMD5Read)) {
         printf("\n");
         return 9+perr("checksum mismatch - re-read of output files failed.\n");
      }
      else
         printf("- OK\n");
   }
   else
      printf("\n");

   return 0;
}

bool isHelpOpt(char *psz) {
   if (!strcmp(psz, "-h"))     return 1;
   if (!strcmp(psz, "-help"))  return 1;
   if (!strcmp(psz, "-?"))     return 1;
   if (!strcmp(psz, "/?"))     return 1;
   if (!strcmp(psz, "/help"))  return 1;
   return 0;
}

// process -opt=value AND -opt value
bool haveParmOption(char *argv[], int argc, int &iDir, char *pszOptBase, char **pszOutParm)
{
   *pszOutParm = 0;  // if this stays NULL it tells ERROR status.

   // check if format -opt=value is given
   char szEqBuf[100];
   sprintf(szEqBuf, "%s=", pszOptBase);
   char *pszOpt = argv[iDir];
   if (*pszOpt == '+') pszOpt++; // e.g. +md5gento=
   if (!strncmp(pszOpt, szEqBuf, strlen(szEqBuf))) {
      *pszOutParm = pszOpt+strlen(szEqBuf);
      return 1;
   }

   // check if format "-opt value" is given
   if (!strcmp(pszOpt, pszOptBase)) {
      if (iDir >= argc-1) {
         perr("missing parameter after option %s\n", pszOptBase);
         return 0;
      }
      iDir++;  // IDIR INCREMENT IS WRITTEN BACK!
      *pszOutParm = argv[iDir];
      return 1;
   }

   return 0;
}

#ifdef VFILEBASE
void resetLoadCaches(bool bfinal)
{
   glblVCache.reset(bfinal);
   glblConCache.reset();
}
#endif // VFILEBASE

// template,tpl: command option handling loop
/*
      if (!chain.usefiles && (nparm < 1)) {
      printx("<help>$sfk cmd ...\n"
             "\n"
             "   summary\n"
             "\n"
             "   $options\n"
             "      -opt1     text1\n"
             "\n"
             "   $pattern support\n"
             "   $command chaining\n"
             "   $see also\n"
             "\n"
             "   $examples\n"
             "      #examp1\n"
             "         explanation1\n"
             );
      return 9;
      }

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-opt1", &pszParm)) {
            if (!pszParm) return 9;
            nValue = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-opt2")) {
            bFlag = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!strcmp(argv[iDir], "key1")) {
            if (iDir >= argc-1) return 9+perr("missing parameter after %s\n", argv[iDir]);
            char *pszParm = argv[++iDir];
         }
      }
*/

StringTable glblSynTests;

void shutdownAllGlobalData()
{__
   // final cleanup of tmp cmd data
   cleanupTmpCmdData();

   // cleanup for all commands
   #ifndef USE_SFK_BASE
   glblMemSnap.shutdown();
   glblFileSnap.shutdown();
   #endif

   glblFileSet.shutdown();
   glblCircleMap.reset();

   #ifdef VFILEBASE
   resetLoadCaches(1);
   #endif // VFILEBASE

   if (pGlblFileParms)  delete pGlblFileParms;
   if (apGlblFileParms) delete [] apGlblFileParms;
   if (pszGlblJamRoot)  delete [] pszGlblJamRoot;
   if (pszGlblDstRoot)  delete [] pszGlblDstRoot;
   if (pszGlblSinceDir) delete [] pszGlblSinceDir;
   if (pszGlblDirTimes) delete [] pszGlblDirTimes;

   chain.shutdown();
   gfiltPreContext.shutdown();
   glblSynTests.resetEntries();

   #ifdef SFK_CCDIRTIME
   if (glblCreatedDirs.numberOfEntries() > 0)
      if (cs.verbose >= 1) {
         pwarn("createddirs list has remaining entries:\n");
         glblCreatedDirs.dump();
      }
   glblCreatedDirs.resetEntries();
   #endif

   #ifdef _WIN32
   // used by getFileMD5NoCache, was alloc'ed on demand:
   if (pGlblMD5NoCacheBuf != 0)
      VirtualFree(pGlblMD5NoCacheBuf, nGlblMD5NoCacheBufSize, MEM_DECOMMIT);
   #endif

   #ifdef SFK_WINPOPUP_SUPPORT
   winCleanupGUI();
   #endif

   #ifdef VFILEBASE
   // in case any tcp was used
   TCPCore::sysCleanup();
   #endif // VFILEBASE
}

void cleanupTmpCmdData()
{
   glblGrepPat.reset();
   glblIncBin.reset();
   glblSFL.resetEntries();
   glblFileListCache.resetEntries();
   #ifndef USE_SFK_BASE
   glblFTPRemList.resetEntries();
   glblFTPLocList.resetEntries();
   filedb.reset();
   glblVerifier.reset();
   #endif
   glblErrorLog.resetEntries();
   glblStaleLog.resetEntries();
}

#ifndef USE_SFK_BASE

// register syntax test
void subregtest(char *pszcmd, char *pszTest) {
   // if not running the syntest cmd, do nothing:
   if (strcmp(pszcmd, "syntest"))
      return;
   if (!bGlblSyntaxTest) // avoid recursion
      glblSynTests.addEntry(pszTest); 
}

#define regtest(x) subregtest(pszCmd, x)

// run user interface tests, by calling main() again
long runSyntaxTests(char *penv[])
{
   bGlblSyntaxTest = 1;
   bool bVerbose = (cs.verbose > 0);
   cs.verbose = 0;
   char **myargv = new char*[100];
   char *pszBuf  = new char[MAX_LINE_LEN+10];
   long myargc = 0;
   long lrc=0, npassed=0, nfailed=0;
   for (long i=0; i<glblSynTests.numberOfEntries(); i++) 
   {
      myargc = 0;
      myargv[myargc++] = "sfk";
      myargv[myargc++] = "-stest";
      char *psz1 = glblSynTests.getEntry(i, __LINE__);
      if (!psz1) break;
      mystrcopy(pszBuf, psz1, MAX_LINE_LEN);
      // linux syntax fixes
      psz1 = pszBuf;
      while (psz1 = strchr(psz1, '$'))
         *psz1++ = glblRunChar;
      // process line
      psz1 = pszBuf;
      // sfk -stest md5gento dummy.dat dummydir
      while (*psz1) {
         char *psz2 = strchr(psz1, ' ');
         if (psz2) {
            *psz2++ = '\0';
            myargv[myargc++] = psz1;
            // activate masked blanks (_)
            char *psz3 = psz1;
            while (psz3 = strchr(psz3, '_'))
               *psz3++ = ' ';
            // continue on next parm
            psz1 = psz2;
         } else {
            if (strlen(psz1))
               myargv[myargc++] = psz1;
            break;
         }
      }
      char *pszCmd = myargv[2];
      int iDir = 3;
      bool bFatal = 0;
      lrc = submain(myargc, myargv, penv, pszCmd, iDir, bFatal);
      if (lrc || bVerbose) {
         printf("rc %ld : ", lrc);
         for (long k=0; k<myargc; k++)
            printf("%s ",myargv[k]);
         printf("\n");
      }
      if (lrc) nfailed++;
      else     npassed++;

      // before the next test, reset processing state
      glblFileSet.reset();
      if (pszGlblSinceDir) { delete [] pszGlblSinceDir; pszGlblSinceDir=0; }
      chain.colfiles = 0;
      bGlblStdInAny = 0;
   }
   if (nfailed > 0)
      printf("%ld syntax checks failed (%ld passed).\n",nfailed,npassed);
   else
      printf(": OK : %ld syntax checks passed.\n",npassed);
   delete [] pszBuf;
   delete [] myargv;
   return (nfailed > 0) ? 9 : 0;
}

long blockChain(char *pszCmd)
{
   if (chain.usefiles || chain.usedata || chain.colfiles || chain.coldata)
      return 9+perr("command \"%s\" does not support chaining.\n", pszCmd);
   return 0;
}

long blockChain(char *pszCmd, int iDir, int argc, char *argv[], long nSilent=0)
{
   char *pszNext  = 0;
   bool  bforce   = 0;
   long nNextType = findNextChainType(iDir, argv, argc, &pszNext, bforce);
   if (nNextType == 0)
      return 0;
   if (!(nSilent & 1)) {
      perr("command \"%s\" does not support chaining (+%s).\n", pszCmd, pszNext);
      if (!(nSilent & 2)) {
         pinf("say \"sfk -nochain ...\" if you want to process a file with name \"+%s\"\n", pszNext);
      }
   }
   return 9;
}

class SFKMainStat {
public:
    SFKMainStat (num nStartTime);
   ~SFKMainStat ( );
private:
   num clStartTime;
};

SFKMainStat::SFKMainStat(num nStartTime) { 
   clStartTime = nStartTime; 
}

SFKMainStat::~SFKMainStat( ) {
   if (gs.tellExecTime)
      printf("done in %s msec\n", numtoa(getCurrentTime()-clStartTime));
}

// sort and count
long groupChainText(char *pcmd, bool brev, bool bcnt, long ndig)
{
   // use a KeyMap of Index-Based StringMaps:
   KeyMap omap;
   omap.setcase(cs.usecase);
   omap.setreverse(brev);

   // collect text lines into groups
   for (long i=0; i<chain.indata->numberOfEntries(); i++) {
      char *pattr = "";
      char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
      num   nidx  = 0;
      AttribStringMap *pgrp = (AttribStringMap*)omap.get(ptext);
      if (!pgrp) {
         // create new string group under search key
         pgrp = new AttribStringMap();
         if (!pgrp) return 9+perr("out of memory");
         mtklog("pgrp-put %p under \"%s\"", pgrp, ptext);
         if (omap.put(ptext, pgrp))
            return 9+perr("failed to sort, probably out of memory");
      } else {
         // add to existing group, at next index
         nidx = pgrp->size(); // next index == size
      }
      if (!pattr) pattr = "";
      if (pgrp->put(nidx, ptext, pattr))
         return 9+perr("failed to sort, probably out of memory");
   }

   // in case of group, need this:
   StringMap oout;

   // dump group contents
   for (long i=0; i<omap.size(); i++) 
   {
      char *pgrpkey = 0;
      AttribStringMap *pgrp = (AttribStringMap*)omap.iget(i, &pgrpkey);
      if (!pgrp) return 9+perr("int. #168281033");
      if (bcnt) 
      {
         long nsize = pgrp->size();
         sprintf(szLineBuf, "%0*lu\t", (int)ndig, nsize);
         long nlen = strlen(szLineBuf);

         memset(szAttrBuf, 'p', nlen);
         szAttrBuf[nlen] = '\0';

         long nrem = MAX_LINE_LEN - nlen;
         // get first entry of group
         char *pattr = 0, *pkey = 0;
         char *ptext = pgrp->iget(0, &pkey, &pattr);
         if (!ptext) return 9+perr("int. #168281035");

         strncpy(szLineBuf+nlen, ptext, nrem);
         szLineBuf[MAX_LINE_LEN-10] = '\0';

         strncpy(szAttrBuf+nlen, pattr, nrem);
         szAttrBuf[MAX_LINE_LEN-10] = '\0';

         oout.put(szLineBuf, szAttrBuf);

         // if (chain.colany())
         //    chain.addLine(szLineBuf, szAttrBuf);
         // else
         //    printColorText(szLineBuf, szAttrBuf, 1); // with lf
      }
      else
      for (long k=0; k<pgrp->size(); k++) {
         char *pkey = 0, *pattr = 0;
         char *pval = pgrp->iget(k, &pkey, &pattr);
         if (!pval) return 9+perr("int. #168281034");
         if (!pattr) pattr = "";
         if (chain.colany())
            chain.addLine(pval, pattr);
         else
            printColorText(pval, pattr, 1); // with lf
      }
   }

   if (bcnt) {
      // dump sorted output
      for (long k=0; k<oout.size(); k++) {
         char *pkey=0;
         char *pattr = oout.iget(k, &pkey);
         if (!pkey) return 9+perr("int. #168281039");
         if (!pattr) pattr = "";
         if (chain.colany())
            chain.addLine(pkey, pattr);
         else
            printColorText(pkey, pattr, 1); // with lf
      }
   }

   // cleanup
   for (long i=0; i<omap.size(); i++) 
   {
      AttribStringMap *pgrp = (AttribStringMap*)omap.iget(i);
      mtklog("pgrp-del %p", pgrp);
      if (pgrp) delete pgrp;
   }

   return 0;
}

#ifdef VFILENET
long execWGet(Coi *psrc, char *pDstDir, ulong nmode)
{__
   char *pSrcName = psrc->name();

   bool bpath2path = (nmode & 2) ? 1 : 0;

   long nMaxDst= 500;
   char szDstBuf[500+10]; mclear(szDstBuf);

   if (pDstDir) {
      mystrcopy(szDstBuf, pDstDir, nMaxDst);
      strcat(szDstBuf, glblPathStr);
   }

   char *pcat = szDstBuf + strlen(szDstBuf);
   long  nrem = nMaxDst  - strlen(szDstBuf);

   num nSize = psrc->getSize(); // if any

   if (psrc->open("rb"))
      return 9+perr("cannot read: %s%s\n", psrc->name(),psrc->lasterr());

   char *pctype = psrc->header("content-type");

   // if content is not in memory yet, try to collect,
   // up to a limit of 200 MB
   num    nalloc = 0;
   uchar *pdata  = 0;
   num    nused  = 0;
   bool   btomem = psrc->data().src.data ? 0 : 1;

   // make sure to use the redirected source name
   pSrcName = psrc->name();

   bool bSetDefault = 0;
   if (!flatURLName(pSrcName, pctype, pcat, nrem, nmode, bSetDefault))
      return 9+perr("wrong URL format: %s\n", pSrcName);

   if (bSetDefault && !nmode)
      return 9+perr("need -path2name or -fullpath on URL's like : %s\n", pSrcName);

   char *pDstName = szDstBuf;

   if (bpath2path)
      if (createOutDirTree(pDstName))
         return 9;

   Coi *pdst = new Coi(pDstName, "wb");
   if (!pdst) return 9+perr("out of memory");
   CoiAutoDelete odel2(pdst, 0); // no decref

   num nread    = 0;
   num nWritten = 0;

   // if (!cs.quiet && !cs.nowarn && pdst->existsFile())
   //    pwarn("file exists, overwriting: %s\n", pdst->name());

   if (pdst->open("wb"))
      perr("cannot write: %s%s\n", pdst->name(),pdst->lasterr());
   else
   {
      info.setAction("write", pdst->name(), "");

      while ((nread = psrc->read(abBuf, sizeof(abBuf)-1000)) > 0) 
      {
         if (pdst->write(abBuf, nread) != nread) {
            perr("cannot fully write %s, probably disk full.\n", pdst->name());
            break;
         }

         if (btomem)
         {
            num nrem = nalloc - nused;
            if (nrem < nread + 1000) 
            {
               // expand buffer
               if (!nalloc) nalloc = 10000; // initial

               num nalloc2 = nalloc * 2 + nread;

               if (nalloc2 >= 100 * 1000000) {
                  pinf("download will not be cached (too large).\n");
                  btomem = 0;
                  delete [] pdata;
                  pdata  = 0;
                  nalloc = 0;
               } else {
                  uchar *ptmp = new uchar[nalloc2+100];
                  memcpy(ptmp, pdata, nused);
                  // swap old and new
                  delete [] pdata;
                  pdata  = ptmp;
                  nalloc = nalloc2;
                  nrem   = nalloc - nused;
               }
            }
         }

         if (btomem)
         {
            // add block to memory
            if (nused+nread > nalloc)
               { perr("int. #228290640"); btomem=0; break; }
            memcpy(pdata+nused, abBuf, nread);
            nused += nread;
         }

         nWritten += nread;
         info.setProgress(nSize, nWritten, "bytes");
      }
   }
 
   pdst->close();
   psrc->close();

   if (btomem && pdata && nused)
      psrc->setContent(pdata, nused, 0);

   // NO cleanup of pdata, as it is cached!

   if (cs.quiet < 2)
      info.print("done : %s (%s bytes).\n", pdst->name(), numtoa(nWritten));

   return 0;
}
#endif // VFILENET

bool startsLikeHttpCommand(char *psz)
{
   if (strBegins(psz, "GET "))  return 1;
   if (strBegins(psz, "POST ")) return 1;
   if (strBegins(psz, "HEAD ")) return 1;
   return 0;
}

class CharAutoRestore {
public:
      CharAutoRestore (char **pp) {
         pClPPtr   = pp;
         pClOldVal = *pClPPtr;
      }
     ~CharAutoRestore ( ) { 
         *pClPPtr  = pClOldVal;
      }
private:
      char **pClPPtr;
      char *pClOldVal;
};

// block all trivial signals like SIGPIPE.

#ifndef SIGPIPE
 #define SIGPIPE  13  // Broken pipe (POSIX).
#endif

#ifndef SIGCONT
 #define SIGCONT  18  // Continue (POSIX).
#endif

#ifndef SIGWINCH
 #define SIGWINCH 28  // Window size change (4.3 BSD, Sun).
#endif

#ifndef SIGTRAP
 #define SIGTRAP   5  // Trace trap (POSIX).
#endif

void sfkSignalHandler(int nsig)
{
   const char *psig = "";
   switch (nsig) {
      case SIGPIPE : psig = "SIGPIPE"; break;
      case SIGCONT : psig = "SIGCONT"; break;
      case SIGWINCH: psig = "SIGWINCH"; break;
      case SIGTRAP : psig = "SIGTRAP"; break;
   }
   if (nsig != SIGWINCH)
      pinf("signal %u (%s) caught and ignored.\n", nsig, psig);
}

void initSignalHandlers()
{
   signal(SIGPIPE , sfkSignalHandler);
   signal(SIGCONT , sfkSignalHandler);
   signal(SIGWINCH, sfkSignalHandler);
   signal(SIGTRAP , sfkSignalHandler);
}

#ifdef WINCE
#define ushort unsigned short
int wmain(int argc, char *argvw[])
{
   char **penv = 0;

   char **argv = new char*[100];
   for (int iarg=0; iarg<argc; iarg++)
   {
      ushort *praw = (ushort*)argvw[iarg];
      int nlen = 0;
      while (praw[nlen]) nlen++;
      char *pstr = new char[nlen+1];
      for (int k=0; k<nlen; k++)
            pstr[k] = (char)praw[k];
      pstr[nlen] = '\0';
      argv[iarg] = pstr;
      // printf("   arg %d = %s\n",iarg,pstr);
   }

   wce_SetCurrentDir();

#else
int main(int argc, char *argv[], char *penv[])
{
#endif

   // catch all help requests
   if (argc == 2) 
   {
      char *pfirst = argv[1];
      if (   !strcmp(pfirst, "-h") || !strcmp(pfirst, "-help")
          || !strcmp(pfirst, "-?") || !strcmp(pfirst, "/?")
          || !strcmp(pfirst, "/h") || !strcmp(pfirst, "/help")
         )
      {
         printf("To get help, type the command without any parameter.\n");
         printf("For example: \"sfk\", \"sfk list\", \"sfk run\".\n");
         return 9;
      }
   }

   // block trivial signals
   initSignalHandlers();

   #ifdef WITH_TRACING
   initCrashHandler();
   #endif

   #ifdef SFINT
   bool bSkipCNA = 0;
   #endif

   // fundamental inits
   static bool bFirstCall = 1;
   if (bFirstCall)
   {
      bFirstCall = 0;

      szGlblOpenWriteName[0] = 0;
   
      initWildCards();
      initConsole();
      chain.init();
   
      char *pszCfg = getenv("SFK_CONFIG");
      if (pszCfg) 
      {
         char *pszParm = strstr(pszCfg, "active-file-age:");
         if (pszParm)
            nGlblActiveFileAgeLimit = atol(pszParm+16);
         if (strstr(pszCfg, "skip-hour-jump"))
            bGlblIgnore3600 = 1;
         #ifdef SFINT
         if (strstr(pszCfg, "ignore-exec-name"))
            bSkipCNA = 1;
         #endif
         #ifdef VFILEBASE
         if (strstr(pszCfg, "xdemo"))
            gs.xelike = cs.xelike = 1;
         #endif // VFILEBASE
         #ifdef VFILENET
         // if (strstr(pszCfg, "nocache"))
         //    setDiskCacheActive(0);
         #endif // VFILENET
      }
   }

   #ifdef SFINT
   // command name aliasing: if our executable is not sfk.exe
   char **paliasv = 0;
   int    naliasc = 0;
   if (!bSkipCNA && !(mystrstri(argv[0], "sfk"))) {
      // then rebuild parameter set, autoselecting the command
      paliasv = new char*[argc+10];
      naliasc = argc+1;
      for (long i=0; i<argc; i++)
        paliasv[i+1] = argv[i];
      paliasv[0] = "sfk";
      // remap parameter set
      argc = naliasc;
      argv = paliasv;
      // special option for cn-aliases: if first parm is "-version"
      // sfk list -version
      if (argc >= 3 && !strcmp(argv[2], "-version")) {
         // then run version command instead
         argv[1] = "version";
         argc = 2;
      }
   }
   #endif

   // parse and remove general prefix options, e.g. -nocol
   int iDirPre = 1;
   while ((iDirPre < argc) && setGeneralOption(argv, argc, iDirPre, 1)) // 1: global
      iDirPre++;
   memcpy(&cs, &gs, sizeof(cs)); // copy global, permanent options
   argc -= (iDirPre-1);
   argv += (iDirPre-1);

   char *pszCmd = "?";
   int   iDir   = 0;

   if (argc < 2) {
      // no parms: show main help
      pszCmd = "dump-main-help";
      // and fall through
   } else {
      pszCmd = argv[1];
      iDir   = 2;
   }

   nGlblStartTime = getCurrentTime();

   SFKMainStat mainStat(nGlblStartTime);

   // see also end of main, loop processing
   bool  bFatal = 0;
   long  lRC    = 0;

   // special case like "sfk +toterm":
   if (argc == 2 && pszCmd[0] == '+')
      pszCmd++; // user wants help for chain-only command

   // sfk cmd parm
   // => nparm == 1 (one parm remaining for this command)
   // => iDir  == 2 (on the parameter, not on the command)

   // command chaining support: from list to +run etc.
   #define STEP_CHAIN(iDirNext,bMod)          \
      if (iDirNext)                           \
      {                                       \
         char *pszCmdOld = pszCmd;            \
         pszCmd = argv[iDirNext];             \
         if (pszCmd[0] == '+')                \
            pszCmd++;                         \
         iDir   = iDirNext+1;                 \
         nparm  = argc-iDir;                  \
         bChainCycle = 1;                     \
         bool bHaveMore = (iDirNext < argc);  \
         if (!bMod) {                         \
            chain.colfiles = 0;               \
            chain.coldata  = 0;               \
         } else {                             \
          if (chain.moveOutToIn(pszCmd)) {    \
            bDone = 1;                        \
            break;                            \
          }                                   \
         }                                    \
         resetStats();                        \
         if (lRC >= 9) {                      \
            pinf("chaining stops before %s, rc=%ld\n", pszCmd, lRC); \
            bDone = 1;                        \
            break;                            \
         } else {                             \
            continue;                         \
         }                                    \
      }

   lRC = submain(argc, argv, penv, pszCmd, iDir, bFatal);

   // print overall informal messages
   if (!gs.nonotes) {
      if (gs.utf16read)
         printx("<time>%ld utf-16 file(s) decoded%s.<def>\n", gs.utf16read, gs.verbose ? "":" (-verbose for more)");
      else
      if (gs.utf16found && gs.verbose)
         printx("<time>%ld utf-16 file(s) found. (see \"sfk help utf\")<def>\n", gs.utf16found);
   }

   #ifdef VFILEBASE
   if (gs.cachestat) {
      num nmax  = glblVCache.bytesMax();
      num ndrop = glblVCache.filesDropped();
      printx(
         "<time>peak cache usage = %ld mb. "
         "the memlimit was %sreached (%ld drops).<def>\n",
         (long)(nmax / 1000000),
         (ndrop > 0) ? "":"not ",
         (long)ndrop
         );
   }
   #endif // VFILEBASE

   // print error and warning stats
   if (nGlblErrors) {
      setTextColor(nGlblErrColor);
      printf("%ld errors", nGlblErrors);
      if (nGlblWarnings) {
         setTextColor(nGlblWarnColor);
         printf(", %ld warnings", nGlblWarnings);
         setTextColor(nGlblErrColor);
      }
      if (bGlblSysErrOccured && !bGlblSysErrDetail) {
         printf(" occurred. ");
         setTextColor(nGlblTimeColor, 1);
         printf("add -exterr after sfk for more.\n");
      } else {
         printf(" occurred.\n");
      }
      setTextColor(-1);
   }
   else
   if (nGlblWarnings) {
      setTextColor(nGlblWarnColor);
      printf("%ld warnings occurred.\n", nGlblWarnings);
      setTextColor(-1);
   }

   shutdownAllGlobalData();

   #ifdef SFINT
   if (paliasv)
      delete [] paliasv;
   #endif

   #ifdef _MSC_VER
    #ifdef SFK_MEMTRACE
    if (!bFatal && !nGlblError && !bGlblEscape)
       listMemoryLeaks(); // if any
    #endif
   #endif

   checkFileWrite();

   // if any error occurred during file tree processing,
   // build highest error code as application return code.
   if (nGlblShellRC > lRC)
      lRC = nGlblShellRC;

   if (gs.showrc)
      printf("sfk rc: %ld\n", lRC);

   if (bGlblPauseOnEnd) {
      printf("Press ENTER to continue.\n");
      while (getchar() != '\n');
   }

   return lRC;
}

// #undef  _
// #define _ printf("[%d]\n",__LINE__);

char *askBlackList[] = {
   "how","do","i","in","for","the","a","to",
   "use","using","of","by","many","every",
   "only","part","bytes","within","all",
   "from","into","cmd","command",
   "calculate","calc","using","with",
   "on","2g","one","two","three",
   "and","can","out","you","some","is",
   "an","computer","example","cr",
   "specific","given",
   0 // EOD
};

char *askReduxList[] = {
   "1bigger", "1directory", "3converting", "4splitting",
   "4comparison", "2converter", "4conversion",
   "2colored", "7tabulation", "2sorted",
   0 // EOD
};

char *askSynList[][2] = {
   { "search", "find" },
   { "determine", "find" },
   { "check", "find" },
   { "show", "find" },
   { "string", "word" }, { "phrase", "word" },
   { "txt", "text" },
   { ".txt", "text" },
   { ".bin"," binary" },
   { "filename", "file" },
   { "change", "replace" },
   { "generate", "create" },
   { "shortname", "alias" },
   { "hexadecimal", "hex" },
   { "coloured", "colored" },
   { "linefeed", "lf" },
   { "cr-lf", "crlf" },
   { "execute", "run" },
   { "duplicated", "duplicate" },
   { "executable", "exe" },
   { "colour", "color" },
   { "ls", "list" },
   { "rejoin", "join" },
   { "subfolder", "dir" },
   { "multiple", "many" },
   { "communication", "connection" },
   { "unix", "linux" },
   { ".exe", "exe" },
   { 0, 0 } // EOD
};

// returns a ptr into szLineBuf or NULL
char *filterAskPattern(char *prawpat, char *ppre1, char *ppre2)
{
   // strip all 1-char words
   if (strlen(prawpat) < 2) return 0;

   long i=0;

   strcopy(szLineBuf, prawpat);
   for (i=0; askBlackList[i]; i++)
      if (!mystricmp(szLineBuf, askBlackList[i]))
         return 0;

   // word reduction:
   char *p   = szLineBuf;
   long nlen = strlen(p);

   // force all lowercase
   for (i=0; i<nlen; i++)
      p[i] = tolower(p[i]);

   // director ies -> director
   if (nlen > 7 && strEnds(p, "ies")) p[nlen-3] = '\0';
   else // file s -> file
   if (nlen > 3 && p[nlen-1] == 's')  p[nlen-1] = '\0';
   else // list ing -> list
   if (nlen > 6 && strEnds(p, "ing")) {
      p[nlen-3] = '\0';
      // split ting -> split by dub consonants
      if (p[nlen-4] == p[nlen-5])
         p[nlen-4] = '\0';
   }

   // reduce by list
   for (i=0; askReduxList[i]; i++) {
      char *ppat = askReduxList[i];
      long  nred = (*ppat++) - '0';
      if (!mystricmp(szLineBuf, ppat)) {
         long ncpy = strlen(ppat)-nred;
         memcpy(szLineBuf, ppat, ncpy);
         szLineBuf[ncpy] = '\0';
         break;
      }
   }

   // reduce synonyms
   for (i=0; askSynList[i][0]; i++) {
      char *pfrom = askSynList[i][0];
      char *pto   = askSynList[i][1];
      if (!mystricmp(p, pfrom))
      {  strcpy(p, pto); break; }
   }
   if (strBegins(p, "folder") || strBegins(p, "director")) strcpy(p, "dir");

   // reduce three word phrases
   #define ifpair(s1,s2) if (!strcmp(ppre2,s1) && !strcmp(ppre1,s2))
   if (ppre2 && ppre1) {
      ifpair ("in","a")
         if (!strcmp(p, "dir")) return 0; // "in a dir"
      ifpair ("of","a")
         if (!strcmp(p, "dir")) return 0; // "of a dir"
   }

   // reduce two word phrases
   if (ppre1) {
      if (strBegins(ppre1, "dir") && !strcmp(p, "tree"))
         return 0; // any command uses a "dir tree"
      if (!strcmp(ppre1, "in") || !strcmp(ppre1, "of") || !strcmp(ppre1, "all")) {
         if (!strcmp(p, "dir"))  return 0; // "in dir", "of dir"
         if (!strcmp(p, "tree")) return 0; // "in tree", "of tree"
      }
      if (!strcmp(ppre1, "file") && strBegins(p, "name"))
         strcpy(p, "file"); // "file name" -> "file"
      if (!mystricmp(ppre1, "cr") && !mystricmp(p, "lf"))
         strcpy(p, "crlf"); // "cr lf" -> "crlf"
   }

   // reduce number strings
   for (i=0; i<nlen; i++)
      if (!isdigit(p[i])) break;
   if (i >= nlen) return 0;

   return szLineBuf;
}

long submain(int argc, char *argv[], char *penv[], char *pszCmd, int iDir, bool &bFatal)
{
   int   nparm  = argc - iDir; // number of parameters (after command name)
   bool  bDone  = 0;
   long  lRC    = 0;
   bool  btest  = bGlblSyntaxTest;

   // help text collection support:
   bool  bhelp  = 0;
   bool  bexec  = 0;

   #define ifcmd(xcond) \
      if (bhelp || (xcond))

   #define ifhelp(xcond) \
      if (bhelp || (xcond)) {

   #define ehelp \
      if (!bhelp) return 9; printx("\n"); } bexec=1; } \
      if (!bhelp && bexec) { bexec=0

   // if the very first command starts with +
   if (*pszCmd == '+')
      pszCmd++; // then skip this char

   // for +loop: restart point
   char *pszCmdStart = pszCmd;
   int   iDirStart   = iDir;

 bool bChainCycle = 0;
 do
 {
   cs.curcmd = pszCmd;

   if (bChainCycle && cs.verbose) {
      printf("[chain process index %ld, \"%s\", cmd=%s, nparm=%ld, \"%s\" uf=%d %ld ud=%d %ld cf %d cd %d]\n",
         iDir,argv[iDir-1],pszCmd,nparm,(iDir<argc)?argv[iDir]:"[eod]",
         chain.usefiles, chain.usefiles ? chain.numberOfInFiles() : 0,
         chain.usedata , chain.usedata  ? chain.indata->numberOfEntries() : 0,
         chain.colfiles, chain.coldata
         );
      if (cs.verbose > 1)
         if (chain.usedata)
            chain.indata->dump("chain.indata");
   }

   bChainCycle = 0;
   bexec       = 0;

   long lFiles=0, lDirs=0; // deprecated stats
   num  nBytes=0;          // deprecated stats

   if (!strcmp(pszCmd, "dumphelp") || !strcmp(pszCmd, "ask"))
   {
      if (!strcmp(pszCmd, "ask") && (nparm < 1)) {
      printx("<help>$sfk ask word1 [word2 word3 ...]\n"
             "\n"
             "   search the help text of all sfk commands for lines containing\n"
             "   all given words. keep your query short and up to the point,\n"
             "   listing only the most important words.\n"
             "\n"
             "   if your query produces no results, rephrase it:\n"
             "   - use singular instead of plural: directory vs. directories,\n"
             "     file vs. files\n"
             "   - use synonyms: directory vs. folder, list file vs. find file,\n"
             "     old file vs. most recent files\n"
             "\n"
             "   $no option processing by default:\n"
             "      by default, \"sfk ask\" does NOT process any options itself,\n"
             "      but treats them as text to search for. if you want to set any\n"
             "      options although, say \"sfk ask word1 word2 ... -opt -youropt\"\n"
             "\n"
             "   $no output chaining support:\n"
             "      output of sfk ask can NOT be post-processed in a command chain.\n"
             "      instead, words starting with \"+\" are searched for as well:\n"
             "         #sfk ask +filter\n"
             "            searches for help text lines containing \"+filter\".\n"
             "      if you really need to post-process output from sfk ask, pipe it\n"
             "      to another sfk process like \"sfk ask foo | sfk filter -+bar\".\n"
             "\n"
             "   $examples\n"
             "      #sfk ask walk subfolders\n"
             "      #sfk ask find oldest files\n"
             "      #sfk ask replace binary\n"
             "         search for the given words.\n"
             "      #sfk ask -nocol\n"
             "         search where the word \"-nocol\" appears.\n"
             "      #sfk ask -nocol -opt -nocol\n"
             "         the same, but also use -nocol to switch off color output.\n"
             );
         return 9;
      }

      // activate help text collection mode
      bhelp = bGlblCollectHelp = 1;
      bDone = 1;
      // fall through
   }

   regtest("list -zip -time -since 5d -size xdir .dat");
   regtest("list -late -since 2006-01-01_12:01:01 -dir xdir -file .dat");
   regtest("list -old -stat -since today .");
   regtest("list -big -withdirs -since 20060101 .");
   regtest("list -small -hidden -quot .");
   regtest("list -late=20 -pure .");
   regtest("list -late=all -notime -nosize");
   regtest("list -late -sincedir rdir xdir");
   regtest("list -sincedif rdir -relnames .");

   ifcmd (   !strcmp(pszCmd, "list") || !strncmp(pszCmd, "sel", 3) // +chaining
          || !strcmp(pszCmd, "dir")  || !strcmp(pszCmd, "larc")
         )
   {
      ifhelp ((iDir < 3) && !chain.usefiles && (nparm < 1))
      printx("<help>$sfk list [-time] [-size|-size=digits] [...] dir [mask]\n"
             "$sfk sel[ect] -dir dir1 dir2 -file .ext1 .ext2 !.ext3 [...]\n"
             "\n"
             "   list all or just selected files from a directory tree.\n"
             "   select is the same, but it ignores command chaining input.\n"
             "\n"
             "   $options:\n"
             "      -time      show date and modification time\n"
             "      -size[=n]  show size of files [n characters wide]\n"
             "      -stat      show statistics (number of files, dirs, bytes)\n"
             #ifdef _WIN32
             "                 and tell if hidden files or dirs were skipped.\n"
             #endif
             #if (!defined(_WIN32) && !defined(SFK_LIB5))
             "      -nofollow  or -nofo does not follow symbolic directory links\n"
             #endif
             "      -withdirs  list also directories\n"
             "      -justdirs  list just directories\n"
             #ifdef _WIN32     
             "      -hidden    list also hidden or system files\n"
             #endif
             #ifndef _WIN32
             "      -verbose   list also non-regular files\n"
             "      -showskip  tell whenever dir contents are skipped to avoid\n"
             "                 double processing caused by symbolic links.\n"
             "      -allowdups disable detection of duplicate dir contents.\n"
             #endif
             "      -arc       list contents of .zip .jar .ear etc. archives\n"
             #ifdef VFILEBASE
             "                 and also .gz, .bz2, .tar, .tar.gz and .tar.bz2\n"
             "                 as deep as possible, including nested archives.\n"
             "                 type \"sfk help opt\" for supported file extensions.\n"
             "      -qarc      quick list archives, lists only archive entries\n"
             "                 at the top level, skipping nested archives.\n"
             #endif // VFILEBASE
             "      -sort[=n]  sort by name, list all or last n files\n"
             "      -sortrev   sort by name, in reverse order\n"
             "      -late[=n]  sort by time, list latest   [n] files last\n"
             "      -old[=n]   sort by time, list oldest   [n] files last\n"
             "      -big[=n]   sort by size, list biggest  [n] files last\n"
             "      -small[=n] sort by size, list smallest [n] files last\n"
             "      -late=all  sort by time, list all files\n"
             "      -notime    don't list time, after -late or -old\n"
             "      -nosize    don't list size, after -big  or -small\n"
             "      -pure      pure list of filenames, leave out time, size,\n"
             "                 headline or statistics.\n"
             "      -quot      surround filenames by double quotes. needed when\n"
             "                 post-processing filename lists containing blanks.\n"
             "      -quiet     do not show the \"scan\" progress information\n"
             "      -since     list only files since this timestamp, e.g.\n"
             "                    \"2006-01-31 12:15:59\" or 20060131121559\n"
             "                    2006-01-31 or 20060131\n"
             "                    today : files changed since midnight of today\n"
             "                    1d    : changed since 1 day, i.e. not counting\n"
             "                            from midnight, but 24 hours into the past\n" 
             "                    5h, 30m, 10s : 5 hours, 30 minutes, 10 seconds.\n"
             "      -before    select files modified before that timestamp.\n"
             "      -today     short replacement for \"-since today\".\n"
             "      -usectime  use or list creation time instead of modification time.\n"
             "                 may not be available on some filesystems.\n"
             "      -sincedir  compare against another directory, list files that\n"
             "       or -sd    have been added, have different time, or content.\n"
             "                 does not list files which have been removed.\n"
             "      -sinceadd  like -sincedir, list only added files.\n"
             "      -sincedif  like -sincedir, list only changed files.\n"
             "                 does not list files with diff. time but same content.\n"
             "                 does not list added files.\n"
             "      -sincechg  list files with different content, and added files.\n"
             "       or -sc    does not list files with diff. time but same content.\n"
      //     "      -incref    include names listed after -dir in sincedir references.\n"
      //     "      -verbose   lists non-existing reference directory names.\n"
             "      -relnames  list filenames relative to specified directory(s),\n"
             "                 i.e. strip root directory names at the beginning.\n"
             "      -tofile x  write all names directly to file x (using less memory\n"
             "                 than the chain command +tofile x).\n"
             "\n"
             "   $important details of file name / extension selection:\n"
             "      - when specifying a filename pattern beginning with a dot \".\"\n"
             "        and no wildcard, only files with this extension will be selected.\n"
             "      - otherwise the pattern is searched anywhere within the filename.\n"
             "        to force a filename start comparison, say %cpattern (with a slash).\n"
             "      - filename means the relative filename, not directory or path name.\n"
             ,glblPathChar
             );
      printx("\n"
             "   $command chaining difference between list and select:\n"
             "      +list accepts files from previous commands. +select ignores them,\n"
             "      allowing scripts to run many independent selects in one chain.\n"
             );
             #ifdef VFILEBASE
      if (cs.xelike)
      printx("\n"
             "   $no default archive content processing:\n"
             "      .zip .jar .tar .tgz .bz2 archive contents are NOT listed by default,\n"
             "      as this is not desirable if you just want a quick dir tree overview.\n"
             "      specify -arc or -qarc to activate archive content listing.\n"
             "      type \"sfk help opt\" to list all supported archive extensions.\n");
             #endif // VFILEBASE
      printx("\n"
             "   $aliases:\n"
             "      #sfk dir<def>         same as \"sfk list -stat\".\n"
             "      #sfk select<def>      same as list, but ignoring chain input.\n"
             "      #sfk larc<def>        same as \"sfk list -arc\".\n"
             );
      printx("\n"
             "   $see also:\n"
             "      #sfk help select<def> the sfk file selection syntax.\n"
             "      #sfk help opt<def>    for further general options.\n"
             "      #sfk stat<def>        to list directory tree sizes.\n");
      printx("\n"
             "   $examples:\n"
             "      #sfk list .\n"
             "         list all files of current directory and all subdirectories.\n"
             "      #sfk list mydir <not>.bak <not>.tmp.txt\n"
             "         list all files within mydir, except .bak and .tmp.txt files.\n"
             "      #sfk list -dir . -file foo .htm .java\\%c\n"
             "         this will find and list the following sample filenames:\n"
             "            thefoobar.dat     - matches anywhere-pattern \"foo\"\n"
             "            biginfo.htm       - matches exact extension  \".htm\"\n"
             "            test.java.9.15    - matches anywhere-pattern \".java\\%c\"\n"
             "         the command will NOT list the following sample filenames:\n"
             "            foosys\\thebar.dat - pattern must match filename, not path.\n"
             "            biginfo.html      - does not match extension \".htm\"\n"
             "      #sfk list -dir mydir <not>tmp <not><sla>save<sla> -file .txt\n"
             "         list all .txt files within mydir, excluding all sub folders\n"
             "         having \"tmp\" in their name, or called exactly \"save\".\n"
             ,glblWildChar,glblWildChar
             );
      printx("      #sfk alias list = sfk list -noop\n"
             "         after this, just typing \"list\" lists the current directory.\n"
             "      #sfk list -dir src1 -file .cpp -dir src2 -file .hpp\n"
             "         list .cpp files from src1, .hpp files from src2.\n"
             "      #sfk list -dir src \"*examples*\"\n"
             "         list contents of all directories having a name with \"examples\",\n"
             "         located somewhere below src. note that \"*examples*\" defines a\n"
             "         path mask, whereas \"examples\" would be another root directory.\n"
             "         under linux, patterns with a * wildcard MUST have quotes \"\".\n"
             "      #sfk list -late -dir . <wild>foo<wild> -file .jsp .java\n"
             "         list the most recent .jsp and .java files, in all dirs below\n"
             "         the current one (.) having \"foo\" in their pathname.\n"
             "      #sfk list -sincedir src5 src1 .cpp\n"
             "         provided that directory src5 is an older copy of src1, list the\n"
             "         .cpp files that have been added/changed since src5 was created.\n"
             "      #sfk list -pure -late=30 -quot | zip ..\\update.zip -@\n"
             "         collect the latest 30 files from current dir into a zip file,\n"
             "         using InfoZIP's option \"-@\" to use a filename list from stdin.\n"
             "      #sfk sel src .bak +del\n"
             "         select all .bak files in src, then delete them.\n"
             "      #sfk list -nosub -late mydir +sleep 5000 +loop\n"
             "         list most recent files of mydir every 5 seconds,\n"
             "         excluding all sub folder contents.\n"
             "      #sfk list . .jpg +count\n"
             "         tell the number of .jpg files in current directory tree.\n"
             #ifdef VFILEBASE
             "      #sfk larc src.zip +view\n"
             "         show content listing of zip file src.zip in Depeche View,\n"
             "         to search filenames interactively (\"sfk view\" for details).\n"
             #endif
             "      #sfk list . >lslr\n"
             "         list files of the current directory and all subdirectories into\n"
             "         an index text file \"lslr\" (named after the unix command \"ls -lR\").\n"
             "         doing this in a root directory may take some while, but afterwards\n"
             "         you will find the location of every file in realtime, by simply\n"
             "         typing \"sfk find lslr your_filename_pattern\".\n"
             "      #sfk list -qarc -tofile lslrx .\n"
             "         same as above, but including hidden and system files, as well as\n"
             "         the first content level of every .zip and .jar file. using -tofile\n"
             "         instead of \">lslrx\" redirection allows you to see a progress info.\n"
             "         doing this in a root dir like C:\\ may produce a filename listing\n"
             "         of several hundred MB in size.\n"
             #ifdef VFILEBASE
             "      #sfk list -hidden -arc -tofile lslrxl .\n"
             "         produce an ultimate file listing, including hidden and system files,\n"
             "         .zip and .jar contents, .tar, tar.gz and tar.bz2 contents, as well as\n"
             "         archive contents embedded within archives, like .class files embedded\n"
             "         within .jar files within a .tar.bz2 archive. running this command in a\n"
             "         root dir like C:\\ may take some hours, and it may produce a 1 GB\n"
             "         or more file listing, so make sure there is enough disk space.\n"
             #endif
             );
      ehelp;

      CommandScope ocmd("List");

      // the "dir" command is more verbose
      bool bStat = !strcmp(pszCmd, "dir") ? 1 : 0;

      // larc is the same as list -arc
      if (!strcmp(pszCmd, "larc")) {
         cs.travelzips = 1;
         #ifdef VFILEBASE
         cs.xelike     = 1;  // process zips as deep as possible
         #endif // VFILEBASE
      }

      nGlblListMode = 2;
      cs.listByTime = 0;
      cs.listBySize = 0;
      cs.listByName = 0;

      #ifdef VFILEBASE
      // list is the only command where traveling
      // of text content links is allowed.
      cs.travelHttp = 1;
      #endif // VFILEBASE

      // in case of multiple select in a chain, reset fileset:
      glblFileSet.reset();

      // the "select" command always ignores chain input:
      bool bselect = strBegins(pszCmd, "sel");
      if (bselect) chain.reset();

      bool bTime=0, bSize=0, bPure=0;

      char *pszParm    = 0;
      char *toFileName = 0;

      for (; iDir < argc; iDir++) 
      {
         char *pszParm = 0;
         #ifdef VFILEBASE
         if (!strcmp(argv[iDir], "-qarc")) {
            cs.travelzips  = 1;
            cs.xelike      = 1;
            cs.shallowzips = 1;  // toplevel only
         }
         else
         #endif // VFILEBASE
         if (!strcmp(argv[iDir], "-qarc")) {
            cs.travelzips  = 1;
         }
         else
         if (!strcmp(argv[iDir], "-twinscan")) {
            return 9+perr("-twinscan was replaced by sfk dupfind.\n");
         }
         else
         if (!strcmp(argv[iDir], "-size")) {
            // do not just remember the flag, but also option sequence.
            if (!bSize) {
               cs.listForm = ((cs.listForm << 8) | 0x01);
               bSize = 1;
            }
         }
         else
         if (!strncmp(argv[iDir], "-size=", strlen("-size="))) {
            // size format with digits specified
            if (!bSize) {
               cs.listForm = ((cs.listForm << 8) | 0x01);
               bSize = 1;
            }
            char *psz1 = argv[iDir] + strlen("-size=");
            nGlblListDigits = atol(psz1);
         }
         else
         if (!strncmp(argv[iDir], "-small", 6)) {
            // list sorted by size, show smallest 50 by default
            cs.listBySize = -50;
            if (!bSize && !bPure) {
               cs.listForm = ((cs.listForm << 8) | 0x01);
               bSize = 1;
            }
            if (!strncmp(argv[iDir], "-small=", strlen("-small="))) {
               char *psz1 = argv[iDir] + strlen("-small=");
               if (!strcmp(psz1, "all")) {
                  cs.listBySize    = 0 - 1; // sort direction
                  cs.listBySizeAll = 1;
               } else {
                  cs.listBySize = 0 - atol(psz1);
               }
            }
         }
         else
         if (!strncmp(argv[iDir], "-big", 4)) {
            // list sorted by size, show biggest 50 by default
            cs.listBySize = 50;
            if (!bSize && !bPure) {
               cs.listForm = ((cs.listForm << 8) | 0x01);
               bSize = 1;
            }
            if (!strncmp(argv[iDir], "-big=", strlen("-big="))) {
               char *psz1 = argv[iDir] + strlen("-big=");
               if (!strcmp(psz1, "all")) {
                  cs.listBySize    = 0 + 1; // sort direction
                  cs.listBySizeAll = 1;
               } else {
                  cs.listBySize = atol(psz1);
               }
            }
         }
         else
         if (!strncmp(argv[iDir], "-sort", 5))
         {
            // list sorted by name, ALL by default
            cs.listByName    = 0 + 1;
            cs.listByNameAll = 1;
            if (!strncmp(argv[iDir], "-sort=", 6)) 
            {
               char *psz1 = argv[iDir] + 6;
               if (!strcmp(psz1, "all")) {
                  // all is default
               } else {
                  cs.listByName    = atol(psz1);
                  cs.listByNameAll = 0;
               }
            }
            if (!strncmp(argv[iDir], "-sortr", 6)) 
            {
               cs.listByName = 0 - 1;
               if (!strncmp(argv[iDir], "-sortrev=", 9)) 
               {
                  char *psz1 = argv[iDir] + 9;
                  if (!strcmp(psz1, "all")) {
                     // all is default
                  } else {
                     cs.listByName    = 0 - atol(psz1);
                     cs.listByNameAll = 0;
                  }
               }
            }
         }
         else
         if (!strcmp(argv[iDir], "-nosize")) {
            // reverse implicite size listing by "-big"
            if ((cs.listForm & 0xFF) == 0x01) {
               cs.listForm >>= 8;
               bSize = 0;
            }
         }
         else
         if (!strcmp(argv[iDir], "-time")) {
            // do not just remember the flag, but also option sequence.
            if (!bTime) {
               cs.listForm = ((cs.listForm << 8) | 0x02);
               bTime = 1;
            }
         }
         else
         if (!strcmp(argv[iDir], "-stat")) {
            bStat = 1;
         }
         else
         if (!strncmp(argv[iDir], "-old", 4)) {
            // list sorted by time, show oldest 50 by default
            cs.listByTime = -50;
            if (!bTime && !bPure) {
               cs.listForm = ((cs.listForm << 8) | 0x02);
               bTime = 1;
            }
            if (!strncmp(argv[iDir], "-old=", strlen("-old="))) {
               char *psz1 = argv[iDir] + strlen("-old=");
               if (!strcmp(psz1, "all")) {
                  cs.listByTime    = 0 - 1; // sort direction
                  cs.listByTimeAll = 1;
               } else {
                  cs.listByTime = 0 - atol(psz1);
               }
            }
         }
         else
         if (!strncmp(argv[iDir], "-late", 5)) {
            // list sorted by time, show latest 50 by default
            cs.listByTime = 50;
            if (!bTime && !bPure) {
               cs.listForm = ((cs.listForm << 8) | 0x02);
               bTime = 1;
            }
            if (!strncmp(argv[iDir], "-late=", strlen("-late="))) {
               char *psz1 = argv[iDir] + strlen("-late=");
               if (!strcmp(psz1, "all")) {
                  cs.listByTime    = 0 + 1; // sort direction
                  cs.listByTimeAll = 1;
               } else {
                  cs.listByTime = atol(psz1);
               }
            }
         }
         else
         if (haveParmOption(argv, argc, iDir, "-sort", &pszParm)) {
            if (!pszParm) return 9;
            if (!strncmp(pszParm, "late", 4)) {
               cs.listByTime    = 0 + 1; // sort direction
               cs.listByTimeAll = 1;
            }
            if (!strncmp(pszParm, "old", 3)) {
               cs.listByTime    = 0 - 1; // sort direction
               cs.listByTimeAll = 1;
            }
            if (!strncmp(pszParm, "big", 3)) {
               cs.listBySize    = 0 + 1; // sort direction
               cs.listBySizeAll = 1;
            }
            if (!strncmp(pszParm, "small", 5)) {
               cs.listBySize    = 0 - 1; // sort direction
               cs.listBySizeAll = 1;
            }
         }
         else
         if (!strcmp(argv[iDir], "-notime")) {
            // reverse implicite time listing by "-late"
            if ((cs.listForm & 0xFF) == 0x02) {
               cs.listForm >>= 8;
               bTime = 0;
            }
         }
         else
         if (!strcmp(argv[iDir], "-pure")) {
            cs.pure = 1;
            cs.listForm = 0;
            bTime = 0;
            bSize = 0;
            cs.quiet = 1;
            cs.nohead  = 1;
            bPure = 1;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-tofile", &pszParm)) {
            if (!pszParm) return 9;
            toFileName = pszParm;
            continue;
         }
         else {
            char *pszOpt = argv[iDir];
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir)) {
               if (!strcmp(pszOpt, "-since")) {
                  // selecting -since activates time listing by default
                  if (!bPure && !bTime) {
                     cs.listForm = ((cs.listForm << 8) | 0x02);
                     bTime = 1;
                  }
               }
            }
            else
               break;
         }
      }

      long nsort=0, msort=0;
      if (cs.listByTime) { nsort++; msort |= 1; }
      if (cs.listBySize) { nsort++; msort |= 2; }
      if (cs.listByName) { nsort++; msort |= 4; }
      if (nsort > 1) {
         szLineBuf[0] = '\0';
         if (msort & 1) strcat(szLineBuf, "time");
         if (msort & 2) { if (szLineBuf[0]) strcat(szLineBuf, " AND "); strcat(szLineBuf, "size"); }
         if (msort & 4) { if (szLineBuf[0]) strcat(szLineBuf, " AND "); strcat(szLineBuf, "name"); }
         return 9+perr("cannot sort by %s\n", szLineBuf);
      }

      int iDirNext = 0;
      bool bAnyDirParms = 0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext, &bAnyDirParms)) return lRC;
      if (btest) return 0;

      // plausi checks
      if (chain.useany() && bAnyDirParms) {
         perr("%s got filenames from command chain AND as parameters", pszCmd);
         pinf("say \"+select\" instead of \"+%s\" to ignore chain input\n", pszCmd,pszCmd);
         return 9;
      }
      if (bselect && !bAnyDirParms) {
         if (chain.useany()) {
            perr("%s requires dir- or filename parameters, chain input is ignored.", pszCmd);
            pinf("say \"+list\" instead of \"+%s\" to use chained input filenames.\n", pszCmd);
            return 9;
         }
         // "sfk ... +sel" without any dir parms
         perr("%s requires dir- or filename parameters.", pszCmd);
         return 9;
      }

      if (chain.colany())
         cs.nohead = 1;

      // prepare listing to file
      cs.outfile = 0;
      if (toFileName) {
         if (chain.colany())
            return 9+perr("-tofile excludes any further chain processing.");
         if (!(cs.outfile = fopen(toFileName, "w")))
            return 9+perr("cannot open for writing: %s", toFileName);
      }

      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);

      // end listing to file
      if (cs.outfile) { fclose(cs.outfile); cs.outfile = 0; }

      info.clear();

      if (cs.listBySize) {
         long nCnt  = glblFileListCache.numberOfEntries();
         long iFrom = 0;
         if (!cs.listBySizeAll && (nCnt > abs(cs.listBySize))) {
            iFrom = nCnt - abs(cs.listBySize);
            if (!cs.nohead)
                printx("<file>[listing %ld of %ld files by size:]<def>\n", (long)(abs(cs.listBySize)), nCnt);
         }
         for (long i=iFrom; i<nCnt; i++) {
            Coi *pcoi = glblFileListCache.getEntry(i, __LINE__);
            // get text line prefixed by metatext length
            char *pszFull = pcoi->getExtStr();
            if (!pszFull) return 9+perr("internal 141271931\n");
            int nMetaLen = atol(pszFull);
            if (nMetaLen > (long)strlen(pszFull)) return 9+perr("internal 61212\n");
            if (strlen(pszFull) < 6) return 9+perr("internal 61213\n");
            char *pszText = pszFull+6;
            if (chain.colfiles)
               chain.addFile(*pcoi);
            else
            if (chain.coldata)
               chain.addLine(pszText, "");
            else
            {
               if (nMetaLen) {
                  setTextColor(nGlblFileColor);
                  printf("%.*s", nMetaLen, pszText);
                  setTextColor(-1);
               }
               oprintf("%s\n", pszText+nMetaLen);
            }
         }
      }

      if (cs.listByTime) {
         long nCnt  = glblFileListCache.numberOfEntries();
         long iFrom = 0;
         if (!cs.listByTimeAll && (nCnt > abs(cs.listByTime))) {
            iFrom = nCnt - abs(cs.listByTime);
            if (!cs.nohead)
                printx("<file>[listing %ld of %ld files by date:]<def>\n", (long)(abs(cs.listByTime)), nCnt);
         }
         long noldday = -1;
         long i=iFrom;
         if (i > 0) i--; // one precycle to find previous entry's day
         for (; i<nCnt; i++) {
            Coi *pcoi = glblFileListCache.getEntry(i, __LINE__);
            num nTime = pcoi->getTime();
            struct tm *pLocTime = 0;
            mytime_t nTime2 = (mytime_t)nTime;
            #ifdef SFK_W64
            pLocTime = _localtime64(&nTime2);   // may be NULL
            #else
            pLocTime = localtime(&nTime2);      // may be NULL
            #endif
            long nday = pLocTime->tm_yday;      // 0..365
            if (i < iFrom) {
               noldday = nday;
               continue; // empty precycle
            }
            // get text line prefixed by metatext length
            char *pszFull = pcoi->getExtStr();
            if (!pszFull) return 9+perr("internal 141271933\n");
            int nMetaLen = atol(pszFull);
            if (nMetaLen > (long)strlen(pszFull)) return 9+perr("internal 61211\n");
            if (strlen(pszFull) < 6) return 9+perr("internal 61214\n");
            char *pszText = pszFull+6;
            if (chain.colfiles)
               chain.addFile(*pcoi);
            else
            if (chain.coldata)
               chain.addLine(pszText, "");
            else
            {
               if (nMetaLen) {
                  if (nday != noldday) {
                     noldday = nday;
                     setTextColor(nGlblFileColor);
                  } else {
                     // setTextColor(nGlblPreColor);
                  }
                  printf("%.*s", nMetaLen, pszText);
                  setTextColor(-1);
               }
               oprintf("%s\n", pszText+nMetaLen);
            }
         }
      }

      if (cs.listByName) {
         long nCnt  = glblFileListCache.numberOfEntries();
         long iFrom = 0;
         if (!cs.listByNameAll && (nCnt > abs(cs.listByName))) {
            iFrom = nCnt - abs(cs.listByName);
            if (!cs.nohead)
                printx("<file>[listing %ld of %ld files by name:]<def>\n", (long)(abs(cs.listByName)), nCnt);
         }
         for (long i=iFrom; i<nCnt; i++) {
            Coi *pcoi = glblFileListCache.getEntry(i, __LINE__);
            // get text line prefixed by metatext length
            char *pszFull = pcoi->getExtStr();
            if (!pszFull) return 9+perr("internal 141271934\n");
            int nMetaLen = atol(pszFull);
            if (nMetaLen > (long)strlen(pszFull)) return 9+perr("internal 61220\n");
            if (strlen(pszFull) < 6) return 9+perr("internal 61221\n");
            char *pszText = pszFull+6;
            if (chain.colfiles)
               chain.addFile(*pcoi);
            else
            if (chain.coldata)
               chain.addLine(pszText, "");
            else
            {
               if (nMetaLen) {
                  setTextColor(nGlblFileColor);
                  printf("%.*s", nMetaLen, pszText);
                  setTextColor(-1);
               }
               oprintf("%s\n", pszText+nMetaLen);
            }
         }
      }

      if (bStat) // FIX 153R3: do not also check quiet, nohead
      {
         num   nbytes = nGlblBytes;
         char *punit  = "bytes";
         num   ndiv   = 1;

         if (nbytes > 1000000)
            {  ndiv   = 1000000; punit = "mb"; }
         else
         if (nbytes > 1000)
            {  ndiv   = 1000; punit = "kb"; }

         char nbuf1[50], nbuf2[50];

         if (ndiv > 1)
            printf("%ld files, %ld dirs, %s %s, %s bytes",cs.files,cs.dirs,numtoa(nbytes/ndiv,1,nbuf1),punit,numtoa(nbytes,1,nbuf2));
         else
            printf("%ld files, %ld dirs, %s bytes",cs.files,cs.dirs,numtoa(nbytes,1,nbuf1));

         if (cs.numHiddenFiles || cs.numHiddenDirs) {
            printf(", ");
            setTextColor(nGlblWarnColor, 1);
            printf("%ld hidden files, %ld dirs.\n", cs.numHiddenFiles, cs.numHiddenDirs);
            setTextColor(-1);
         }
         else
         if (cs.numHiddenFilesSkipped || cs.numHiddenDirsSkipped) {
            printf(".\n");
            setTextColor(nGlblWarnColor, 1);
            printf("skipped %ld hidden files, %ld hidden dirs.\n", cs.numHiddenFilesSkipped, cs.numHiddenDirsSkipped);
            setTextColor(-1);
         }
         else {
            printf(".\n");
         }
      }

      // diverse convience stuff, reminders etc.
      if (!cs.nohead && !cs.quiet) {
         bool btold = 0;
         if (cs.addedFilesSkipped > 0) {
            setTextColor(nGlblTimeColor, 1);
            printf("skipped %ld added files. ", cs.addedFilesSkipped);
            btold = 1;
         }
         if (cs.sincetime)
            if (cs.maxFileTime < cs.sincetime) {
               // user specified -since, but no files matched:
               num nnow = 0;
               tryGetRelTime("now", nnow);
               num nsec  = nnow - cs.maxFileTime;
               num nhrs  = nsec / 3600;
               num ndays = nhrs / 24;
               setTextColor(nGlblHeadColor, 1);
               if (ndays <= 0)
                  printf("most recent file is %s hours old.", numtoa(nhrs));
               else
                  printf("most recent file is %s days old.", numtoa(ndays));
               btold = 1;
            }
         if (btold) {
            setTextColor(-1);
            printf("\n");
         }
      }

      // detect -sincedir user errors
      if (!cs.quiet && pszGlblSinceDir && (nGlblMissingRefDirs > 0)) {
         if (nGlblMissingRefDirs > nGlblMatchingRefDirs)
            setTextColor(nGlblWarnColor, 1);
         else
            setTextColor(nGlblTimeColor, 1);
         printf("found %ld matching and %ld missing reference dirs (try -incref or -verbose)\n",nGlblMatchingRefDirs,nGlblMissingRefDirs);
         setTextColor(-1);
      }

      if (!cs.quiet) {
         if (cs.noFiles)
            printf("%lu non-regular files skipped.\n", cs.noFiles);
      }

      // step to next chain command (if any),
      // and copy filenames from chainfiles2 to chainfiles.
      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   regtest("md5gento x.dat xdir");
   regtest("md5gento=x.dat -quiet xdir");
   regtest("md5gento x.dat -rel -dir xdir");
   regtest("list xdir +md5gento xfile.md5");

   ifcmd (!strncmp(pszCmd, "md5gento", 8))   // +chaining
   {
      ifhelp (!strcmp(pszCmd, "md5gento") && (nparm < 2))
      printx("<help>$sfk md5gento[=]outputfile [-rel[names]]]] dirname [-quiet]\n"
             "\n"
             "   create list of md5 checksums over all selected files.\n"
             "\n"
             "   $options:\n"
             "\n"
             "      -rel   create a list with relative filenames, i.e. strip\n"
             "             the supplied dirname from the beginning of each name.\n"
             "\n"
             "      -quiet  do not print progress output while reading files.\n"
             "\n"
             "   #sfk md5gento contents.md5 .\n"
             "\n"
             "      create checksum of all files in current dir and subdirs,\n"
             "      and store them in contents.md5.\n"
             "\n"
             "   #sfk select -dir prod -file !.tmp +md5gento=checksums.md5\n"
             "\n"
             "      first select all files from prod, excluding .tmp files,\n"
             "      then create an md5 list to checksums.md5\n"
            );
      ehelp;

      pszGlblOutFile = 0;

      iDir--;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "md5gento", &pszParm)) {
            if (!pszParm) return 9;
            pszGlblOutFile = pszParm;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-rel", 4)) {
            bGlblMD5RelNames = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // fall through to short dir format
         break;
      }

      if (!pszGlblOutFile)
         return 9+perr("missing output filename\n");

      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3)) return lRC;
      if (btest) return 0;

      fGlblOut = fopen(pszGlblOutFile, "w");
      if (!fGlblOut) return 9+perr("cannot write %s\n", pszGlblOutFile);

      lRC = walkAllTrees(eFunc_MD5Write, lFiles, lDirs, nBytes);

      fclose(fGlblOut);

      info.print("%u files hashed into %s. %u kb/sec\n", glblFileCount.value(), pszGlblOutFile, currentKBPerSec());
      bDone = 1;
   }

   regtest("md5check x.dat");
   regtest("md5check=x.dat -quiet -skip=2");
   regtest("md5check x.dat -rel xdir -skip 10");

   ifcmd (!strncmp(pszCmd, "md5check", 8))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (!strcmp(pszCmd, "md5check") && !chain.usefiles && (nparm < 1))
      printx("<help>$sfk md5check[=]inputfile [-rel[ativeto]] dirname] [-quiet]\n"
             "\n"
             "   verify list of md5 checksums.\n"
             "\n"
             "   $options:\n"
             "\n"
             "      -rel     if dirname is supplied, treat filenames from list\n"
             "               as being relative to dirname. in this case, run the\n"
             "               command from dirname's parent directory.\n"
             "\n"
             "      -quiet   do not print progress output while checking files,\n"
             "               and do not list kb/sec speed stats.\n"
             "\n"
             "      -skip=n  do not check all files, perform just spot checking\n"
             "               by skipping n files after every checked file.\n"
             "\n"
             "   $return codes for batch files\n"
             "      0   normal execution, all checksums matched.\n"
             "      1   normal execution, checksum(s) mismatched.\n"
             "      2   some files were missing, all other checksums matched.\n"
             "      3   some files were missing, and some checksums mismatched.\n"
             "    >=9   severe error occurred, e.g. wrong checksum file format.\n"
             #ifdef _WIN32
             "\n"
             "         #@rem windows batchfile example\n"
             "         @echo off\n"
             "         sfk md5check mysums.txt -quiet >nul 2>nul\n"
             "         IF ERRORLEVEL 1 GOTO mdfailed\n"
             "         sfk echo \"[[green]]all ok[[def]]\"\n"
             "         GOTO mddone\n"
             "         :mdfailed\n"
             "         sfk echo \"[[red]]verification failed[[def]]\"\n"
             "         :mddone\n"
             #endif
            );
      ehelp;

      char *pszInFile = 0;
      char *pszRefDir = 0;

      iDir--;
      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "md5check", &pszParm)) {
            if (!pszParm) return 9;
            pszInFile = pszParm;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-rel", 4)) {
            iDir++;
            if (iDir >= argc) return 9+perr("missing dirname after -rel\n");
            pszRefDir = argv[iDir];
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-skip", &pszParm)) {
            if (!pszParm) return 9;
            nGlblMD5Skip = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // non-option parameter:
         if (!pszInFile)
            pszInFile = argv[iDir];
         else
            return 9+perr("unexpected parameter: \"%s\" (2)\n", argv[iDir]);
      }

      if (!pszInFile)
         return 9+perr("missing input filename\n");

      if (btest) return 0;

      char *pInFile = loadFile(pszInFile);
      if (!pInFile) return 9;

      lRC = execMD5check(pInFile, pszRefDir);

      delete [] pInFile;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   /*
   if (!strncmp(pszCmd, "metagen", 7))
   {
      if (argc < 3) {
      printx("<help>$sfk metagen[to][=]dbfile [-rel[names]]]] fileselection\n"
             "\n"
             "   create or update database with file meta informations.\n"
             "   this stores time, attribute, path and a content checksum\n"
             "   of all selected files.\n"
             "\n"
             "   $options:\n"
             "      -rel   create a list with relative filenames, i.e. strip\n"
             "             the supplied dirname from the beginning of each name.\n"
            );
      return 9;
      }

      char *pszDBFile = 0;

      iDir = 1;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "metagento", &pszParm)) {
            if (!pszParm) return 9;
            pszDBFile = pszParm;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "metagen", &pszParm)) {
            if (!pszParm) return 9;
            pszDBFile = pszParm;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-rel", 4)) {
            bGlblMD5RelNames = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // fall through to short dir format
         break;
      }

      if (!pszDBFile)
         return 9+perr("missing output filename\n");

      // always create new db:
      remove(pszDBFile);

      if (filedb.openUpdate(pszDBFile))
         return 9+perr("cannot open file meta db: %s\n", pszDBFile);

      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3)) return lRC;
      lRC = walkAllTrees(eFunc_MetaUpd, lFiles, lDirs, nBytes);

      long nSignsWritten = 0;
      if (filedb.canUpdate())
         if (filedb.save(nSignsWritten))
            return 9;

      info.print("%u file infos saved into %s. %u kb/sec\n", nSignsWritten, pszDBFile, currentKBPerSec());
      bDone = 1;
   }

   if (!strcmp(pszCmd, "metacheck"))
   {
      if (argc < 3) {
      printx("<help>$sfk metacheck dbfile [-rel[names]]]] fileselection\n"
             "\n"
             "   compare selected files against file meta db, and list those\n"
             "   which have different time or content.\n"
             "\n"
             "   $options:\n"
             "      -rel   use relative filenames.\n"
            );
      return 9;
      }

      char *pszDBFile = 0;

      iDir = 1;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "metacheck", &pszParm)) {
            if (!pszParm) return 9;
            pszDBFile = pszParm;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-rel", 4)) {
            bGlblMD5RelNames = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // fall through to short dir format
         break;
      }

      if (!pszDBFile)
         return 9+perr("missing output filename\n");

      if (filedb.openRead(pszDBFile))
         return 9+perr("cannot open file meta db: %s\n", pszDBFile);

      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3)) return lRC;
      lRC = walkAllTrees(eFunc_MetaCheck, lFiles, lDirs, nBytes);

      info.print("%u files compared.\n", cs.files);
      bDone = 1;
   }
   */

   regtest("md5 xfile1");
   regtest("md5 -quiet -verify bfb9acc99d1811730687f49a09318e8f xfile1");

   ifcmd (!strcmp(pszCmd, "md5"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk md5 [-quiet] [-verify md5sum] file1 [file2 file3 ...]\n"
             "\n"
             "   calculate md5 hash of one or more files, and optionally compare the results.\n"
             "   if md5 sums are compared, a message is shown, and the shell return code\n"
             "   is set to 0 (all equal), or 1 (not equal), or >1 (any other error).\n"
             "\n"
             "   $options\n"
             "      -nonames   do not echo filename(s), show only the md5 sum.\n"
             "      -verify    or -ver, or -v verifies the given filename(s) against\n"
             "                 the given checksum.\n"
             "      -nocomp    if multiple filenames are given, do not compare.\n"
             "\n"
             "      #sfk md5 test01.dat\n"
             "         tell md5 sum of test01.dat\n"
             "\n"
             "      #sfk md5 test01.dat test02.dat\n"
             "         compare both files, if content is the same.\n"
             "\n"
             #ifdef _WIN32
             "      #sfk md5 -quiet -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat\n"
             "         check if test01.dat has an md5 matching the one specified.\n"
             "         issues no output, returns just a shell return code.\n"
             "         within a windows .bat file, check the RC this way:\n"
             "\n"
             "         @echo off\n"
             "         sfk md5 -quiet -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat\n"
             "         if errorlevel 1 goto mismatch\n"
             "         echo \"file checked, all ok\"\n"
             "         goto done\n"
             "         :mismatch\n"
             "         echo \"file content mismatch\"\n"
             "         :done\n"
             #else
             "      #sfk md5 -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat\n"
             "         check if test01.dat has an md5 matching the one specified.\n"
             #endif
             );
      ehelp;

      bool bMismatch  = 0;
      bool bNames     = 1;
      bool bComp      = 1;
      char *pszVerify = 0;
      int  iFile      = -1;
      int  iFileMax   = argc; // exclusive

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (   haveParmOption(argv, argc, iDir, "-verify", &pszParm)
             || haveParmOption(argv, argc, iDir, "-ver", &pszParm)
             || haveParmOption(argv, argc, iDir, "-v", &pszParm)
            ) 
         {
            if (!pszParm) return 9;
            pszVerify = pszParm;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-noname")) {
            bNames = 0;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-nocomp")) {
            bComp = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext)) {
            iFileMax = iChainNext;
            break;
         }
         // process non-option keywords:
         if (iFile < 0) iFile = iDir;
         // else step through supplied filenames
      }

      if (iFile < 0) return 9+perr("supply filename(s) for reading\n");
      if (btest) return 0;

      num nstart = getCurrentTime();

      // read file(s), dump md5s underneath
      szLineBuf2[0] = '\0';
      long nFiles = 0;
      for (; iFile < iFileMax; iFile++)
      {
         nFiles++;

         {
            SFKMD5 md5;
            char *pszFile = argv[iFile];
            // special case: -verify checksum *filename
            // -> skip * before filename
            if (pszVerify && pszFile[0] == '*')
               pszFile++;
            if (getFileMD5(pszFile, md5))
               return 9;
            unsigned char *pmd5 = md5.digest();
            for (int i=0; i<16; i++)
               sprintf(&szLineBuf[i*2], "%02x", pmd5[i]);
            if (!cs.quiet) {
               if (chain.colany()) {
                  if (bNames)
                     chain.print("%s\t%s", szLineBuf, pszFile);
                  else
                     chain.print("%s", szLineBuf);
               } else {
                  if (bNames)
                     oprintf("%s\t%s\n", szLineBuf, pszFile);
                  else
                     printf("%s\n", szLineBuf);
               }
            }
            if (szLineBuf2[0] && strcmp(szLineBuf, szLineBuf2))
               bMismatch = 1;
            if (pszVerify && strcmp(pszVerify, szLineBuf))
               bMismatch = 1;
            strcpy(szLineBuf2, szLineBuf);
         }
      }

      lRC = bMismatch ? 1 : 0;

      if (((nFiles > 1 && bComp) || pszVerify != 0) && !cs.quiet) {
         if (chain.colany()) {
            if (bMismatch)
               chain.print("rc1 mismatch");
            else
               chain.print("rc0 equal");
         } else {
            if (bMismatch)
               printf("content mismatch (RC==1)\n");
            else
               printf("content is equal (RC==0)\n");
         }
      }

      if (cs.verbose)
         printf("done in %ld msec\n", (long)(getCurrentTime() - nstart));

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "test"))
   {
      if (argc < 3) {
      printx("<help>$sfk test mode dbfile tctitle infile\n"
             "\n"
             "   record/compare automated test results on a database.\n"
             "\n"
             "      mode:\n"
             "         rec   record checksum of infile\n"
             "         upd   record only if not yet contained in db\n"
             "         cmp   compare checksum against db entry\n"
             "      dbfile : a database file, created by sfk in mode -rec\n"
             "      tctitle: name of the testcase, e.g. T01.1.mytest\n"
             "      infile : an output file resulting from a testcase\n"
             "\n"
             "   the sequence of text lines within the infile is ignored.\n"
             "   this may lead to a checksum of \"0000\" if the input file\n"
             "   contains the same content twice.\n"
             "\n"
             "   $example:\n"
             "      #sfk test rec mycrc.db T01.1.encoding out1.dat\n"
             "      -> creates checksum of out1.dat, writes to mycrc.db\n"
             "         under the title T01.1.encoding\n"
             "      #sfk test cmp mycrc.db T01.1.encoding out1.dat\n"
             "      -> creates checksum of out1.dat, reads 2nd checksum\n"
             "         from mycrc.db, and compares both.\n"
             );
         return 9;
      }

      if (argc >= 3 && !strcmp(argv[2], "workdir"))
      {
         #ifdef _WIN32
         _getcwd(szLineBuf,sizeof(szLineBuf)-10);
         #else
         getcwd(szLineBuf,sizeof(szLineBuf)-10);
         #endif
         char *psz = strrchr(szLineBuf, glblPathChar);
         if (!psz) return 9;
         psz++;
         char *pszRelWorkDir = psz;
         if (argc == 4) {
            if (!strcmp(argv[3], pszRelWorkDir))
               return 0;
            else {
               if (cs.verbose)
                  printf("\"%s\" != \"%s\"\n",pszRelWorkDir,argv[3]);
               return 9;
            }
         } else {
            printf("%s\n", pszRelWorkDir);
         }
         return 0;
      }

      if (argc < 6) return 9+perr("missing arguments. type \"sfk test\" for help.\n");

      char *pszMode   = argv[2];
      char *pszDBFile = argv[3];
      char *pszTitle  = argv[4];
      char *pszInFile = argv[5];

      // create checksum of infile in szLineBuf.
      if (getFuzzyTextSum(pszInFile, abBuf))
         return 9;
      for (int i=0; i<16; i++)
         sprintf(&szLineBuf2[i*2], "%02x", abBuf[i]);

    {
      TestDB tdb(pszDBFile);

      // select command
      if (!strcmp(pszMode, "rec")) {
         tdb.load(1); // silent: ignore rc, create on 1st use
         // write unconditional, overwrite existing vals
         if (tdb.update(pszTitle, szLineBuf2)) return 9;
         if (tdb.write()) return 9;
         int tlen = strlen(pszTitle);
         if (tlen > 15) tlen = 15;
         printf(":REC : %s%.*s %s\n", pszTitle, (int)(15-tlen), pszGlblBlank, szLineBuf2);
      }
      else
      if (!strcmp(pszMode, "upd")) {
         tdb.load(1); // silent: ignore rc, create on 1st use
         // write only if not yet contained
         if (!tdb.getValue(pszTitle)) {
            if (tdb.update(pszTitle, szLineBuf2)) return 9;
            if (tdb.write()) return 9;
            int tlen = strlen(pszTitle);
            if (tlen > 15) tlen = 15;
            printf(":ADD : %s%.*s %s\n", pszTitle, (int)(15-tlen), pszGlblBlank, szLineBuf2);
         }
      }
      else
      if (!strcmp(pszMode, "cmp")) {
         if (tdb.load(0)) return 9;
         char *pszVal = tdb.getValue(pszTitle);
         if (!pszVal) return 9+perr("no such entry: %s\n", pszTitle);
         if (!strcmp(pszVal, szLineBuf2)) {
            // match
            printf(": OK : %s\n", pszTitle);
         } else {
            // mismatch
            printf(":FAIL: %s   - mismatch of %s\n", pszTitle, pszInFile);
            lRC = 9;
         }
      }
      else
         return 9+perr("unknown test mode: %s\n", pszMode);
    }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "snapto")) 
   {
      ifhelp (1)
      printx("$sfk snapto=outfile [-pure] [-nosub] -dir mydir1 -file .ext1 .ext2\n"
             "\n"
             "    Collect many text files into one large text file, specifying in detail\n"
             "    what sub folders and file (extensions) to include or exclude.\n"
             "    The resulting file format can be loaded directly by Depeche View,\n"
             "    allowing interactive search and filtering of the content.\n"
             "\n"
             "    $options\n"
             );
             #ifdef VFILEBASE
      if (cs.xelike)
      printx("       -arc        include content of .zip .jar .tar etc. archives.\n");
             #endif // VFILEBASE
             #ifdef _WIN32
      printx("       -hidden     include hidden and system files (not default).\n");
             #endif
      printx("       -allbin     include binary files as text extract (not default).\n"
             "       -pure       don't insert filenames.\n"
             "       -prefix=x   insert x before every file.\n"
             "       -nometa     by default, sfk adds the file system's time and size\n"
             "                   info to each :file: header. can be disabled here.\n"
             "                   note that size= may not reflect the actual bytes used\n"
             "                   within the snapfile, due to line ending conversions.\n"
         //  "       -raw        add text file content 1:1 without CRLF conversions\n"
         //  "                   and skip binary files completely. assures that the\n"
         //  "                   size= header field reflects the true content size.\n"
         //  "       -rawest     like -raw but does not even convert unexpected null\n"
         //  "                   or EOF (0x1A) characters within text data.\n"
             "       -nosub      or -norec does not include subdirectories (subfolders).\n"
             "       -wrap[=n]   auto-wrap long lines [near column n], e.g. -wrap=80.\n"
             "       -stat       show time stats at end.\n"
             ,glblPathChar);
      printx("\n"
             "    $see also\n"
             "       #sfk view<def>    about Depeche View, a high speed text browser.\n"
             );
      printx("\n"
             "    $examples\n"
             "       #sfk snapto=all-src.cpp . .cpp .hpp .dll <not>tmp\n"
             "          includes .cpp, .hpp and even .dll text extracts, excludes all\n"
             "          files with \"tmp\" in their name, e.g. tmp10.cpp\n"
             "\n"
             "       #sfk snapto=all-src.cpp -dir src2 <not>src2<sla>old -file -all .doc\n"
             "          includes all text files, and .doc binary extracts.\n"
             "\n"
             "       #sfk select src5 .txt .exe +snapto=all.txt\n"
             "          filenames provided by command chaining are always included,\n"
             "          no matter if binary or not. in this case, extracts from .exe\n"
             "          binary files are also placed into the output.\n"
             "\n"
             "       #sfk select -text mydir <not>.bak +snapto=all.txt\n"
             "          select all text files from mydir, excluding .bak files.\n"
             );
      ehelp;
      // no real action here
      return 9;
   }

   regtest("snapto=xfile.txt xdir .cpp .hpp -wrap");
   regtest("snapto=xfile.txt -pure -prefix=foo -dir xdir1 xdir2 -file .cpp");
   regtest("list xdir +snapto=xfile.txt");

   if (!strncmp(pszCmd, "snapto=", strlen("snapto=")))   // +chaining
   {
      pszGlblOutFile = pszCmd+strlen("snapto=");

      bool bstat     = 0;
      cs.addsnapmeta = 0xFFFFUL; // add as much infos as possible
      cs.addsnaplf   = "\n";     // by default converted by fprintf etc.

      #ifdef VFILEBASE
      cs.precachezip = 1;
      #endif // VFILEBASE

      const char *poutmode = "w";

      for (; iDir < argc; iDir++) {
         if (!strncmp(argv[iDir],"-prefix=",strlen("-prefix="))) {
            char *psz = argv[iDir]+strlen("-prefix=");
            if (strlen(psz) > 40)
               return 9+perr("prefix too long, only up to 40 characters are allowed.");
            pszGlblJamPrefix = psz;
         }
         else
         if (!strcmp(argv[iDir],"-pure"))
            bGlblJamPure = 1;
         else
         if (!strcmp(argv[iDir],"-stat"))
            bstat = 1;
         else
         if (!strcmp(argv[iDir],"-nometa"))
            cs.addsnapmeta = 0;
         else
         if (!strcmp(argv[iDir],"-raw")) {
            cs.addsnapraw = 1;
            // write snapfile in binary mode,
            // to avoid any conversions by fwrite
            poutmode = "wb";
            // therefore we need to specify exact
            // line endings used for header lines
            cs.addsnaplf  = glblLineEnd;
         }
         else
         if (!strcmp(argv[iDir],"-rawest")) {
            cs.addsnapraw = 2;
            poutmode = "wb";
         }
         else
         if (isDirParm(argv[iDir]))
            break; // fall through
         else
         if (!setGeneralOption(argv, argc, iDir))
            break;
      }

      // collect dir and mask parms
      bGlblAllowAllPlusPosFile = 1;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3)) return lRC;
      if (btest) return 0;

      fGlblOut = fopen(pszGlblOutFile, poutmode);
      if (!fGlblOut) return 9+perr("cannot write %s\n", pszGlblOutFile);

      // write global file header
      fprintf(fGlblOut, ":snapfile sfk,1.1,%slprefix=%s",
         cs.addsnapraw ? "raw,":"", pszGlblJamPrefix);
      if (cs.wrapcol > 0)
         fprintf(fGlblOut, ",wrap=%u", cs.wrapcol);
      fprintf(fGlblOut,"%s%s",cs.addsnaplf,cs.addsnaplf);
      // we will scan the input if we see this content, and exclude it

      // reset stats in case of input chaining
      glblFileCount.reset();
      cs.lines   = 0;
      nGlblBytes = 0;

      lRC = walkAllTrees(eFunc_JamFile, lFiles, lDirs, nBytes);

      fclose(fGlblOut);

      ulong nmbytes = (ulong)(nGlblBytes/1000000UL);
      ulong nkbytes = (ulong)(nGlblBytes/1000UL);
      ulong nkbsec  = currentKBPerSec();
      ulong nmbsec  = nkbsec / 1000UL;
      ulong nmsec   = (ulong)(getCurrentTime() - nGlblStartTime);
      ulong nsec    = nmsec / 1000UL;

      info.clear();

      if (bstat)
      printf("%u files collected into %s, %d lines, %u %s, %u %s, %u %s/sec\n",
         glblFileCount.value(), pszGlblOutFile, cs.lines,
         (nmbytes>0)?nmbytes:nkbytes, (nmbytes>0)?"mb":"kb",
         (nsec>=10)?nsec:nmsec, (nsec>=10)?"sec":"msec",
         (nmbsec>=10)?nmbsec:nkbsec, (nmbsec>=10)?"mb":"kb");
      else
      printf("%u files collected into %s, %d lines, %u %s\n",
         glblFileCount.value(), pszGlblOutFile, cs.lines,
         (nmbytes>0)?nmbytes:nkbytes, (nmbytes>0)?"mb":"kb");

      bDone = 1;
   }

   regtest("text-join-lines xinfile xoutfile");

   ifcmd (!strcmp(pszCmd, "joinlines") || !strcmp(pszCmd, "text-join-lines"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 2)
      printx("<help>$sfk joinlines infile outfile\n"
             "\n"
             "   join text lines from text split by email reformatting.\n"
            );
      ehelp;

      for (; iDir < argc; iDir++)
         if (!setGeneralOption(argv, argc, iDir))
            break;

      if (iDir >= argc-1) return 9+perr("missing arguments\n");

      char *pszInFile  = argv[iDir+0];
      for (long k=iDir+1; k<argc; k++)
         if (isChainStart(pszCmd, argv, argc, k, 0))
            return 9+perr("%s does not support chaining (%s).\n",pszCmd,argv[k]);
      char *pszOutFile = argv[iDir+1];

      if (btest) return 0;

      char *pInFile = loadFile(pszInFile);
      if (!pInFile) return 9;

      fGlblOut = fopen(pszOutFile, "w");
      if (!fGlblOut) {
         perr("cannot write %s\n", pszOutFile);
         delete [] pInFile;
         return 9; 
      }

      lRC = execTextJoinLines(pInFile);

      fclose(fGlblOut);
      delete [] pInFile;

      bDone = 1;
   }

   if (!strcmp(pszCmd, "scantab2")) 
   {
      cs.scanTabs = 1;
      if (lRC = processDirParms(pszCmd, argc, argv, 2, 3)) return lRC;
      lRC = walkAllTrees(eFunc_Detab, lFiles, lDirs, nBytes);
      printf("%d files of %d contain tabs.\n", cs.tabFiles, cs.files);
      bDone = 1;
   }

   regtest("scantab -dir xsrc1 xsrc2 -file .cpp .hpp .txt");
   regtest("scantab -quiet -pure . .cpp .hpp");
   regtest("list xdir .txt +scantab");

   ifcmd (!strcmp(pszCmd, "scantab"))  // +chaining
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk scantab [-quiet] dir [mask] [-pure]\n"
             "\n"
             "   list files containing tabs.\n"
             "\n"
             "   $options\n"
             "      -quiet   do not list filenames, show only statistics.\n"
             "      -pure    list only filenames, but no statistics.\n"
             "\n"
             "   $return codes for batch files\n"
             "      0 = no tabs, 1 = tabs found, >1 = error occurred.\n"
      //     "   -ind[ent]  collect also indentation statistics\n"
      //     "   -indsel=4  list only files with indentation 4\n"
      //     "   -verbose   list estimated indendation per file\n"
            );
      ehelp;

      // allow option -pure to be used anywhere:
      bGlblAllowGeneralPure = 1;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-indsel", &pszParm)) {
            if (!pszParm) return 9;
            cs.indentFilt = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-ind", 4)) {
            cs.scanIndent = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-pure")) {
            cs.pure = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         break;
      }

      memset(aGlblIndentStats, 0, sizeof(aGlblIndentStats));
      cs.scanTabs = 1;
      int iDirNext = 0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext)) return lRC;
      if (btest) return 0;

      lRC = walkAllTrees(eFunc_Scantab, lFiles, lDirs, nBytes);
      if (!lRC && (cs.tabFiles > 0)) lRC = 1; // found files with tabs

      if (!cs.indentFilt && !cs.pure)
         printf("%d files of %d contain tabs.", cs.tabFiles, cs.files);

      bool bTold=0;
      if (cs.scanIndent) 
      {
         // create sorted indent stats
         long i,k;
         long asize[20], acnt[20];
         memset(asize, 0, sizeof(asize));
         memset(acnt , 0, sizeof(acnt));
         // transform
         for (i=0; i<=8; i++) {
            long nsize = i;
            long ncnt  = aGlblIndentStats[i];
            asize[i] = nsize;
            acnt[i]  = ncnt;
         }
         // sort
         for (i=0; i<10; i++)
            for (k=i+1; k<10; k++)
               if (acnt[k] > acnt[i] || (asize[i] == 0)) {
                  long n   = acnt[i];
                  acnt[i]  = acnt[k];
                  acnt[k]  = n;
                       n   = asize[i];
                  asize[i] = asize[k];
                  asize[k] = n;
               }
         // dump sorted stats
         for (i=0; i<=10; i++) {
            if (acnt[i] > 0) {
               if (!bTold) {
                  printf(" %ld files have indent %ld", acnt[i], asize[i]);
                  bTold = 1;
               }
               else
               if (asize[i] > 0) {
                  printf(", %ld/%ld", acnt[i], asize[i]);
                  bTold = 1;
               }
               else
               if (bTold) // list unknowns only if others listed before
                  printf(", %ld/unknown", acnt[i]);
            }
         }
      }

      if (bTold)
         printf(".\n");
      else
      if (!cs.indentFilt && !cs.pure)
         printf("\n");

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   regtest("detab=3 xfile");
   regtest("detab=3 xsrc .cpp .hpp");
   regtest("list xdir .txt +detab=3");

   ifcmd (!strncmp(pszCmd, "detab", 5))  // +chaining (alpha)
   {
      ifhelp(   strncmp(pszCmd, "detab=", 6)
             || (!chain.useany() && (nparm < 1)) 
            )
      printx("<help>$sfk detab=tabsize dir ext1 [ext2 ...] [-to outmask]\n"
             "\n"
             "   replace tabs by spaces within file(s) or text stream.\n"
             "\n"
             "   $options\n"
             "      -to outmask   do not overwrite original files, but write\n"
             "                    to output files according to outmask, e.g.\n"
             "                    #-to tmp\\<run>path\\<run>base.<run>ext<def> or #-to tmp\\<run>file\n"
             "      -yes          if files are selected, really (re)write them.\n"
             "                    without -yes, detab is only simulated.\n"
             "\n"
             "   $see also\n"
             "      #sfk scantab<def>   list files containing TAB characters.\n"
             "\n"
             "   $examples\n"
             "      #sfk detab=3 sources .cpp .hpp\n"
             "         replace tabs by up to 3 blanks, within all .cpp and .hpp\n"
             "         files of directory tree \"sources\".\n"
             "\n"
             "      #sfk select -dir src -file .java +detab=4 -to tmp\\<run>file\n"
             "         list all .java files of src, then detab with tabsize 4,\n"
             "         writing all outputs to directory tree \"tmp\".\n"
             "\n"
             "      #sfk detab=4 src .java -relnames -to tmp\\<run>file\n"
             "         nearly the same, however stripping the \"src\" input directory\n"
             "         name from output file paths (not possible with \"+detab\" form).\n"
             "\n"
             "      #sfk filter mytext.txt +detab=8\n"
             "         detab content of a single file to the console.\n"
            );
      ehelp;

      char *pszTabSize = pszCmd+strlen("detab=");
      if (!(cs.tabSize = atol(pszTabSize))) return 9+perr("invalid tab size\n");
      cs.scanTabs = 0;

      int iDirNext = 0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext)) return lRC;
      if (btest) return 0;

      cs.sim = !cs.yes;

      if (chain.usedata) {
         // detab stream line
         for (long i=0; i<chain.indata->numberOfEntries(); i++) {
            szLineBuf[0]  = '\0';
            szLineBuf2[0] = '\0';
            char *psrc = chain.indata->getEntry(i, __LINE__);
            if (psrc) {
               strcopy(szLineBuf, psrc);  
               removeCRLF(szLineBuf);
            }
            detabLine(szLineBuf, szLineBuf2, MAX_LINE_LEN, cs.tabSize);
            if (chain.coldata) {
               chain.addLine(szLineBuf2, "");
            } else {
               printf("%s\n", szLineBuf2);
            }
         }
      } else {
         // detab file contents
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         lRC = walkAllTrees(eFunc_Detab, lFiles, lDirs, nBytes);

         const char *sxinfo = cs.sim ? "would be ":"";
         printf("%d files checked, %d %sdetabbed, %d tabs in total.\n", 
            cs.files, cs.tabFiles, sxinfo, cs.tabsDone);

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");
      }

      if (chain.usedata) {
         STEP_CHAIN(iDirNext, 1); // 1: use new data
      } else {
         STEP_CHAIN(iDirNext, 0); // 0: reuse existing filename list
      }

      bDone = 1;
   }

   ifcmd (strBegins(pszCmd, "del") || !strcmp(pszCmd, "rmtree"))  // +chaining
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk delete dir ext1 [ext2 ...] [-yes]\n"
             "$sfk deltree targetdir [-yes]\n"
             "$sfk del -dir dir1 dir2 -file .ext1\n"
             "\n"
             "   delete files or dirs, even if they're write protected.\n"
             "   deltree or rmtree deletes a directory tree with all contents.\n"
             "\n"
             "   $options\n"
             "      -yes         really delete the files. without option -yes,\n"
             "                   del only lists the files that would be deleted.\n"
             "      -withdirs    if you supply a file mask other than \"<wild>\",\n"
             "      or -wdir     and file deletion leads to an empty directory,\n"
             "                   then the directory is removed as well. if you\n"
             "                   supply no file mask (or \"<wild>\"), then every\n"
             "                   empty directory is always deleted. this option\n"
             "                   cannot be used with chaining, as chaining passes\n"
             "                   only filenames, but no processed directory names.\n"
             #ifdef _WIN32
             "      -hidden      include hidden and system files.\n"
             "                   this option is default when using deltree.\n"
             #endif
             "\n"
             "   $lazy confirmation on command chaining\n"
             "      if you selected files in a command chain, then want to add +del\n"
             "      you may type \"+del.\" (with a dot) or \"+del!\" (windows only)\n"
             "      instead of \"+del -yes\" to actually delete the files.\n"
             "\n"
             "   $examples\n"
             "      #sfk del -withdirs src .bak\n"
             "         deletes .bak files within src and all subdirs.\n"
             "         if a directory contained only .bak files,\n"
             "         it is deleted as well.\n"
             "\n"
             "      #sfk del -yes -withdirs -hidden tmp\n"
             "         delete tmp with all files, including hidden files.\n"
             "\n"
             "      #sfk deltree. tmp\n"
             "         the same as above, with \".\" as a short for -yes.\n"
             "\n"
             "      #sfk list -dir src -file foo*.hpp +del\n"
             "         first list target files, then add +del\n"
             #ifdef _WIN32
             "\n"
             "      #sfk fromclip +del\n"
             "         take a list of filenames from clipboard and delete them.\n"
             "         see \"sfk help shell\" on how to configure your windows\n"
             "         command prompt, to allow easy copying of filename lists.\n"
             #endif
            );
      ehelp;

      bool bdeltree = 0;

      if (strBegins(pszCmd, "deltree")) {
         bdeltree = cs.hidden = cs.withdirs = 1;
         if (   !strcmp(pszCmd, "deltree.")
             || !strcmp(pszCmd, "deltree!")
            )
            cs.yes = 1;
      }

      if (strBegins(pszCmd, "rmtree")) {
         bdeltree = cs.hidden = cs.withdirs = 1;
         if (   !strcmp(pszCmd, "rmtree.")
             || !strcmp(pszCmd, "rmtree!")
            )
            cs.yes = 1;
      }

      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // process non-option keywords:
         break; // fall through
      }

      // lazy confirmation: accept -del. as -del -yes
      if (!strcmp(pszCmd, "del.") || !strcmp(pszCmd, "del!"))
         cs.yes = 1;

      int iDirNext = 0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext)) return lRC;
      if (btest) return 0;

      cs.sim = !cs.yes;

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_Delete, lFiles, lDirs, nBytes);

      info.clear();
      if (cs.quiet < 2) {
         const char *sxinfo = cs.sim ? "would be ":"";
         if (cs.withdirs)
            printf("%d files, %ld dirs %sdeleted. ", cs.filesDeleted, cs.dirsDeleted, sxinfo);
         else
            printf("%d files %sdeleted. ", cs.filesDeleted, sxinfo);
         char *pcont = "including ";
         if (cs.filesDeletedWP) {
            printx("<time>including %ld readonly files<def>", cs.filesDeletedWP);
            pcont = ", ";
         }
         if (cs.dirsDeletedWP)
            printx("<time>%s%ld readonly dirs<def>", pcont,cs.dirsDeletedWP);
         printf("\n");
      }

      if (cs.sim && !cs.nohead) {
         #ifdef _WIN32
         printx("$[say -yes, %s. or %s! to execute.]\n",bdeltree ? "deltree":"del",bdeltree ? "deltree":"del");
         #else
         printx("$[say -yes or %s. to execute.]\n",bdeltree ? "deltree":"del");
         #endif
      }

      STEP_CHAIN(iDirNext, 0); // 0: reuse existing filename list

      bDone = 1;
   }

   regtest("entab=3 xfile");
   regtest("list xdir .java +entab=4");

   ifcmd (!strncmp(pszCmd, "entab=", strlen("entab=")))  // +chaining (alpha)
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk entab=tabsize dir ext1 [ext2 ...]\n"
             "\n"
             "   replace groups of spaces by tabs within file(s).\n"
             "\n"
             "      #sfk entab=3 sources .cpp .hpp\n"
             "      #sfk entab=3 singleFileName.txt\n"
             "\n"
             "   $experimental!\n"
             "   so far, this command rewrites every selected file,\n"
             "   no matter if blanks would be replaced by tabs or not.\n"
            );
      ehelp;

      char *pszTabSize = pszCmd+strlen("entab=");
      if (!(cs.tabSize = atol(pszTabSize))) return 9+perr("invalid tab size\n");
      cs.scanTabs = 0;

      int iDirNext = 0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext)) return lRC;
      if (btest) return 0;

      cs.sim = !cs.yes;

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_Entab, lFiles, lDirs, nBytes);

      const char *sxinfo = cs.sim ? "would be ":"";
      printf("%d files checked, %d %sentabbed, %d tabs in total.\n", 
         cs.files, cs.tabFiles, sxinfo, cs.tabsDone);

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      STEP_CHAIN(iDirNext, 0);
      bDone = 1;
   }

   regtest("addcr xfile");
   regtest("lf-to-crlf xsrc .cpp .hpp");
   regtest("list xdir .txt +addcr");
   regtest("list -dir xdir1 xdir2 -file .cpp .hpp +lf-to-crlf");

   ifcmd (   !strcmp(pszCmd, "lf-to-crlf")   // +chaining (alpha)
          || !strcmp(pszCmd, "addcr") 
          || !strcmp(pszCmd, "addcrlf")
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk lf-to-crlf [or addcr] dir .ext1 .ext2 [-to outmask]\n"
             "\n"
             "   convert just-lf (unix) text format to cr+lf (dos/windows).\n"
             "\n"
             "   $examples\n"
             "\n"
             "      #sfk addcr src .cpp .hpp\n"
             "         add crlf on all .cpp and .hpp files within src.\n"
             "\n"
             "      #sfk select -dir doc -file .txt +addcr -to tmp\\<run>file\n"
             "         add crlf on all .txt files within doc, saving to tmp.\n"
            );
      ehelp;
 
      int iDirNext = 0;
 
      nGlblConvTarget = eConvFormat_CRLF;
      // printf("argr %ld, iDir %ld\n",argr,iDir);
      if (nparm == 1 && strcmp(argv[iDir], "-i")) {
         // single file name given
         char *pszFile = argv[iDir];
         if (btest) return 0;
         if (execFormConv(pszFile, 0))
            return 9;
      } else {
         if (lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext)) return lRC;
         if (btest) return 0;
         lRC = walkAllTrees(eFunc_FormConv, lFiles, lDirs, nBytes);
      }
      printf("%d files converted.\n", cs.files);

      STEP_CHAIN(iDirNext, 0);
      bDone = 1;
   }

   regtest("remcr xfile");
   regtest("crlf-to-lf xsrc .cpp .hpp");
   regtest("list xdir .txt +remcr");
   regtest("list -dir xdir1 xdir2 -file .cpp .hpp +crlf-to-lf");

   ifcmd (   !strcmp(pszCmd, "crlf-to-lf")   // +chaining (alpha)
          || !strcmp(pszCmd, "remcr") 
          || !strcmp(pszCmd, "remcrlf")
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk crlf-to-lf [or remcr] dir .ext1 .ext2 [-to outmask]\n"
             "\n"
             "   convert cr+lf (dos/windows) text format to just-lf (unix).\n"
             "\n"
             "      #sfk remcr src .cpp .hpp\n"
            );
      ehelp;

      int iDirNext = 0;

      nGlblConvTarget = eConvFormat_LF;
      if (nparm == 1 && strcmp(argv[iDir], "-i")) {
         // single file name given
         char *pszFile = argv[iDir];
         if (btest) return 0;
         if (execFormConv(pszFile, 0))
            return 9;
      } else {
         if (lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext)) return lRC;
         if (btest) return 0;
         lRC = walkAllTrees(eFunc_FormConv, lFiles, lDirs, nBytes);
      }
      printf("%d files converted.\n", cs.files);

      STEP_CHAIN(iDirNext, 0);
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "synctext"))
   {
      ifhelp (1)
      printx("<help>$sfk synctext=dbfile [-stop] dir mask [<not>mask2]\n"
             "   collect several files into one editable clusterfile, for rapid global editing.\n"
             "   1. load the created clusterfile with your favourite text editor,\n"
             "      then apply global changes, and save:\n"
             "      -> changes in the clusterfile are written back to targets automatically.\n"
             "   2. load any of the target files in your editor, apply changes, save:\n"
             "      -> changes in the targets are synced into the clusterfile automatically.\n"
             "   option -stop: exit after initial file collection, e.g. for post-processing.\n"
             "      #sfk synctext=cluster.cpp . .cpp .hpp\n"
             "\n"
             "$sfk synctext=dbfile [-up]\n"
             "    reuse an existing clusterfile.\n"
             "    on start, by default, cluster diffs are written to the target files.\n"
             "    on start, with -up, target file diffs are written into the cluster.\n"
             "       sfk synctext=cluster.cpp\n"
             "\n"
             "$sfk synctext=dbfile -from=myconfig.sfk\n"
             "    read command line parameters from config file, e.g.\n"
             "       -dir\n"
             "          foosys\\bar1\\include\n"
             "          foosys\\bar1\\source\n"
             "          <not>save_patch\n"
             "       -file\n"
             "          .cpp .hpp\n"
             "\n"
             "<head>synctext mapping of compiler error output line numbers:<def>\n"
             "    make yoursys.mak >err.txt 2>&1\n"
             "    sfk maptext=yourcluster.cpp [-nomix] [-cmd=...] <err.txt\n"
             "       nomix: list only the mapped output lines. cmd: on first mapped line,\n"
             "       call supplied command, with clustername and line as parameters.\n"
             );
      ehelp;
      // no real action here
      return 9;
   }

   regtest("synctext=xfile.java xdir1");
   regtest("list xdir +synctext=xfile.cpp");

   if (!strncmp(pszCmd, "synctext=", strlen("synctext="))) // +chaining
   {
      char *pszSnapFile = pszCmd+strlen("synctext=");
      glblFileSnap.setFileName(pszSnapFile);
      pszGlblOutFile = pszSnapFile; // to avoid inclusion of this in input

      // determine current root dir
      #ifdef _WIN32
      _getcwd(szLineBuf,sizeof(szLineBuf)-10);
      #else
      getcwd(szLineBuf,sizeof(szLineBuf)-10);
      #endif
      char *psz = strrchr(szLineBuf, glblPathChar);
      if (!psz)
         return 9+perr("you can do this only from within a directory, not from root.\n");
      psz++;
      pszGlblJamRoot = strdup(psz);
      glblFileSnap.setRootDir(pszGlblJamRoot);

      bool bInitialUpSync = 0;
      bool bStop = 0;
      for (; iDir < argc; iDir++) {
         if (!strcmp(argv[iDir], "-up"))
            bInitialUpSync = 1;
         else
         if (!strcmp(argv[iDir], "-stop"))
            bStop = 1; // stop after collecting files
         else
         if (isDirParm(argv[iDir]))
            break; // fall through
         else
         if (!setGeneralOption(argv, argc, iDir))
            break;
      }

      // collect dir and mask parms
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 0)) // no autocomplete!
         return lRC;
      if (btest) return 0;

      long nReloadInfo = 0;

      // if any target file information is given
      if (glblFileSet.anyRootAdded())
      {
         if (glblFileSet.fileMasks().numberOfEntries() <= 0)
            return 9+perr("you have to select file types, e.g. synctext=tmp.txt thedir .hpp .cpp\n");

         // read and add targets to memory snapshot
         walkAllTrees(eFunc_SnapAdd, lFiles, lDirs, nBytes);
         // now, glblMemSnap contains all targets.

         // create and write the snapfile
         glblFileSnap.copyTargetsFrom(glblMemSnap);
         if (glblFileSnap.writeToFile())
            return 9;
         printf("> created: %s\n", glblFileSnap.getFileName());
      }
      else
      {
         // else load the snapfile directly
         printf("> load : %s\n", glblFileSnap.getFileName());
         long bDroppedAny = 0;
         if (glblFileSnap.readFromFile(bDroppedAny, 0))
            return 9;
         // and force initial sync
         long lMissing = 0;
         if (glblMemSnap.mirrorTargetsFrom(glblFileSnap, lMissing))
            return 9;
         if (lMissing > 0) {
            fprintf(stderr, "> info: %d files do not exist, will re-create\n", lMissing);
         }
         if (bInitialUpSync) {
            // user selected initial up-sync
            printf("> re-reading all targets ...\n");
            long lSynced = 0;
            glblMemSnap.setAllTouched();
            if (glblFileSnap.syncUpTargets(glblMemSnap, lSynced))
               return 9;
            // tell initially to reload snapfile
            if (lSynced > 0)
               nReloadInfo = 7;
         } else {
            // initial down-sync (default)
            printf("> sync : %s\n", glblFileSnap.getFileName());
            long nSynced = 0;
            if (glblMemSnap.syncDownTargets(glblFileSnap, nSynced))
               return 9;
            printf("> done : %d targets (re)written [%u,%u]\n", nSynced, glblFileSnap.numberOfTargets(), glblMemSnap.numberOfTargets());
         }
      }

      // wait for changes and sync them
      int iBlink = 0;
      char *pszBlink = "-\\|/";
      char *pszInfo  = "";
      num  lSnapFileTime = getFileTime(glblFileSnap.getFileName());
      long bLFDone = 0;
      long bbail = bStop; // 0 by default
      while (!bbail)
      {
         #ifdef _WIN32
         for (long iDelay=0; iDelay<10; iDelay++) {
            if (userInterrupt()) {
               bbail = 1;
               break;
            }
            Sleep(100);
         }
         #else
         sleep(1);
         #endif

         pszInfo = "                   ";

         if (bFatal) {
            if (!bLFDone) { bLFDone=1; printf("\n"); }      
            iBlink++;
            if (iBlink & 1) printf("* * * S Y N C   A B O R T E D * * *   \r");
            else            printf("                                      \r");
            fflush(stdout);
            continue;
         }

         // check for updates in the snapfile
         num lSnapTimeNew = getFileTime(glblFileSnap.getFileName());
         if (lSnapTimeNew != lSnapFileTime) 
         {
            // remember new filetime
            lSnapFileTime = lSnapTimeNew;
            // re-read the snapfile
            long bDroppedAny = 0;
            if (glblFileSnap.readFromFile(bDroppedAny, 1))
               { bFatal=1; continue; }
            if (bDroppedAny) {
               // target list changed. have to re-write and reload.
               if (glblFileSnap.writeToFile()) return 9;
               bDroppedAny = 0;
               if (glblFileSnap.readFromFile(bDroppedAny, 1)) return 9;
               nReloadInfo = 7;
            }
            // check for changed snapfile targets
            long nSynced = 0;
            if (glblMemSnap.syncDownTargets(glblFileSnap, nSynced))
               { bFatal=1; continue; }
            if (nSynced == 0 && nReloadInfo == 0) {
               printf("[ NODIF: %s ]                       \n", glblFileSnap.getFileName());
            } else {
               #ifdef SFK_WINPOPUP_SUPPORT
               // collect short infos about written files
               szLineBuf[0] = '\0';
               for (int i=0; i<MAX_SYNC_INFO; i++) {
                  char *psz1 = glblMemSnap.getLastSyncInfo(i);
                  if (psz1) {
                     char *psz2 = strrchr(psz1, glblPathChar);
                     if (psz2) psz1 = psz2+1;
                     if ((strlen(psz1)+strlen(szLineBuf)) < sizeof(szLineBuf)-10) {
                        strcat(szLineBuf, psz1);
                        strcat(szLineBuf, " ");
                     }
                  }
               }
               // e.g. on file dropping, this might be empty
               if (strlen(szLineBuf) > 0)
                  showInfoPopup(szLineBuf);
               #endif
            }
            pszInfo = (nSynced > 0) ? (char*)"loaded" : (char*)"no change";
         }

         // check for updates in the target files
         long lRC = glblMemSnap.checkLoadTargets();
         if (lRC > 3)
           { bFatal=1; continue; }
         long lSynced = 0;
         if (lRC & 1) {
            // updates have been reloaded. 
            // reloaded targets have the touched() flag set.
            // we expect user knows what's going on,
            // therefore sync up into the snapfile.
            if (glblFileSnap.syncUpTargets(glblMemSnap, lSynced))
               { bFatal=1; continue; }
            if (lSynced > 0)
               nReloadInfo = 7;
         }
         if (lRC & 2) {
            // files became unreadable and have been dropped
            if (lSynced == 0) {
               printf("[ WRITE : %s ]\n", glblFileSnap.getFileName());
               glblFileSnap.writeToFile();
               nReloadInfo = 7;
            }
            // else cluster write was done above
         }

         iBlink++;
         if (nReloadInfo > 0) {
            if (nReloadInfo == 7) {
               #ifdef SFK_WINPOPUP_SUPPORT
               showInfoPopup(0);
               #endif
            }
            nReloadInfo--;
            if (iBlink & 1) pszInfo = "* * * RELOAD CLUSTER NOW * * *";
            else            pszInfo = "                              ";
            printf("%s \r",pszInfo);
            fflush(stdout);
         } else {
            #ifdef _WIN32
            printf("%c auto-sync active, %d targets. (%u kb) %s \r",
               pszBlink[iBlink & 3],glblMemSnap.numberOfTargets(),
               #ifdef SFK_MEMTRACE
               sfkmem_bytes / 1024,
               #else
               0,
               #endif
               pszInfo);
            #else
            printf("%c auto-sync active, %d targets. %s \r",
               pszBlink[iBlink & 3],glblMemSnap.numberOfTargets(),
               pszInfo);
            #endif
            fflush(stdout);
         }
      }

      bDone = 1;
   }

   if (!strncmp(pszCmd, "maptext=", strlen("maptext=")))
   {
      if (blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      char *pszSnapFile = pszCmd+strlen("maptext=");
      glblFileSnap.setFileName(pszSnapFile);
      pszGlblOutFile = pszSnapFile; // to avoid inclusion of this in input

      // options, command supplied?
      bool bMix = 1;
      char *pszCmd2 = 0;
 
      for (; iDir < argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-nomix")) {
            bMix = 0;
         }
         else
         if (!strncmp(argv[iDir], "-cmd=", strlen("-cmd="))) {
            pszCmd2 = argv[iDir] + strlen("-cmd=");
         }
         else
         if (isDirParm(argv[iDir]))
            break; // fall through
         else
         if (!setGeneralOption(argv, argc, iDir))
            break;
 
      }
 
      // determine current root dir
      #ifdef _WIN32
      _getcwd(szLineBuf,sizeof(szLineBuf)-10);
      #else
      getcwd(szLineBuf,sizeof(szLineBuf)-10);
      #endif
      char *psz = strrchr(szLineBuf, glblPathChar);
      if (!psz)
         return 9+perr("you can do this only from within a directory, not from root.\n");
      psz++;
      pszGlblJamRoot = strdup(psz);
      glblFileSnap.setRootDir(pszGlblJamRoot);

      // collect dir and mask parms
      if (lRC = processDirParms(pszCmd2, argc, argv, iDir, 0)) // no autocomplete!
         return lRC;
      if (btest) return 0;

      long nReloadInfo = 0;

      // load the snapfile directly
      // printf("> load : %s\n", glblFileSnap.getFileName());
      long bDroppedAny = 0;
      if (glblFileSnap.readFromFile(bDroppedAny, 0))
         return 9;

      // go into compiler output parsing mode
      glblFileSnap.mapCompilerOutput(bMix, pszCmd2);

      bDone = 1;
   }

   regtest("stat -minsize=10 .");
   regtest("stat -quiet -i");

   ifcmd (strBegins(pszCmd, "stat") || strBegins(pszCmd, "treesize"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk stat [-minsize=mb] dir [-i]\n"
             "$sfk treesize[mb] dir\n"
             "\n"
             "   show directory tree size statistics in mbytes.\n"
             #ifdef _WIN32
             "   hidden and system files are INCLUDED by DEFAULT,\n"
             "   to make sure the real size usage is always shown.\n"
             #endif
             "\n"
             "   $options\n"
             "      -minsize=n   list only dirs and files with a size\n"
             "                   of at least n mbytes.\n"
             "      -i           read list of directories from stdin.\n"
             #ifdef _WIN32
             "      -nohidden    exclude hidden and system files.\n"
             #endif
             "      -nosum       print no summary at end of listing.\n"
             "      -sum         print only the summary.\n"
             "      -kbytes      list all sizes in kbytes.\n"
             "      -bytes       list all sizes in bytes.\n"
             "      -flat        show the no. of files and bytes per folder\n"
             "                   without it's subfolders (do not accumulate).\n"
             "\n"
             "   $aliases\n"
             "      #sfk stat10<def>       does the same as #sfk stat -minsize=10<def>\n"
             "      #sfk treesize100<def>  does the same as #sfk stat -minsize=100<def>\n"
             #ifdef VFILEBASE
             "\n"
             "   $limitations\n"
             "      this command cannot summarize zip file contents.\n"
             #endif // VFILEBASE
             "\n"
             "   $examples\n"
             "      #sfk stat . -minsize=10m\n"
             "          list sizes of all directories below the current one\n"
             "          having a size of at least 10 mbytes.\n"
             "\n"
             "      #sfk stat50 docs\n"
             "          list all directories and single files under the docs\n"
             "          directory tree having a size of >= 50 mbytes.\n"
             "\n"
             "      #type dirlist.txt | sfk stat -quiet -i\n"
             "          list sizes of dirs listed in dirlist.txt\n"
             );
      ehelp;

      nGlblListMode = 1;
      cs.withdirs   = 1; // always, esp. on receive of dirs by chain
      bool bSummary = 1;
      cs.hidden     = 1; // INCLUDE HIDDEN FILES BY DEFAULT (windows)

      // command aliases: "stat10" == "stat -minsize=10"
      char *pqsize = pszCmd + 4;
      if (strBegins(pszCmd, "treesize"))
            pqsize = pszCmd + 8;
      if (*pqsize) {
         if (!isdigit(*pqsize)) return 9+perr("supply a number after stat, like stat10.\n");
         nGlblListMinSize = atol(pqsize) * 1000000;
      }

      int iChainNext = 0;
      for (; iDir < argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-minsize=", strlen("-minsize="))) {
            char *pszMinSize = &argv[iDir][strlen("-minsize=")];
            nGlblListMinSize = atol(pszMinSize) * 1000000;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-kbyte")) {
            cs.listunit = 'k';
            continue;
         }
         else
         if (strBegins(argv[iDir], "-byte")) {
            cs.listunit = 'b';
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-flat")) {
            cs.flatdirstat = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nosum", 6)) {
            bSummary = 0;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-sum")) {
            cs.statonlysum = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // short file set expected
      }

      int nAutoComp = (bGlblStdInAny || chain.usefiles) ? 3 : 1;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, nAutoComp, &iChainNext))
         return lRC;
      if (btest) return 0;

      // on which level should directory size summaries be highlighted?
      if (glblFileSet.numberOfRootDirs() < 2)
         cs.stathilitelevel = 1; // on 0 (rootdir) and 1 (first below)
      // else >= 2 roots exist, highlight only on that level

      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);

      if (cs.flatdirstat) {
         lFiles = cs.flatfilecnt;
         lDirs  = cs.flatdircnt;
         nBytes = cs.flatbytecnt;
      }

      long lMBytes = (long)(nBytes / 1000000);

      if (!cs.quiet && bSummary) {
         // chained mode: no dir stats, just add filesizes.
         setTextColor(nGlblHeadColor);
         switch (cs.listunit) {
            case 'b':
               printf("%s, %5ld files, %ld dirs, %s bytes.\n", numtoa_blank(nBytes, 12), lFiles, lDirs, numtoa(nBytes));
               break;
            case 'k':
               printf("%s kb, %5ld files, %ld dirs, %s bytes.\n", numtoa_blank(nBytes/1000, 10), lFiles, lDirs, numtoa(nBytes));
               break;
            default :
               printf("%5ld mb, %5ld files, %ld dirs, %s bytes.\n", lMBytes, lFiles, lDirs, numtoa(nBytes));
               break;
         }
         setTextColor(-1);
         if (cs.noFiles)
            printf("%lu non-regular files skipped.\n", cs.noFiles);
      }

      // chaining: collected text lines
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   regtest("find -norec -text -lnum -nocol xdir xpat1 xpat2");
   regtest("grep -c -names -quiet -pat xpat1 -dir xdir1 xdir2 -file .dat");
   regtest("list xdir +find mypat");
   regtest("list xdir +find -pat mypat");

   ifcmd (   !strcmp(pszCmd, "find") || !strcmp(pszCmd, "grep")   // +chaining
          || !strcmp(pszCmd, "ftext")
         )
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk find [-c] singledir pattern [pattern2] [pattern3] ... [-names]\n"
             "$sfk grep [-c] -pat pattern [pattern2] -dir dir1 [-file] [.ext1] ...\n"
             "\n"
             "    case-insensitive pattern search for text and binary. if multiple\n"
             "    patterns are given, then only areas containing ALL are listed.\n"
             "    by default, find tries to autodetect if a file is text or binary.\n"
             "    with binary files, the distance between patterns found must be <80\n"
             "    chars to be listed as a hit.\n"
             "\n"
             "    $options\n");
             #ifdef VFILEBASE
      if (cs.xelike)
      printx("    -arc      include content of .zip .jar .tar etc. archives.\n");
             #endif // VFILEBASE
      printx("    -text     process only text files, skip all binary files.\n"
             "              finds patterns also over long lines, avoiding line breaks.\n"
             "    -bin      do not autodetect file content, process all as binary.\n"
             "              can also be used for floating text files (one linefeed per\n"
             "              paragraph, not per line). may produce unwanted line breaks\n"
             "              with short-lined text.\n"
             #ifdef _WIN32
             "    -hidden   include hidden and system files.\n"
             #endif
             "    -c        case-sensitive search (not default).\n"
             "    -lnum     list line numbers of hits.\n"
             "    -nocol    disable color highlighting of output (sfk help colors).\n"
             "    -names    list only names of files containing at least one hit.\n"
             "    -count    list no. of matching lines per file. implies -names.\n"
             "              requires -text option, cannot be used with binary files.\n"
             "    -quiet    do not show \"scan\" progress info.\n"
             "    -pure     do not list filenames, list only text hits without indent.\n"
             "              default when specifying a single file as first parameter.\n"
             "    -verbose  tells in detail what find is actually searching for.\n"
             #ifdef _WIN32
             "    -nocconv  disable umlaut and accent character conversions during\n"
             "              output to console. \"sfk help opt\" for details.\n"
             #endif
             );
      printx("\n"
             "    $pattern support:\n"
             "       no wildcards or slash patterns are supported, with one exception:\n"
             "       if you need to find patterns starting with \"-\" or \"+\", prefix\n"
             "       them with backslash \\ to avoid misinterpretation as options.\n"
             "\n"
             "    $return codes for batch files\n"
             "       0 = no matches, 1 = matches found, >1 = major error occurred.\n"
             "       see also \"sfk help opt\" on how to influence error processing.\n"
             "\n"
             "    $aliases\n"
             "       \"sfk grep\"  is the same as \"sfk find\".\n"
             "       \"sfk ftext\" is the same as \"sfk find -text\".\n"
             "\n"
             "    $see also\n"
             "       sfk filter     - flexible pattern finding, for text files only.\n"
             "       sfk hexfind    - an optimized binary file pattern finder.\n"
             "\n"
             "    $examples\n"
             "       #sfk find . foo bar include\n"
             "          search all files in current dir for the words foo+bar+include.\n"
             "          note that the short form syntax supports one directory name,\n"
             "          and any number of text patterns, but no file name patterns.\n"
             "\n"
             "       #sfk find -pat text1 text2 -dir src1 src2 -file .cpp .hpp\n"
             "          searches within the specified directories and file masks.\n"
             "\n"
             "       #sfk list src +find -verbose \\-pat \\\\-foo \\+list\n" 
             "          find lines containing words \"-pat\", \"\\-foo\" and \"+list\"\n"
             "          in all files of directory src, with verbose search infos.\n"
             "\n"
             "       #sfk find testfiles class +view\n"
             "          search \"class\" within \"testfiles\", and show results\n"
             "          interactively in Depeche View (\"sfk view\" for details).\n"
             "\n"
             "       #sfk filter -+-pat -+\\-foo -++list -dir src\n"
             "          alternative search, done with sfk filter, on textfiles.\n"
             "\n"
             "       #sfk hexfind src /-pat/ /-foo/ /+list/\n"
             "          alternative search with sfk hexfind. patterns are OR combined.\n"
             );
      ehelp;

      bGlblAllowGeneralPure  = 1;
      bGlblBinGrep           = 1;
      bGlblBinGrepAutoDetect = 1;
      bGlblShortSyntax       = 0;

      bool bGotFileDir  = 0;
      bool bcolpat      = 0;  // collecting patterns

      // alias presets
      if (!strcmp(pszCmd, "ftext")) {
         bGlblBinGrep = 0;
         bGlblBinGrepAutoDetect = 0;
      }

      #ifdef VFILEBASE
      cs.precachezip = 1;
      #endif // VFILEBASE

      // only enable colorful scan status if console is available
      if (!bGlblConsColumnsSet)
         cs.quiet = true;

      for (; iDir < argc; iDir++) 
      {
         if (!bcolpat && !strcmp(argv[iDir], "-text")) {
            bGlblBinGrep = 0;
            bGlblBinGrepAutoDetect = 0;
         }
         else
         if (!bcolpat && !strncmp(argv[iDir], "-bin", 4)) {
            bGlblBinGrep = 1;
            bGlblBinGrepAutoDetect = 0;
         }
         else
         if (!bcolpat && !strcmp(argv[iDir], "-lnum"))
            bGlblGrepLineNum = 1;
         else
         if (!bcolpat && !strcmp(argv[iDir], "-c"))
            cs.usecase = 1;
         else
         if (!bcolpat && !strcmp(argv[iDir], "-count")) {
            if (bGlblBinGrep || bGlblBinGrepAutoDetect) {
               perr("-count cannot be used only with text file search");
               pinf("say -text -count instead of -count\n");
               return 9;
            }
            cs.useJustNames    = 1;
            cs.countMatchLines = 1;
         }
         else
         if (!bcolpat && setGeneralOption(argv, argc, iDir))
            continue;
         else
         if (!bcolpat && !strncmp(argv[iDir], "-", 1))
            break; // process long -dir form
         else
         if (!bcolpat && !chain.usefiles && !bGotFileDir) {
            // single dir or file specified.
            bGotFileDir = 1;
            Coi ocoi(argv[iDir], 0);
            if (ocoi.isTravelDir()) {
                if (lRC = setProcessSingleDir(argv[iDir]))
                   return lRC;
            } else {
                if (!fileExists(argv[iDir]))
                    return 9+perr("no such file or dir: %s\n", argv[iDir]);
                glblSFL.addEntry(ocoi); // is copied
                cs.pure = 1;
            }
            bGlblShortSyntax = 1;
            bcolpat = 1;
            // is -pat following immediately?
            if ((iDir < argc-1) && !strcmp(argv[iDir+1], "-pat"))
               iDir++; // then skip this
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, 0)) {
            break; // fall thru, let pdp set iDirNext
         }
         else {
            // search pattern specified.
            bcolpat = 1;
            char *psz = argv[iDir];
            if (psz[0] == '+') {
               perr("unknown chain command: %s\n", psz);
               pinf("to search for this word, say \\%s\n", psz);
               return 9;
            }
            if (!strncmp(psz, "\\\\", 2) || !strncmp(psz, "\\+", 2) || !strncmp(psz, "\\-", 2))
               psz++;
            glblGrepPat.addString(psz);
            // see also: processDirParms, which may also add to glblGrepPat.
         }
      }

      int iDirNext=0;
      if (iDir < argc) {
         if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))
            return lRC;
      } else {
         if (!chain.usefiles && !bGotFileDir)
            return 9+perr("please specify a directory or file name.\n");
      }

      if (cs.verbose) {
         printf("[searching lines with");
         long nGrepPat = glblGrepPat.numberOfEntries();
         for (long i=0; i<nGrepPat; i++) {
            char *pszPat = glblGrepPat.getString(i);
            if (i==0)
               printf(" \"%s\"", pszPat);
            else
               printf(" AND \"%s\"", pszPat);
         }
         printf("]\n");
      }
      if (!glblGrepPat.numberOfEntries())
         return 9+perr("no search patterns specified.\n");
      if (btest) return 0;

      if (chain.colany())
         cs.quiet = 1;

      lRC = walkAllTrees(eFunc_Grep, lFiles, lDirs, nBytes);
      if (!lRC && cs.anymatches) lRC = 1; // found a match
      info.clear(); // in case nothing was found

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "bin-to-src"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (argc < 5)
      printx("$sfk bin-to-src [...] infile outfile namePrefix\n"
             "\n"
             "   create sourcefile containing a binary data block. the outfile\n"
             "   will contain variable definitions beginning with namePrefix.\n"
             "\n"
             "   $options\n"
             "      -java     create java source code output, default is C.\n"
             "      -class    java: create a fully compilable class with a short\n"
             "                demo source code how to write the data to a file.\n"
             "      -pack     C source: compress data with a simple RLE scheme.\n"
             "      -hex      C source: produce hex numbers instead of decimal.\n"
             "      -append   do not overwrite output, but append to it.\n"
             "\n"
             "      -recsize=n   java: define number of bytes per record used\n"
             "                   within the raw data. default is 500. higher values\n"
             "                   produce less records, which may help if you get\n"
             "                   a \"code too large\" error during java compile.\n"
             "\n"
             "   $examples\n"
             "      #sfk bin-to-src myimg.dat imgsrc.cpp img01\n"
             "         create C source code containing content from myimg.dat.\n"
             "\n"
             "      #sfk bin-to-src -java -class myimg.dat imgdata.java imgdata\n"
             "         create a Java class \"imgdata\" with myimg.dat content.\n"
            );
      ehelp;

      bool bPack  = 0;
      bool bHex   = 0;
      bool bJava  = 0;
      bool bClass = 0;
      bool bAppend= 0;
      long nrecsize = 500;

      for (; iDir < argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-recsize", &pszParm)) {
            if (!pszParm) return 9;
            nrecsize = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-pack"))
            bPack = 1;
         else
         if (!strcmp(argv[iDir], "-hex"))
            bHex  = 1;
         else
         if (!strcmp(argv[iDir], "-java"))
            bJava = 1;
         else
         if (!strcmp(argv[iDir], "-class"))
            bClass = 1;
         else
         if (!strcmp(argv[iDir], "-append"))
            bAppend = 1;
         else
         if (!setGeneralOption(argv, argc, iDir))
            break;
      }

      if (iDir+3 > argc) return 9+perr("missing parameters.\n");

      char *pszInFile  = argv[iDir+0];
      char *pszOutFile = argv[iDir+1];
      char *pszPrefix  = argv[iDir+2];

      num   nFileSize = 0;
      uchar *pInFile = loadBinaryFile(pszInFile, nFileSize);
      if (!pInFile) return 9+perr("cannot read %s\n", pszInFile);

      fGlblOut = fopen(pszOutFile, bAppend ? "a":"w");
      if (!fGlblOut) {
         perr("cannot write %s\n", pszOutFile);
         delete [] pInFile;
         return 9; 
      }

      if (bJava)
         lRC = execBinToJava(pInFile, (long)nFileSize, bPack, pszPrefix, bClass, nrecsize);
      else
         lRC = execBinToCpp(pInFile, (long)nFileSize, bPack, pszPrefix, bHex);

      fclose(fGlblOut);
      delete [] pInFile;

      bDone = 1;
   }

   regtest("filter -no-empty-lines -count -lnum -case ++mypat");
   regtest("filter -no-blank-lines");
   regtest("filter -cnt -c -+mypat2 -+mypat3 -rep _foo_bar_");
   #ifdef _WIN32
   regtest("filter -+foo -+!bar -ls+start -le+end -ls!nstart -le!nend");
   regtest("filter -sep \" \" -form $40col1_$-50col2 -join");
   regtest("filter -sep ; -form $col3_$col5 -wrap");
   regtest("filter x.txt -blocksep _ -form $col1 -wrap=80");
   #else
   regtest("filter -+foo -+:bar -ls+start -le+end -ls:nstart -le:nend");
   regtest("filter -sep \" \" -form \"#40col1_#-50col2\" -join");
   regtest("filter -sep ; -form \"#col3_#col5\" -wrap");
   regtest("filter x.txt -blocksep _ -form #col1 -wrap=80");
   #endif

   ifcmd (   !strncmp(pszCmd, "filt", 4) || !strncmp(pszCmd, "ffilt", 5)
          || !strncmp(pszCmd, "filefilt", 8)
         )
   {
      ifhelp (!chain.usedata && (nparm < 1))
      printx("<help>$sfk filter [fileOrDir] -selectoption(s) -processoption(s)\n"
             "$sfk filt -selectoption(s) -processoption(s) -dir mydir -file .ext1 .ext2\n"
             "$sfk filter [-memlimit=n] -write inoutfile -replacepattern(s)\n"
             "\n"
             "   filter and change text lines, from standard input, or from file(s).\n"
             "   input lines may have a maximum length of %lu characters.\n",
             (ulong)(MAX_LINE_LEN-96)
             );
      printx("\n"
             "   $line selection options\n"
             "      -+pat1 -+pat2 [...]   - include lines containing pat1 OR  pat2\n"
             "      ++pat1 ++pat2 [...]   - include lines containing pat1 AND pat2\n"
             "      -ls+pat1              - include lines starting with pat1\n"
             "      -le+pat1 -le+pat2     - include lines ending   with pat1 OR pat2\n"
             "\n"
             "      -<not>pat1 -<not>pat2         - exclude lines containing pat1 OR  pat2\n"
             "      -ls<not>pat1              - exclude lines starting with pat1\n"
             "      -le<not>pat1 -le<not>pat2     - exclude lines ending with pat1 or pat2\n"
             "      -no-empty-lines       - exclude empty lines\n"
             "      -no-blank-lines       - exclude lines containing just whitespaces\n"
             "      -unique [-case]       - if same line occurs twice, keep only first.\n"
             "                              default is case insensitive text comparison.\n"
             "      -inc[lude] p1 to p2   - include only lines within blocks surrounded by\n"
             "                              boundary lines containing patterns p1 or p2\n"
             "      -inc-      p1 to p2   - same, but exclude boundary lines on output\n"
             "      -cut[-]    p1 to p2   - remove block of lines from p1 until p2\n"
             "      -inc[-]    \"*\" to p1  - include all from text start until marker\n"
             "      -cut[-]    p1 to \"*\"  - cut all from marker line until end of text\n"
             "      -nocheck     - with inc, cut: ignore block endings without a start\n"
             "      -addmark txt - with inc, cut: insert txt after every processed block\n"
             "      -context=n            - select n lines of context around hit lines\n"
             "      -precon=5:blue        - select context before or after hit lines,\n"
             "      -postcon=5:cyan:---     in blue or cyan, with separator \"---\".\n"
             "\n");
      printx("   $text processing options\n"
             "      applied <err>after<def> line selection options only.\n"
             "      -rep[lace] _src_dest_\n"
             "          replace string src by dest. first character is separator character (e.g. _).\n"
             "          src is case-insensitive. to select case-sensitive search, say -case.\n"
             "      -lsrep[lace], -lerep[lace]\n"
             "          same as -replace, but replaces only once at line start or line end.\n"
             "      -high[light] color pattern : highlight matching parts within lines.\n"
             "         color   : red = dark red, Red = bright red, green, blue,\n"
             "                   yellow, cyan, magenta, default.\n"
             "         pattern : e.g. \"GET * HTTP/\"\n"
             "         type \"sfk help colors\" for more about colors.\n"
             "      -lshigh[light], -lehigh[light]\n"
             "         same as -highlight, but only at line start or line end.\n"
             );
      printx("      -sep[arate] \"; \" -form \"<run>col1 mytext <run>[-0n.nq]col2 ...\"\n"
             "          break every line into columns separated by any character listed after -sep,\n"
             "          then reformat the text according to a user-defined mask. when leaving out -sep,\n"
             "          the whole line is packed into column 1. if -spat was specified, then -form\n"
             "          also supports slash patterns like \\t.\n"
             "      -form \"<run>40col1 <run>-3.5col2 <run>05qline <run>(10.10qcount+1000)\"\n"
             "          reformat column 1 as right-ordered with at least 40 chars, column 2 left-\n"
             "          ordered with at least 3 and a maximum of 5 chars, then add the input line\n"
             "          number, \"q\"uoted, right justified with 5 digits, prefixed by zeros,\n"
             "          then the output line number plus 1000 within quotes. NOTE: some examples\n"
             "          may not work in an sfk script, see section \"common errors\" below.\n"
             "          adding values so far only works with (q)line and (q)count.\n"
             #ifdef _WIN32
             "      -uform \"##40col1 ##-3.5col2 ##05qline\"\n"
             "          the same as -form but using unix style syntax. short for filter -upat.\n"
             #endif
             );
      printx("      -blocksep \" \" = treat blocks of whitespace as single whitespace separator.\n"
             "      -join[lines] join output lines, do not print linefeeds.\n"
             "      -wrap[=n]    wrap output lines near console width [or at column n].\n"
             "                   set SFK_CONFIG=columns:n to define or override the console width.\n"
             "\n");
      printx("   $conditional text processing\n"
             "      -[ls/le]where pattern -replace | -highlight | -sep ... -form\n"
             "          replace, highlight or reformat lines matching the given pattern.\n"
             "          all lines that do not match the pattern stay unchanged.\n"
             "      -within pattern -replace _from_to_\n"
             "          replace text in a part of the line matching the given pattern.\n"
             "          the rest of the line text stays unchanged.\n"
             "\n");
      printx("   $pattern support\n"
             "      wildcards * and ? are active by default. add -lit[eral] to disable.\n"
             "      slash patterns are NOT active by default. add -spat to use \\t \\q etc.\n"
             "      if you need the wildcard * but ALSO want to find/replace '*' characters:\n"
             "      add -spat, then specify \\\\* or \\? to find/replace '*' or '?' characters.\n"
             "      instead of typing \"sfk filter -spat -rep\" all the time, you may use the\n"
             "      short form \"sfk filt -srep\". the same applies for -(s)sep, -(s)form etc.\n"
             #ifndef _WIN32
             "      Linux users: add quotes \"\" around everything that contains * or ?,\n"
             "      otherwise it will be misinterpreted by the linux command shell.\n"
             #endif
             "\n"
             "   $unified syntax\n"
             "      since sfk 1.5.4 you can also use -: -ls: -le: under windows.\n"
             "      filter ... -uform or filter -upat ... -form uses ## instead of $$.\n"
             "\n"
             "   $further options\n");
             #ifdef VFILEBASE
      if (cs.xelike)
      printx("      -arc            include content of .zip .jar .tar etc. archives.\n");
             #endif // VFILEBASE
      printx("      -verbose        show names of all files which are currently scanned.\n"
             "      -write          do not print output to console but overwrite input file(s).\n"
             "                      only files with actual text changes will be rewritten.\n"
             "                      this function may be used only with plain ASCII files, not with\n"
             "                      binaries like .doc, .xls. see also \"sfk replace\".\n"
             "      -write -to msk  do not overwrite input files, but save according to mask msk,\n"
             "                      e.g. tmp\\<run>file . saves only changed files. say -writeall\n"
             "                      to write all files, including those without changes.\n"
             "      -memlimit=mb    when using -write, output is cached in memory, which is limited\n"
             "                      to 300 mb. use this option to extend, e.g. -memlimit=400\n"
             "      -yes            -write simulates by default. add -yes to really write changes.\n"
             "      -snap           detect snapfiles and list subfile names having text matches.\n"
             "      -snapwithnames  same as -snap, but include subfile names in filtering.\n"
             "      -nofile[names]  do not list filenames, do not indent text lines.\n"
             "      -count, -cnt    preceed all result lines by output line counter\n"
             "      -lnum           preceed all result lines by input  line number\n"
             "      -case           compare case-sensitive (not default)\n"
             "      -lit[eral]      treat wildcards * and ? as normal chars (read more above).\n"
             #ifdef _WIN32
             "      -hidden         include hidden and system files.\n"
             #endif
          // "      -bin[ary]       process also files that look like binaries (replacing\n"
          // "                      characters with code 0x00 and 0x1A by '.')\n"
             "      -noinfo         do not warn on line selection combined with -write.\n"
             "      -noop \\\"        no operation, take the \\\" parameter but do nothing.\n"
             "                      may help if your (windows) shell miscounts quotations.\n"
             "      -hitfiles       if another command follows (e.g. +run or +ffilter),\n"
             "                      pass a list of files containing at least one hit.\n"
             #ifdef _WIN32
             "      -nocconv        disable umlaut and accent character conversions during\n"
             "                      output to console. \"sfk help opt\" for details.\n"
             #endif
             "\n"
             "   $list of possible input sources\n"
             "      from stdin                : type x.txt | sfk filter -+pattern\n"
             "      from single input file    : sfk filter x.txt -+pattern\n"
             "      text from chained command : sfk list mydir .txt +filter -+pattern\n"
             "      from many files, directly : sfk filter -+pattern -dir mydir -file .txt\n"
             "      from many files, by chain : sfk list mydir .txt +filefilter -+pattern\n"
             "      in general, whenever you need to make sure that file contents (not the\n"
             "      file names) are processed, prefer to say \"filefilter\" or \"ffilt\".\n"
             );
      printx("\n"
             "   $return codes for batch files\n"
             "      0   normal execution, no matching lines found.\n"
             "      1   normal execution,    matching lines found.\n"
             "          with -write: returns rc 1 only if any changes were written.\n"
             "     >1   major error occurred. see \"sfk help opt\" for error handling options.\n"
             );
      printx("\n"
             "   $common errors\n"
             "      when using filter -form within sfk scripts, expressions like <run>10.10col1\n"
             "      may collide with script parameters <run>1 <run>2 <run>3. to solve this, use brackets\n"
             "      like <run>(10.10col1), or \"sfk label ... -prefix=%%\", or -uform.\n"
             );
      printx("\n"
             "   $see also\n"
             "      #sfk find<def>       find words in text and binary files. faster, but less flexible.\n"
             "      #sfk hexfind<def>    find text or binary data in binary files, with hex dump output.\n"
             "      #sfk replace<def>    replaces many strings in parallel, in text and binary files.\n"
             "      #sfk help color<def> for the list of color names.\n"
             );
      printx("\n"
             "   $examples\n"
             "      #anyprog | sfk filter -+error: -<not>warning\n"
             "         run command anyprog, filter output for error messages, remove warning messages.\n"
             "      #sfk filter result.txt -rep _\\_/_ -rep xC:/xD:/x\n"
             "         read result.txt, turn all \\ slashes into /, and C:/ expressions to D:/\n"
             "      #sfk filter export.csv -sep \";\" -format \"title: <run>-40col2 remark: <run>-60col5\"\n"
             "         reformat comma-separated data, exported from spreadsheet, as ascii text.\n"
             "      #sfk stat . +filter -blocksep \" \" -format \"<run>4col1 mb in folder: <run>col5\"\n"
             "         reformats output of the stat command.\n"

             "      #sfk filter mycsv.txt >out.txt -spat -rep _\\\"__ -rep _\\t__ -rep \"_;_\\\"\\t\\\"_\" -form \"<run>qcol1\"\n"
             "         read semicolon-separated spreadsheet data mycsv, strip all double colons\n"
             "         and tab characters from data fields. replace field separator \";\" by TAB,\n"
             "         and surround all fields by double colon. -form without -sep means \"pack the whole\n"
             "         line into <run>col1\", allowing -form to add quotes at start and end of each line.\n"

             "      #sfk filter logs\\access.log \"-+GET * 404\"\n"
             "         list all lines from access.log containing a phrase with GET and 404.\n"

             "      #sfk filter log.txt \"-ls<not>??.??.???? ??:??:?? * *\"\n"
             "         excludes lines from log.txt starting with a date, and having two more words,\n"
             "         like \"20.05.2007 07:23:09 org.whatever.server main\"\n"
             );
      printx("      #%s | sfk run -idirs \"sfk filt tpl.conf >httpd.conf -rep _AbsWorkDir_<run>path_\"\n"
             "         create httpd.conf from tpl.conf, replacing the word \"AbsWorkDir\" by the path\n"
             "         from which the command is run. note we can NOT use -spat in this case, otherwise\n"
             "         a pathname like C:\\temp would produce garbage (contains slash pattern \"\\t\").\n"
             #ifdef _WIN32
             , "cd"
             #else
             , "pwd"
             #endif
             );
      printx("      #sfk filter in.txt -spat -sep \"\\t\" -rep _\\q__ -form \"INSERT INTO MYDOCS (DOC_ID,\n"
             "         #DESCRIPTION) VALUES ('TestDoc<run>03line','<run>col2');\"\n"
             "         this example (typed in one line) creates a list of SQL statements, using tab-\n"
             "         separated, quoted input data, and using the input line number for document id's.\n"
             "         the -rep _\\q__ means the same as -rep _\\\"__ - it strips quotes from the input,\n"
             "         but using \\q is safer then \\\" as it doesn't let the shell miscount quotes.\n"
             );
      printx("      #sfk list documents .txt +filter -+big*foo -+wide*foo\n"
             "         from all .txt files in documents, filter the filenames (NOT the file contents)\n"
             "         for big*foo OR wide*foo.\n"
             );
      printx("      #sfk list documents .txt +filefilter -+big*foo -+wide*foo\n"
             "         from all .txt files in documents, filter the file contents (NOT the names)\n"
             "         for text lines containing big*foo OR wide*foo.\n"
             );
             #ifdef _WIN32
      printx("      #bin\\runserver.bat 2>&1 | sfk filter -+exception\n"
             "         filter standard output AND error stream (\"2>\") for exceptions\n"
             "      #IF %%ERRORLEVEL%%==1 GOTO hitAvailable\n"
             "         in a batchfile jumps to label :hitAvailable if no. of hits > 0\n"
             );
             #endif
      printx("      #sfk filt log.txt -high cyan \"*.*.*(*.java:*)\" -high green \"sql select *\"\n"
             "         dump log.txt, listing java stack traces in cyan, and sql selects in green.\n"
             );
      printx("      #sfk filt x.html -where \"000099\" -rep \"_<font*000099*>_<b>_\" -rep \"_</font>_</b>_\"\n"
             "         replaces html <font> commands by <b>, but only in lines with \"000099\" (=blue).\n"
             );
      printx("      #sfk filt foo.cpp -cut \"ifdef barmode\" to \"endif // barmode\"\n"
             "         strip blocks of lines from foo.cpp, surrounded by the given patterns.\n"
             );
      printx("      #sfk filt csv.txt -spat -within \"\\q*\\q\" -rep _,_\\x01_ -rep _,_\\t_ -rep _\\x01_,_\n"
             "         change separators in comma separated data from comma to tab, also taking\n"
             "         care of quotes, by replacing in-quote commas by a placeholder (\\x01).\n"
             "         if the data contains escaped quotes like \"\" then further prefiltering\n"
             "         can be necessary, like removing those quotes by -sreplace _\\q\\q__\n"
             );
      printx("      #sfk filt mysrc.cpp \"-+fopen(\" -postcontext=3:blue:----- +view\n"
             "         filter source file \"mysrc.cpp\" for fopen calls, and list the following\n"
             "         three lines (post context) of every call, separating outputs by -----\n"
             "         and showing the whole result in Depeche View (\"sfk view\" for more).\n"
             );
      ehelp;

      CommandScope ocmd("Filter");

      bool bFileFilt = !strncmp(pszCmd, "ffilt", 5) || !strncmp(pszCmd, "filefilt", 8);

      memset(&gfilter, 0, sizeof(gfilter));
      gfilter.argv    = argv;
      gfilter.iPat    = iDir;
      gfilter.nPat    = argc - iDir; // MAX estimation, must be reduced on chaining
      gfilter.bDumpLF = 1;
      gfilter.bSkipBinaries = 1; // always, this is a text-only filter.
      gfilter.bFilenames = 1;
      gfilter.cprecolor  = ' ';
      gfilter.cpostcolor = ' ';

      #ifdef VFILEBASE
      cs.precachezip = 1;
      #endif // VFILEBASE

      char *pszInPath = 0;

      // if we're a chain receiver
      bool bOldUseFiles = chain.usefiles;
      bool bWalkDirs    = chain.colfiles | chain.usefiles;
      if (chain.usedata) {
         cs.quiet = 1; // no filename listings
      }

      // set options, check syntax
      int iDirNew   = 0;
      int iChainNew = 0;
      if (setFilterParms(
         argv, argc, gfilter.iPat, gfilter.nPat,
         gfilter,
         &pszInPath, &iDirNew, &iChainNew
         ))
         return 9;

      // if -test mode, init test stats
      if (cs.test)
         mclear(ftest);

      // logical autocomplete of options:
      // saying -lnum or -count AND -write always means to write ALL files.
      if ((gfilter.bLNum || gfilter.bCnt) && gfilter.bReWrite)
         cs.writeall = 1;

      bool bsid = 0;
      if (pszInPath) {
         // single input file or directory specified?
         bWalkDirs = 1;
         Coi ocoi(pszInPath, 0);
         if (bsid = ocoi.isTravelDir()) {
            setProcessSingleDir(pszInPath);
            // gfilter.bSkipBinaries = 1;
         } else {
            if (!cs.usesnap)
               gfilter.bSingleFile = 1;
            glblSFL.addEntry(ocoi); // is copied
         }
      }

      long nInputs = 0;
      if (pszInPath)    nInputs++;
      if (iDirNew > 0)  nInputs++;
      if (bOldUseFiles) nInputs++;

      if (nInputs > 1) {
         perr("filter cannot process input files from multiple sources.\n");
         long nsrc = 1;
         setTextColor(nGlblWarnColor);
         if (bOldUseFiles) {
            printf("info : source %ld are filenames from previous command.\n", nsrc++);
            printf("tip  : try to select all files within the previous command.\n");
         }
         if (pszInPath)   printf("info : source %ld is input %s \"%s\"\n", nsrc++, bsid?"directory":"file", pszInPath);
         if (iDirNew > 0) printf("info : source %ld is directory or file parameter \"%s\"\n", nsrc++, argv[iDirNew]);
         setTextColor(-1);
         return 9;
      }

      // if any dir parms found
      if (iDirNew)
      {
         iDir = iDirNew ? iDirNew : iChainNew;
         // gfilter.bSkipBinaries = 1;
         if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iChainNew)) return lRC;
         bWalkDirs = 1;
      }
 
      // snapfile parse does not allow rewrite
      if (cs.usesnap && gfilter.bReWrite)
         return 9+perr("options -snap and -rewrite not allowed together.");

      if (btest) return 0;

      // if collecting filenames for another chained command
      if (chain.colfiles) {
         cs.quiet = 1;
         char *pszChainCmd = iChainNew ? argv[iChainNew] : (char*)"";
         if (!strcmp(pszChainCmd, "+copy")) {
            // copy follows: insist on true input filenames
            gfilter.bPassHitFiles = 1;
         }
      }

      if (bWalkDirs)
      {
         // used in most cases:
         if (gfilter.bReWrite) {
            cs.sim = !cs.yes;
            if (cs.sim && !cs.nohead)
               printx("$[simulating:]\n");
         }
         if (!gfilter.bPassHitFiles && chain.colfiles) {
            // the next chain step (e.g. run) wants us to collect filenames.
            // but we are processing a single input file,
            // therefore auto-reconfig:
            chain.colfiles    = 0;
            chain.coldata     = 1;  // collect text now
            chain.text2files  = 1;  // but let it autoconvert
         }
         lRC = walkAllTrees(eFunc_Filter, lFiles, lDirs, nBytes);
         if (cs.sim && !cs.nohead)
            printx("$[add -yes to really write changes.]\n");
         if (!lRC) lRC = gfilter.nTotalRC;   // info if any matches found
      }
      else 
      {
         // processing stdin or chain data:
         if (gfilter.bReWrite) {
            perr("-write cannot be used this way, as it needs filenames.\n");
            pinf("maybe you want to use filefilter (ffilt) instead of filter?\n");
            return 9;
         }
         if (chain.colfiles) {
            // the next chain step (e.g. run) wants us to collect filenames.
            // but we are processing an input text stream.
            // therefore auto-reconfig:
            chain.colfiles    = 0;
            chain.coldata     = 1;  // collect text now
            chain.text2files  = 1;  // but let it autoconvert
         }
         if (!cs.usesnap)
            gfilter.bSingleFile = 1; // don't dump filename
         lRC = execFilter(0, stdin, chain.usedata ? chain.indata : 0);
         if (!lRC) lRC = gfilter.nTotalRC;   // info if any matches found
      }

      info.clear(); // for -verbose output

      if (!cs.quiet && cs.binariesSkipped)
         printx("<time>%ld binary files skipped%s.<def>\n", cs.binariesSkipped, cs.verbose?"":" (-verbose for more)");

      // command cleanup:
      glblFilterDups.reset(); // after last file

      // analyze -test results
      if (cs.test) {
         lRC = 0;
         for (long i=0; i<FILT_MAXTESTMASKS; i++) {
            // if (ftest.apPosMasks[i])
            //    printf("%ld: pos %s %ld\n",i,ftest.apPosMasks[i],ftest.anPosHits[i]);
            if (ftest.apPosMasks[i] && !ftest.anPosHits[i]) {  
               // a required phrase was not found
               printx("<err>miss :<def> %s\n", ftest.apPosMasks[i]);
               lRC = 10;
            }
            if (ftest.apNegMasks[i] &&  ftest.anNegHits[i]) {
               // an error phrase was found
               printx("<err>fail :<def> %s\n", ftest.apNegMasks[i]);
               lRC = 11;
            }
         }
      }

      int iDirNext = iChainNew;
      STEP_CHAIN(iDirNext, 1);
 
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "addhead"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("$sfk addhead <in >out [-noblank] string1 string2 ...\n"
             "\n"
             "   insert string(s) at the start of text lines.\n"
             "\n"
             "   $options\n"
             "      -noblank    does not add blank chars between added strings.\n"
             "\n"
             "   $see also\n"
             "      #sfk filter infile.txt -form \"string1<run>col1\"\n"
             "         does the same and is more flexible.\n"
            );
      ehelp;

      bool bblank=1;
      if (!strcmp(argv[iDir], "-noblank") && argc >= 4)
         { bblank=0; iDir++; }

      char *pszToAdd = argv[iDir];
      long nMaxLineLen = sizeof(szLineBuf)-10;
      while (fgets(szLineBuf, nMaxLineLen, stdin))
      {
         removeCRLF(szLineBuf);
         // left: collect all parameters to add as head
         szLineBuf2[0] = '\0';
         for (int i1=iDir; i1<argc; i1++) {
            strcat(szLineBuf2, argv[i1]);
            if (!bblank && (i1 == argc-1))
               continue;
            strcat(szLineBuf2, " "); 
         }
         // add middle
         strcat(szLineBuf2, szLineBuf);
         // no right side
         printf("%s\n", szLineBuf2);
      }
      fflush(stdout);
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "addtail"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("$sfk addtail <in >out [-noblank] string1 string2 ...\n"
             "\n"
             "   add string(s) at the end of text lines.\n"
             "\n"
             "   $options\n"
             "      -noblank    does not add blank chars between added strings.\n"
             "\n"
             "   $see also\n"
             "      #sfk filter infile.txt -form \"<run>col1string1\"\n"
             "         does the same and is more flexible.\n"
            );
      ehelp;

      bool bblank=1;
      if (!strcmp(argv[iDir], "-noblank") && argc >= 4)
         { bblank=0; iDir++; }

      char *pszToAdd = argv[iDir];
      long nMaxLineLen = sizeof(szLineBuf)-10;
      while (fgets(szLineBuf, nMaxLineLen, stdin))
      {
         removeCRLF(szLineBuf);
         // right: collect all parameters
         for (int i1=iDir; i1<argc; i1++) {
            if (!bblank && (i1 == iDir))
               { }
            else
               strcat(szLineBuf, " "); 
            strcat(szLineBuf, argv[i1]);
         }
         printf("%s\n", szLineBuf);
      }
      fflush(stdout);
      bDone = 1;
   }

   #ifndef NO_ZIP_LIST
   // internal, to test zip/jar listing via central dir
   if (!strcmp(pszCmd, "ziplist"))
   {
      if (checkArgCnt(argc, 3)) return 9;

      FileList oFiles;
      getZipList(argv[2], oFiles);

      long nFiles = oFiles.clNames.numberOfEntries();
      for (long i=0; i<nFiles; i++) 
      {
         char *psz = oFiles.clNames.getEntry(i, __LINE__);
         num nSize = oFiles.clSizes.getEntry(i, __LINE__);
         num nTime = oFiles.clTimes.getEntry(i, __LINE__);
         printf("%s %s %s\n", timeAsString(nTime), numtoa(nSize,10), psz);
      }
      bDone = 1;
   }
   #endif

   // internal, to test zip listing as stream
   if (!strcmp(pszCmd, "ziplist2"))
   {
      if (checkArgCnt(argc, 3)) return 9;

      SFKMD5 md5;
      FileList oFiles;
      getZipMD5(argv[2], md5, oFiles, 1);

      long nFiles = oFiles.clNames.numberOfEntries();
      for (long i=0; i<nFiles; i++) 
      {
         char *psz = oFiles.clNames.getEntry(i, __LINE__);
         num nSize = oFiles.clSizes.getEntry(i, __LINE__);
         num nTime = oFiles.clTimes.getEntry(i, __LINE__);
         printf("%s %s %s\n", timeAsString(nTime), numtoa(nSize,10), psz);
      }
      bDone = 1;
   }

   // the freezeto command is kept internal, as it massively uses .zip files,
   // which may create problems if freezing FAT32 and then unpacking on NTFS.
   // esp. "+x" attributes of extracted files may be missing.
   // as a general workaround, always unzip on FAT32 only.
   if (!strcmp(pszCmd, "freezeto")) {
      printx(
         "<help>$sfk freezeto=targetdir [-quiet][-hidden][-verbose[=2]]]] -dir src1 -copy|zip\n"
         "\n"
         "    create self-verifying, self-unpacking archive tree, for dvd burning.\n"
         "    this copies or zips all or updated files from src to target,\n"
         "    USING THE EXTERNAL COMMANDS XCOPY from windows, ZIP and UNZIP\n"
         "    from the InfoZIP group. these tools must be available via the\n"
         "    command line PATH. if using -zip on trees, every directory's\n"
         "    content is packed into a single .zip file, for best compromise\n"
         "    between read speed, fail safety, and compression.\n"
         "\n"
         "    !dirname excludes directory \"dirname\".\n"
         "    quiet  : avoid listing every single zip or xcopy call.\n"
         "    hidden : also include system and hidden files.\n"
         "    verbose: show [=2 list] every zip or copy action.\n"
         "\n"
         "    examples:\n"
         "       #sfk freezeto=d:\\freeze -dir mysrc <not>mysrc\\old\\ -zip -dir myprog -copy\n"
         "       #sfk freezeto=d:\\freeze -from=freeze-script.sfk\n"
         "\n"
         "       this creates an archive tree d:\\freeze. files from mysrc are zipped,\n"
         "       except mysrc\\old, which is excluded. files from myprog are copied.\n"
         "       alternatively, supply all parms in a script and say -from=scriptname.\n"
         "       sfk will copy sfk" EXE_EXT " and unzip" EXE_EXT " into a dir d:\\freeze\\05-arc-tools,\n"
         "       and create several batch files for verification and later decompression.\n"
         "       before burning d:\\freeze onto dvd (or copying it to usb stick), test-run\n"
         "       the created batch 01-verify-arc.bat if it really behaves like expected.\n"
         "\n"
         "    For good performance, use freezeto only with TWO PHYSICALLY INDEPENDENT\n"
         "    HARD DISKS - e.g. from internal to external disk, or from network to local.\n"
         "    Do NOT freezeto DIRECTLY onto usb stick or dvd-rw media! Instead, 1. freeze\n"
         "    to an intermediate folder 2. then burn/copy this folder to the target media.\n"
         "\n"
         "    NOTE: as everything else, freezeto comes WITHOUT ANY WARRANTY!\n"
         "    -> Always have a manual check afterwards if your most important\n"
         "       files are really contained within the backup archives!\n"
         "    -> Test read your backup media on different drives and machines,\n"
         "       by running the auto-created script file 01-verify-arc.bat\n"
         "    -> Test restoring of your backups from time to time!\n"
         "       to do so, copy media onto hard disk, then 02-unpack-arc.bat,\n"
         "       \"del 01-arc-part.zip /S\", and finally run 03-verify-org.bat.\n"
         );

      return 0;
   }

   if (!strncmp(pszCmd, "freezeto=", strlen("freezeto=")))
   {
      if (argc < 3) return 9+perr("missing parms\n");

      char *pszDstRoot = pszCmd+strlen("freezeto=");
      if (strlen(pszDstRoot) <= 0)
         return 9+perr("missing target dir\n");
      if (!isDir(pszDstRoot))
         return 9+perr("no such directory: %s\n", pszDstRoot);

      // copy destination root, auto-add path char
      pszGlblDstRoot = new char[strlen(pszDstRoot)+10];
      strcpy(pszGlblDstRoot, pszDstRoot);
      if (!endsWithPathChar(pszDstRoot))
         strcat(pszGlblDstRoot, glblPathStr);

      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3))
         return lRC;

      // test if required tools are available, using freeze-log as tmpfile.
      bool bBail = 0;

      sprintf(szLineBuf2, "%s09-freeze-log.txt", pszGlblDstRoot);
      if (!isWriteable(szLineBuf2)) return 9+perr("cannot write to: %s\n", szLineBuf2);

      long lToolRC = 0;

      #ifdef _WIN32
      lToolRC = checkXCopy(szLineBuf2, "[/D");
      if (lToolRC) { perr("cannot run XCOPY command. please check your path. (rc %ld)\n", lToolRC); bBail=1; }
      #else
      pszGlblXCopyCmd = strdup("cp");
      #endif

      lToolRC = checkZipVersion(szLineBuf2);
      if (lToolRC) { perr("cannot run ZIP command. please get InfoZIP 2.31 or higher.\n"); bBail=1; }

      lToolRC = checkUnzipVersion(szLineBuf2);
      if (lToolRC) { perr("cannot run UNZIP command. please get Unzip 5.52 or higher.\n"); bBail=1; }

      char *pszSFKCmd = findPathLocation("sfk" EXE_EXT);
      if (!pszSFKCmd) { perr("cannot find location of sfk" EXE_EXT " within PATH.\n"); bBail=1; }
      else
         pszGlblSFKCmd = strdup(pszSFKCmd);

      // cleanup tmp infos. szLineBuf2 string is further used in prep's.
      remove(szLineBuf2);

      if (bBail) return 9;

      // tell exactly which external tool commands we're using.
      printf("] using: %s, %s\n", pszGlblXCopyCmd, pszGlblSFKCmd);
      printf("] using: %s (%ld.%ld), %s (%ld.%ld)\n", pszGlblZipCmd, nGlblZipVersionHi, nGlblZipVersionLo, pszGlblUnzipCmd, nGlblUnzipVersionHi, nGlblUnzipVersionLo);

      char szContentsName[1024];
      char szMD5ArcName[1024];
      char szBatchName[1024];
      char szMD5OrgName[1024];
   // char szTimesName[1024];
      char szToolsDir[1024];
      char szStaleList[1024];

      const char *pszVerArcBatch = "01-verify-arc.bat";
      const char *pszUnpArcBatch = "02-unpack-arc.bat";
      const char *pszVerOrgBatch = "03-verify-org.bat";
      const char *pszToolsDir    = "05-arc-tools";
      const char *pszContentFile = "06-content.txt";
      const char *pszMD5OrgFile  = "07-md5-org.txt";
      const char *pszMD5ArcFile  = "08-md5-arc.txt";
      #ifdef SFK_USE_DIR_TIMES
      const char *pszTimesFile   = "10-dir-times.txt";
      #endif
      const char *pszStaleList   = "10-stale-list.txt";

      sprintf(szContentsName, "%s%s", pszGlblDstRoot, pszContentFile);
      sprintf(szMD5ArcName  , "%s%s", pszGlblDstRoot, pszMD5ArcFile );
      sprintf(szMD5OrgName  , "%s%s", pszGlblDstRoot, pszMD5OrgFile );
      sprintf(szBatchName   , "%s%s", pszGlblDstRoot, pszUnpArcBatch);
      #ifdef SFK_USE_DIR_TIMES
      sprintf(szTimesName   , "%s%s", pszGlblDstRoot, pszTimesFile  );
      #endif
      sprintf(szToolsDir    , "%s%s", pszGlblDstRoot, pszToolsDir   );

      // ----- file preparations begin -----
      #ifdef SFK_USE_DIR_TIMES
      pszGlblDirTimes = loadFile(szTimesName);
      #endif

      #ifdef _WIN32
      int nRCmd = _mkdir(szToolsDir);
      #else
      int nRCmd =  mkdir(szToolsDir, S_IREAD | S_IWRITE | S_IEXEC);
      #endif
      if (!nRCmd) printf("] mkdir: %s\n", szToolsDir);
      // else we expect the dir already exists.

      // copy at least sfk.exe and unzip.exe to the tools dir:
      #ifdef _WIN32
      sprintf(szLineBuf, "copy %s %s /Y 1>%s 2>&1", pszGlblSFKCmd, szToolsDir, szLineBuf2);
      #else
      sprintf(szLineBuf, "cp %s %s 1>%s 2>&1", pszGlblSFKCmd, szToolsDir, szLineBuf2);
      #endif
      printf("] copy : %s -> %s\n", pszGlblSFKCmd, szToolsDir);
      nRCmd = system(szLineBuf);
      if (nRCmd) pwarn("RC %d while copying sfk" EXE_EXT " to archive tree.\n", nRCmd);

      #ifdef _WIN32
      sprintf(szLineBuf, "copy %s %s /Y 1>%s 2>&1", pszGlblUnzipCmd, szToolsDir, szLineBuf2);
      #else
      sprintf(szLineBuf, "cp %s %s 1>%s 2>&1", pszGlblUnzipCmd, szToolsDir, szLineBuf2);
      #endif
      printf("] copy : %s -> %s\n", pszGlblUnzipCmd, szToolsDir);
      nRCmd = system(szLineBuf);
      if (nRCmd) pwarn("RC %d while copying unzip" EXE_EXT " to archive tree.\n", nRCmd);

      #ifdef _WIN32
      if (!cs.hidden)
         printf("] info : excluding hidden and system files. use \"dir /AHS /S /B\" to list them.\n");
      #endif

      // ----- file preparations end -----

      if (!(fGlblCont   = fopen(szContentsName, "w"))) return 9+perr("unable to write: %s\n", szContentsName);
      if (!(fGlblMD5Arc = fopen(szMD5ArcName  , "w"))) return 9+perr("unable to write: %s\n", szMD5ArcName  );
      if (!(fGlblBatch  = fopen(szBatchName   , "w"))) return 9+perr("unable to write: %s\n", szBatchName   );
      if (!(fGlblMD5Org = fopen(szMD5OrgName  , "w"))) return 9+perr("unable to write: %s\n", szMD5OrgName  );
      #ifdef SFK_USE_DIR_TIMES
      if (!(fGlblTimes  = fopen(szTimesName   , "w"))) return 9+perr("unable to write: %s\n", szTimesName   );
      #endif

      lRC = walkAllTrees(eFunc_Mirror, lFiles, lDirs, nBytes);

      fclose(fGlblCont);
      fclose(fGlblMD5Arc);
      fclose(fGlblBatch );
      fclose(fGlblMD5Org);
      #ifdef SFK_USE_DIR_TIMES
      fclose(fGlblTimes );
      #endif

      sprintf(szBatchName, "%s%s", pszGlblDstRoot, pszVerArcBatch);
      if (!(fGlblBatch = fopen(szBatchName   , "w"))) return 9+perr("unable to write: %s\n", szBatchName   );
      fprintf(fGlblBatch, "%s%csfk md5check %s %%1 %%2 %%3\n", pszToolsDir, glblPathChar, pszMD5ArcFile);
      fclose(fGlblBatch);

      sprintf(szBatchName, "%s%s", pszGlblDstRoot, pszVerOrgBatch);
      if (!(fGlblBatch = fopen(szBatchName   , "w"))) return 9+perr("unable to write: %s\n", szBatchName   );
      fprintf(fGlblBatch, "%s%csfk md5check %s %%1 %%2 %%3\n", pszToolsDir, glblPathChar, pszMD5OrgFile);
      fclose(fGlblBatch);

      if (bGlblEscape)
         logError("error: user interrupt. archive tree is INCOMPLETE.");

      long nInfo = 0;
      long nErr  = 0;
      if (glblErrorLog.numberOfEntries() > 0) 
      {
         long nMsg = glblErrorLog.numberOfEntries();
         long i = 0;
         for (i=0; i<nMsg; i++) {
            char *psz = glblErrorLog.getEntry(i, __LINE__);
            if (!strncmp(psz, "info", 4))
               nInfo++;
            else
               nErr++;
         }
         printf("=== %d errors, %d informal messages: ===\n", nErr, nInfo);
         for (i=0; i<nMsg; i++)
            printf("%s\n", glblErrorLog.getEntry(i, __LINE__));
      }
      else {
         printf("=== no errors registered. ===\n");
      }

      sprintf(szLineBuf2, "%s09-freeze-log.txt", pszGlblDstRoot);
      printf("=== content of logfile %s, without empty file warnings: ===\n", szLineBuf2);
      FILE *fin = fopen(szLineBuf2, "r");
      if (fin) {
         while (fgets(szLineBuf, sizeof(szLineBuf)-10, fin)) {
            removeCRLF(szLineBuf);
            if (!strstr(szLineBuf, "01-arc-part.zip not found or empty"))
               printf("%s\n", szLineBuf);
         }
         fclose(fin);
      }
      printf("=== end of logfile content. ===\n");

      printf("done: scanned %lu files in %lu sec (%lu kb/sec)\n",
         glblFileCount.value(), currentElapsedMSec()/1000, currentKBPerSec());
      printf("info: %lu files are frozen within %lu zip archives.\n", nGlblFzConArcFiles, nGlblFzConArchives);
      printf("info: %lu files have a copy in the target tree.\n", nGlblFzConCopFiles);

      if (nErr > 0)
         printf("warn: there are %ld error messages. read error logs above.\n", nErr);

      sprintf(szStaleList, "%s%s", pszGlblDstRoot, pszStaleList);
      if (glblStaleLog.numberOfEntries() > 0) 
      {
         // write stale list
         FILE *fout = fopen(szStaleList, "w");
         if (!fout)
            perr("unable to write %s\n", szStaleList);
         else {
            fprintf(fout,
               "# list of archive parts containing outdated files.\n"
               "# AFTER you burned the current archive tree to DVD,\n"
               "# you may preceed the next backup with a cleanup:\n"
               #ifdef _WIN32
               "# type 10-stale-list.txt | sfk run -ifiles \"del %cpfile\"\n", glblRunChar
               #else
               "# cat 10-stale-list.txt | sfk run -ifiles \"rm %cpfile\"\n", glblRunChar
               #endif
               );
            long nEntries = glblStaleLog.numberOfEntries();
            for (long i=0; i<nEntries; i++)
               fprintf(fout, "%s\n", glblStaleLog.getEntry(i, __LINE__));
            fclose(fout);
         }
      }
      else
      {
         remove(szStaleList); // in case any old list is given
      }

      printf("note: check your most important files now manually,\n");
      printf("note: by listing some archives within %s.\n", pszGlblDstRoot);

      if (nGlblFzMisArcFiles > 0)
         printf("warn: %lu files failed archiving (read error logs above).\n", nGlblFzMisArcFiles);

      if (nGlblFzMisCopFiles > 0)
         printf("warn: %lu files failed to copy (read error logs above).\n", nGlblFzMisCopFiles);

      // cleanup
      if (pszGlblXCopyCmd) delete [] pszGlblXCopyCmd;
      if (pszGlblZipCmd  ) delete [] pszGlblZipCmd  ;
      if (pszGlblUnzipCmd) delete [] pszGlblUnzipCmd;
      if (pszGlblSFKCmd  ) delete [] pszGlblSFKCmd  ;

      // further cleanups (ErrorLog, StaleLog) are done 
      // after return in cleanupTmpCmdData.

      if (glblErrorLog.numberOfEntries() > 0)
         return 5;

      bDone = 1;
   }

   #ifndef USE_SFK_BASE
   ifcmd (!strcmp(pszCmd, "patch"))
   {
      ifhelp (nparm < 1)
      printx(
          "<help>$sfk patch [-revoke|-redo] yourpatchfile.cpp [-sim|-verify]\n"
          "\n"
          "   search text blocks in file(s) and replace them by other text blocks,\n"
          "   including backup creation and optional restore of original files.\n"
          "\n"
          "   -revoke: undo all patches, by replacing the modified targets\n"
          "            by the backup files which sfk stores in save_patch.\n"
          "            the target files are touched afterwards (date/time update)\n"
          "            to enforce proper recompile. use -keepdates to avoid this.\n"
          "   -redo  : undo all patches and then re-apply patches.\n"
          "            best used whenever you change the patchfile itself,\n"
          "            to have your changes updated in the target files.\n"
          "   -exact-match: by default, leading whitespaces are ignored.\n"
          "                 use this option enforce exact 1:1 line matching.\n"
          "   -keep-dates: by default, revoked files get touched. use this option\n"
          "                to enforce original file dates (yet windows only).\n"
          "   -sim     : simulate what the patch would do, don't change anything.\n"
          "   -qs      : quick summary, just tell a one-line status.\n"
          "   -stats   : show statistics of select-replace usage.\n"
          "   -verify  : check if an applied patch is still intact.\n"
          "   -nopid   : apply irrevocable patch without [patch-id].\n"
          "   -anyroot : ignore the :root dir entry in a patch file.\n"
          "\n"
         );
      printx(
         "   $patchfile rules:\n"
         "   - patches are executed exactly in the order as given in the patchfile.\n"
         "   - each :from/:to statement is executed exactly once.\n"
         "   - if ANY of the :from/:to statements doesn't match the input,\n"
         "     the whole file is NOT patched.\n"
         "   - the first :to block for a new target file must contain the word [patch-id],\n"
         "     by using a comment in the target file's syntax, e.g. in C++: // [patch-id].\n"
         "     this marks the file as being patched -> sfk will not patch it again.\n"
         "\n"
         "   it is recommended that your patchfiles have the ending .cpp (or .java etc.)\n"
         "   to enable syntax highlighting with your favourite text editor.\n"
         "\n"
         );
      printx("   #sfk patch -example\n"
             "      shows a detailed patchfile example.\n"
             "   #sfk patch -template\n"
             "      gives a simple, empty patchfile template.\n"
             );
      ehelp;

      lRC = patchMain(argc-1, argv, 1);

      bDone = 1;
   }
   #endif // USE_SFK_BASE

   ifcmd (!strcmp(pszCmd, "if"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk ... +if expression command1 ... +command2\n"
             "\n"
             "   execute command1 if expression is true, then continue to command2.\n"
             "   if expression is not true, skip directly to command2.\n"
             "   can be used only in a command chain, after another command.\n"
             "\n"
             "   $supported expressions\n"
             "      rc=n   return code of previous command equal  to   n\n" 
             "      rc>n   return code of previous command higher than n\n"
             "      rc<n   return code of previous command lower  than n\n"
             "\n"
             "   $see also\n"
             "      sfk call labelname - call sub functions in a script.\n"
             "\n"
             "   $examples\n"
             "      #sfk filter in.txt -+err +if \"rc>0\" run -yes \"x.bat\" +echo done\n"
             "         if file in.txt contains the word \"err\", run x.bat.\n"
             "         the \"echo done\" is always executed.\n"
            );
      ehelp;

      int iChainNext = 0;
      char *pexpr    = 0;
      int iThenCmd   = 0;

      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pexpr)
            { pexpr = argv[iDir]; continue; }
         if (!iThenCmd)
            { iThenCmd = iDir; continue; }
         // ignore all other parms as they probably belong
         // to the thenCmd.
      }

      if (!pexpr)    return 9+perr("need an expression after if.");
      if (!iThenCmd) return 9+perr("need a command after \"if expression\".");

      // evaluate expression
      bool btrue = 0;
      if (strBegins(pexpr, "rc=")) {
         long ncmp = atol(pexpr+3);
         btrue = (lRC == ncmp) ? 1 : 0;
      }
      else
      if (strBegins(pexpr, "rc<")) {
         long ncmp = atol(pexpr+3);
         btrue = (lRC < ncmp) ? 1 : 0;
      }
      else
      if (strBegins(pexpr, "rc>")) {
         long ncmp = atol(pexpr+3);
         btrue = (lRC > ncmp) ? 1 : 0;
      }
      else
         return 9+perr("unsupported expression: %s\n", pexpr);

      if (btrue)
         iChainNext = iThenCmd;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "call"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk ... +call label [parm1 parm2 ...]\n"
             "\n"
             "    call a sub function in the current script,\n"
             "    starting at the given label.\n"
             "\n"
             "    $see also\n"
             "       type \"sfk tail\" for a script example.\n"
            );
      ehelp;

      char *pszLabel     = 0;
      char *pszFlatParms = 0;

      int  iChainNext =  0;
      int  iLocalParm = -1;
      int  nLocalParm =  0;
      int  nState     =  0;
      bool bliteral   =  0;

      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (nState < 1 && !strncmp(argv[iDir], "-", 1)) {
            // general options are interpreted only before script name,
            // i.e. as long as nState == 0.
            if (strBegins(argv[iDir], "-lit")) {
               bliteral = 1;
               continue;
            }
            else
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (!bliteral && isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszLabel) {
            pszLabel = argv[iDir];
            nState = 1;
         }
         else
         if (iLocalParm < 0) {
            iLocalParm = iDir;
            nLocalParm = 1;
            nState = 2;
         }
         else
            nLocalParm++;
      }

      if (!pGlblCurrentScript)
         return 9+perr("cannot use call outside a script.");

      // pGlbl is the original script data we're running within.
      // make a copy as this will be stuffed with terminators.
      char *pScript = strdup(pGlblCurrentScript);

      // this copy must then be auto deleted.
      CharAutoDel odel(pScript);

      lRC = 0;

      // create temporary argv[] from script file
      StringTable oDynaStrings;
      char **psubargv = 0;
      int    nsubargc = 0;
      for (long npass=0; npass<2; npass++)
      {
         char *psz1 = pScript;
         char  cold = 0; // old char before current one

         // jump to start label, if any.
         if (pszLabel) {
            sprintf(szLineBuf, "label %s", pszLabel);
            psz1 = strstr(pScript, szLineBuf);
            if (!psz1) {
               perr("label not found: %s\n", pszLabel);
               pinf("use \"sfk label %s +...\" to start with a label.\n", pszLabel);
               pinf("use \"sfk ... +label %s +...\" to insert a label.\n", pszLabel);
               lRC = 9;
               break;
            }
            // do NOT skip anything, let the chain
            // start with the "label" command.
            cold = '\0';
         }

         // main processing, until +end token.
         while (*psz1)
         {
            bool bnewline = 0;
            nextToken(&psz1, cold, bnewline);
            if (*psz1)
            {
               // on next (non-blank) token
               char *ptok = psz1;
               if (bnewline && !strncmp(ptok, "//", 2)) {
                  // skip remark line
                  while (*ptok && *ptok != '\n') ptok++;
                  // do NOT skip lf, set newline on next cycle
                  psz1 = ptok;
                  continue;
               }

               // find end of token
               skipPastToken(&psz1, cold);
               long ntoklen = psz1 ? (psz1-ptok) : 0;

               long nrc = 0;
               if (npass && *psz1) {
                  cold = *psz1;   // e.g. lf will be overwritten
                  *psz1++ = '\0';
                  // post-process token: strip quotes, transform inner quotes,
                  // substitute parameters.
                  // uses: szLineBuf
                  nrc = postProcessToken(&ptok, oDynaStrings, argc, argv, iLocalParm, nLocalParm);
                  if (nrc >= 9) return 9+perr("unexpected format: \"%s\"\n", ptok);
                  // nrc==1 means skip EMPTY token.
               }

               // special first token "-prefix=..." ?
               // printf("tok %d: \"%s\"\n",nsubargc,ptok);
               if (!nrc && nsubargc<3 && strBegins(ptok, "-prefix=")) {
                  // give script input parameters a user-defined name
                  if (npass) { // not in prescan phase
                     strcopy(cs.paramprefix, ptok+8);
                  }
                  continue;
               }

               // count and register token
               if (!nrc) {
                  if (npass)
                     psubargv[nsubargc] = ptok;
                  nsubargc++;
               }

               // reached "+end"?
               if (ntoklen==4 && !strncmp(ptok, "+end", 4))
                  break;

            }  // endif *psz1

         }  // endwhile *psz1

         // at end of first pass, alloc token array
         if (!npass) {
            psubargv = new char*[nsubargc+10];
            nsubargc = 0;
         }

      }  // endfor pass

      if (cs.verbose > 0) {
         printf("loaded %d words from global script:\n", nsubargc);
         for (long i=0; i<nsubargc; i++)
            printf("%s,",psubargv[i]);
         printf("\n");
      }

      if (!lRC)
      {
         char *pszSubCmd = psubargv[0];
         int iSubDir = 1;
         // if chain starts like "sfk ...", skip "sfk":
         if (!strcmp(pszSubCmd, "sfk")) {
            pszSubCmd = psubargv[1];
            iSubDir = 2;
         }
         if (cs.verbose > 0)
            printf("  run from \"%s\" (index %d)\n", pszSubCmd, iSubDir);
         lRC = submain(nsubargc, psubargv, penv, pszSubCmd, iSubDir, bFatal);
      }

      if (psubargv) delete [] psubargv;
      oDynaStrings.resetEntries();

      // pScript is auto deleted.

      if (lRC >= 9) return lRC;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   regtest("run echo_$purefile xdir .cpp .hpp");
   regtest("list xdir +run echo_$pfile");

   ifcmd (!strcmp(pszCmd, "run"))
   {
      ifhelp (!chain.usefiles && !chain.usedata && (nparm < 1))
      printx("<help>$sfk run \"your command <run>pfile [<run>prfile] [...]\" [-yes] [-nohead] [-quiet] [...]\n"
             "\n"
             "    run a self-defined command on every file- or directory name.\n"
             "    within your command string, you may specify:\n"
             "\n"
             "       $<run>file<def>                     - insert full filename, including path.\n"
             "       $<run>quotfile<def>    or $<run>qfile<def>    - just as <run>file, but with quotes \"\" around.\n"
             "       $<run>relfile<def>     or $<run>qrelfile<def> - insert relative filename, without path.\n"
             "       $<run>base<def>        or $<run>qbase<def>    - the relative base filename, without extension.\n"
             "       $<run>ext<def>         or $<run>qext<def>     - filename extension. foo.bar.txt has extension .txt.\n"
             "       $<run>path<def>        or $<run>qpath<def>    - the path (directory) without filename.\n"
             "       $<run>since<def>       or $<run>qsince<def>   - with option -sincediff: the reference file name.\n"
             "       $<run>text<def>        or $<run>qtext<def>    - one record of input text, similar to <run>file.\n"
             "\n"
             "       always prefer 'q' forms over non-quoted forms: as soon as there is a filename\n"
             "       containing blanks, e.g. X:\\the src files\\test one.txt, you will need quotations,\n"
             "       or you have to manually insert \\\" or \\q escaped quotes (see 3rd example below).\n"
             "       you may also use <run>quotrelfile, <run>quotsince, <run>quottext for greater clarity.\n"
             "       if you supply only <run>path expressions, only directories will be processed.\n"
             "       on single word chain commands like \"+run vi\", \" <run>qfile\" is added automatically.\n"
             "\n"
             "    $further pattern support:\n"
             "       -spat       activates slash patterns like \\t \\q \\xnn etc.\n"
             "\n"
             "    $options\n"
             "       -yes        really execute. default is just to simulate what would be done.\n"
             "       -nohead     does not display the [simulating:] info text.\n"
             "       -noinfo     unless you use <run>text, sfk checks the input filenames\n"
             "                   1. if they contain blanks, but no quotes are given within command.\n"
             "                   2. if they seem to use the wrong path separator character.\n"
             "                   in both cases, a reminder is printed. if you know that your command\n"
             "                   needs no changes, add -noinfo or use <run>text instead of <run>file.\n"
             "       -quiet      does not echo the commands before execution.\n"
             "       -relnames   strips the root directory names from filenames.\n"
             "       -i[files]   process a text or filename list from stdin.\n"
             "       -idirs      process a directory name list from stdin.\n"
             "                   on stdin, '##' remark lines and empty lines are skipped. note:\n"
             "                   \"sfk.exe <list.txt\" supports only 4 KB for list.txt under windows.\n"
             "                   \"type list.txt | sfk.exe\" supports unlimited stream length.\n"
             "       -nofile[names]   with chaining, does not create \":file \" name records.\n"
             "       -printcmd   print the full command which is executed to console.\n"
             "       -stoprc=n   stop processing if a command returns return code >= n.\n"
             "\n");
      printx("    $command string format\n"
             "       with option -spat, slashpatterns like \\t \\q \\xnn are supported.\n"
             "       due to syntax limitations of the command shell, it may help\n"
             "       - to use \\q instead of \\\"   (avoids quote miscounting at shell)\n"
             "       - to use \\x26 instead of &  (if ampersand is behaving unexpected)\n"
             "\n"
             );
      printx("    $temporary or permanent output files\n"
             "       if run output is post-processed by $command chaining<def>, e.g. run ... +filter,\n"
             "       sfk creates temporary files to collect the output. by default, these files\n"
             "       are deleted when run finishes. say \"sfk help options\" for more on this.\n"
             "       specify $-to targetdir\\<run>file<def> to write command output into a permanent\n"
             "       target fileset. required directories are created automatically.\n"
             "       -to accepts the same mask as run itself, e.g. -to \"mydir\\<run>path\\<run>base.tmp\"\n"
             "       by default, standard output AND standard error stream are written to file.\n"
             "       add $2>nul<def> to your command to strip the error stream.\n"
             "\n");
      printx("    $command chaining notes\n"
             "       sfk run \"...<run>path...\" +nextcmd: will pass directories, not filenames.\n"
             "       sfk run ... -to tmp\\<run>file +nextcmd: will pass output filenames, not input.\n"
             "       sfk run ... +run: will pass unchanged input filename list.\n"
             "\n");
      printx("    $examples\n"
             "       #sfk run \"attrib -R <run>qfile\" -quiet testfiles\\FooBank\\BarDriver -yes\n"
             "          removes readonly attribute on all files within BarDriver\n"
             "       #sfk run \"<img src=<run>quottext>\" -dir . -file .jpg -nohead >index.html\n"
             "          create html-style image list of all jpegs (using just simulation).\n"
             "          note that option -nohead removes the [simulating:] info text lines.\n"
             "       #type dirlist.txt | sfk run -idirs \"xcopy \\\"x:\\<run>path\\\" \\\"z:\\<run>path\\\" /I /D\" -yes\n"
             "          update-copy all directories from dirlist.txt from x: to z:\n"
             "       #sfk run \"diff oldsrc\\<run>file newsrc\\<run>file\" -relnames -sincediff oldsrc newsrc\n"
             "          compare directories, run \"diff\" on all files with different content.\n"
             "       #sfk run \"diff <run>qsince <run>qfile\" -sincediff oldsrc newsrc\n"
             "          same as above, only shorter and safer (including quotes around filenames).\n"
             "       #sfk run \"zip update.zip <run>qfile\" -since 20070131 . .java .jsp\n"
             "          collect .java and .jsp files added/changed since 31-Jan-2007 into a zip file.\n"
             "       #sfk list testfiles .txt +run vi\n"
             "          open all .txt files in vi. <run>qfile is added automatically.\n"
             "       #sfk sel . .avi +run \"ffmpeg -i <run>file -f image -t .02 thumbs\\<run>base-%%d.jpg\"\n"
             "          extract first image from all .avi movies, videos using ffmpeg.\n"
             "\n"
             "    Don't try to execute a full run statement in ONE GO. Almost certainly, something\n"
             "    will go wrong (wrong files selected, syntax error in the command itself), and you\n"
             "    end up with many wrong output files. Instead, use THREE STEPS:\n"
             "    \n"
             "    $1. find the correct file set, by some trial and error:\n"
             "          #sfk run \"echo <run>quotfile\" mydir\n"
             "       This will simply show all filenames from \"mydir\". no command is executed\n"
             "       on those files, so nothing bad is happening. almost certainly, you notice\n"
             "       that too many files are included. Maybe you have to add \"-nosub\" to exclude\n"
             "       subfolders, or add more details about your file selection, like:\n"
             "          #sfk run \"echo <run>quotfile\" mydir .jpg .jpeg\n"
             "       which reduces the file set to just .jpg and .jpeg files within \"mydir\".\n"
             "    \n"
             "    $2. Replace \"echo\" by the actual command, still running in simulation mode.\n"
             "          #sfk run \"copy <run>quotfile \\\"d:\\pic\\small_<run>base.jpg\\\"\" mydir .jpg .jpeg\n"
             "       This simulates a copy of all images from mydir to d:\\pic, prefixing their name\n"
             "       by \"small_\", and ensuring that all target file extensions are only \".jpg\".\n"
             "    \n"
             "    $3. When you're satisfied with the simulation output, add \"-yes\".\n"
             "\n"
             );
      printx("    $see also\n"
             "       sfk runloop - run commands using a loop counter.\n"
             );
      ehelp;

      bool bAnyToken  = 0;
      int  iChainNext = 0;

      for (; iDir < argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-stoprc", &pszParm)) {
            if (!pszParm) return 9;
            cs.stoprc = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-i")) {
            bGlblStdInAny   = 1;
            bGlblStdInFiles = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-printcmd")) {
            cs.printcmd = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-ifiles")) {
            if (bGlblStdInDirs) return 9+perr("cannot use -ifiles and -idirs together.\n");
            bGlblStdInFiles = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-idirs"))  {
            if (bGlblStdInFiles) return 9+perr("cannot use -ifiles and -idirs together.\n");
            bGlblStdInDirs = 1;
            cs.justdirs  = 1;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-int")) {
            cs.intrun = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!cs.runCmd[0])
         {
            cs.runCmd  = argv[iDir];
            if (strchr(cs.runCmd, '#')) bAnyToken = 1;
            #ifdef SFK_BOTH_RUNCHARS
            if (strchr(cs.runCmd, '$')) bAnyToken = 1;
            #endif
            // special command: echo WITHOUT any valid token
            if (!strcmp(cs.runCmd, "echo")) {
               cs.runCmd = cs.justdirs ? (char*)"echo $quotpath" : (char*)"echo $quotfile";
               cs.sim = 1;
            }
            continue;
         }
         // further non-option keys:
         // short dir parms IF not reading chain
         if (chain.useany()) {
            perr("conflicting parameter: %s\n", argv[iDir]);
            pinf("run is already receiving chain input, so %s is too much.\n", argv[iDir]);
            return 9;
         }
         break; // fall through
      }
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iChainNext)) return lRC;

      if (!bAnyToken) {
         if (chain.useany()) {
            perr("detected chain input data, but no token found in run command:\n");
            setTextColor(nGlblWarnColor);
            printf("       %s\n", cs.runCmd);
            setTextColor(-1);
            pinf("you may add %cfile or some other token to the run command.\n", glblRunChar);
            pinf("to drop the chain contents, replace +run by \"+then run\".\n");
            pinf("to print them, insert \"+toterm\" or \"+tofile filename\" before +run.\n");
         // pinf("type \"sfk run\" for help. add -verbose to list the chain input on error.\n");
            if (cs.verbose) chain.dumpContents(); // not sure if this helps
            return 9;
         }
         // no token and no chain input: execute simple command once.
         cs.quiet = 1;
         cs.force   = 1;
      }

      if (bGlblStdInDirs)
         if (anyFileInRunCmd(cs.runCmd)) 
            return 9+perr("-idirs only allowed with %cpath, not with file commands.\n", glblRunChar);

      if (chain.usedata)
         chain.convInDataToInFiles();

      // add $qfile implicitely if 1) single word command 2) chain input 3) no -force:
      char *pszDynaRunCmd = 0;
      if (!cs.force && !bAnyToken && chain.usefiles && !strchr(cs.runCmd, ' ')) {
         // in this case, accept trailing "." as a replacement for -yes.
         int nlen = strlen(cs.runCmd);
         if (cs.runCmd[nlen-1] == '.') { cs.yes=1; nlen--; }
         sprintf(szLineBuf, "%.*s \"%cfile\"", (int)nlen, cs.runCmd, glblRunChar);
         cs.runCmd = pszDynaRunCmd = strdup(szLineBuf);
         bAnyToken = 1;
      }
      else
      if (!bAnyToken && !cs.force) {
         if (!cs.runCmd[0])
            perr("empty run command. type \"sfk run\" for help.\n");
         else {
            perr("no valid token in run command: \"%s\". type \"sfk run\" for help.\n", cs.runCmd);
            pinf("you may also add -force to run the command without any tokens.\n");
         }
         return 9;
      }

      // NO RETURN W/O DELETE FROM HERE

      if (btest) { if (pszDynaRunCmd) delete [] pszDynaRunCmd; return 0; }

      cs.sim = !cs.yes;

      if (chain.coldata && cs.sim)
         pwarn("%s will receive no data as long as in simulation.\n", argv[iChainNext]);

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      if (!bAnyToken) {
         // no tokens at all: run command w/o any file input
         long lFiles=0, lDirs=0; num nBytes=0;
         Coi ocoi((char*)"?", 0); // dummy
         cs.nonames = 1; // do NOT create a ":file ?" line
         lRC = execRunFile(&ocoi, 0, 0, lFiles, lDirs, nBytes); // todo: -to support
      }
      else
      if (bGlblStdInFiles || bGlblStdInDirs) {
         lRC = walkStdInListFlat(eFunc_Run, lFiles, nBytes);
      } else {
         if (!anyFileInRunCmd(cs.runCmd))
            cs.justdirs = true;
         lRC = walkAllTrees(eFunc_Run, lFiles, lDirs, nBytes);
      }

      // comment on user errors
      if (!cs.quiet && !cs.noinfo && !bGlblStdInAny) {
         if (cs.badNameForm & 1)
            pinf("%ld input names contain blanks, but no quotes (or %cqfile) found.\n", cs.blankRunFiles, glblRunChar);
         if (cs.badNameForm & 2)
            pinf("%ld input names seem to use %c path separator instead of %c\n", cs.wrongpcRunFiles, glblWrongPChar, glblPathChar);
      }

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      // NO RETURN W/O DELETE UNTIL HERE
      if (pszDynaRunCmd) delete [] pszDynaRunCmd;

      if (chain.coldata) {
         STEP_CHAIN(iChainNext, 1);
      } else {
         // pass a newly created filename list
         // - if we did not receive a filename list
         // - or if -to outfiles were defined
         STEP_CHAIN(iChainNext, (!chain.usefiles || cs.tomask));
      }

      bDone = 1;
   }

   regtest("runloop 1 100 copy_xfilesrc_xfiledst$03i.dat");

   ifcmd (!strcmp(pszCmd, "runloop") || !strcmp(pszCmd, "printloop"))
   {
      ifhelp (nparm < 3)
      printx("<help>$sfk runloop ifrom ito \"your command <run>[digits]i\" [-yes] [-nohead] [-quiet]\n"
             "$sfk runloop ifrom -steps=n [-inc=i] \"your command <run>[digits]i\"\n"
             "$sfk printloop ifrom ito \"your text <run>[digits]i\"\n"
             "\n"
             "    run a self-defined command many times, or simply print text to\n"
             "    the console, with a counter starting at ifrom, running until ito,\n"
             "    or running n times if -steps=n is specified.\n"
             "\n"
             "    with runloop, execution of commands is just simulated by default,\n"
             "    so nothing happens. as soon as your command is looking well, add\n"
             "    option \"-yes\" to really execute.\n"
             "\n"
             "    $options\n"
             "       -inc=i    increment step counter by i instead of 1.\n"
             "       -spat     support slashpatterns like \\t \\q \\xnn.\n"
             "       -nohead   does not display the [simulating:] info text.\n"
             "                 printloop is the same as runloop -nohead.\n"
             "       -quiet    does not echo the commands before execution.\n"
             "\n"
             "    $command string format\n"
             "       the command string may contain <run>i which is replaced by the\n"
             "       loop counter, or slashpatterns if option -spat is given.\n"
             "       due to syntax limitations of the command shell, it may help\n"
             "       - to use \\q instead of \\\"   (avoids quote miscounting at shell)\n"
             "       - to use \\x26 instead of &  (if ampersand is behaving unexpected)\n"
             "       <run>i also supports format parameters before 'i' like:\n"
             "          <run>5i    print 5 digits, right justified, filled with blanks.\n"
             "          <run>05i   print 5 digits, right justified, filled with zeros.\n"
             "          <run>-5i   print 5 digits, left  justified, filled with blanks.\n"
             "\n"
             "       #sfk runloop 1 100 \"copy mytest.dat testfile_<run>03i.dat\" -yes\n"
             "          creates 100 copies of mytest.dat named testfile_001.dat,\n"
             "          testfile_002.dat, testfile_003.dat etc.\n"
             "\n"
             "       #sfk printloop 1 100 -spat \"<a href=\\qhttp://...&page=<run>i\\q><run>i</a>\"\n"
             "          creates html code containing 100 web links. note that \\q was used\n"
             "          instead of \\\", as '&' may create problems when combined with \\\"\n"
             "          (a syntax mess produced by the command shell, not by sfk itself.)\n"
             "          and to enable slash patterns like \\q, -spat had to be added.\n"
             "\n"
             "    $see also\n"
             "       sfk run - run self-defined command on filenames.\n"
             );
      ehelp;

      bool bisprint = !strcmp(pszCmd, "printloop");

      bool bHaveFrom=0, bHaveTo=0;
      long nfrom = 0;
      long nto   = 0;
      long ninc  = 1;
      char *pszRunMask = 0;
      int  iChainNext = 0;

      for (; iDir < argc; iDir++)
      {
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         if (strBegins(argv[iDir], "-steps=")) {
            if (bHaveTo) return 9+perr("too many parameters before %s",argv[iDir]);
            if (!bHaveFrom) return 9+perr("a start value must be specified before %s",argv[iDir]);
            nto = nfrom + atol(argv[iDir]+7) - 1;
            bHaveTo = 1;
            continue;
         }

         if (strBegins(argv[iDir], "-inc=")) {
            ninc = atol(argv[iDir]+5);
            if (ninc <= 0) return 9+perr("-inc value must be > 0");
            continue;
         }

         if (strBegins(argv[iDir], "-int")) {
            cs.intrun = 1;
            continue;
         }

         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unexpected option: %s\n",argv[iDir]);
         }

         // first non-option parm: from value
         if (!bHaveFrom) {
            nfrom = atol(argv[iDir]);
            bHaveFrom = 1;
            continue;
         }
         
         // 2nd non-option parm: to value
         if (!bHaveTo) {
            nto = atol(argv[iDir]);
            bHaveTo = 1;
            continue;
         }

         // 3rd: the run mask
         if (!pszRunMask) {
            pszRunMask = argv[iDir];
            continue;
         }

         return 9+perr("unexpected parameter: \"%s\" (3)\n", argv[iDir]);
      }

      // do not check for ito >= ifrom, allowing also noop cases.

      if (!bHaveFrom || !bHaveTo || !pszRunMask)
         return 9+perr("missing parameters. type \"sfk runloop\" for help.\n");

      if (btest) return 0;

      char szTokMask[20];

      cs.sim = !cs.yes;
      cs.nohead |= cs.quiet;

      // chaining plausi
      if (chain.colfiles) {
         perr("runloop cannot collect filenames, only text data.\n");
         if (iChainNext)
            pinf("try to insert +texttofilenames or +ttf before %s\n",argv[iChainNext]);
         return 9;
      }
      if (chain.colany())
         cs.nohead = 1;
      if (!cs.sim && chain.colany())
         return 9+perr("output chaining is supported only for simulation output.\n");

      if (!bisprint && cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      copyFormStr(szRunCmdBuf, MAX_LINE_LEN, pszRunMask, strlen(pszRunMask));
      pszRunMask = szRunCmdBuf;

      for (long i=nfrom; i<=nto && !userInterrupt(); i += ninc)
      {
         szLineBuf[0] = '\0';
         char *pszCur = pszRunMask;
         while (1) 
         {
            char *pszTok = strchr(pszCur, glblRunChar);
            if (!pszTok) break;
            // copy left
            int nBufLen = strlen(szLineBuf);
            sprintf(&szLineBuf[nBufLen], "%.*s", (int)(pszTok-pszCur), pszCur);
            // isolate token until 'i'
            char *pszTok2 = pszTok;
            while (*pszTok2 && *pszTok2 != 'i')
               pszTok2++;
            if (*pszTok2 != 'i') return 9+perr("wrong syntax, expected %ci somewhere.\n",glblRunChar);
            strcpy(szTokMask, "%ld");
            int nTokExtLen = pszTok2-pszTok-1;
            if (nTokExtLen > 0)
               sprintf(szTokMask, "%%%.*sld",(int)nTokExtLen,pszTok+1);
            // use (formatted) token
            nBufLen = strlen(szLineBuf);
            sprintf(&szLineBuf[nBufLen], szTokMask, i);
            // continue with next part
            pszCur = pszTok2+1;
         }
         if (pszCur)
            strcat(szLineBuf, pszCur);

         // now holding full command in szLineBuf.
         if (!cs.quiet && !cs.sim) {
            printf("%s\n", szLineBuf);
            fflush(stdout); 
         }

         int iRC = 0;
      
         if (bisprint || cs.sim) {
            // special case: just dump resulting command to terminal
            if (chain.coldata)
               chain.addLine(szLineBuf, "");
            else
               printf("%s\n", szLineBuf);
         } else {
            if (cs.intrun)
               iRC = runInternal(szLineBuf);
            else
               iRC = system(szLineBuf);
         }
      
         if (!cs.quiet && !cs.sim) {
            if (iRC) {
               printf("... error, rc %d\n", iRC);
               fflush(stdout);
            }
         }
      }

      if (!bisprint && cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      if (chain.coldata) {
         STEP_CHAIN(iChainNext, 1);
      }

      bDone = 1;
   }

   #ifdef WITH_FN_INST
   ifcmd (!strcmp(pszCmd, "inst")) // +chaining
   {
      ifhelp (   ( chain.usefiles && (nparm < 2))
              || (!chain.usefiles && (nparm < 3))
             )
      printx("<help>$sfk inst mtkinc mtkmac -dir ... -file ...\n"
             "$sfk inst -revoke[|-redo] [-keep-dates] -dir ... -file ...\n"
             "\n"
             "  instrument c++ sourcecode with calls to sfk micro tracing kernel.\n"
             "\n"
             "  $parameters:\n"
             "    mtkinc         path and name of mtktrace.hpp file\n"
             "    mtkmac         mtk block entry macro name, _mtkb_\n"
             "\n"
             "  $options:\n"
             "    -revoke        undo all changes (copy backups back).\n"
             "                   do not specify mtkinc, mtkmac on -revoke.\n"
             "    -keep-dates    on revoke, also reactivate original file dates\n"
             "    -redo          redo all changes\n"
             "    -witheol       also instrument { at end of line, like in:\n"
             "                   void Foo::bar(int nmode) {\n"
             "\n"
             "       #sfk inst mtk/mtktrace.hpp _mtkb_ -dir testfiles !save_ -file .cpp\n"
             "          instrument the code (saving all in save_inst dirs)\n"
             "\n"
             "       #sfk inst -revoke -keep-dates -dir testfiles !save_ -file .cpp\n"
             "          restore original code (copying back from save-inst dirs),\n"
             "          also restoring the original time stamps.\n"
             "\n"
             "       #sfk sel -dir base ext lib -file .cpp +inst mtk/mtktrace.hpp _mtkb_\n"
             "          select the files of interest, and when done, run +inst on them.\n"
             "\n"
             "    NOTE: is is recommended that you do NOT say \"-dir .\" in your batch files\n"
             "          to ensure that instrumenting is always done on the correct path.\n"
             "\n"
             "    read more about the sfk micro tracing kernel in the mtk/ dir.\n"
            );
      ehelp;

      for (; (iDir < argc) && !strncmp(argv[iDir], "-", 1); iDir++)
      {
         // inst-specific prefix options
         if (!strcmp(argv[iDir], "-revoke")) {
            bGlblInstRevoke = 1;
         }
         else
         if (!strcmp(argv[iDir], "-redo")) {
            bGlblInstRevoke = 1;
            bGlblInstRedo   = 1;
         }
         else
         if (!strcmp(argv[iDir], "-keep-dates")) {
            bGlblTouchOnRevoke = 0;
         }
         else
         if (!strcmp(argv[iDir], "-witheol")) {
            bGlblInstEol   = 1;
         }
         else
         if (isDirParm(argv[iDir]))
            break; // fall through
         else
         if (!setGeneralOption(argv, argc, iDir))
            break; // other option, fall through
      }
      if (!bGlblInstRevoke || bGlblInstRedo) {
         // no revoke: expect further parms
         if (iDir >= argc-1) { fprintf(stderr, "error  : inst: missing parms. supply include and macro.\n"); return 9; }
         pszGlblInstInc = argv[iDir++];
         pszGlblInstMac = argv[iDir++];
      }
      int iDirNext=0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext)) return lRC;

      lRC = walkAllTrees(eFunc_Inst, lFiles, lDirs, nBytes);

      STEP_CHAIN(iDirNext, 0);

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "strings"))
   {
      // extract strings from single binary file
      ifhelp (nparm < 1)
      printx("$sfk strings [-umlauts] [-wrapbin=n] filename\n"
             "\n"
             "   extract strings from a binary file. resulting text lines are split\n"
             "   at column 80 by default, which can be changed by -wrapbin or -wrap.\n"
             "\n"
             "   $examples\n"
             "      #sfk strings test.exe +filter -+VersionInfo\n"
             );
      ehelp;

      char *pszFile = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszFile)
            pszFile = argv[iDir];
         else
            return 9+perr("unexpected parameter: %s", argv[iDir]);
      }

      // just for chaining:
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 0, &iChainNext)) return lRC;
 
      if (!pszFile) return 9+perr("missing filename");

      Coi ocoi(pszFile, 0);
      if (ocoi.open("rb"))
         return 9+perr("cannot read: %s\n", pszFile);

      BinTexter bt(&ocoi);
      bt.process(BinTexter::eBT_Print);

      ocoi.close();

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "pathfind") || !strcmp(pszCmd, "where"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      // find out exact location of a command in the path
      ifhelp (nparm < 1)
      printx("<help>$sfk pathfind mycmd\n"
             "$sfk where mycmd\n"
             "\n"
             #ifdef _WIN32
             "   search the current directory and the PATH for the location\n"
             "   of a command mycmd. \"where\" is the same as \"pathfind\".\n"
             "\n"
             "   if mycmd does not contain a dot '.', sfk searches for all\n"
             "   extensions listed in PATHEXT, e.g. mycmd.bat, mycmd.exe etc.\n"
             #else
             "   search the PATH for the location of a command mycmd.\n"
             #endif
            );
      ehelp;

      char *pszCmd2 = 0;

      for (; iDir < argc; iDir++) {
         if (strncmp(argv[iDir], "-", 1))
            pszCmd2 = argv[iDir];
         else
         if (!setGeneralOption(argv, argc, iDir))
            break;
      }
      if (!pszCmd2) return 9+perr("supply a command name to search within PATH.\n");

      #ifdef _WIN32
      if (!strchr(pszCmd2, '.'))
      {
         // user did NOT supply .bat etc: search for every possible extension
         long nhits = listPathAny(pszCmd2, 0); // 0: not silent
         if (!nhits) {
            if (!cs.quiet) {
               printf("nothing like %s found within PATH and current dir.\n", pszCmd2);
            }
            return 1;
         }
         // results were dumped already
         return 0;
      }
      else
      {
      #else
      {
      #endif
         char *pszAbs = findPathLocation(pszCmd2);
         if (!pszAbs) {
            if (!cs.quiet) {
               #ifdef _WIN32
               printf("%s not found within PATH and current dir.\n", pszCmd2);
               printf("... try also .exe, .bat, .cmd extensions.\n");
               #else
               printf("%s not found anywhere within PATH.\n", pszCmd2);
               #endif
            }
            return 1;
         } else {
            if (!cs.quiet) {
               printf("%s\n", pszAbs);
            }
            return 0;
         }
      }
   }

   regtest("deblank xdir .cpp .hpp");
   regtest("list xdir +deblank -dir xdir");

   ifcmd (!strcmp(pszCmd, "deblank")) // +chaining
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk deblank dirname [.ext1] [.ext2] [...]\n"
             "\n"
             "   remove blanks from filenames and directory names.\n"
             "   simulates by default. add -yes to apply changes.\n"
             "\n"
             "   $examples\n"
             "\n"
             "      #sfk deblank docs\n"
             "         lists all directories and files within docs having\n"
             "         blanks in their names, previewing changes.\n"
             "\n"
             "      #sfk select docs +deblank\n"
             "         deblanks only the names of files, not of directories.\n"
             "\n"
             "      #sfk select -withdirs docs +deblank\n"
             "         deblanks filenames and directories.\n"
            );
      ehelp;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-packalnum")) {
            cs.packalnum = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // fall through
      }

      // sfk deblank -yes
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 1)) return lRC;
      if (btest) return 0;

      if (!cs.yes) printx("$[simulating:]\n");
      lRC = walkAllTrees(eFunc_Deblank, lFiles, lDirs, nBytes);
      if (!cs.yes) printx("$[add -yes to execute.]\n");

      bDone = 1;
   }

   regtest("reflist -dir xdir1 xdir2");

   ifcmd (!strcmp(pszCmd, "reflist") || !strcmp(pszCmd, "deplist"))
   {
      cs.deplist = !strcmp(pszCmd, "deplist");

      ifhelp (nparm < 2) 

      // if dumping all help text, run two passes
      for (long i=0; i<2; i++) {

      if (!cs.deplist)
      printx("<help>$sfk reflist [-path] [-wide] -dir sdir -file .text -dir tdir -file .sext\n"
             "$sfk reflist -dir sourcedir -dir targetdir1 [targetdir2 targetdir3] [...]\n"
             "\n"
             "   list possible dependencies between files through (fuzzy) content analysis.\n"
             "   find out which target files are referenced by any of the source files.\n");
      else
      printx("<help>$sfk deplist [-flat] -dir srcdir [-file ...] -dir targdir [-file ...]\n"
             "$sfk deplist [-flat] singleSourceFile -dir targdir [tdir2 tdir3] [-file ...]\n"
             "\n"
             "   list possible dependencies between files through (fuzzy) string analysis.\n"
             "   find out on which target files the specified source files depend.\n");

      printx("\n"
             "   a list of target files is created from directory targdir. then all source\n"
             "   files are loaded from srcdir, and scanned if the names of the targets appear\n");

      if (!cs.deplist)
      printx("   within their content. if so, the targets are listed, with the number of\n"
             "   referring source files, and a list (of the first 10) of these files.\n"
             "\n"
             "   NOTE that sfk reflist DOES NOT GUARANTEE that files are (not) referenced.\n"
             "   This way of reference detection is just a FUZZY INDICATOR, so keep thinking\n"
             "   and make backups before you massively cleanup files without references!\n"
             "\n");
      else
      printx("   within their content. if so, the sources are listed with their dependencies.\n"
             "\n"
             "   by default, deplist also checks which targdir files depend on other targdir\n"
             "   files (recursive dependencies), resulting in more complete listings.\n"
             "   specify -flat to disable recursive checks.\n"
             "\n"
             "   if you specify just a singleSourceFile name, the source name is NOT included\n"
             "   in the output (unless -incsrc specified), and the filename list can be used\n"
             "   by subsequent (chained) commands.\n"
             "\n");

      printx("   NOTE: you may specify any number of target directories. if your list of\n"
             "   target directories is incomplete, files from there will NOT be found.\n"
             "\n");

      printx("   by default, only relative target filenames are searched, without path,\n"
             "   but including the file name extension.\n"
             "\n"
             "                  e.g. the target file: #the/path/foosys.dll\n"
             "                     runs a search for: #foosys.dll\n"
             "                   in the source files.\n"
             "\n"
             "   $options\n"
             "      -path     : search target filenames including path information.\n"
             "                  e.g. the target file: #the/path/foosys.dll\n"
             "                     runs a search for: #the/path/foosys.dll\n"
             "\n"
             "      -noext    : strip .extensions from filenames, compare only basename.\n"
             "                  e.g. the target file: #the/path/foosys.dll\n"
             "                     runs a search for: #foosys\n"
             "                  which may lead to ambiguities, listing too many hits.\n"
             "                  -noext can also be combined with -path.\n"
             "\n");

      if (!cs.deplist)
      printx("      -wide[=n] : list references in an extended format, with a list of\n"
             "                  (up to to n) source files per target file, telling in\n"
             "                  detail which text patterns were found.\n"
             "\n");
      printx("      -case     : force case sensitive string comparison (not default).\n"
             "      -quiet    : do not print the number of source and target files.\n"
             "      -relnames : if using -path, strip targdir name from target paths\n"
             "                  for comparison.\n"
             "      -flat     : do not check if target files depend on other target files.\n"
             "                  set this to improve speed, if you know that such dependen-\n"
             "                  cies cannot exist, e.g. if the targtes are .wav files.\n"
             "      -memlimit=n : load and analyze only files with a size up to n mbytes.\n"
             "                    the default load limit is 300 mbytes.\n"
             "\n");
      if (!cs.deplist)
      printx("   $see also\n"
             "      sfk deplist - list file dependencies.\n");
      else
      printx("   $see also\n"
             "      sfk reflist - list file references.\n");
      printx("\n"
             "   $examples\n");

      if (!cs.deplist)
      printx("      #sfk reflist -dir mysrcdir mytargdir\n"
             "         check every file in mytargdir if it is referenced\n"
             "         by any file within mysrcdir.\n"
             "\n"
             "      #sfk reflist -dir movie -file .ppt -dir pic -file .png\n"
             "         find out which .png files within pic are referenced\n"
             "         by .ppt files within movie.\n"
             "\n"
             "      #sfk reflist -wide=100 -dir bin -file .exe -dir bin -file .dll\n"
             "         find out which .dll's are directly referenced by .exe files\n"
             "         within directory bin, listing up to 100 references per target.\n"
             "\n"
             "      #sfk reflist -dir . -file .flp -dir . -file .wav\n"
             "         within a FruityLoops project directory lists which .wav files\n"
             "         are referenced by which .flp project files of that directory.\n"
             "\n"
             "      #sfk reflist -dir film -file .ppj -dir audio frames clips\n"
             "         tell which audio, image and movie clip files (e.g. .wav .bmp .avi)\n"
             "         are used by which Adobe Premiere project files (.ppj) within the\n"
             "         film directory. if image sequences are used, only the first image\n"
             "         of such sequences will be found, e.g. foobar00001.bmp\n"
            );
      else
      printx(
             "      #sfk deplist -dir bin -file .exe -dir lib1 lib2 lib3 -file .dll\n"
             "         create a list of all .exe files in bin, and the dll's they depend on,\n"
             "         searching for dll's in lib1, lib2 and lib3 directories.\n"
             "\n"
             "      #sfk deplist bin\\diff.exe -dir bin -file .dll +run \"copy <run>file tmp\"\n"
             "         find out which .dll's are used by diff.exe, and copy them to tmp.\n"
             "\n"
             "      #sfk deplist -relnames -case -path -noext -dir classes -dir classes\n"
             "         find dependencies between java .class files. -path uses path infos,\n"
             "         -noext strips \".class\", -case keeps the capital letters within names.\n"
             "         -relnames strips \"classes/\" from target names for comparison.\n"
             "\n"
             "      #sfk deplist -flat -dir . -file .flp -dir . -file .wav\n"
             "         within a FruityLoops project directory lists which .flp project\n"
             "         files are using which .wav files of that directory. note that\n"
             "         .wav files cannot \"use\" other .wav files, therefore -flat was set\n"
             "         to avoid recursive target checks, speeding up the search.\n"
            );

      if (bhelp) { cs.deplist = cs.deplist ? 0 : 1; printx("\n"); } else break; }
      // end of two passes if dumping all help text

      ehelp;

      bool bIncDstAsSrc  = 0;
      char *pszSingleSrc = 0;
      bool bIncSrc       = 0;
      bool bAutoMax      = 0;

      memset(abGlblRefChars, 0, sizeof(abGlblRefChars));

      if (cs.deplist) {
         bGlblRefWideInfo  = 1;
         bAutoMax          = 1;  // will auto-adapt RefMaxSrc
         bIncDstAsSrc      = 1;
      }

      int iChainNext = 0;
      for (; iDir < argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-wide=", 6)) {
            // user-selected list truncation
            bGlblRefWideInfo = 1;
            nGlblRefMaxSrc   = atol(argv[iDir]+6);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-wide")) {
            bGlblRefWideInfo = 1;
            bAutoMax         = 1;  // will auto-adapt RefMaxSrc
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-path") || !strcmp(argv[iDir], "-abs")) {
            bGlblRefRelCmp = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-noext") || !strcmp(argv[iDir], "-base")) {
            bGlblRefBaseCmp = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-incsrc")) {
            bIncSrc = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-flat")) {
            bIncDstAsSrc = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-fast", 5)) {
            // yet experimental: strip chars from sources input.
            // do not strip all printable chars, except if fast2.
            if (strcmp(argv[iDir], "-fast2"))
               for (ulong uc=0; uc<256; uc++)
                  if (isprint((char)uc))
                     abGlblRefChars[uc] = 1;
            cs.refstripsrc = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option parameter:
         if (!cs.deplist)
            return 9+perr("unexpected: %s\n", argv[iDir]);
         // expect single source file name
         if (pszSingleSrc)
            return 9+perr("only one source file name supported, %s is unexpected.\n",argv[iDir]);
         pszSingleSrc = argv[iDir];
         if (!fileExists(pszSingleSrc))
            return 9+perr("no such file: %s\n", pszSingleSrc);
         cs.depsingle = 1;
      }
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iChainNext)) return lRC;

      // check input: only two dir roots allowed
      if (!pszSingleSrc && glblFileSet.numberOfRootDirs() < 2)
         return 9+perr("need at least two root dirs, for sources and targets.\n");

      if (chain.colfiles) {
         if (cs.depsingle) {
            cs.quiet = 1;
         } else {
            perr("filename chaining is not supported this way.\n");
            if (cs.deplist) {
               pinf("try specifiying a single source filename.\n");
            }
            return 9;
         }
      }

      if (btest) return 0;

      // tree layer 0: targets
      // tree layer 1: sources
      long rlFiles=0, rlDirs=0;
      FileList oDirFiles;
      num  rlBytes = 0, nLocalMaxTime = 0, nTreeMaxTime  = 0;

      // ===== collect list of sources to determine nGlblRefMaxSrc =====
      long isrcroot = 0;
      long idstroot = 1;
      nGlblFunc = eFunc_RefColSrc;
      if (pszSingleSrc) {
         if (execRefColSrc(pszSingleSrc))
            return 9;
         idstroot = 0;
      } else {
         char *pszTree = glblFileSet.setCurrentRoot(isrcroot);
         if (cs.debug) info.print("] src: %s\n", pszTree);
         if (!isDir(pszTree)) return 9+perr("no such directory: %s\n", pszTree);
         Coi *pcoi = new Coi(pszTree, 0); // no relroot, is absolute
         long nrc = walkFiles(pcoi, 0, rlFiles, oDirFiles, rlDirs, rlBytes, nLocalMaxTime, nTreeMaxTime);
         if (!pcoi->refcnt()) delete pcoi;
         if (nrc) return 9;
      }
      long nSrcToList = glblRefSrc.numberOfEntries();
      if (bIncDstAsSrc) {
         // deplist: auto-include destinations as sources.
         // nSrcToList tells how many sources will be listed in output.
         cs.coldstnames = 1;
         for (long iroot=idstroot; iroot<glblFileSet.numberOfRootDirs(); iroot++) {
            char *pszTree = glblFileSet.setCurrentRoot(iroot);
            if (cs.debug) info.print("] dst: %s [included as src]\n", pszTree);
            if (!isDir(pszTree)) return 9+perr("no such directory: %s\n", pszTree);
            Coi *pcoi = new Coi(pszTree, 0); // no relroot, is absolute
            long nrc = walkFiles(pcoi, 0, rlFiles, oDirFiles, rlDirs, rlBytes, nLocalMaxTime, nTreeMaxTime);
            if (!pcoi->refcnt()) delete pcoi;
            if (nrc) return 9;
         }
      }
      if (!cs.quiet) {
         if (bIncDstAsSrc)
            info.print("%05u source files (%u internal sources)\n", nSrcToList, cs.refsrccnt);
         else
            info.print("%05u source files\n", cs.refsrccnt);
      }

      // auto-adapt nGlblRefMaxSrc
      if (bAutoMax && (cs.refsrccnt + 10 > nGlblRefMaxSrc))
         nGlblRefMaxSrc = cs.refsrccnt + 10;

      // setup reference table
      glblRefDst.addRow(__LINE__); // for dst file names
      glblRefDst.addRow(__LINE__); // for dst ref counts
      long i=0;
      for (i=0; i<nGlblRefMaxSrc; i++) {
         glblRefDst.addRow(__LINE__); // for source infos
      }

      // ===== collect list of targets (execRefColDst) =====
      nGlblFunc = eFunc_RefColDst;
      if (bIncDstAsSrc) {
         // have scanned dest. files already, reuse memory list.
         for (i=0; i<glblRefDstNames.numberOfEntries(); i++) {
            char *pszFile = glblRefDstNames.getEntry(i, __LINE__);
            Coi ocoi(pszFile, 0);
            if (execRefColDst(&ocoi))
               return 9;
         }
      } else {
         // have not scanned dest. yet, scan now.
         for (long iroot=idstroot; iroot<glblFileSet.numberOfRootDirs(); iroot++) {
            char *pszTree = glblFileSet.setCurrentRoot(iroot);
            if (cs.debug) info.print("] dst: %s\n", pszTree);
            if (!isDir(pszTree)) return 9+perr("no such directory: %s\n", pszTree);
            Coi *pcoi = new Coi(pszTree, 0); // no relroot, is absolute
            long nrc = walkFiles(pcoi, 0, rlFiles, oDirFiles, rlDirs, rlBytes, nLocalMaxTime, nTreeMaxTime);
            if (!pcoi->refcnt()) delete pcoi;
            if (nrc) return 9;
         }
      }
      if (!cs.quiet)
         info.print("%05u target files\n", glblRefDst.numberOfEntries(0));

      // ===== process potential sources (execRefProcSrc) =====
      /*
      fprintf(stderr, "excluded char map dump:\n");
      for (ulong i=65; i<155; i++)
         if (!abGlblRefChars[i])
            fprintf(stderr, "%c", (char)i);
      fprintf(stderr, "\n");
      */
      for (i=0; i<cs.refsrccnt; i++) {
         char *pszsrc = glblRefSrc.getEntry(i, __LINE__);
         if (execRefProcSrc(pszsrc, 0, i, cs.refsrccnt))
            return 9;
      }
      info.clear();

      if (!bGlblEscape)
      if (cs.deplist) {
         // dump dependency list
         for (long isrc=0; isrc<nSrcToList; isrc++)
         {
            char *pszSrc = glblRefSrc.getEntry(isrc, __LINE__);
            StringTable asrc;
            bool bprinted = 0;
            if (bIncSrc || !pszSingleSrc) bprinted = 2; // dump a tab
            listDependencies(asrc, pszSrc, 0, bIncSrc || (pszSingleSrc ? 0 : 1), bprinted);
            chain.print(' ', 1, ""); // 1: with post-lf
         }
      } else {
         // dump reference list
         for (long idst=0; idst<glblRefDst.numberOfEntries(0); idst++)
         {
            char *pszDst  = glblRefDst.getString(0, idst);
            long  nRefCnt = glblRefDst.getLong(1, idst, __LINE__);
            if (nRefCnt > 0) {
               chain.print('i', 0, "%05u %s       ", (unsigned long)nRefCnt, pszDst);
               if ((nRefCnt > 0) && bGlblRefWideInfo) {
                  chain.print(' ', 2, "      :ref:\t"); // 2: with pre-lf (newline)
               } else {
                  chain.print(' ', 0, "<- "); // within same line
               }
               long nDump = nRefCnt;
               if (nDump > nGlblRefMaxSrc)
                  nDump = nGlblRefMaxSrc;
               for (i=0; i<nDump; i++) 
               {
                  char *pszSrc  = glblRefDst.getString(2+i, idst);
                  chain.print(' ', 0, "%s ", pszSrc); // within same line
                  if (bGlblRefWideInfo && (i<nDump-1)) {
                     chain.print(' ', 2, "      :ref:\t"); // 2: with pre-lf
                  }
               }
               chain.print(' ', 1, ""); // 1: with post-lf
            } else {
               chain.print(' ', 0, "%05u %s", (unsigned long)nRefCnt, pszDst); // with lf
               chain.print(' ', 1, ""); // 1: with post-lf
            }
         }
      }

      // if reflists are incomplete, warn about it
      if (bGlblRefLimitReached) {
         printx("<warn>lists of source files have been truncated at the %ldth entry.<def>\n",nGlblRefMaxSrc);
         printx("<time>use option -wide[=n] to list more source files per target.<def>\n");
      }

      // cleanup
      info.setStatus("wait", "cleaning up memory");
      glblRefDst.reset();
      glblRefSrc.resetEntries();
      glblRefDstNames.resetEntries();
      info.clear();

      // pass created text to next chain command, if any
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "echo"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk echo [-spat] string [string2] [string3] [...]\n"
             "\n"
             "   prints the supplied string to terminal, which may contain color patterns:\n"
             "\n"
             "       [Red][[Red]][def],[Green][[Green]][def],[Blue][[Blue]][def],"
                    "[Yellow][[Yellow]][def],[Cyan][[Cyan]][def],[Magenta][[Magenta]][def]   (bright)\n"
             "       [red][[red]][def],[green][[green]][def],[blue][[blue]][def],"
                    "[yellow][[yellow]][def],[cyan][[cyan]][def],[magenta][[magenta]][def]   (dark)\n"
             "         print the following text in the selected color.\n"
             "\n"
             "       $[[def]]<def>\n"
             "         switch back to default color.\n"
             "\n"
             "       $[[[[<def> print the '[[' character, no not interpret the following word.\n"
             "       $]]]]<def> print the ']]' character, do not interpret it.\n"
             "\n"
             "   $further pattern support:\n"
             "      -spat     activates slash patterns: \\t=TAB \\q=\" \\r=CR \\n=LF\n"
             "                \\xnn = any code with hex value nn.\n"
             "      -literal  or -lit disables everything, even color patterns. set this\n"
             "                always if you need to process filenames in batch files,\n"
             "                using echo to feed a command chain:\n"
             "                   #sfk echo -lit %%1 +filter -rep _/_\\_ ...\n"
             "\n"
             "   $options:\n"
             "      -noline   stay in the same line, print no linefeed.\n"
             "                if your string ends with \\r, -noline is assumed.\n"
             "      -noblank  if multiple strings are given, do not insert blanks\n"
             "                between them.\n"
             "\n"
             "   $see also:<def> sfk help colors\n"
             "\n"
             "   $examples:\n"
             "      #sfk echo \"[[Red]]error:[[def]] missing filename.\"\n"
             "         prints \"[Red]error:[def] missing filename.\" onto terminal.\n"
             "\n"
             "      #sfk echo [[Cyan]]NOTE:[[def]] type the word [[[[red]]]] with brakets!\n"
             "         prints \"[Cyan]NOTE:[def] type the word [[red]] with brakets!\" onto terminal.\n"
             "\n"
             "      #sfk echo \"[[Green]]mytext contains:[[def]]\" +then filter mytext.txt\n"
             "         $+then<def> forces echo $not<def> to pass it's text to filter, but to\n"
             "         print it immediately. filter then prints the content of mytext.\n"
             );
      ehelp;

      bool bNoLine = 0;
      abBuf[0] = '\0';
      int iChainNext = 0;
      bool bfirst = 1;
      bool bNoBlank = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-noline")) {
            bNoLine = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-noblank")) {
            bNoBlank = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) 
         {
            // any indicator that this is not an option?
            char *psz = argv[iDir]+1;
            bool baca = *psz ? 1 : 0; // all chars alphabetic
            for (; *psz; psz++)
               if (!isalpha(*psz))
                  { baca = 0; break; }

            if (!baca)  // e.g. ---===---
               { }      // fall through, take as text
            else
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:

         // if multiple strings are supplied, insert blanks:
         if (!bfirst && !bNoBlank)
            strcat((char*)abBuf, " ");
         bfirst = 0;

         // append another echo string, converting \t etc.
         char *pszsrc  = argv[iDir];
         long  nsrclen = strlen(pszsrc);
         char *pszdst  = (char*)abBuf + strlen((char*)abBuf);
         long  nmaxdst = MAX_ABBUF_SIZE - strlen((char*)abBuf);
         copyFormStr(pszdst, nmaxdst, pszsrc, nsrclen);
      }

      // if constructed string ends with \r, imply -noline
      long nlen = strlen((char*)abBuf);
      if (nlen > 0 && abBuf[nlen-1] == '\r')
         bNoLine = 1;

      if (!cs.wpat) {
         // do not interpret any [red] etc. commands
         if (chain.coldata) {
            if (bNoLine)
               chain.addToCurLine((char*)abBuf, "", 0);
            else
               chain.addLine((char*)abBuf, "", 2); // splitbylf, also on termlf
         } else {
            printf("%s%s",(char*)abBuf,bNoLine?"":"\n");
         }
      } else {
         // default: support [red] etc.
         printEcho(bNoLine, "%s", (char*)abBuf);
      }

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "make-random-file"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 2)
      printx("<help>$sfk make-random-file outfilename size [-text] [-seed=n]\n"
             "\n"
             "   creates a file full of random binary data for testing.\n"
             "   size parameters like 5m, 100k, 9000b are supported.\n"
             "   type \"sfk dupfind\" for details on size parameters.\n"
             "\n"
             "   $options\n"
             "      -text     create text data instead of binary.\n"
             "      -seed=n   specify randomizer seed. default is\n"
             "                to use a time based seed.\n"
             "\n"
             "   $example\n"
             "      #sfk make-random-file tmp1.dat 1m -seed=1234\n"
             "         produce a file tmp1.dat with 1 mbyte of size.\n"
            );
      ehelp;

      char *pszFile = argv[2];
      char *pszSize = argv[3];
      num nSize = numFromSizeStr(pszSize, "size");
      if (nSize < 0) return 9;
      bool bText = 0;
      unsigned nSeed = (unsigned)time(NULL);

      iDir = 4;
      for (; iDir < argc; iDir++) {
         if (!strncmp(argv[iDir], "-seed=", strlen("-seed="))) {
            nSeed = (unsigned)atol(argv[iDir]+strlen("-seed="));
         }
         else
         if (!strcmp(argv[iDir], "-text")) {
            bText = 1;
         }
         else
            return 9+perr("unknown option: %s\n", argv[iDir]);
      }

      FILE *fout = 0;
      if (bText) fout = fopen(pszFile, "w");
      else       fout = fopen(pszFile, "wb");
      if (!fout)
         return 9+esys("fopenw", "unable to write %s\n", pszFile);

      info.setAction("write", pszFile, "");

      bool bTold = 0;

      srand(nSeed);

      num nRemain  = nSize;
      num nWritten = 0;
      long nBlockSize = sizeof(abBuf)-10;
      long i=0;
      while (nRemain > 0) {
         if (bText) {
            long ibreak = 40 + rand() % 80;
            for (i=0; i<nBlockSize; i++) 
            {
               abBuf[i] = (uchar)(rand()%26+'a');
               // add line breaks near 80 chars
               if ((i % ibreak) == ibreak-2)
                  { abBuf[i] = '\r'; }
               if ((i % ibreak) == ibreak-1) {
                  abBuf[i] = '\n';
                  ibreak = 40 + rand() % 80;
               }
            }
         } else {
            for (i=0; i<nBlockSize; i++)
               abBuf[i] = (uchar)rand();
         }
         long nWriteSize = nBlockSize;
         if (nWriteSize > nRemain)
             nWriteSize = nRemain;
         num nWrite = myfwrite(abBuf, nWriteSize, fout);
         if (nWrite != nWriteSize) {
            esys("fwrite", "unable to write after %s bytes.\n", numtoa(nWritten));
            lRC = 9;
            break;
         }
         nRemain  -= nWriteSize;
         nWritten += nWriteSize;
         info.setProgress(nSize, nWritten, "bytes");
      }

      fclose(fout);

      info.print("written %s (%s bytes).\n", pszFile, numtoa(nWritten));

      bDone = 1;
   }

   // internal
   if (!strcmp(pszCmd, "testfwrite"))
   {
      if (blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      if (nparm < 2) { 
         printx("<help>$sfk testfwrite outfile blocksize\n");
         return 9;
      }
      char *pszFile = argv[iDir++];
      char *pszSize = argv[iDir++];
      num nSize = numFromSizeStr(pszSize, "size");

      testfwrite(pszFile, nSize);
     
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "color"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("<help>$sfk color colorname\n"
             "\n"
             "   switches the text color of terminal (command line).\n"
             "   supported color names are:\n"
             "\n"
            );
      if (bhelp) {
      printx("   white,grey,red,green,blue,yellow,cyan,magenta,black\n");
      } else {
         setTextColor(15); printf("      white  \n");
         setTextColor(14); printf("      grey   \n");
         setTextColor( 3); printf("      red    \n");
         setTextColor( 5); printf("      green  \n");
         setTextColor( 9); printf("      blue   \n");
         setTextColor( 7); printf("      yellow \n");
         setTextColor(13); printf("      cyan   \n");
         setTextColor(11); printf("      magenta\n");
         setTextColor( 0); printf("      black  \n");
         setTextColor(-1);
      }
      ehelp;

      char *pszCol = argv[2];
      if (!strcmp(pszCol, "white" ))  { setTextColor(15); return 0; }
      if (!strcmp(pszCol, "grey"  ))  { setTextColor(14); return 0; }
      if (!strcmp(pszCol, "red"   ))  { setTextColor( 3); return 0; }
      if (!strcmp(pszCol, "green" ))  { setTextColor( 5); return 0; }
      if (!strcmp(pszCol, "blue"  ))  { setTextColor( 9); return 0; }
      if (!strcmp(pszCol, "yellow"))  { setTextColor( 7); return 0; }
      if (!strcmp(pszCol, "cyan"))    { setTextColor(13); return 0; }
      if (!strcmp(pszCol, "magenta")) { setTextColor(11); return 0; }
      if (!strcmp(pszCol, "black" ))  { setTextColor( 0); return 0; }
      printf("unsupported color: %s\n", pszCol);
      return 1;
   }

   ifcmd (!strncmp(pszCmd, "ver", 3) && strncmp(pszCmd, "veri",4))
   {
      if (chain.useany()) {
         perr("sfk ver does not support input chaining.");
         pinf("you may use \"+then ver filename\" instead.\n");
         return 9;
      }

      ifhelp (nparm < 1 && strcmp(pszCmd, "ver."))
      printx(
         "<help>$sfk version filename\n"
         "$sfk ver -own\n"
         "\n"
         "   print version of a binary file, or of sfk itself.\n"
         "   the provided file is searched for a string with format:\n"
         "\n"
         "      #$$%s:name=sfk,type=base,os=windows,vernum=1.5.1,fix=0,\n"
         "      #title=Swiss File Knife,date=Aug  2 2008,info=major rework$$\\0\n"
         "\n"
         "   $version string fields:\n"
         "    [2] *name    short name, usually similar to the executable name\n"
         "    [3]  type    the type of edition, e.g. base or extended\n"
         "    [4] *os      operating system, e.g. windows, linux-lib6, linux-lib5\n"
         "    [5] *vernum  version number, any number of values separated by dots\n"
         "    [6]  fix     fix level, e.g. a revision or service pack number\n"
         "    [7] *title   long, descriptive name, as printed in a help text\n"
         "    [8] *date    release or compile date\n"
         "    [9]  info    additional infos or remarks, free text string\n"
         "\n"
         "   fields marked with \"*\" are mandatory for a valid version string.\n"
         "   the other fields can be left out, or be empty like \",fix=,\".\n"
         "   if found, contents are printed TAB-separated, #after the filename<def>,\n"
         "   therefore the #[]<def> numbers given above are #output column numbers<def>,\n"
         "   not the location in the input string (which is random anyway).\n"
         "\n"
         "   $options\n"
         "      -verbose   tells a warning if file(s) contain no version.\n"
         "\n"
         "   $examples\n"
         "      #sfk ver dview.exe\n"
         "         print the version of a Depeche View executable.\n"
         "      #sfk ver -own\n"
         "         print sfk's version.\n"
         "      #sfk ver -nosub . .exe +filt -ssep \"\\t\" -sform \"$$-20.20col1\\t$$col5\"\n"
         "         search all .exe files of the current dir for versions,\n"
         "         reformatting the output, with a 20 chars filename limit.\n"
         "\n"
         , "version"
         );
      ehelp;

      if (   (nparm==1 && !strcmp(argv[iDir+0], "-own"))
          || !strcmp(pszCmd, "ver.")
         )
      {
         // tell own version
         // 1.1.7.2 -> 1172 decimal. 1.1.7 -> 1170 decimal.
         // $version:vernum,shortid,full name,type$\0"
         // 0123456789
         StringMap omap;
         if (parseVersion((char*)pszGlblVersion, strlen(pszGlblVersion), omap))
            return -1;

         char *pnam = omap.get("name"  , "");
         char *ptyp = omap.get("type"  , "");
         char *pos  = omap.get("os"    , "");
         char *pnum = omap.get("vernum", "");
         char *pfix = omap.get("fix"   , "");
         char *ptit = omap.get("title" , "");
         char *pdat = omap.get("date"  , "");
         char *pinf = omap.get("info"  , "");

         // create integer from version string
         char *psz1 = pnum;
         long nVer = 0;
         long nDot = 3;
         while (*psz1) {
            char c = *psz1++;
            if (c == '.')
               { nVer = nVer * 10; nDot--; }
            else
               nVer = nVer + (c - '0');
         }
         while (nDot-- > 0)
            nVer = nVer * 10;
   
         printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", argv[0],
            pnam,ptyp,pos,pnum,pfix,ptit,pdat,pinf);

         // return version to shell, for further processing
         return nVer;
      }

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         break;
      }

      int iDirNext = 0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext)) return lRC;
      if (btest) return 0;

      lRC = walkAllTrees(eFunc_Version, lFiles, lDirs, nBytes);

      info.clear();

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "messagebox"))
   {
      if (argc < 4) return 9+perr("missing parameters, specify title and text\n");
      char *pszTitle = argv[2];
      char *pszText  = argv[3];
      MessageBox(0, pszText, pszTitle, MB_OK);
      return 0;
   }
   #endif

   #ifdef WITH_TCP
   ifcmd (strBegins(pszCmd, "httpserv") || strBegins(pszCmd, "webserv"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      printx(
         "<help>$sfk httpserv [-h[elp]]]] [-port=nport] [-rw]\n"
         "\n"
         "   The SFK Instant HTTP Server for easy file transfer.\n"
         "\n"
         "   $default behaviour:\n"
         "   * the CURRENT DIRECTORY is made accessible, without subdirs.\n"
         "   * any kind of directory traversal (.., / etc.) is blocked.\n"
         "   * just ONE CLIENT (browser etc.) can connect at a time.\n"
         "\n"
         "   $options:\n"
         "     -port=n     use other port than default, e.g. -port=81.\n"
         "     -port2=n    alternative port, used if first port fails.\n"
         "                 use -port2=0 to disable alternative port.\n"
         "     -rw         allow write access. displays a single file\n"
         "                 upload form when accessing \"/\".\n"
      // "     -deep       allow paths in filenames, and allow access\n"
      // "                 to files within subdirectories.\n"
         "     -nolist     do not provide a content listing, but change\n"
         "                 any access to \"/\" into \"index.html\".\n"
         "\n"
         "   NOTE: be aware that ANYONE may connect to your server.\n"
         "         this is a primitive, low-performance http server\n"
         "         made for easy transfer of boot strapping files\n"
         "         like the sfk binaries and/or sfk source code.\n"
         "         if you need more power and configurable security,\n"
         "         download and install a real http server like apache.\n"
         "\n"
         "   $see also:\n"
         "     #sfk ftpserv -h<def>    the SFK Instant FTP server.\n"
         #ifdef VFILENET
         "     #sfk wget<def>          a web file download command.\n"
         #endif // VFILENET
         );
      ehelp;

      cs.timeOutMSec = 30000;

      int   iDir    =     2;
      ulong nPort   =    80;
      ulong nPort2  =  8080;
      char *pszPath =   ".";
      bool  bSub    =     0;
      bool  bDeep   =     0;
      bool  bNoList =     0;
      bool  bRW     =     0;

      // no verbose progress indicator at server side.
      cs.noprog = 1;

      for (; iDir < argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-port", &pszParm)) {
            if (!pszParm) return 9;
            nPort  = atol(pszParm);
            nPort2 = 0;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-port2", &pszParm)) {
            if (!pszParm) return 9;
            nPort2 = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-deep")) {
            bDeep = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-nolist")) {
            bNoList = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-rw")) {
            bRW = 1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-timeout", &pszParm)) {
            if (!pszParm) return 9;
            cs.timeOutMSec = atol(pszParm) * 1000;
            continue;
         }
         else
         if (strncmp(argv[iDir], "-", 1)) {
            pszPath = argv[iDir];
            continue;
         }
         else
         if (!setGeneralOption(argv, argc, iDir))
            return 9+perr("unknown option: %s\n", argv[iDir]);
      }

      // http server may act on current dir only.
      if (glblFileSet.beginLayer(false, __LINE__)) return 9;
      glblFileSet.addRootDir(pszPath, __LINE__, false);
      glblFileSet.autoCompleteFileMasks(3);
      glblFileSet.setBaseLayer();
      cs.subdirs = bSub; // in case of list command

      if (btest) return 0;

      httpServ(nPort, nPort2, bDeep, bNoList, bRW);

      bDone = 1;
   }

   ifcmd (strBegins(pszCmd, "ftpserv") || strBegins(pszCmd, "sftserv"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      printx(
         "<help>$sfk ftpserv [-h[elp]]]] [-port=nport] [-rw] [-maxsize=n]\n"
         "\n"
         "   The SFK Instant FTP Server for easy file transfer.\n"
         "\n"
         "   $default behaviour:\n"
         "   * the CURRENT DIRECTORY is made accessible, without subdirs.\n"
         "   * any kind of directory traversal (.., / etc.) is blocked.\n"
         "   * just ONE CLIENT (browser etc.) can connect at a time.\n"
         "   * after 30 seconds of inactivity, the connection is closed.\n"
         "\n"
         "   $options:\n"
         "     -port=n     use other port than default, e.g. -port=10000.\n"
         "     -port2=n    alternative port, used if first port fails.\n"
         "                 use -port2=0 to disable alternative port.\n"
         "     -pw=x       require primitive authentication, i.e. client\n"
         "                 must provide password x to login. you may also\n"
         "                 set an environment variable like:\n"
         #ifdef _WIN32
         "                    SET SFK_FTP_PW=mypassword\n"
         #else
         "                    export SFK_FTP_PW=mypassword\n"
         #endif
         "     -rw         allow read+write access. default is readonly.\n"
         "     -maxsize=n  increment size limit per file write to n mbytes.\n"
         "     -timeout=n  set timeout to n seconds.\n"
         "     -noclone    do not try to replicate time stamps on a file\n"
         "                 transmission from an sfk ftp client.\n"
         "     -verbose    list the transmitted ftp commands.\n"
         "                 helpful to get more infos in case of errors.\n"
         "     -quiet[=2]  print less or no status informations.\n"
         "     -deep       ALLOW PATHS IN FILENAMES. for example, the client\n"
         "                 may say \"put the/sub/dir/document.txt\".\n"
         "     -run        allow client to execute system commands.\n"
         "                 requires -pw option being set as well.\n"
         "                 requires an sfk ftp client to run commands.\n"
         "     -runpw=x    require authentication only for run commands.\n"
         "                 can also be set via the environment:\n"
         #ifdef _WIN32
         "                    SET SFK_FTP_RUNPW=mypassword\n"
         #else
         "                    export SFK_FTP_RUNPW=mypassword\n"
         #endif
         "\n"
         "   NOTE: be aware that ANYONE may connect to your server.\n"
         "         with -rw specified, ANYONE may also write large files.\n"
         "         if this is a problem, do NOT use sfk ftpserv, but download\n"
         "         and install a full-scale ftp server like filezilla.\n"
         "\n"
         "   $aliases:\n"
         "      sfk sftserv ...  = the same as sfk ftpserv, but using port 2121.\n"
         "\n"
         "   $problems and solutions:\n"
         "   if you try to login to the server using a regular ftp client, but\n"
         "   you cannot connect and/or transfer files, then usually there is a\n"
         "   firewall or network configuration incompatible to normal FTP.\n"
         "   - if your ftp client provides a command \"passive\", then type that,\n"
         "     press enter, and then try the usual commands like dir, get or put.\n"
         "   - whenever possible, use the SFK FTP client to connect to an SFK FTP\n"
         "     server. client and server will then use a different protocol (SFT)\n"
         "     with which you often can transfer files even if normal FTP fails.\n"
         "   - Windows Vista, Windows 7: the firewall may stop sfk to sfk file\n"
         "     transfer on the default port 21, with error ECONNRESET, probably\n"
         "     because sfk uses a different protocol. You then have to use a\n"
         "     different port, e.g. -port=5000 or use Windows' \"ftp\" command.\n"
         "\n"
         "   $see also:\n"
         "     -  type \"#sfk ftp<def>\" for the SFK FTP client. when it connects to an\n"
         "        SFK FTP server, you get easier connectivity and more features.\n"
         "     -  type \"#sfk httpserv -h<def>\" for the SFK Instant HTTP Server.\n"
         );
      ehelp;

      cs.timeOutMSec = 30000;

      int   iDir    =     2;
      ulong nPort   =  strBegins(pszCmd, "sftserv") ? 2121 : 21;
      ulong nPort2  =  2121;
      bool  bRW     =     0;
      bool  bRun    =     0;
      char *pszPath =   ".";
      bool  bDeep   =     0;
      char *pszAuthPW =   0;
      char *pszRunPW  =   0;
      bool  bSub    =     0;

      // no verbose progress indicator at server side.
      cs.noprog = 1;

      for (; iDir < argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-port", &pszParm)) {
            if (!pszParm) return 9;
            nPort  = atol(pszParm);
            nPort2 = 0;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-port2", &pszParm)) {
            if (!pszParm) return 9;
            nPort2 = atol(pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-pw", &pszParm)) {
            if (!pszParm) return 9+perr("-pw requires a parameter.\n");
            pszAuthPW = pszParm;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-runpw", &pszParm)) {
            if (!pszParm) return 9+perr("-runpw requires a parameter.\n");
            pszRunPW = pszParm;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-maxsize", &pszParm)) {
            if (!pszParm) return 9;
            nGlblTCPMaxSizeMB = atol(pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-timeout", &pszParm)) {
            if (!pszParm) return 9;
            cs.timeOutMSec = atol(pszParm) * 1000;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-rw")) {
            bRW = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-run")) {
            bRun = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-deep")) {
            bDeep = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-sub")) {  // experimental
            bSub = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-noclone")) {
            cs.noclone = 1;
            continue;
         }
         else
         if (strncmp(argv[iDir], "-", 1)) {
            pszPath = argv[iDir];
            continue;
         }
         else
         if (!setGeneralOption(argv, argc, iDir))
            return 9+perr("unknown option: %s\n", argv[iDir]);
      }
      if (!pszPath)
         return 9+perr("missing path.\n");
      if (!pszAuthPW && getenv("SFK_FTP_PW")) {
         pszAuthPW = getenv("SFK_FTP_PW");
         printf("[using SFK_FTP_PW for authentication]\n");
      }
      if (!pszAuthPW && getenv("SFK_FTP_RUNPW")) {
         pszRunPW = getenv("SFK_FTP_RUNPW");
         printf("[using SFK_FTP_RUNPW for run authentication]\n");
      }
      if (bRun && !pszAuthPW && !pszRunPW)
         return 9+perr("-run requires -pw or -runpw being set.\n");

      // ftp server may act on current dir only.
      if (glblFileSet.beginLayer(false, __LINE__)) return 9;
      glblFileSet.addRootDir(pszPath, __LINE__, false);
      glblFileSet.autoCompleteFileMasks(3);
      glblFileSet.setBaseLayer();
      cs.subdirs = bSub; // in case of list command

      if (btest) return 0;

      ftpServ(nPort, bRW, bRun, pszPath, pszAuthPW, pszRunPW, bDeep, nPort2);

      bDone = 1;
   }

   regtest("ftp 127.0.0.1:5000");
   regtest("ftp 127.0.0.1:5000 get xfile");

   ifcmd (!strcmp(pszCmd, "ftp") || !strcmp(pszCmd, "sft"))
   {
      ifhelp (nparm < 1)
      printx(
         "<help>$sfk ftp host[:port] [options] [command [parms]]\n"
         "\n"
         "   The SFK Simple Anonymous FTP Client.\n"
         "\n"
         "   $commands\n"
         "      put x     send a single file with name x\n"
         "      get x     receive a single file with name x\n"
         "      mput x    send multiple files of the current directory\n"
         "                having x in their filename\n"
         "      mget x    receive multiple files from the ftp server\n"
         "                having x in their filename\n"
         "      dir       list the remote directory\n"
         "      cd x      change into remote directory x\n"
         "      !mycmd    execute local command mycmd\n"
         "      run cmd   run remote command (only with sfk ftp server)\n"
         "      bye       exit\n"
         "\n"
         "   $options\n"
         "      -verbose  list the transmitted ftp commands.\n"
         "                helpful to get more infos in case of errors.\n"
         "      -quiet    produce less verbose output.\n"
         "      -noprog   no progress indicator during transfers.\n"
         "      -update   transmit only changed files. this option is experimental\n"
         "                and may or may not work, depending on the server software,\n"
         "                server settings (UTC vs. local time) and time zone.\n"
         "      -new      the same as -update, only shorter to type.\n"
         "      -pw=x     or -pw x sends an authentication password x.\n"
         "                you may also set an environment variable like:\n"
         #ifdef _WIN32
         "                   SET SFK_FTP_PW=mypassword\n"
         #else
         "                   export SFK_FTP_PW=mypassword\n"
         #endif
         "     -noclone   do not try to replicate time stamps on a file\n"
         "                transmission from an sfk ftp server.\n"
      // "      -all      mput, mget: force send/receive of all files,\n"
      // "                not only those that changed.\n"
         "\n"
         "   $aliases\n"
         "      sfk sft ...   = the same as sfk ftp, but using port 2121.\n"
         "\n"
         "   $automatic IP expansion\n"
         "      if you are in the same subnet as the target host,\n"
         "      you may supply only the IP number's last part, e.g.:\n"
         "         sfk ftp 23 ... == sfk ftp 192.168.1.23 ...\n"
         "      this feature may or may not work, depending on your\n"
         "      operating system and number of network interfaces.\n"
         "\n"
         "   $examples\n"
         "      #sfk ftp farpc put test.zip\n"
         "         send test.zip to farpc\n"
         "      #sfk ftp 192.168.1.99:30199 get test.zip\n"
         "         receive test.zip from 192.168.1.99 port 30199\n"
         "      #sfk ftp farpc mput .cpp\n"
         "         send all .cpp files of the local dir to farpc.\n"
         "         subfolder contents are NOT included.\n"
         "      #sfk ftp farpc mget %c\n"
         "         receive all files from farpc's directory,\n"
         "         overwriting everything in the local directory.\n"
         "      #sfk ftp hostname\n"
         "         enter interactive mode, in which you can type\n"
         "         the above commands directly. for example,\n"
         #ifdef _WIN32
         "            !dir runs the command \"dir\" locally.\n"
         #else
         "            !ls runs the command \"ls\" locally.\n"
         #endif
         "\n"
         ,glblWildChar);
    printx(
         "   $IF connected with an sfk ftp server:\n"
         "\n"
         "      #sfk ftp farpc get the\\sub\\dir\\doc.txt\n"
         "         if sfk ftpserv is running with the \"-deep\" option,\n"
         "         direct access to files with full paths is allowed.\n"
         "         all required directories are created automatically.\n"
         "         the deep mode cannot be used with mget, mput and dir.\n"
         "\n"
         "      #sfk sel mydir .txt +ftp farpc mput -update\n"
         "         send all .txt files within mydir that changed since\n"
         "         the last transmission to farpc. requires option -deep\n"
         "         at server side to allow paths.\n"
         "\n"
         "      #sfk sel mydir .txt +sft farpc mput -update\n"
         "         same as above, but using port 2121 against an sfk\n"
         "         server started like \"sfk sftserv -rw -deep\".\n"
         "         recommended to avoid connection problems\n"
         "         that may occur on ftp default port 21.\n"
         "\n"
         "      #sfk filter filelist.txt +ftp farpc mget mydir\n"
         "         create a list with filenames, download the files listed\n"
         "         therein from server farpc into a folder \"mydir\".\n"
         "         may require option -deep at server side to allow paths.\n"
         "\n"
         "      #sfk ftp farpc -pw mypw run \"sh myscript.sh >tmp1.txt 2>&1\"\n"
         "         execute a command on the remote server, redirecting all\n"
         "         output into a file tmp1.txt. requires an sfk ftp server\n"
         "         with option -run, AND -pw authentication on both sides.\n"
         "\n"
         "   $problems and solutions:\n"
         "   - Windows Vista, Windows 7: if the firewall stops sfk to sfk\n"
         "     file transfer on port 21 with ECONNRESET, use a different\n"
         "     port, e.g. -port=5000. read more in the sfk ftpserv help.\n"
         "\n"
         "   $see also:\n"
         "      #sfk ftpserv -help\n"
         "\n"
         "NOTE: existing files are overwritten <err>without asking back<def>.\n"
         "      Make sure that ftp server and client are running\n"
         "      in the correct directories, especially before mput/mget.\n"
         );
      ehelp;

      // collect instant command here
      szLineBuf2[0]   = '\0';
      nGlblTCPMaxSizeMB = 0; // no size limit
      ulong nPort     = !strcmp(pszCmd, "sft") ? 2121 : 21;
      cs.subdirs      = 0; // in case of mput
      char *pszHost   = 0;
      long nstate     = 1;
      char *pszAuthPW = 0;

      bool bChained = chain.usefiles || chain.usedata;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-pw", &pszParm)) {
            if (!pszParm) return 9+perr("-pw requires a parameter.\n");
            pszAuthPW = pszParm;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-up") || !strcmp(argv[iDir], "-new"))
         {
            cs.ftpupdate = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-all")) {
            cs.ftpall = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-noclone")) {
            cs.noclone = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         char *pparm = argv[iDir];
         switch (nstate++) {
            case 1: {
               // first parm must be host:port
               pszHost = strdup(pparm);
               char *psz = strchr(pszHost, ':');
               if (psz) {
                  *psz++ = '\0';
                  nPort = atol(psz);
               }
               // ftp client may act on current dir only.
               if (glblFileSet.beginLayer(false, __LINE__)) return 9;
               glblFileSet.addRootDir(".", __LINE__, false);
               glblFileSet.autoCompleteFileMasks(3);
               glblFileSet.setBaseLayer();
               continue;
            }
            default: {
               // continue to collect instant command
               if (szLineBuf2[0]) strcat(szLineBuf2, " ");
               strcat(szLineBuf2, pparm);
            }
         }
      }

      if (!pszAuthPW && getenv("SFK_FTP_PW")) {
         pszAuthPW = getenv("SFK_FTP_PW");
         if (!cs.quiet)
            printf("[using SFK_FTP_PW for authentication]\n");
      }

      if (btest) {
         if (pszHost) delete [] pszHost;
         return 0;
      }

      // run in interactive or direct mode
      if (szLineBuf2[0]) {
         // direct mode
         ftpClient(pszHost, nPort, szLineBuf2, pszAuthPW, bChained);
      } else {
         // interactive: verbose by default
         if (!cs.quiet) cs.verbose = 1;
         ftpClient(pszHost, nPort, 0, pszAuthPW, bChained);
      }

      // cleanup
      if (pszHost) delete [] pszHost;

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }
   #endif // WITH_TCP

   // internal, experimental
   if (!strcmp(pszCmd, "checkdisk"))
   {
      if (argc < 4) { 
         printx("<help>$sfk checkdisk volumepath rangesizemb|all\n"
                "\n"
                "   test the disk or stick specified by volumepath if it is reliable. sfk will write\n"
                "   100 test files, filling up rangesize mbytes, re-read them, and check for errors.\n"
                "   after that, test files without errors are removed, but those with errors are kept,\n"
                "   to block damaged parts of the media from being reused.\n"
                "\n"
                "   NOTE: detection of errors does NOT always mean that the MEDIA itself is corrupted.\n"
                "         the reason may as well lie within the USB electronic of your PC, or within\n"
                "         the disk drive controller. for USB sticks, always test them at least with\n"
                "         two different PC's.\n"
                "\n"
                "      #sfk checkdisk E:\\ all\n"
                "         checks all space available on drive E:\\, e.g. USB-stick.\n"
                "      #sfk checkdisk G:\\ 1950\n"
                "         checks 1950 mb on drive G:\\\n"
               );
         return 0;
      }
      char *pszVolPath = argv[2];
      char *pszRngSize = argv[3];

      long nRangeMB = -1;
      if (strcmp(pszRngSize, "all"))
         if (!(nRangeMB = atol(pszRngSize)))
            return 9+perr("supply no. of mbytes to check, or \"all\".\n");

      lRC = checkDisk(pszVolPath, nRangeMB);

      bDone = 1;
   }

   regtest("hexdump -showle -wide -nohead xdir .dat1 .dat2");
   regtest("hexdump -lean -pure -dir xdir -file .dat");
   regtest("hexdump -hexsrc xfile1");
   regtest("hexdump -decsrc xfile1 xfile2");
   regtest("hexdump -flat xfile1");
   regtest("tcpdump 5000 -forward xhost:xport -timeout 20000");

   bool btcpdump = 0;
   bool budpdump = 0;
   bool bnetdump = 0;

   ifcmd (   !strcmp(pszCmd, "hexdump")
          || !strcmp(pszCmd, "tcpdump")
          || !strcmp(pszCmd, "udpdump")
         )
   {
      bool btcp = btcpdump = !strcmp(pszCmd, "tcpdump");
      bool budp = budpdump = !strcmp(pszCmd, "udpdump");
      bool bnet = bnetdump = btcp || budp;

      ifhelp ((argc < 3) && (bnet || !chain.usefiles))

      // if dumping all help text, run three passes
      for (long ihelp=0; ihelp<3; ihelp++) {

      // create different help pages for sfk ask:
      if (bhelp)
         switch (ihelp) {
            case 0 : btcp=0; budp=0; bnet=0; break; // hexdump help
            case 1 : btcp=1; budp=0; bnet=1; break; // tcpdump help
            case 2 : btcp=0; budp=1; bnet=1; break; // udpdump help
         }

      if (!bnet)
      printx("<help>$sfk hexdump [-showle] [-wide] [...] dir .ext1 .ext2 .ext3\n"
             "\n"
             "   create human-readable hexdump of binary file(s).\n"
            );
      else
      if (budp)
      printx("<help>$sfk udpdump [-showle] [...] port\n"
             "\n"
             "   create human-readable hexdump of UDP socket input,\n"
             "   for debugging of UDP network applications.\n"
            );
      else
      printx("<help>$sfk tcpdump [-showle] [...] port [-forward host:port] [...]\n"
             "\n"
             "   create human-readable hexdump of tcp socket input, and optionally\n"
             "   dump a tcp conversation, for debugging of web applications.\n"
            );

      printx("\n"
             "   $options:\n"
             "      -showle  highlights line ending characters CR and LF.\n"
             "      -wide    dumps 32 input bytes per line.\n"
             "      -lean    dumps 16 input bytes per line.\n"
             );
      if (bnet) {
      if (budp)
      printx("      -echo    echo received packets back to sender.\n");
      else
      printx("      -forward specifies a host and port to which to forward\n"
             "               incoming requests, to dump a tcp conversation.\n"
             "      -timeout number of milliseconds to wait after last transfer\n"
             "               until connections are closed. default is 60000,\n"
             "               or 10000 if http is detected.\n");
      } else {
      printx("      -nofile  or -nofilenames does not list the filename(s).\n");
      }

      printx("      -pure    lists flat hex characters:\n"
             "               #53464B2D544553540D0A\n"
             "      -hexsrc  lists hex comma separated values:\n"
             "               #0x53,0x46,0x4B,0x2D,0x54,0x45,0x53,0x54,0x0D,0x0A,\n"
             "      -decsrc  lists decimal comma separated values:\n"
             "               #83,70,75,45,84,69,83,84,13,10,\n");

      if (!bnet)
      printx("      -offlen n1 n2   dump from offset n1 only n2 bytes.\n");

      if (bnet)
      printx("      -flat    no hexdump at all, dump characters as they come.\n");

      if (budp)
      printx("      -nohead  does not show the \"received n bytes\" message.\n");

      if (btcp)
      printx("\n"
             "   $see also:\n"
             "     #sfk udpdump   - dump incoming UDP packets.\n"
             "\n"
             "   $example:\n"
             "     #sfk tcpdump 9000 -showle -forward www.google.com:80 -timeout 2000\n"
             "        then connect with your browser to localhost:9000 and see\n"
             "        the http requests and replies which are passing through.\n"
             "        small timeouts are recommended to trace http communication,\n"
             "        as the web browser may wait until the connection is closed.\n"
             "\n"
             "     #sfk tcpdump 5000 -flat -timeout 2000 -forward myproxy:8000\n"
             "        show plaintext communication to anywhere via a proxy server.\n"
             "        to connect this way, you MUST connect to sfk as a proxy:\n"
             "        in Firefox, open tools/options/advanced/network/settings, set\n"
             "        manual proxy configuration, http proxy \"localhost\" port 5000.\n"
             "        then type some external servername, e.g. \"http://google.com\"\n"
             "        in your browser. In this example, is expected that a proxy\n"
             "        machine \"myproxy\" exists within your local network.\n"
             "        After the test, disable the proxy setting in your browser.\n"
             );
      else
      if (budp)
      printx("\n"
             "   $example:\n"
             "     #sfk udpdump 5000\n"
             "        waits on port 5000 for incoming udp packages.\n"
             );
      else
      printx("\n"
             "  $examples:\n"
             "    #sfk hexdump -offlen 4221566976 96 part1.avi\n"
             "        dumps 96 bytes from offset 4221566976 within part1.avi\n"
             "\n"
             "    #sfk hexdump -offlen 0xFBA00000 0x60 part1.avi\n"
             "        the same as above, but using hexadecimal numbers\n"
             );

      if (bhelp) { printx("\n"); } else break; }
      // end of three passes if dumping all help text

      ehelp;

      // autoselect hex dump width by console width
      if (bGlblConsColumnsSet && (nGlblConsColumns >= 120))
         bGlblHexDumpWide = 1;

      cs.timeOutMSec = 60000;
      cs.timeOutAutoSelect = 1;

      long nPort = -1;
      char *pszForward = 0;
      long nForward = 0;
      long nTimeout = 60000;
      int  iChainNext = 0;
      bool bEcho = 0;

      for (; iDir < argc; iDir++)
      {
         char *pszParm = 0;
         if (   !strcmp(argv[iDir], "-show-line-endings")
             || !strcmp(argv[iDir], "-showle")
            )
         {
            bGlblHexdumpShowLE = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-wide")) {
            bGlblHexDumpWide = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-lean") || !strcmp(argv[iDir], "-narrow"))
         {
            bGlblHexDumpWide = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-pure"))   { nGlblHexDumpForm=1; continue; }
         else
         if (!strcmp(argv[iDir], "-hexsrc")) { nGlblHexDumpForm=2; continue; }
         else
         if (!strcmp(argv[iDir], "-decsrc")) { nGlblHexDumpForm=3; continue; }
         else
         if (!strcmp(argv[iDir], "-flat")) { nGlblHexDumpForm=4; continue; }
         else
         if (haveParmOption(argv, argc, iDir, "-forward", &pszParm)) {
            if (!pszParm) return 9;
            strcopy(szLineBuf, pszParm);
            pszForward = szLineBuf;
            char *psz = strrchr(pszForward, ':');
            if (!psz) return 9+perr("missing port, specify -forward host:port\n");
            *psz++ = '\0';
            nForward = atol(psz);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-timeout", &pszParm)) {
            if (!pszParm) return 9;
            cs.timeOutMSec = atol(pszParm);
            cs.timeOutAutoSelect = 0;
            if (cs.timeOutMSec < 200) {
               printx("<warn>note: timeout set to %ld milliseconds (%f seconds).<def>\n", cs.timeOutMSec, (double)cs.timeOutMSec / 1000.0);
            }
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-offlen", &pszParm))
         {
            if (!pszParm) return 9;

            nGlblHexDumpOff = numFromSizeStr(pszParm,"-offlen offset");
            if (nGlblHexDumpOff < 0) return 9;

            if (iDir >= argc) return 9+perr("supply values like -offlen 10000 100");
            char *pszlen = argv[++iDir];
            nGlblHexDumpLen = numFromSizeStr(pszlen,"-offlen length");
            if (nGlblHexDumpLen < 0) return 9;

            continue;
         }
         else
         if (   haveParmOption(argv, argc, iDir, "-off"   , &pszParm)
             || haveParmOption(argv, argc, iDir, "-offset", &pszParm)
            )
         {
            if (!pszParm) return 9;
            nGlblHexDumpOff = numFromSizeStr(pszParm, "-offset");
            if (nGlblHexDumpOff < 0) return 9;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-echo")) {
            bEcho = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         if (bnetdump && (nPort == -1)) {
            nPort = atol(argv[iDir]);
            continue;
         }

         break; // fall through to non-option processing
      }

      if (!strcmp(pszCmd, "tcpdump")) {
         if (nPort == -1)
            return 9+perr("specify port number to listen on.\n");
         if (btest) return 0;
         // get pszForward out of szLineBuf
         if (pszForward)
            pszForward = strdup(pszForward);
         tcpAnyServ(nPort, pszForward, nForward);
         if (pszForward)
            delete [] pszForward;
      }
      else
      if (!strcmp(pszCmd, "udpdump")) {
         if (nPort == -1)
            return 9+perr("specify port number to listen on.\n");
         if (btest) return 0;
         // get pszForward out of szLineBuf
         if (pszForward)
            pszForward = strdup(pszForward);
         udpAnyServ(nPort, pszForward, nForward, bEcho);
         if (pszForward)
            delete [] pszForward;
      } else {
         if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iChainNext)) return lRC;
         if (btest) return 0;
         lRC = walkAllTrees(eFunc_Hexdump, lFiles, lDirs, nBytes);
      }

      if (chain.coldata) {
         STEP_CHAIN(iChainNext, 1);
      } else {
         STEP_CHAIN(iChainNext, 0);
      }

      bDone = 1;
   }

   // not yet official
   if (!strcmp(pszCmd, "sendudp") || !strcmp(pszCmd, "udpsend"))
   {
      // if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      if (nparm < 1) {
      printx("<help>$sfk sendudp host port [options] data [data2] [...]\n"
             "\n"
             "   send a UDP message, and optionally receive replies.\n"
             "\n"
             "   $options:\n"
             "      -listen        wait for a single reply, and dump it.\n"
             "      -listen=n      wait for so many replies and dump them.\n"
             "      -listenall     receive endless.\n"
             "      -timeout=n     wait up to n msec for replies.\n"
             "      -wide, -lean   etc. change hex dump output format.\n"
             "                     for details, type \"sfk hexdump\"\n"
             "\n"
             "   $input data format:\n"
             "      0x123456       a hex string which is converted to binary\n"
             "      foo            any other plain text is sent as is, but\n"
             "                     zero termination is NOT done automatically.\n"
             "\n"
             "      all given data fragments are joined into one large block.\n"
             "      how long the block can be is system dependent, but it must\n"
             "      always stay below 2000 bytes.\n"
             "\n"
             "   $examples\n"
             "\n"
             "      #sfk udpsend localhost 12345 -listen hello 0x00\n"
             "         send \"hello\" followed by a zero byte to localhost\n"
             "         on port 12345, then receive a single reply.\n"
             "\n"
             );
      return 9;
      }

      int ndstport = -1;
      int nownport = -1;
      long  nlisten = 0;
      char  szDstIP[200+10];
      uchar abMsg[2000+100];
      long  nMsg = 0;
      long  nMsgMax = sizeof(abMsg)-100;
      char szBuf[10];
      num   nTimeout = 0;

      mclear(szDstIP);
      mclear(abMsg);
      mclear(szBuf);

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-replyport", &pszParm)) {
            if (!pszParm) return 9;
            nownport = atol(pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-timeout", &pszParm)) {
            if (!pszParm) return 9;
            nTimeout = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-listen")) {
            nlisten = 1;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-listen=")) {
            nlisten = atol(argv[iDir]+8);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-listenall")) {
            nlisten = -1;
            continue;
         }
         else
         if (   !strcmp(argv[iDir], "-show-line-endings")
             || !strcmp(argv[iDir], "-showle")
            )
         {
            bGlblHexdumpShowLE = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-wide")) {
            bGlblHexDumpWide = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-lean") || !strcmp(argv[iDir], "-narrow"))
         {
            bGlblHexDumpWide = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-pure"))   { nGlblHexDumpForm=1; continue; }
         else
         if (!strcmp(argv[iDir], "-hexsrc")) { nGlblHexDumpForm=2; continue; }
         else
         if (!strcmp(argv[iDir], "-decsrc")) { nGlblHexDumpForm=3; continue; }
         else
         if (!strcmp(argv[iDir], "-flat")) { nGlblHexDumpForm=4; continue; }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:
         if (!szDstIP[0])
            { strcopy(szDstIP, argv[iDir]); continue; }
         if (ndstport < 0)
            { ndstport = atol(argv[iDir]); continue; }

         // join data parts
         char *ppart = argv[iDir];
         if (strBegins(ppart, "0x")) {
            char *pszHex = ppart+2;
            while (*pszHex) {
               szBuf[0] = *pszHex++;
               if (!*pszHex) return 9+perr("wrong hex format: %s\n",ppart);
               szBuf[1] = *pszHex++;
               if (!isxdigit(szBuf[0])) return 9+perr("wrong hex format: %s\n",ppart);
               if (!isxdigit(szBuf[1])) return 9+perr("wrong hex format: %s\n",ppart);
               abMsg[nMsg++] = (uchar)strtol(szBuf, 0, 0x10);
               if (nMsg > nMsgMax) return 9+perr("data too long");
            }
         } else {
            long nlen = strlen(ppart);
            if (nMsg+nlen > nMsgMax) return 9+perr("data too long");
            memcpy(abMsg+nMsg, ppart, nlen);
            nMsg += nlen;
         }
      }

      udpClient(szDstIP, ndstport, nlisten, nownport, abMsg, nMsg, nTimeout);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (strBegins(pszCmd, "ip") || strBegins(pszCmd, "ownip"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported
      
      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      printx("<help>$sfk ip [-help], sfk ownips [-help]\n"
             "\n"
             "   list the current machines ip address(es).\n"
             "\n"
             );
      ehelp;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      int   nnum  = 0;
      char *plist = ownIPList(nnum, 0, "\t");
 
      chain.print("%s", plist);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "split"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 2)
      printx("<help>$sfk split partsize inputfile [outputfilebase] [-nov[erify]]]]\n"
             "\n"
             "   reads and splits inputfile into output files of specified size.\n"
             "   if output files exist already, split asks if it may overwrite;\n"
             "   specify -yes to overwrite outputs without asking.\n"
             "\n"
             "   partsize syntax:\n"
             "       100000b  ,  100k        = 100000 bytes\n"
             "       2000000k , 2000m , 2g   = 2 giga-bytes\n"
             "\n"
             "   if outputfilebase is omitted, outputfilenames will be:\n"
             "       inputfile.part1\n"
             "       inputfile.part2\n"
             "       inputfile.part3\n"
             "       ...\n"
             "   if outputfilebase is given, .part1 is appended to this.\n"
             "\n"
             "      #sfk split 2g c:\\bigfish.avi d:\\transfer\\easy.avi\n"
             "         splits bigfish.avi into easy.avi.part1, .part2 etc.\n"
             "\n"
             "   to rejoin the files, use the sfk join command:\n"
             "\n"
             "      #sfk join d:\\transfer\\easy.avi.part1 e:\\full.avi\n"
             "         joins easy.avi.part1, .part2 etc. into full.avi\n"
            );
      ehelp;

      // default working buffer: 100 mb
      num nWorkBufSize   = 100 * 1000000;
      char *pszSplitSize = 0;
      char *pszSrc       = 0;
      char *pszDstBase   = 0;
      bool  bVerify      = 1;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-buffer", &pszParm)) {
            if (!pszParm) return 9;
            nWorkBufSize = numFromSizeStr(pszParm, "-buffer");
            if (nWorkBufSize <= 0) return 9;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nov", 4)) {
            bVerify = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }

         // process non-option keywords:
         if (!pszSplitSize) { pszSplitSize = argv[iDir]; continue; }
         if (!pszSrc      ) { pszSrc       = argv[iDir]; continue; }
         if (!pszDstBase  ) {
            pszDstBase = argv[iDir];
            if (isDir(pszDstBase))
               return 9+perr("supply a full output filename, not just a directory name.\n");
            continue; 
         }

         return 9+perr("unexpected parameter: \"%s\" (4)\n",argv[iDir]);
      }

      if (!pszSplitSize) return 9+perr("missing split size\n");
      if (!pszSrc      ) return 9+perr("missing input filename\n");

      uchar *pWorkBuf = new uchar[nWorkBufSize+1000];
      if (!pWorkBuf) return 9+perr("out of memory, cannot allocate working buffer.\n");

      // NO RETURN W/O DELETE FROM HERE

      num nSplitSize = numFromSizeStr(pszSplitSize);
      if (nSplitSize <= 0) {
         delete [] pWorkBuf;
         return 9+perr("supply a size info like 1048100b 500k 2000m or 2g and a filename.\n");
      }

      printf("splitting into files of %s bytes each.\n", numtoa(nSplitSize));

      num  nRemain = getFileSize(pszSrc);
      if (nRemain <= 0) {
         delete [] pWorkBuf;
         return 9+perr("no or empty input file: %s\n", pszSrc);
      }

      FILE *fin = fopen(pszSrc, "rb");
      if (!fin) {
         delete [] pWorkBuf;
         return 9+perr("unable to open input file: %s\n", pszSrc);
      }

      if (!pszDstBase)
           pszDstBase = pszSrc;

      long nout = 1;
      bool ball = cs.yes;
      num  ntotal = 0;

      SFKMD5 md5;

      bool bbail=0;
      while (!bbail && (nRemain > 0))
      {
         // open next output file
         sprintf(szLineBuf, "%s.part%ld", pszDstBase, nout++);
         char *pszDst = szLineBuf;

         if (!ball && fileExists(pszDst))
         {
            while (1) {
               printf("%s exists, overwrite? (yes/no/all) ",pszDst);
               fflush(stdout);
               char nReply = getYNAchar();
               if (nReply == 'y') break;
               if (nReply == 'a') { ball=1; break; }
               if (nReply == 'n') { delete [] pWorkBuf; fclose(fin); return 5; }
            }
         }
 
         FILE *fout = fopen(pszDst, "wb");
         if (!fout) {
            delete [] pWorkBuf;
            fclose(fin); return 9+perr("unable to write: %s\n", pszDst); 
         }
          
         // copy binary part until splitsize is reached
         num nLocRemain = nSplitSize;
         while (nLocRemain > 0) 
         {
            num nTotalMB = ntotal / 1000000;
            printf("writing %s, %s mb done overall \r", pszDst, numtoa(nTotalMB));

            long nMaxRead = nWorkBufSize;
            if (nMaxRead > nLocRemain)
                nMaxRead = (long)nLocRemain;
            long nread = myfread(pWorkBuf, nMaxRead, fin);
            if (nread <= 0) {
               bbail = 1;
               break; // EOF on input
            }

            long nwrite = (long)myfwrite(pWorkBuf, nread, fout);
            if (nwrite != nread) {
               delete [] pWorkBuf;
               fclose(fout); fclose(fin);
               return 9+esys("fwrite", "error while writing: %s (r=%ld w=%ld)\n", pszDst, nread, nwrite);
            }

            md5.update(pWorkBuf, nread);

            nLocRemain -= nread;
            nRemain -= nread;
            ntotal += nread;
         }
 
         // close output file
         fclose(fout);
      }
 
      fclose(fin);

      delete [] pWorkBuf;

      // NO RETURN W/O DELETE UNTIl HERE

      // in case there are superfluous old output files from previous runs:
      sprintf(szLineBuf, "%s.part%ld", pszSrc, nout);
      char *pszDst = szLineBuf;
      if (fileExists(pszDst))
      {
         while (!ball) {
            printf("%s exists, overwrite? (yes/no/all) ",pszDst);
            fflush(stdout);
            char nReply = getYNAchar();
            if (nReply == 'y') break;
            if (nReply == 'a') { ball=1; break; }
            if (nReply == 'n') { fclose(fin); return 5; }
         }
         // then cleanup at least the first one.
         remove(pszDst);
      }

      char szMD5Write[100];

      printf("%s split into %ld files, %s total bytes.\n", pszSrc, nout-1, numtoa(ntotal));
      uchar *pmd5 = md5.digest();
      for (long i=0; i<16; i++)
         sprintf(&szMD5Write[i*2], "%02x", pmd5[i]);
      printf("md5 = %s   %s\n", szMD5Write, bVerify ? "[write ]":"");

      if (bVerify) {
         // run verify of output:
         sprintf(szLineBuf2, "%s.part1", pszDstBase, nout++);
         if (execJoin(szLineBuf2, 0, 1, szMD5Write))
            return 9+perr("verification of output failed! splitting is incomplete.\n");
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "join"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("<help>$sfk join inputfile.part1 [outputfilebase] [-test]\n"
             "\n"
             "   join many input files into one output file.\n"
             "\n"
             "   if outputfilebase is omitted, outputfilename is just\n"
             "   like inputfile, but without the \".part1\" extension.\n"
             "\n"
             "   $options\n"
             "      -test  does not really join the files, but reads all\n"
             "             input files, telling the overall md5 checksum.\n"
             "             join -test is recommended after every \"sfk split\"\n"
             "             command, to verify if the splitted files are ok\n"
             "             and can be rejoined.\n"
             "\n"
             "      -force if the output file exists already, overwrite it\n"
             "             without asking back.\n"
             "\n"
             "   $examples\n"
             "      #sfk join d:\\transfer\\easy.avi.part1 e:\\full.avi\n"
             "         joins easy.avi.part1, .part2 etc. into full.avi\n"
             "\n"
             "      #sfk join -test d:\\transfer\\easy.avi.part1\n"
             "         simulates joining (does not write any output file),\n"
             "         and tells if the input files are ok, by checksum.\n"
            );
      ehelp;

      char *pszFirstInput = 0;
      char *pszDst        = 0;
      bool bTest = 0;

      for (; iDir < argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-test")) {
            bTest = 1;
            continue;
         }

         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unexpected option: %s\n",argv[iDir]);
         }

         // first non-option parm
         if (!pszFirstInput) { pszFirstInput = argv[iDir]; continue; }
         if (!pszDst       ) { pszDst        = argv[iDir]; continue; }

         return 9+perr("unexpected parameter: \"%s\" (5)\n",argv[iDir]);
      }

      if (execJoin(pszFirstInput, pszDst, bTest, 0))
         return 9;

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "partcopy") || !strcmp(pszCmd, "copypart"))
   {
      ifhelp (nparm < 4)
      printx("<help>$sfk partcopy infile offset length outfile [offset2] [-yes]\n"
             "$sfk partcopy infile -fromto startoffset endoffset outfile ...\n"
             "\n"
             "   reads length bytes from infile at specified offset,\n"
             "   writing them into another file. if offset2 is specified,\n"
             "   outfile is not created, but the bytes are used to overwrite\n"
             "   other bytes within the output file.\n"
             "\n"
             "   by default, the command $simulates<def>, checking file lengths\n"
             "   but not copying any data. add -yes to really copy contents.\n"
             "\n"
             "   length syntax:\n"
             "       100000   ,  100k        = 100000 bytes\n"
             "       2000000k , 2000m , 2g   = 2 giga-bytes\n"
             "\n"
             "   $options\n"
             "      -quiet    do not print number of copied bytes.\n"
             "      -fromto   use this if you don't want to specify offset\n"
             "                and length for the input, but a start and end\n"
             "                offset (with length being end minus start).\n"
             "\n"
             "   $see also\n"
             "      $sfk hexdump<def>   -offlen offset len infile\n"
             "      $sfk hexfind<def>   infile -bin /hexvalues/\n"
             "      $sfk hextobin<def>\n"
             "\n"
             "   $examples\n"
             "      #sfk partcopy first.dat 10000 50 second.dat 500000\n"
             "         copies 50 bytes from first.dat at offset 10000 into\n"
             "         second.dat (which should exist) at offset 500000\n"
             "\n"
             "      #sfk partcopy first.dat -fromto 0x2710 0x2950 second.dat\n"
             "         input start and end offset in hexadecimal numbers,\n"
             "         output file is created (no output offset given).\n"
             );
      ehelp;

      char  *pszSrc     =  0;
      char  *pszDst     =  0;
      num    nSrcOff    = -1;
      num    nDstOff    = -1;
      num    nCopyLen   =  0;
      bool   bDelDst    =  0;
      bool   bAbsolute  =   0;

      long nstate = 1;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-fromto")) {
            bAbsolute = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }

         // process non-option keywords:
         switch (nstate++) {
            case 1: pszSrc    = argv[iDir];                 continue;
            case 2: nSrcOff   = myatonum(argv[iDir]);       continue;
            case 3:
               if (bAbsolute) {
                  num nSrcEnd = myatonum(argv[iDir]);
                  nCopyLen    = nSrcEnd - nSrcOff;
                  if (nCopyLen < 0)
                     return 9+perr("end offset is lower than start offset");
               } else {
                  nCopyLen    = numFromSizeStr(argv[iDir], "length");
               }
               continue;
            case 4: pszDst    = argv[iDir];                 continue;
            case 5: nDstOff   = myatonum(argv[iDir]);       continue;
         }

         return 9+perr("unexpected parameter: \"%s\" (10)\n",argv[iDir]);
      }

      if (!pszSrc)         return 9+perr("missing input filename");
      if (nSrcOff < 0)     return 9+perr("missing input offset");
      if (nCopyLen <= 0)   return 9; // error printed above
      if (!pszDst)         return 9+perr("missing output filename");
      // output offset is optional.
      if (nDstOff < 0) {
         bDelDst = 1;
         nDstOff = 0;
      }

      num nInFileSize = getFileSize(pszSrc);
      if (nInFileSize < 0)
         return 9+perr("no such input file: %s", pszSrc);
      num nSrcOffMax  = nSrcOff + nCopyLen;
      if (nInFileSize < nSrcOffMax)
         return 9+perr("input file %s has a size of %s bytes, cannot copy requested part.",pszSrc,numtoa(nInFileSize));

      cs.sim = !cs.yes;

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      if (cs.sim && !bDelDst) {
         // check target file size
         num nOutFileSize = getFileSize(pszDst);
         if (nOutFileSize < 0)
            return 9+perr("no such output file: %s", pszDst);
         num nDstOffMax   = nDstOff + nCopyLen;
         if (nOutFileSize < nDstOffMax)
            return 9+perr("output file %s has a size of %s bytes, cannot copy requested part.",pszDst,numtoa(nOutFileSize));
      }

      FILE *fin = fopen(pszSrc, "rb");
      if (!fin) return 9+perr("unable to open input file: %s\n", pszSrc);

      FILE *fout = 0;
      if (!cs.sim) {
         fout = fopen(pszDst, bDelDst ? "wb" : "r+b");
         if (!fout) { fclose(fin); return 9+perr("unable to write: %s\n", pszDst); }
      }

      // seek to target locations
      if (myfseek(fin, nSrcOff, SEEK_SET)) {
         fclose(fin); if (fout) fclose(fout);
         return 9+perr("unable to seek within source file\n");
      }
      if (!cs.sim && myfseek(fout, nDstOff, SEEK_SET)) {
         fclose(fin); fclose(fout);
         return 9+perr("unable to seek within target file\n");
      }

      // verbose info during simulation          
      if (cs.sim || cs.verbose) {
         printf("copying %s bytes, ",numtoa(nCopyLen));
         printf("from input offset %s ",numtoa(nSrcOff));
         printf("to %s, ",numtoa(nSrcOffMax));
         printf("to target offset %s\n",numtoa(nDstOff));
      }

      // copy binary part
      num nRemain = nCopyLen;
      num nTotal  = 0;
      while (nRemain > 0) 
      {
         long nMaxRead = sizeof(abBuf);
         if (nMaxRead > nRemain)
             nMaxRead = (long)nRemain;

         long nread = fread(abBuf, 1, nMaxRead, fin);
         if (nread <= 0) {
            perr("unable to fully read part from %s, copy failed", pszSrc);
            lRC = 9;
            break; // EOF on input
         }

         if (fout) {
            long nwrite = myfwrite(abBuf, nread, fout);
            if (nwrite != nread) {
               esys("fwrite", "error while writing: %s   \n", pszDst);
               lRC = 9;
               break;
            }
         }

         nRemain -= nread;
         nTotal  += nread;
      }

      if (fout) fclose(fout);
      fclose(fin);

      if (!lRC && !cs.quiet) {
         if (cs.sim)
            printx("$[add -yes to really copy data.]\n");
         else
            printf("%s bytes copied.\n", numtoa(nTotal));
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "fuzz"))
   {
      ifhelp (nparm < 2)
      printx("<help>$sfk fuzz infile outfileBaseName [loops command]\n"
             "\n"
             "   change file contents at random, by intention, to test programs\n"
             "   for errors in it's input file processing. a maximum of 10 percent\n"
             "   of the data is modified.\n"
             "\n"
             "   outfileBaseName is the output filename WITHOUT extension.\n"
             "   the output filename gets the same extension as the input,\n"
             "   plus an optional prefix if loops are used.\n"
             "\n"
             "   $optional parameters:\n"
             "\n"
             "      loops  run the fuzzing loops times, each time executing\n"
             "             a user defined command. the command string MUST\n"
             "             contain the phrase \"$$outfile\" which is replaced\n"
             "             by the current fuzzed output file.\n"
             "             the amount of modified data is near-zero in the first loop,\n"
             "             and then incremented per further loop, up to max. 10 percent.\n"
             "\n"
             "   $options:\n"
             "      -verbose  tell in detail which byte (offsets) are modified.\n"
             "\n"
             "   $examples\n"
             "      #sfk fuzz in.dat tmp\\test 10 \"myprog.exe $$outfile\"\n"
             "          run 10 fuzzing tests, all output to console.\n"
             "\n"
             "      #sfk fuzz in.dat tmp\\test 10 \"myprog.exe $$outfile >$$outfile-report.txt 2>&1\"\n"
             "          run 10 fuzzing tests, output to report files in tmp.\n"
             );
      ehelp;

      char *pszSrc = 0;
      char *pszDst = 0;
      long  nloops = 1;
      char *pszCmd = 0;

      long nstate = 1;
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }

         // process non-option keywords:
         switch (nstate++) {
            case 1: pszSrc = argv[iDir]; continue;
            case 2: pszDst = argv[iDir]; continue;
            case 3: nloops = atol(argv[iDir]); continue;
            case 4: pszCmd = argv[iDir]; continue;
         }

         return 9+perr("unexpected parameter: \"%s\" (12)\n",argv[iDir]);
      }

      if (!pszSrc) return 9+perr("missing input filename");
      if (!pszDst) return 9+perr("missing output filename");
      if (nloops && !pszCmd) return 9+perr("missing user command");

      if (pszCmd && !strstr(pszCmd, "$outfile"))
         return 9+perr("missing phrase $outfile in user command");

      srand((unsigned)time(NULL));

      num nInFileSize = getFileSize(pszSrc);
      if (nInFileSize < 0)
         return 9+perr("no such input file: %s", pszSrc);

      char szOutName[300];
      char *pext = strrchr(pszSrc, '.');
      if (!pext) pext = ".dat";

      for (long iloop=1; iloop <= nloops; iloop++)
      {
         // change a max. of 10 percent of the data
         num ndensity = (num)iloop * 10000 / (num)nloops;

         FILE *fin = fopen(pszSrc, "rb");
         if (!fin) return 9+perr("unable to open input file: %s\n", pszSrc);

         sprintf(szOutName, "%s-%05lu%s", pszDst, (ulong)iloop, pext);

         FILE *fout = fopen(szOutName, "wb");
         if (!fout) { fclose(fin); return 9+perr("unable to write: %s\n", szOutName); }
   
         // copy binary part
         num nRemain = nInFileSize;
         num nTotal  = 0;
         num nFuzzed = 0;
         while (nRemain > 0) 
         {
            long nMaxRead = sizeof(abBuf);
            if (nMaxRead > nRemain)
                nMaxRead = (long)nRemain;
   
            long nread = fread(abBuf, 1, nMaxRead, fin);
            if (nread <= 0) {
               perr("unable to fully read part from %s, copy failed", pszSrc);
               lRC = 9;
               break; // EOF on input
            }
   
            // modify buffer bytes at random
            num nshoot = nread * ndensity / 100000;
            for (num i=0; i<nshoot; i++) 
            {
               ulong ioff   = (ulong)(rand() % nread);
               uchar imod   = (uchar)(rand() & 0xFFUL);
               if (cs.verbose)
                  printf("xor offset %05lxh with %02lxh\n", ioff, (ulong)imod);
               abBuf[ioff] ^= imod;
               nFuzzed++;
            }
   
            if (fout) {
               long nwrite = myfwrite(abBuf, nread, fout);
               if (nwrite != nread) {
                  esys("fwrite", "error while writing: %s   \n", szOutName);
                  lRC = 9;
                  break;
               }
            }
   
            nRemain -= nread;
            nTotal  += nread;
         }
   
         fclose(fout);
         fclose(fin);
   
         if (pszCmd) 
         {
            char szCmd[300];
            char szCmd2[300];

            strcopy(szCmd, pszCmd);

            // replace any number of outfile phrases
            while (1)
            {
               char *psz1 = strstr(szCmd, "$outfile");
               if (!psz1) break;
   
               long nleft = psz1 - szCmd;
               memcpy(szCmd2, szCmd, nleft);
               szCmd2[nleft] = '\0';
   
               strcat(szCmd2, szOutName);
   
               psz1 += 8;
               strcat(szCmd2, psz1);

               strcopy(szCmd, szCmd2);
            }

            // printf("FUZZ.BEGIN       \"%s\"\n", szCmd);

            int iRC = system(szCmd);

            printf("FUZZ.DONE density=%03ld fuzzed=%05ld %03ld = \"%s\"\n",
               (long)(ndensity/10), (long)nFuzzed, (long)iRC, szCmd);
         }
         else
         if (!lRC && !cs.quiet) {
            printf("%s bytes written, %ld modified into %s\n", numtoa(nTotal), (long)nFuzzed, szOutName);
         }

      }  // endfor loops

      bDone = 1;
   }

   // experimental
   ifcmd (strBegins(pszCmd, "webreq"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk webrequest [options] http://host[:port]/path\n"
             "$sfk webrequest host:port path [header1 header2 ...]\n"
             "\n"
             "   send a simple http text request and receive a text reply.\n"
             "   does not support http proxies and special transfer modes.\n"
             "\n"
             "   any text parameter after host:port is sent as a separate\n"
             "   text line (http header line), with CRLF being appended.\n"
             "\n"
             "   $options:\n"
             "      -verbose  show exactly what is sent to the server,\n"
             "                with each line prefixed by \"<\".\n"
             "\n"
             "   $see also:\n"
             "      #sfk wget<def>  for text and binary file downloads.\n"
             "\n"
             "   $examples:\n"
             "      #sfk webreq http://127.0.0.1/\n"
             "         send a simple GET for the root page.\n"
             "\n"
             "      #sfk webreq 127.0.0.1:80 / \"Host: foobar.com:80\"\n"
             "         the same, but also add a Host header line.\n"
             "         the \"/\" is converted into a GET ... HTTP1.1 line.\n"
             "\n"
             "      #sfk webreq 127.0.0.1:80 \"GET / HTTP1.1\"\n"
             "         similar, but with the first request line\n"
             "         explicitely defined by the user.\n"
            );
      ehelp;

      char *pHostPort   = 0;
      long  nFirstReq   = 0;
      long  nMaxReq     = 0;
      bool  bnopath     = 0;
      long  nPort       = 80;
      char *pFullUrl    = 0;

      char  szHost[200];   mclear(szHost);
      char  szUrlBuf[200]; mclear(szUrlBuf);

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-nopath")) {
            bnopath = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         char *psz = argv[iDir];
         // accept also http://host:port/path
         if (!pFullUrl && strBegins(psz, "http://")) {
            pFullUrl = psz;
            strcopy(szUrlBuf, psz);
            pHostPort  = szUrlBuf + strlen("http://");
            char *psz2 = strchr(pHostPort, '/');
            if (!psz2) return 9+perr("incomplete url: %s\n", psz);
            *psz2 = '\0';
            nFirstReq = nMaxReq = iDir;
            continue;
         }
         if (!pHostPort)
            { pHostPort = argv[iDir]; continue; }
         if (!nFirstReq)
            { nFirstReq = nMaxReq = iDir; continue; }
         // continue to loop over further request phrases,
         // until next chain command is found.
         nMaxReq = iDir;
      }

      if (!pHostPort)
         return 9+perr("missing host:port\n");
      if (!nFirstReq && !chain.usedata)
         return 9+perr("no request string or chain input data given.\n");

      strcopy(szHost, pHostPort);
      char *psz1 = strchr(szHost, ':');
      if (psz1) {
         *psz1++ = '\0';
         nPort = atol(psz1);
      }

      prepareTCP();

      struct hostent *pTarget;
      struct sockaddr_in sock;
      SOCKET hSock = socket(AF_INET, SOCK_STREAM, 0);
      if (hSock == INVALID_SOCKET)
         return 9+perr("cannot create socket\n");
      if ((pTarget = sfkhostbyname(szHost)) == NULL)
         return 9+perr("cannot get host: %s\n", szHost);

      memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
      sock.sin_family = AF_INET;
      sock.sin_port = htons((unsigned short)nPort);

      if ((connect(hSock, (struct sockaddr *)&sock, sizeof(sock))) == -1) {
         perr("cannot connect to %s:%lu, %s\n", szHost, nPort, netErrStr());
         return 9;
      }

      // szLineBuf3 is the Host: header
      snprintf(szLineBuf3, MAX_LINE_LEN, "Host: %s:%ld", szHost, nPort);
      char *pszHostHead = szLineBuf3;
      
      do
      {
         bool bGotHeaderEnd = 0;
         bool bGotHostHead  = 0;
         char *pline = 0;
         long ireq = nFirstReq; // if any
         while (1)
         {
            // get next input line
            if (chain.usedata) {
               // either from chain input data
               if (chain.indata->eod())
                  break;
               pline = chain.indata->read(0);
               removeCRLF(pline);
            } else {
               // or from command parameters
               if (ireq > nMaxReq)
                  break;
               pline = argv[ireq];
               if (ireq == nFirstReq && strBegins(pline, "http://")) {
                  pline += strlen("http://");
                  pline = strchr(pline, '/');
                  if (!pline) return 9+perr("wrong url: %s\n", argv[ireq]);
               }
               if (ireq == nFirstReq && !startsLikeHttpCommand(pline)) {
                  snprintf(szLineBuf2, MAX_LINE_LEN, "GET %s HTTP/1.1", pline);
                  pline = szLineBuf2;
               }
               ireq++;
            }
            if (striBegins(pline, "host:"))
               bGotHostHead = 1;
            if (!strlen(pline) && !bGotHeaderEnd) {
               // reached end of input header
               bGotHeaderEnd = 1;
               // RFC2616 section 14.23: client MUST send a Host: header.
               // if none was provided, auto-append it now.
               if (!bGotHostHead) {
                  bGotHostHead = 1;
                  sendLine(hSock, pszHostHead);
               }
            }
            sendLine(hSock, pline);
         }
         if (!bGotHostHead) {
            bGotHostHead = 1;
            sendLine(hSock, pszHostHead);
         }
         if (!bGotHeaderEnd) {
            // header must be completed by an empty line
            sendLine(hSock, "");
         }

         bool bfirst = 1;
         long nwebrc = 0;
         while (!readLineRaw(hSock, szLineBuf))
         {
            removeCRLF(szLineBuf);
            chain.print("%s\n", szLineBuf);
            if (bfirst) {
               bfirst = 0;
               // HTTP/1.1 200 OK
               char *psz1 = szLineBuf;
               skipToWhite(&psz1);
               nwebrc = atol(psz1);
               continue;
            }
         }

         // lRC = nwebrc;
      }
      while (0);

      closesocket(hSock);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   #ifdef VFILENET
   ifcmd (!strcmp(pszCmd, "wget"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk wget [options] url [outdir] [options]\n"
             "\n"
             "   download content from a given http:// URL.\n"
             "   an optional output directory can be specified.\n"
             "\n"
             "   $options:\n"
             "      -proxy     hostname:port of a proxy server. from within a company\n"
             "                 network, it is often required to connect through proxies.\n"
             "                 alternatively, set the environment variable SFK_PROXY :\n"
             #ifdef _WIN32
             "                   #set SFK_PROXY=myproxyhost:8000\n"
             #else
             "                   #export SFK_PROXY=myproxyhost:8000\n"
             #endif
             "                 to find out what proxy your browser is using, see\n"
             "                 - Firefox: tools/options/advanced/network/settings\n"
             "                 - IE: tools/internet options/connections/lan settings\n"
             "      -path2name include web path in generated output name,\n"
             "                 to create unique names on multiple downloads.\n"
             "                 this option is default on chained processing.\n"
             "      -fullpath  recreate the whole web path within output dir.\n"
             "      -nodom     do not include domain name in output name.\n"
             "      -nopath    do not include any path and domain information\n"
             "                 within the output names. will not work if URL\n"
             "                 does not contain any relative filename.\n"
             "      -quiet     or -noprog shows no download progress indicator.\n"
             "\n"
             "   $limitations:\n"
             "      although sfk wget can download a list of URL's, it is not\n"
             "      a real webpage downloader/archiver, as this would require\n"
             "      the conversion of html pages to adapt contained links.\n"
             "\n"
             "   $examples:\n"
             "      #sfk wget http://foobar.com/thefile.zip\n"
             "         download thefile.zip, connecting directly.\n"
             "\n"
             "      #sfk wget -proxy myproxy:8000 http://foobar.com/x.zip foo.zip\n"
             "         download x.zip, writing the content into a file foo.zip,\n"
             "         connecting through a proxy server myproxy on port 8000.\n"
             "\n"
             "      #sfk filt urls.txt +wget mydir\n"
             "         if urls.txt contains a list of http:// URL's, load it\n"
             "         and download all contents into mydir. the output names\n"
             "         will include path information found in the source URL.\n"
             "\n"
             "      #sfk filt urls.txt +wget -fullpath mydir\n"
             "         the same as above, but create the whole dir structure.\n"
            );
      ehelp;

      CommandScope oscope("WGet");

      char *pSrcName    = 0;
      char *pDstDir     = 0;
      bool  bchained    = chain.useany();
      bool  bpath2name  = bchained;
      bool  bpath2path  = 0;
      bool  bwithdom    = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-path2name")) {
            bpath2name = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-fullpath") || !strcmp(argv[iDir], "-path2path"))
         {
            bpath2path = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-nopath")) {
            bpath2name = bpath2path = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-nodom")) {
            bwithdom = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pSrcName && !bchained)
            { pSrcName = argv[iDir]; continue; }
         if (!pDstDir)
            { pDstDir  = argv[iDir]; continue; }
         return 9+perr("unexpected parameter: %s\n", argv[iDir]);
      }

      if (!pSrcName && !bchained)      return 9+perr("missing URL\n");
      if (pDstDir && !isDir(pDstDir))  return 9+perr("target dir does not exist: %s\n", pDstDir);

      ulong nmode = bpath2name ? 1 : 0;
      if (bpath2path) nmode |= 2;
      if (bwithdom) nmode |= 4;

      if (pSrcName) 
      {
         Coi *psrc = glblVCache.get(pSrcName);
         if (!psrc) {
            psrc = new Coi(pSrcName, 0);
            if (!psrc) return 9+perr("out of memory");
            psrc->incref("wget");
         }
         CoiAutoDelete odel(psrc, 1); // with decref

         execWGet(psrc, pDstDir, nmode);

         if (!psrc->isCached() && psrc->data().src.data)
            glblVCache.put(psrc->orgName(), psrc, "wget");
      }
      else
      if (chain.usefiles)
      {
         for (long i=0; i<chain.numberOfInFiles(); i++)
         {
            Coi *pcoi = chain.getFile(i);
            if (!pcoi) return 9+perr("int. #9529726");
            execWGet(pcoi, pDstDir, nmode);
         }
      }
      else
         return 9+perr("wrong chain input, need filenames.");

      bDone = 1;
   }
   #endif // VFILENET

   if (!strcmp(pszCmd, "filesys") || !strcmp(pszCmd, "fsinfo"))
   {
      if (!chain.usefiles && (nparm < 1)) {
      printx("<help>$sfk filesys rootdir\n"
             "\n"
             "   dump file system informations\n"
             "\n"
             "   $options\n"
             "      -free  tell only the number of free bytes\n"
             "\n"
             "   $examples\n"
             "      #sfk filesys C:\n"
             "         explanation1\n"
             );
      return 9;
      }

      bool bfree  = 0;
      char *proot = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-free")) {
            bfree = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!proot)
            { proot = argv[iDir]; continue; }
         return 9+perr("unexpected parameter: %s", argv[iDir]);
      }

      if (!proot)
         return 9+perr("please specify a root dir name, e.g. C:");

      num nTotal=0, nFree=0;
      char szFSName[200];
      char szVolID[200];
   
      if (getFileSystemInfo(proot, nTotal, nFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10))
         return 9+perr("unable to read file system infos.");

      if (bfree)
         printf("%s\n", numtoa(nFree));
      else
         printf("filesys=\"%s\" volume=\"%s\" totalmb=%ld freemb=%ld\n",
            szFSName, szVolID, (long)(nTotal/1000000), (long)(nFree/1000000));

      bDone = 1;
   }

   if (!strcmp(pszCmd, "fileinfo"))
   {
      char *pszFile = argv[2];

      #ifdef _MSC_VER
         #ifdef SFK_W64
         struct __stat64 ostat;
         #else
         struct stat ostat;
         #endif
      #else
         struct stat64 ostat;
      #endif

      long bdir=0,bread=0,bwrite=0;
      num  nmtime=0,nsize=0;
   
      num aExtTimes[2];
      memset(aExtTimes, 0, sizeof(aExtTimes));

      if (getFileStat(pszFile, bdir, bread, bwrite,
          nmtime, nsize, aExtTimes, &ostat, sizeof(ostat))) {
         perr("cannot read: %s", pszFile);
      } else {
         num nctime   = aExtTimes[0];
         num natime   = aExtTimes[1];
         ulong nmode  = (ulong)ostat.st_mode;
         ulong ninode = (ulong)ostat.st_ino;
         ulong ndev   = (ulong)ostat.st_dev;
         ulong nrdev  = (ulong)ostat.st_rdev;
         printf("mode=%08lXh inode=%lu device=%lu rdev=%lu\n", nmode, ninode, ndev, nrdev);
         printf("   S_IFDIR  %d\n", (nmode & S_IFDIR ) ? 1 : 0);
         printf("   S_IFCHR  %d\n", (nmode & S_IFCHR ) ? 1 : 0);
         printf("   S_IFREG  %d\n", (nmode & S_IFREG ) ? 1 : 0);
         printf("   S_IREAD  %d\n", (nmode & S_IREAD ) ? 1 : 0);
         printf("   S_IWRITE %d\n", (nmode & S_IWRITE) ? 1 : 0);
         printf("   S_IEXEC  %d\n", (nmode & S_IEXEC ) ? 1 : 0);
         #ifndef _WIN32
         printf("   S_IFIFO  %d\n", (nmode & S_IFIFO ) ? 1 : 0);
         printf("   S_IFLNK  %d\n", (nmode & S_IFLNK ) ? 1 : 0);
         printf("   S_IFBLK  %d\n", (nmode & S_IFBLK ) ? 1 : 0);
         printf("   S_IFSOCK %d\n", (nmode & S_IFSOCK) ? 1 : 0);
         struct passwd *ppass = getpwuid(ostat.st_uid);
         if (ppass)
         printf("   owner    %s\n", ppass->pw_name);
         #endif
      }

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "rawcol"))
   {
      long nval = atol(argv[2]);
      SetConsoleTextAttribute(hGlblConsole, nval);
      bDone = 1;
   }
   #endif

   if (!strcmp(pszCmd, "filetime"))
   {
      char *pszSrc = argv[2];

      if (argc > 3)
         printf("%s :\n", pszSrc);
      FileStat ofs;
      if (ofs.readFrom(pszSrc))
         return 9+perr("cannot read: %s\n",pszSrc);
      ofs.dump();

      if (argc > 3) {
         char *pszDst = argv[3];
         printf("%s :\n", pszDst);
         FileStat ofd;
         if (ofd.readFrom(pszDst))
            return 9+perr("cannot read: %s\n",pszDst);
         ofd.dump();
         ofs.dumpTimeDiff(ofd);
      }

      #ifdef USE_SFT_UPDATE
      char *pszFile = pszSrc;
      num nFileTime = getFileTime(localPath(pszFile));
      printf("time3: %ld localPath: %s\n",(long)nFileTime,localPath(pszFile));
      printf("time4: %s", timeAsString(nFileTime, 1));
      #endif

      bDone = 1;
   }

   if (!strcmp(pszCmd, "loadlib") || !strcmp(pszCmd, "loaddll"))
   {
      int iChainNext = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // load another library:
         char *pszFile = argv[iDir];

         #ifdef _WIN32
   
         HINSTANCE hlib = LoadLibraryA(pszFile);
         if (hlib != NULL)
            printf("loaded: %s   (%lxh)\n", pszFile, (ulong)hlib);
         else
         {
            int nerr = GetLastError();
            char buffer[128];
            buffer[0] = '\0';
            FormatMessageA(
               FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
               NULL, nerr, 
               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
               buffer, sizeof(buffer)-10, NULL);
            printf("failed to load %s : rc=%d %s\n",pszFile,nerr,buffer);
         }
   
         #else
   
      /*
         #ifdef MAC_OS_X
         NSObjectFileImage himg = 0;
         NSObjectFileImageReturnCode hres = 0;
         hres = NSCreateObjectFileImageFromFile(pszFile, &himg);
         if (hres == NSObjectFileImageSuccess) {
            NSModule hmod = NSLinkModule(himg, pszFile, NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_RETURN_ON_ERROR);
            NSDestroyObjectFileImage(himg);
            if (hmod != NULL)
               printf("loaded: %s\n", pszFile);
            else
               printf("failed to load: %s\n", pszFile);
         } else {
            printf("failed to load: %s\n", pszFile);
         }
         #else
         void *plib = dlopen(pszFile, RTLD_NOW);
         if (plib)
            printf("loaded: %s\n", pszFile);
         else
            printf("failed to load: %s\n", pszFile);
         #endif
      */
   
         #endif
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "readtest"))
   {
      char *pszSrc = argv[2];

      num nstart = getCurrentTime();
      long nlines = 0;

      Coi ocoi(pszSrc, 0);
      if (ocoi.open("rb"))
         return 9+perr("cannot read: %s", pszSrc);
      while (ocoi.readLine(szLineBuf, MAX_LINE_LEN) > 0) {
         nlines++;
         // if (!(nlines & 65535))
         //   { printf("%ld lines   \r", nlines); fflush(stdout); }
         printf("%s",szLineBuf);
      }
      ocoi.close();

      num nelaps = getCurrentTime() - nstart;
      fprintf(stderr, "%ld lines in %s msec\n",nlines,numtoa(nelaps));

      bDone = 1;
   }

   if (!strcmp(pszCmd, "md5test"))
   {
      SFKMD5 md5;
      uchar adata[] = { 0xFF };
      md5.update(adata, 1);
      uchar *pmd5 = md5.digest();
      mtklog("test digest: %02X %02X %02X %02X",pmd5[0],pmd5[1],pmd5[2],pmd5[3]);
      printf("test digest: %02X %02X %02X %02X\n",pmd5[0],pmd5[1],pmd5[2],pmd5[3]);
      bDone = 1;
   }

   if (!strcmp(pszCmd, "noop") || !strcmp(pszCmd, "rem"))  // +chaining
   {
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
      }

      int iDirNext = 0;
      if (processDirParms(pszCmd, argc, argv, iDir, 0, &iDirNext)) return 9;

      STEP_CHAIN(iDirNext, 0);

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "coninfo"))
   {
      hGlblConsole = GetStdHandle(STD_OUTPUT_HANDLE);
      CONSOLE_SCREEN_BUFFER_INFO oConInf;
      if (!GetConsoleScreenBufferInfo(hGlblConsole, &oConInf)) {
         printf("no console info available.\n");
      } else {
         WORD nAttrib = oConInf.wAttributes;
         printf("cons.attrib:\t0x%02lx\n", nAttrib);
         printf("cons.width :\t%u\n", oConInf.dwSize.X);
         printf("cons.height:\t%u\n", oConInf.dwSize.Y);
      }
      bDone = 1;
   }
   #endif

   /*
      NOTE:
         Between SystemInWinterTime and SystemInDST,
         -  FAT  mtimes and wft are NOT jumping,
         -  NTFS mtimes ARE jumping, wft are NOT jumping.
      SOLUTION:
         -  on Windows, do not read mtime, but use GetFileTime()
            then either convert this back to mtime (with local-
            dst-conversion)
            or store and use it directly in FileStat::writeTo().
            Also think on what to optimize:
            -  unchanged windows filetime
            -  and/or unchanged displayed filetime,
               which is relative to the current system DST mode.
            -  check also what xcopy does.
      TODOS:
        - /S /H /I /R /K /Y /D
        -  x  .  x  .  x  x  .
        - copy write-protected files
        - copy hidden dirs, files by default
        - do NOT copy empty directories
   */
   ifcmd (   !strcmp(pszCmd, "copy")  || !strcmp(pszCmd, "sync")
          || !strcmp(pszCmd, "xcopy") || !strcmp(pszCmd, "xsync")
         )
   {
      bool bext = 0;
      if (pszCmd[0] == 'x') { bext=1; pszCmd++; }

      ifhelp (!chain.usefiles && (argc < 4))

         printx("<help>$sfk copy srcRoot dstRoot [-dir subdir1 subdir2] [-file .ext1 .ext2]\n"
                "$sfk sync srcRoot dstRoot [-dir subdir1 subdir2] [-file .ext1 .ext2]\n"
                "\n");
         if (bext)
         printx("   Extended tree copy (experimental).\n");
         else
         printx("   Directory tree copy, update copy and synchronization.\n");
         printx("\n"
                "   If destination does not yet exist, whole content of source is copied,\n"
                "   #INCLUDING HIDDEN AND SYSTEM FILES.<def> If destination already exists,\n"
                "   only updates are copied.\n"
                "\n"
                "   #Symbolic links are NOT kept<def>, but their content is duplicated. If this\n"
                "   is a problem, use a copy command of your operating system instead.\n"
                "\n"
                "   $copy<def>   copies files from source to destination if the target file\n"
                "          doesn't exist yet, or if the source is NEWER than the target.\n"
                "          copy will NOT copy OLDER files over NEWER files. furthermore,\n"
                "          files that exist in destination but not in source are not removed,\n"
                "          so copy will ADD and REPLACE, but not DELETE.\n"
                "\n"
                "   $sync<def>   does the same as copy, however files that exist in source,\n"
                "          but not in destination, are called STALE files, and are DELETED\n"
                "          if their age is >= %ld days. USE WITH CARE. If you specify wrong\n"
                "          folders or file masks, this may delete files unintentionally.\n"
                "          Take a close look at the output of the simulation mode, which\n"
                "          is active by default.\n"
                ,nGlblActiveFileAgeLimit);
         printx("\n"
            //  "   -cache      try to cache many small files in memory before writing\n"
            //  "               them to the target directory.\n"
            //  "   -verify     try(!) to verify files after write. not active by default,\n"
            //  "               as verify may succeed even if files have been corrupted on the\n"
            //  "               target media (written data is often cached by operating system).\n"
                "   -mirror     with sync, copy even older files from source over destination.\n"
                /*
                "   -del        delete files in destination that do not exist in source,\n"
                "               i.e. cleanup trash files. \"sfk copy -del\" is the same\n"
                "               as \"sfk sync\". trash files younger than %ld days are called\n"
                "               \"stale\", and are not deleted even with -del specified.\n"
                "   -nodel      do not delete files or directories in destination.\n"
                "               \"sfk sync -nodel\" is the same as \"sfk copy\".\n"
                */
                );
         printx("   -wipe       delete stale files now (ignoring file ages).\n"
                "   -nocopy     with sync, do not copy files, run only delete cleanup.\n"
                "               can be used if you want copy files first with a different\n"
                "               copy program, and then run an sfk sync-delete.\n"
                "   -diff       list files in destination which have been modified after\n"
                "               last copy. Whenever you get a short info \"n differing files\n"
                "               in dest\", add -dif to get their names listed.\n"
                "   -since      or -sincedir/dif/add/chg copies only files selected by age\n"
                "               or difference to another directory. \"sfk list\" for details.\n"
                "   -nohidden   exclude hidden and system files from copy.\n"
                #ifndef _WIN32
                "   -nofollow   do not follow symbolic link directory contents.\n"
                #endif
                "   -stat       in simulation: do not list filenames, only size statistics.\n"
                "   -keepstale=n   change the 30 days limit for stale files until deletion.\n"
                "   -noinfo     do not comment on skipped files.\n"
                "   -rel[names] only with input chaining: strips source root directory names\n"
                "               from filenames. if not selected, absolute paths starting\n"
                "               like C:\\ or /tmp will be stripped automatically.\n"
                "               some chain commands may provide filenames without separate\n"
                "               directories, in this case -relnames will produce an error.\n"
             // "   -mem=mb     during read, data is cached in memory to reduce head movements\n"
             // "               on HD. the buffer size (default=100mb) can be changed here.\n"
                "   -ltarg      always list target filenames (instead of source filenames).\n"
                );
         if (bext)
         printx("   -deep       verify content of files with same time and size. this takes\n"
                "               much time, but is useful if you suspect that some hardware,\n"
                "               esp. usb sticks, sometimes damages files during write.\n"
                "               in this case, add an extra sfk sync -deep call (without -yes),\n"
                "               just to have the files scanned after copy (with usb sticks,\n"
                "               remove and re-insert them first to clear all file caches).\n"
                "\n");
         if (bext)
         printx("   $special options for use with unreliable media (usb sticks):\n"
                "\n"
                "   -sign[meta] write signature databases for later verify, in a subdir\n"
                "               \"zz-shadow-01\" within the target root directory.\n"
                "\n"
                "   -save[meta] write signature databases AND redundant copies of copied\n"
                "               files in destination, within the \"zz-shadow-01\" dir.\n"
                "\n"
                "   -load[meta] reads meta informations from source directory, verifies if\n"
                "               source files have been modified, and if so, takes redundant\n"
                "               shadow copies instead.\n"
                "\n"
                "   -shadow=5m  limit creation of shadow files to small files < 5 mbytes.\n"
                /*
                "   same as above, only more detailed:\n"
                "\n"
                "   -signto     with \"-signto filename\", a signature database is created,\n"
                "               containing content checksums of all source files. it is\n"
                "               recommended to create a signature directory, e.g. e:\\sign,\n"
                "               containing all signature files on the target media.\n"
                "   -check      with \"-check filename\", a signature database is loaded, and all\n"
                "               source files are checked against this database. if the filename\n"
                "               is not found, or the content differs, the file is NOT copied.\n"
                "   -shadow     with -signto, copies every file twice, creating a \"shadow\"\n"
                "               of every file in a parallel target directory \"zz-shadow-01\".\n"
                "               \"sfk sync -check\" will look for shadow files automatically\n"
                "               in case that a (master) file is corrupted.\n"
                "\n"
                */
                );
         printx("\n"
                "   files with whole content being copied are listed in default color.\n"
                "   files that will be deleted during sync are listed in <warn>warning color<def>.\n"
                "   files with differing time but equal content are listed in <time>time color<def>.\n"
                "\n"
               );
         printx("   $completeness and efficiency:\n"
                "   -  under Windows, SFK uses the CopyFileEx API function, which should\n"
                "      be able to copy most file attributes and contents as good and fast\n"
                "      as the XCopy command provided with Windows.\n"
                "   -  under Linux, no native copy function is available, therefore SFK may\n"
                "      not be able to copy all attributes, access rights and timestamps\n"
                "      of the original files. Furthermore, copying can be slower than \"cp\".\n"
                "   -  Directory attributes, access rights and time stamps may not be\n"
                "      completely reproduced both on Windows and Linux.\n"
                "   -  Changes from/to Daylight Saving Time, differing time zones or copies\n"
                "      between FAT and NTFS may always copy files which were copied already.\n"
                "      this is a general problem with all copy commands.\n"
                "\n"
               );
         printx("   $using file system views:\n"
                "      if you want to specify many directory trees and dir/file masks,\n"
                "      you may create a fileset, containing a list of directories.\n"
                "      type \"sfk help fileset\" for details.\n"
                "\n"
                "   #NO WARRANTY FOR DATA INTEGRITY.<def> SFK copy is very convenient to use,\n"
                "   but if you need to copy massive amounts of highly important data, it is\n"
                "   recommended to use the original copy command of your operating system.\n"
                "   Always keep backups of important stuff. After large copies, do some spot\n"
                "   checking if important files were really copied without modifications.\n"
                "   Always double-check the reliability of external media like USB sticks,\n"
                "   e.g. by creating md5 lists (see \"sfk md5gento\").\n"
                "\n"
                );
      // printx("   $see also:\n"
      //        "      #sfk help select<def> - about the file selection syntax.\n"
      //        "\n"
      //        );
         printx("   $examples:\n"
                "      #sfk copy c:\\work d:\\arc\\work -dir . <not>\\tmp\\ <not>\\save\\ -file <not>.bak\n"
                "         copy directory tree c:\\work to d:\\arc\\work, excluding all dirs\n"
                "         called tmp or save, including all files except .bak files.\n"
                "\n"
                "      #sfk copy d:\\proj v:\\team\\proj -dir foosys\\include foosys\\source tools\n"
                "         within directory tree proj, copy subdirectory trees foosys\\include,\n"
                "         foosys\\source and tools, including all files therein.\n"
                "\n"
                "      #sfk filter testfiles -+foo +copy \\tmp\n"
                "         copy all files from testfiles containing \"foo\" to \\tmp.\n"
                "\n"
                "      #sfk copy work archive -fileset myflist.txt\n"
                "         copy the files listed in myflist.txt from work to archive.\n"
                "         note that \"-yes\" must be specified directly after \"copy\".\n"
                "         see also \"sfk help fileset\".\n"
                "\n"
                "      #sfk list mydir .txt .doc code.cpp +copy d:\\save\n"
                "         copies all .txt, .doc and code.cpp files from within mydir,\n"
                "         including all subdirs, to d:\\save. ALSO copies mycode.cpp,\n"
                "         subcode.cpp.1 etc. as \"code.cpp\" ist just a pattern.\n"
                "\n");
         if (bext)
         printx("      #sfk sync -save x:\\ e:\\ -dir src -wipe\n"
                "         copy directory \"src\" from X: onto usb stick (E:), with checksums\n"
                "         and shadow files, instantly deleting stale files that are found\n"
                "         within E:\\src but not within X:\\src .\n"
                "\n"
                "      #sfk verify e:\\ -all\n"
                "         verifies files on the stick (leave out -all to check only the ones\n"
                "         copied most recently). you must remove and re-insert the stick before\n"
                "         running the verify, otherwise data is taken from cache, leading always\n"
                "         to successful verifies even if files are corrupted.\n"
                "\n"
                "      #sfk sync -load e:\\ z:\\ -dir src\n"
                "         copies files from stick to hard disk (Z:), verifying all source files\n"
                "         before copy. files that fail verification are replaced by shadows.\n"
                "\n"
                "      #sfk copy -save x:\\ e:\\ -dir src -since today\n"
                "         copies today's changed or added files from X:\\src to E:\\src.\n"
                "\n"
                );

      ehelp;

      bool bchain = chain.usefiles;

      char *pszSrc   = 0;
      char *pszDst   = 0;
      bool  bCopy    = 1;
      long  nDoSave  = 0;
      bool  bDoLoad  = 0;
      long  nBufMB   = 100;
      int iChainNext = 0;

      cs.verifyLate = 0;
      cs.hidden = 1; // include hidden/system by default
      cs.syncFiles = !strncmp(pszCmd, "sync", 4);

      // int iDir = 2;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-mem", &pszParm)) {
            if (!pszParm) return 9;
            nBufMB = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nov", 4)) {
            cs.verifyEarly = 0;
            cs.verifyLate  = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-ver", 4)) {
            cs.verifyEarly = 0;
            cs.verifyLate  = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-mir", 4)) {
            cs.syncOlder = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-noca", 5)) {
            bGlblUseCopyCache = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-del", 4)) {
            cs.syncFiles = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-wipe")) {
            cs.delStaleFiles = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nodel", 6)) {
            cs.syncFiles = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-noco", 5)) {
            bCopy = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-dif", 4)) {
            bGlblShowSyncDiff = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-cache")) {
            bGlblUseCopyCache = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-deep")) {
            bGlblIgnoreTime = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-style")) {
            nGlblCopyStyle = 0;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-link")) {
            cs.copyLinks = 1; // windows only, untested.
            continue;
         }
         else
         if (strBegins(argv[iDir], "-nobuf")) {
            cs.copyNoBuf = 1; // windows only, untested.
            continue;
         }
         else
         if (strBegins(argv[iDir], "-decrypt")) {
            cs.copyDecrypt = 1; // windows only, untested.
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-stat"))  { cs.dostat=1; continue; }
         else
         if (!strncmp(argv[iDir], "-save", 5))   { nDoSave=2; continue; }
         else
         if (!strncmp(argv[iDir], "-sign", 5))   { nDoSave=1; continue; }
         else
         if (!strncmp(argv[iDir], "-load", 5))   { bDoLoad=1; continue; }
         else
         if (!strcmp(argv[iDir], "-shadow")) {
            nGlblCopyShadows = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-shadow=", 8)) {
            nGlblCopyShadows = 1;
            nGlblShadowSizeLimit = atol(argv[iDir]+8) * 1000000;
            continue;
         }
         /*
         else
         if (haveParmOption(argv, argc, iDir, "-signto", &pszParm)) {
            if (!pszParm) return 9;
            pszSignTo = pszParm;
            continue;
         }
         */
         else
         if (haveParmOption(argv, argc, iDir, "-check", &pszParm)) {
            if (!pszParm) return 9;
            if (filedb.openRead(pszParm, 1)) return 9;
            // -> filedb.canRead() is set
            cs.skipOwnMetaDir = 1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-checksigns", &pszParm)) {
            if (!pszParm) return 9;
            if (filedb.openRead(pszParm, 1)) return 9;
            // -> filedb.canRead() is set
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!bchain && !pszSrc) { 
            pszSrc = argv[iDir]; 
            if (!coiExists(pszSrc, 1)) // 1: or dir
               return 9+perr("no such file or directory: %s\n", pszSrc);
            continue; 
         }
         if (!pszDst) { pszDst = argv[iDir]; continue; }
         // further parms: file selection masks
         break; // fall through
      }

      // init source and target dirs or files.

      if (!bchain && !pszSrc) return 9+perr("missing source directory or file.\n");
      if (!pszDst) return 9+perr("missing target directory%s.\n", bchain? "":" or file");

      // remember this, have to strip it from full paths
      pszGlblCopySrc = pszSrc; // NULL on chaining

      num nTime1 = getCurrentTime();

      // parse subdirs and general options
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iChainNext))
         return lRC;

      // now we know if in simulation or not
      cs.sim = !cs.yes;

      // reset global statistics
      nGlblBytes = 0;

      // activate source shadow skip implicitely if meta data are found
      if (!bchain && !cs.skipOwnMetaDir) {
         joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszSrc, "zz-shadow-01");
         if (isDir(szRefNameBuf)) {
            joinPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, szRefNameBuf, "zz-sign");
            if (filedb.isSignatureFile(szRefNameBuf2)) {
               filedb.setMetaDir(szRefNameBuf);
               cs.skipOwnMetaDir = 1;
            }
         }
      }

      if (!bchain)
      {
         // execute aliases: save, load, verify
         if (bDoLoad) {
            // same as -check dstroot\zz-shadow-01\sign.dat -shadow
            // setup signature database name:
            if (filedb.canRead()) return 9+perr("specify -load OR -check, but not both");
            joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszSrc, "zz-shadow-01");
            if (!isDir(szRefNameBuf)) return 9+perr("metadb directory not found: %s\n", szRefNameBuf);
            if (filedb.setMetaDir(szRefNameBuf)) return 9;
            joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszSrc, "zz-sign");
            // if (!cs.sim)
            if (filedb.openRead(szRefNameBuf2, 1)) return 9;
            // avoid copying of own metadir to target
            cs.skipOwnMetaDir = 1;
         } 
         else
         if (nDoSave) {
            // user said -save explicitely
            if (!cs.sim) {
               if (createSubDirTree(pszDst, "zz-shadow-01"))
                  return 9;
               joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszDst, "zz-sign");
               if (filedb.openUpdate(szRefNameBuf2))
                  return 9;
               if (nDoSave >= 2)
                  nGlblCopyShadows = 1;
            }
         } else {
            // no -save: check if a signature db exists in target
            joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszDst, "zz-shadow-01");
            if (isDir(szRefNameBuf)) {
               joinPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, szRefNameBuf, "zz-sign");
               if (filedb.isSignatureFile(szRefNameBuf2)) {
                  if (!cs.sim) {
                     // user forgot -save: open for update implicitely
                     // setTextColor(nGlblTimeColor);
                     // oprintf("updating signature database: %s-nn.dat\n", szRefNameBuf2);
                     // setTextColor(-1);
                     filedb.openUpdate(szRefNameBuf2); // ignore rc
                  } else {
                     setTextColor(nGlblTimeColor);
                     printf("NOTE: signature database found. say -save to write shadows.\n");
                     setTextColor(-1);
                  }
               }
            }
         }

         // check: -shadow requires explicite -dir name listings
         if (nGlblCopyShadows || nDoSave) {
            if (!cs.sim) {
               if (!filedb.canRead() && !filedb.canUpdate())
                  return 9+perr("-shadow requires -signto or -check\n");
            }
         }
      }  // endif nochain

      // setup work buffer
      if (!cs.sim && nBufMB) {
         nGlblWorkBufSize = (num)nBufMB * 1000000;
         pGlblWorkBuf = new uchar[nGlblWorkBufSize];
         if (!pGlblWorkBuf) return 9+perr("out of memory, cannot allocate working buffer.\n");
         glblCopyCache.setBuf(pGlblWorkBuf, nGlblWorkBufSize);
      }
      // NO RETURN W/O DELETE FROM HERE

      bool bSrcDir = bchain || isDir(pszSrc);
      bool bDstDir = isDirByName(pszDst) || isDir(pszDst);
      long nVerFiles  = 0;
      long nVerFailed = 0;
      long nSignsWritten = 0;
 
      mtklog("copy: copy=%d chain=%d sdir=%d ddir=%d", bCopy,bchain,bSrcDir,bDstDir);
      mtklog("copy: src=\"%s\" dir=%d", pszSrc, bSrcDir);
      mtklog("copy: dst=\"%s\" dir=%d", pszDst, bDstDir);

      if (!bchain && !bSrcDir && !bDstDir) {
         if (!bCopy) return 9+perr("-nocopy not supported with single file operation.\n");
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         // single conditional file copy.
         createOutDirTree(pszDst);
         lRC = execFileCopySub(pszSrc, pszDst);
         glblCopyCache.flush();
      }
      else
      if (!bchain && !bSrcDir) {
         if (!bCopy) return 9+perr("-nocopy not supported with single file operation.\n");
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         // src is a file, target a dir.
         strcopy(szRefNameBuf, pszDst);
         long nLen = strlen(szRefNameBuf);
         if ((nLen > 0) && (szRefNameBuf[nLen-1] != glblPathChar))
            strcat(szRefNameBuf, glblPathStr);
         // isolate last part of source name
         char *pszRelName = strrchr(pszSrc, glblPathChar);
         #ifdef _WIN32
         if (!pszRelName) pszRelName = strrchr(pszSrc, ':');
         #endif
         if (pszRelName) pszRelName++;
         else pszRelName = pszSrc;
         // combine target filename
         strcat(szRefNameBuf, pszRelName);
         if (cs.verbose)
            info.print("%s => %s\n",pszSrc,szRefNameBuf);
         createOutDirTree(szRefNameBuf);
         lRC = execFileCopySub(pszSrc, szRefNameBuf);
         glblCopyCache.flush();
      }
      else
      while (bSrcDir) // need to exit by break
      {
         // copy directory tree to a target tree.
         pszGlblPreRoot = pszSrc; // NULL on chaining
         pszGlblCopyDst = pszDst;

         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         if (bCopy) {
            mtklog("copy: calling walktrees, hasroot.0 = %d", glblFileSet.hasRoot(0));
            lRC = walkAllTrees(eFunc_Copy, lFiles, lDirs, nBytes);
            if (lRC)
               break;
         }
         glblCopyCache.flush();

         // separate verify pass after copy, to (hopefully)
         // get around file system caching:
         if (!cs.sim && cs.verifyLate) // verify
         {
            long lRC   = glblVerifier.verify();
            nVerFiles  = glblVerifier.matchedFiles();
            nVerFailed = glblVerifier.failedFiles();
            info.clear(); // status output below
         }

         if (!bchain && cs.syncFiles)
         {
            // cleanup pass: check target for trash files

            // 1. reverse copy direction
            pszGlblPreRoot = pszDst;
            pszGlblCopySrc = pszDst;
            pszGlblCopyDst = pszSrc;

            if (nGlblCopyShadows) {
               // 2. meta dir was written on copy, filter it out on reverse scan.
               cs.skipOwnMetaDir = 1;
               joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszGlblCopySrc, "zz-shadow-01");
               if (!cs.sim && !isDir(szRefNameBuf)) return 9+perr("metadb directory not found: %s\n", szRefNameBuf);
               filedb.setMetaDir(szRefNameBuf);
            }

            cs.filesScanned = 0;
            cs.dirsScanned  = 0;
            lRC = walkAllTrees(eFunc_Cleanup, lFiles, lDirs, nBytes);
         }

         if (filedb.canUpdate())
            filedb.save(nSignsWritten); // ignore rc

         break;         
      }

      glblCopyCache.flush();

      // NO RETURN W/O DELETE UNTIL HERE

      info.clear();

      if (cs.sim && !cs.nohead) {
         if (cs.files || cs.dirs || cs.filesDeleted || cs.dirsDeleted || cs.filesCloned || cs.dirsCloned)
            printx("$[add -yes to execute.]\n");
         else
            printx("$[no differences.]\n");
      }

      bool bsilent = (cs.nohead || cs.quiet);

      num nTime2 = getCurrentTime();
      num nDiff  = nTime2-nTime1;
      bool bTold = 0;
      if (!bSrcDir && !bDstDir) 
         { } // single file copy
      else 
      if (!bsilent && (cs.files || cs.dirs || cs.filesCloned || cs.dirsCloned))
      {
         const char *pszVerb = cs.sim ? "would copy":"copied";
         if (!cs.filesCloned && !cs.dirsCloned)
            printx("$%s %lu files, %lu dirs.", pszVerb, cs.files, cs.dirs);
         else {
            printx("$%s %lu files, %lu dirs (%lu/%lu attribs", pszVerb, cs.files, cs.dirs, cs.filesCloned, cs.dirsCloned);
            if (nVerFiles > 0)
               printx("$, %ld verified",nVerFiles);
            if (nVerFailed > 0)
               printx("$, <err>%ld failed",nVerFailed);
            printx("$).");
         }
         if (nGlblBytes > 0) {
            num nmbytes = nGlblBytes / 1000000;
            num nkbytes = nGlblBytes / 1000;
            if (nmbytes > 0)
               printx(" <time>%s mb.<def>",numtoa(nmbytes));   
            else
            if (nkbytes > 0)
               printx(" <time>%s kbytes.<def>",numtoa(nkbytes));
            else
               printx(" <time>%s bytes.<def>",numtoa(nGlblBytes));
         }
         bTold = 1;
      }
      if (!bsilent && (cs.filesDeleted || cs.dirsDeleted)) {
         const char *pszVerb = cs.sim ? "would delete":"deleted";
         setTextColor(nGlblWarnColor, 1);
         printf("%s%s %ld files, %ld dirs.", bTold?" ":"", pszVerb, cs.filesDeleted, cs.dirsDeleted);
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && cs.filesNewerInDst) {
         // setTextColor(nGlblWarnColor, 1);
         printx("%s$(%ld differing files in dest)", bTold?" ":"", cs.filesNewerInDst);
         // setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && (cs.numHiddenFilesSkipped || cs.numHiddenDirsSkipped)) {
         setTextColor(nGlblWarnColor, 1);
         printf("%sskipped %ld hidden files, %ld dirs.", bTold?" ":"", cs.numHiddenFilesSkipped, cs.numHiddenDirsSkipped);
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && bTold && (nSignsWritten > 0)) { // && filedb.canUpdate()
         setTextColor(nGlblTimeColor, 1);
         printf(" %ld signatures", nSignsWritten);
         if (cs.shadowsWritten)
            printf(", %ld shadows", cs.shadowsWritten);
         printf(".");
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && filedb.canRead() && filedb.anyEvents())
      {
         char *pszpre = " ";
         char *pszsub = "signs ";
         if (filedb.numberOfVerFailed() > 0) {
            if (filedb.numberOfVerFailed() == cs.shadowFallbacks)
               setTextColor(nGlblWarnColor, 1);
            else
               setTextColor(nGlblErrColor, 1);
            printf(" %ld signatures failed", filedb.numberOfVerFailed());
            if (cs.shadowFallbacks) {
               setTextColor(nGlblWarnColor, 1);
               printf(", %ld shadow fallbacks", cs.shadowFallbacks);
            }
            pszpre=", "; pszsub="";
         }
         if (filedb.numberOfVerMissing() > 0) {
            setTextColor(nGlblErrColor, 1);
            printf("%s%ld %snot found", pszpre, filedb.numberOfVerMissing(), pszsub);
            pszpre=", "; pszsub="";
         }
         setTextColor(nGlblTimeColor, 1);
         if (filedb.numberOfVerifies() > 0) {
            printf("%s%ld %schecked.", pszpre, filedb.numberOfVerifies(), pszsub);
            pszpre=", "; pszsub="";
         }
         setTextColor(-1);
         bTold = 1;
      }
      if (bTold)
         printf("\n");

      if (cs.filesStale) {
         setTextColor(nGlblWarnColor, 1);
         printf("%ld stale but recently edited files are kept until deletion limit (%ld days).\n", cs.filesStale, nGlblActiveFileAgeLimit);
         setTextColor(-1);
      }

      delete [] pGlblWorkBuf;
      pGlblWorkBuf = 0;

      pszGlblPreRoot = 0;

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "verify") ||!strcmp(pszCmd, "syncver"))
   {
      if (blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      if (argc < 3) {
      printx("<help>$sfk sfk verify [-cleanup] [-all] rootdir\n"
             "\n"
             "   verify contents of directory by a given file meta database,\n"
             "   as it is created by sfk copy -sign ...\n"
             "\n"
             "   $options\n"
             "      -cleanup     cleanup records that fail to verify, and/or\n"
             "                   update records with timestamp mismatches.\n"
             "      -all         by default, only records that have been updated\n"
             "                   recently are checked. say -all to check all.\n"
             "\n"
             "   $see also\n"
             "      sfk copy\n"
             "\n"
             "   $examples\n"
             "      #sfk verify e: -all\n"
             "         verify contents on E:, which could be an USB stick.\n"
             );
      return 9;
      }

      char *pszDBFile = 0;
      pszGlblCopySrc  = 0;
      bool bCheckAll  = 0;
      bool bCleanup   = 0;
      char *pszParm1  = 0;
      char *pszParm2  = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-all")) {
            bCheckAll = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-cle", 4)) {
            bCleanup = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // process non-option keywords:
         if (!pszParm1) { pszParm1 = argv[iDir]; continue; }
         if (!pszParm2) { pszParm2 = argv[iDir]; continue; }
         return 9+perr("unexpected parameter: \"%s\" (7)\n", argv[iDir]);
      }

      if (!pszParm2)
         // just one parm: have rootdir
         pszGlblCopySrc = pszParm1;
      else {
         pszDBFile      = pszParm1;
         pszGlblCopySrc = pszParm2;
      }

      if (!pszGlblCopySrc) return 9+perr("missing root directory name\n");

      if (pszDBFile) {
         if (filedb.openRead(pszDBFile, 1))
            return 9;
      } else {
         joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszGlblCopySrc, "zz-shadow-01");
         if (!isDir(szRefNameBuf)) return 9+perr("metadb directory not found: %s\n", szRefNameBuf);
         joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszGlblCopySrc, "zz-sign");
         if (filedb.openRead(szRefNameBuf2, 1)) return 9;
      }

      long nVerMixRC = 0;
      long nSkipped = 0;
      for (long i=0; i<filedb.numberOfFiles(); i++) 
      {
         if (userInterrupt())
            break;
         long nflags = filedb.getFileFlags(i);
         if (bCheckAll || (nflags >= 2)) {
            nVerMixRC |= filedb.verifyFile(i, bCleanup);
         } else {
            nSkipped++;
         }
      }
      info.clear();

      bool bTold = 0;

      if (!cs.quiet) {
         if (!filedb.numberOfVerifies() && !bCheckAll) {
            long ncnt = filedb.numberOfFiles();
            printf("%s contains no recently updated files. say -all to check all %ld entries.",pszGlblCopySrc,ncnt);
         } else {
            const char *pxinfo = bCheckAll ? "" : "recently updated ";
            printf("%s %ld %sfiles verified.",pszGlblCopySrc,filedb.numberOfVerifies(),pxinfo);
         }
         bTold = 1;
      }

      if (!cs.quiet && filedb.canRead() && filedb.anyEvents())
      {
         char *pszpre = " ";
         char *pszsub = "signs ";
         if (filedb.numberOfVerFailed() > 0) {
            if (filedb.numberOfVerFailed() == cs.shadowFallbacks)
               setTextColor(nGlblWarnColor, 1);
            else
               setTextColor(nGlblErrColor, 1);
            printf(" %ld signatures failed", filedb.numberOfVerFailed());
            if (cs.shadowFallbacks) {
               setTextColor(nGlblWarnColor, 1);
               printf(", %ld shadow fallbacks", cs.shadowFallbacks);
            }
            pszpre = ", ";
         }
         if (filedb.numberOfVerMissing() > 0) {
            setTextColor(nGlblErrColor, 1);
            printf("%s%ld %snot found", pszpre, filedb.numberOfVerMissing(), pszsub);
            pszpre=", "; pszsub="";
         }
         setTextColor(nGlblTimeColor, 1);
         printf("%s%ld %schecked", pszpre, filedb.numberOfVerifies(), pszsub);
         if (nSkipped)
            printf(", %ld skipped", nSkipped);
         printf(".");
         setTextColor(-1);
         bTold = 1;
      }
      if (bTold)
         printf("\n");

      if (nVerMixRC && bCleanup) {
         // at least one record failed to verify, and cleanup is selected:
         // rewrite meta db.
         long nRecWritten = 0;
         long nSaveRC = filedb.save(nRecWritten);
         if (!nSaveRC)
            printf("metadb cleaned up, %ld records written.\n", nRecWritten);
         // else error was printed within save()
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "getcwd") || !strcmp(pszCmd, "cwd"))
   {
      ifhelp (nparm >= 1 && isHelpOpt(argv[iDir]))
      printx("<help>$sfk getcwd\n"
             "\n"
             "   print the current working directory.\n"
             "\n"
             "   $examples\n"
             "      #sfk getcwd +filter -form \"workdir is $$col1\"\n"
             "         print workdir with some additional text.\n"
             );
      ehelp;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s", argv[iDir]);
      }

      #ifdef _WIN32
      _getcwd(szLineBuf,sizeof(szLineBuf)-10);
      #else
      getcwd(szLineBuf,sizeof(szLineBuf)-10);
      #endif

      if (chain.colfiles) {
         Coi ocoi(szLineBuf, 0);
         chain.addFile(ocoi); // is copied
      }
      else
      if (chain.coldata) {
         chain.addLine(szLineBuf, "", 0);
      } else {
         printf("%s\n", szLineBuf);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "cd")) 
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk cd targetdir +nextcmd ...\n"
             "\n"
             "   change the directory for the next chain command.\n"
             "   does NOT change the directory of the command shell.\n"
             "\n"
             "   $options\n"
             "      -echo     echo the command on execution\n"
             "\n"
             "   $examples\n"
             "      #sfk cd testfiles +list -time -size .\n"
             "         enter directory \"testfiles\", then list all files.\n"
             );
      ehelp;

      char *pszDir = 0;
      bool  becho  = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-echo")) {
            becho = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszDir)
            pszDir = argv[iDir];
         else
            return 9+perr("unexpected: %s", argv[iDir]);
      }

      if (!pszDir) return 9+perr("missing dir name for cd");

      // plausi check
      if (iChainNext <= 0) {
         perr("missing chain commands after \"cd\"");
         pinf("cd can change the dir for subsequent chain commands only.\n");
         pinf("to change the dir of your command shell, use \"cd\" but not \"sfk cd\"\n");
         return 9;
      }

      int nrc = chdir(pszDir);
      if (nrc) return 9+perr("cannot cd into: %s", pszDir);

      if (becho)
         printx("<time>cd %s<def>\n", pszDir);

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "mkdir")) 
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk mkdir path\n"
             "\n"
             "   create a directory, or directory tree.\n"
             "\n"
             "   $options\n"
             "      -echo     echo the command on execution\n"
             "\n"
             "   $examples\n"
             "      #sfk mkdir tmp\\foo\\bar\n"
             "         create directory bar within foo within tmp.\n"
             );
      ehelp;

      char *pszDir = 0;
      bool  becho  = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-echo")) {
            becho = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszDir)
            pszDir = argv[iDir];
         else
            return 9+perr("unexpected: %s", argv[iDir]);
      }

      if (!pszDir) return 9+perr("missing dir name for mkdir");

      lRC = createSubDirTree(pszDir, "");
      if (lRC) return lRC;

      if (becho)
         printx("<time>mkdir %s<def>\n", pszDir);

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   if (strBegins(pszCmd, "linelen") || strBegins(pszCmd, "strlen"))
   {
      if (!chain.useany() && (nparm < 1)) {
      printx("<help>$sfk linelen [options]\n"
             "$sfk strlen phrase\n"
             "\n"
             "   tell the length of text lines supplied via stdin\n"
             "   or through command chaining, or tell the length\n"
             "   of a single string.\n"
             "\n"
             "   the result is printed to terminal, and supplied\n"
             "   as a return code to the command shell.\n"
             "\n"
             "   \"sfk strlen\" does not accept any options,\n"
             "   allowing to supply a string starting with \"-\".\n"
             "\n"
             "   $options\n"
             "      -i         read lines from standard input,\n"
             "                 tell the longest line length.\n"
             "      -min       tell the minimum, not the maximum length.\n"
             "      -minmax    tell both min and max length.\n"
             "      -verbose   tell minmax, line numbers and line text.\n"
             "                 you may also type -all or -ver\n"
             "      -quiet     do not print anything to terminal,\n"
             "                 just provide the shell return code.\n"
             "\n"
             "   $limitations\n"
             "      if the input contains stream text, i.e. text where\n"
             "      linefeeds are used only for paragraphs (not lines),\n"
             "      the result will be a paragraph length, and it can be\n"
             "      completely wrong if there are paragraphs longer than\n"
             "      4000 characters approx.\n"
             "\n"
             "   $examples\n"
             "      #sfk strlen \"foo bar\"\n"
             "         results in a string length of 7.\n"
             "\n"
             "      #sfk filter foo.txt +linelen -all\n"
             "         list the shortest and longest line of foo.txt\n"
             );
      return 9;
      }

      bool  braw = strBegins(pszCmd, "strlen");

      char *pphrase = 0;
      bool  bstdin  = 0;
      bool  bdetail = 0;
      bool  bmin    = 0;
      bool  bmax    = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (!braw && !strcmp(argv[iDir], "-i")) {
            bstdin = 1;
            continue;
         }
         else
         if (!braw && !strcmp(argv[iDir], "-min")) {
            bmin = 1; bmax = 0;
            continue;
         }
         else
         if (!braw && !strcmp(argv[iDir], "-max")) {
            bmax = 1;
            continue;
         }
         else
         if (!braw && !strcmp(argv[iDir], "-minmax")) {
            bmin = 1; bmax = 1;
            continue;
         }
         else
         if (!braw && strBegins(argv[iDir], "-ver") || !strcmp(argv[iDir], "-all"))
         {
            bdetail = 1;
            continue;
         }
         else
         if (!braw && !strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pphrase) {
            pphrase = argv[iDir];
            continue;
         }
         return 9+perr("only one phrase can be supplied.\n");
      }

      if (!pphrase && !chain.usedata && !bstdin)
         return 9+perr("missing phrase, chain text or -i option.\n");

      if (pphrase)
         { bmin=0; bdetail=0; }

      long iline = 0;
      long nmin  = -1;
      long nmax  = 0;
      long imin  = 0;
      long imax  = 0;
      mclear(szLineBuf2);  // will contain min line
      mclear(szLineBuf3);  // will contain max line

      if (bstdin)
         myfgets_init();

      if (pphrase) {
         nmax = strlen(pphrase);
         bdetail = 0;
      }
      else
      while (1) 
      {
         if (chain.usedata) {
            if (chain.indata->eod())
               break;
            char *psz = chain.indata->read(0);
            mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
         } else {
            if (!myfgets(szLineBuf, MAX_LINE_LEN, stdin))
               break;
         }
         iline++;
         removeCRLF(szLineBuf);
         long nlen = strlen(szLineBuf);
         if (nmin < 0 || nlen < nmin) {
            nmin = nlen;
            imin = iline;
            strcopy(szLineBuf2, szLineBuf);
         }
         if (nlen > nmax) {
            nmax = nlen;
            imax = iline;
            strcopy(szLineBuf3, szLineBuf);
         }
      }

      if (!cs.quiet) {
         if (bdetail) {
            chain.print("min\t%ld\t%ld\t\"%s\"", nmin, imin, szLineBuf2);
            chain.print("max\t%ld\t%ld\t\"%s\"", nmax, imax, szLineBuf3);
            lRC = nmax;
         }
         else
         if (bmin && bmax) {
            chain.print("%ld\t%ld", nmin, nmax);
            lRC = nmax;
         }
         else
         if (bmin) {
            chain.print("%ld", nmin);
            lRC = nmin;
         }
         else {
            if (!cs.quiet)
               chain.print("%ld", nmax);
            lRC = nmax;
         }
      }

      if (iChainNext > 0) lRC = 0;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   // internal
   if (!strcmp(pszCmd, "getlines"))
   {
      // cs.debug = 1;
      char *pszFile = argv[2];
      FILE *fin = fopen(pszFile, "rb");
      if (!fin) return 9+perr("failed\n");
      memset(szLineBuf, '$', MAX_LINE_LEN);
      myfgets_init();
      while (myfgets(szLineBuf, MAX_LINE_LEN, fin))
      {
         printf(">%s<\n", szLineBuf);
         memset(szLineBuf, '$', MAX_LINE_LEN);
      }
      fclose(fin);
      bDone = 1;
   }

   if (!strcmp(pszCmd, "mdfuzzy"))
   {
      // cs.verbose = 1;
      char *pszFile = argv[2];
      if (getFuzzyTextSum(pszFile, abBuf))
         return 9;
      for (int i=0; i<16; i++)
         printf("%02x ", abBuf[i]);
      printf("\n");
      bDone = 1;
   }

   // create cd batch to current directory
   ifcmd (!strcmp(pszCmd, "mkcd"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("<help>$sfk mkcd cdname\n"
             "\n"
             "   creates an alias batch file, remembering the current directory.\n"
             "   this batch can be used later to re-enter the remembered directory.\n"
             "\n"
             "   #example:\n"
             "\n"
             "   1. you are currently working in\n"
             "         C:\\Documents And Long Complicated Paths\\Users\\You\\Work\n"
             "\n"
             "   2. now type:\n"
             "         #sfk mkcd cd1\n"
             "            which saves above path in a command \"cd1\".\n"
             "\n"
             "   3. you go into a different directory, e.g.\n"
             "         C:\\Another Project\\Nested Dirs\\Work2\n"
             "\n"
             "   4. now type:\n"
             "         #sfk mkcd cd2\n"
             "\n"
             "   => now, anytime you type:\n"
             "         #cd1\n"
             "            you jump instantly into\n"
             "               C:\\Documents And Long Complicated Paths\\Users\\You\\Work\n"
             "\n"
             "      and anytime you type:\n"
             "         #cd2\n"
             "            you jump instantly into\n"
             "               C:\\Another Project\\Nested Dirs\\Work2\n"
             "\n"
             "   if the creation of the alias fails, please type \"sfk alias\" to read\n"
             "   about the required directories and access rights.\n"
         );
      ehelp;

      if (checkArgCnt(argc, 3)) return 9;
      char *pszAlias = argv[2];

      // find ourselves, result in szLineBuf
      char *pszSFKCmd = findPathLocation("sfk" EXE_EXT, 1); // 1: exclude work dir
      if (!pszSFKCmd) return 9+perr("cannot find location of sfk" EXE_EXT " within PATH.\n");
      // create batch filename parallel to sfk.exe
      szRefNameBuf[0] = '\0';
      char *psz1 = strrchr(pszSFKCmd, glblPathChar);
      if (!psz1) return 9+perr("unable to find path of sfk" EXE_EXT "\n");
      sprintf(szRefNameBuf, "%.*s", (int)(psz1-pszSFKCmd+1),pszSFKCmd);
      char *pszRel = szRefNameBuf+strlen(szRefNameBuf);
      strcat(szRefNameBuf, pszAlias);
      #ifdef _WIN32
      strcat(szRefNameBuf, ".bat");
      #endif
      char nReply = 'y';
      if (fileExists(szRefNameBuf)) {
         printf("%s exists, overwrite? (yes/no) ",szRefNameBuf);
         fflush(stdout);
         nReply = getYNAchar();
      }
      if (nReply == 'y') 
      {
         // determine current directory
         #ifdef _WIN32
         _getcwd(szLineBuf,sizeof(szLineBuf)-10);
         #else
         getcwd(szLineBuf,sizeof(szLineBuf)-10);
         #endif

         // write the batch
         FILE *fout = fopen(szRefNameBuf, "w");
         if (!fout) return 9+perr("cannot write batch file: %s\n", szRefNameBuf);

         // write alias batch header for later re-identification.
         fprintf(fout, "%s\n", pszGlblAliasBatchHead);

         #ifdef _WIN32
         // include drive change
         char *psz2 = strchr(szLineBuf, ':');
         if (psz2)
            fprintf(fout, "@%.*s\n@cd \"%s\"\n",
               (int)(psz2-szLineBuf+1),szLineBuf,  // e.g. C:
               psz2+1);   // rest of path, relative to drive
         else
            fprintf(fout, "@cd \"%s\"\n", szLineBuf);
         #else
         fprintf(fout, "cd \"%s\"\n", szLineBuf);
         #endif

         fclose(fout);

         #ifndef _WIN32
         chmod(szRefNameBuf, S_IREAD | S_IWRITE | S_IEXEC);
         #endif

         printf("batch created: %s\n", szRefNameBuf);
         #ifdef _WIN32
         printf("type \"%s\" to reenter %s\n",pszAlias,szLineBuf);
         #else
         printf("type \". %s\" to reenter %s\n",pszAlias,szLineBuf);
         #endif
      }
      bDone = 1;
   }

   // create alias batch
   ifcmd (!strcmp(pszCmd, "alias"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk alias [-list|-del|-ren] [shortname] [=] [command]\n"
             "\n"
             "   create, list, delete or rename command aliases. aliases are\n"
             "   short command names selected by yourself to save typing effort.\n"
             "\n"
             "   $sfk alias shortname = command ...\n"
             "\n"
             "      create an alias. this actually creates a small batch file\n"
             "      in the directory where sfk itself is located.\n"
             "\n"
             "      requirements:\n"
             "      #-  the sfk executable has been copied into some directory x.\n"
             "      #-  this directory x must be in your PATH.\n"
             "      #-  you must have write permission for directory x.\n"
             "      #-  directory x is NOT the current working directory \".\".\n"
             "\n"
             "      if any of these requirements is not met, the command will fail.\n"
             "      for example, if sfk" EXE_EXT " is located just in your current\n"
             "      working directory \".\", copy sfk" EXE_EXT " into a different\n"
             "      directory of the PATH, and then start aliasing.\n"
             "\n"
             "   $see also\n"
             "      sfk mkcd : create an alias remembering the current directory.\n"
             "\n"
             "   $examples\n"
             "      #sfk alias list = \"sfk list\"\n"
             "         creates the alias named \"list\". from now on, you can\n"
             "         type \"list\" instead of \"sfk list\".\n"
             "\n"
             #ifdef _WIN32
             "      #sfk alias wherc = \"sfk list -arc . .jar filter -+%%1.class\"\n"
             #else
             "      #sfk alias wherc = \"sfk list -arc . .jar filter -+\\$$1.class\"\n"
             #endif
             "         creates alias \"wherc\", searching for class files in jars.\n"
             "         after the alias exists, command \"wherc Foo\" executes the\n"
             "         commands from above, listing all class names with \"Foo\".\n"
             #ifdef _WIN32
             "\n"
             "      #sfk alias tab2c \"sfk fromclip +filt -spat -rep _\\t_,_ +toclip\"\n"
             "         then type tab2c to replace tabs by commas within clipboard.\n"
             #endif
             "\n"
             "      #sfk alias copytoday \"sfk run \\\"copy <run>file c:\\tmp\\\" . -today\"\n"
             "         copy all files changed today to c:\\tmp. if double quotes \"\n"
             "         should be part of your command, they must be escaped as \\\"\n"
             #ifdef _WIN32
             "\n"
             "      #sfk alias wide MODE CON COLS=160\n"
             "         extend the current shell window to a width of 160 columns.\n"
             "\n"
             "      #sfk alias ec \"notepad c:\\app\\bin\\%%1.bat\"\n"
             "         provided that c:\\app\\bin is in your path, creates\n"
             "         a command \"ec\" to instantly edit further commands.\n"
             #else
             "\n"
             "      #sfk alias ec \"vi /home/myuser/tools/\\$$1\"\n"
             "         provided that /home/myuser/tools is in your path, creates\n"
             "         a command \"ec\" to instantly edit further commands.\n"
             #endif
             "\n"
             "      #PARAMETER LIMITATION:<def> note that the created batch files\n"
             #ifdef _WIN32
             "      may accept only a maximum of 9 parameters, called %%1 to %%9.\n"
             #else
             "      may accept only a maximum of 9 parameters. they must be typed\n"
             "      with back slash \\$$1 to \\$$9 and will appear as $$1 to $$9\n"
             "      in the created batch script.\n"
             #endif
             "      Further parameters may be ignored, or cannot be addressed.\n"
             "\n"
             "      #USE SURROUNDING QUOTES<def> whenever your command string contains\n"
             "      special characters like %% \\ ! otherwise these chars may be\n"
             "      removed (or misinterpreted) by the command shell.\n"
             "\n"
             "   $sfk alias -list\n"
             "      list all existing aliases. this actually scans the directory\n"
             "      where sfk is located for batch files containing aliases.\n"
             "\n"
             "   $sfk alias shortname\n"
             "      list definition of an existing alias.\n"
             "\n"
             "   $sfk alias -del aliasname\n"
             "      delete an alias (deletes the associated batchfile).\n"
             "\n"
             "   $sfk alias -ren oldname newname\n"
             "      renane an alias (renames the associated batchfile).\n"
            );
      #ifdef SFINT
      printx("\n"
             "   $COMMAND NAME ALIASING:\n"
             "\n"
             "   another way to avoid typing \"sfk\" on every command is this:\n"
             "\n"
             "   - in the directory where sfk is located, create another executable,\n"
             "     for example \"list.exe\", as a link to sfk.exe:\n"
             #ifdef _WIN32
             "        fsutil hardlink create list.exe sfk.exe\n"
             #else
             "        ln -sf sfk list\n"
             #endif
             "\n"
             "   - now simply type \"list\" instead of \"sfk\": sfk will detect that\n"
             "     it's name is no longer \"sfk\", and tries to run the supplied\n"
             "     command name automatically.\n"
             "\n"
             "   - this behaviour can be disabled by " SFK_SETENV_CMD " SFK_CONFIG=ignore-exec-name\n"
             "\n"
             "   if in any doubt what version of sfk is run by the aliased command,\n"
             "   type the new command name with \"-version\" as first parameter.\n"
             );
      #endif
      ehelp;

      // find ourselves, result in szLineBuf
      char *pszSFKCmd = findPathLocation("sfk" EXE_EXT, 1); // 1: exclude work dir
      if (!pszSFKCmd) return 9+perr("cannot find location of sfk" EXE_EXT " within PATH.\n");

      // isolate path of sfk.exe in szRefNameBuf
      szRefNameBuf[0] = '\0';
      char *psz1 = strrchr(pszSFKCmd, glblPathChar);
      if (!psz1) return 9+perr("unable to find path of sfk" EXE_EXT "\n");
      sprintf(szRefNameBuf, "%.*s", (int)(psz1-pszSFKCmd+1),pszSFKCmd);

      if ((nparm >= 1) && !strcmp(argv[iDir], "-list"))
      {
         // list all aliases located parallel to sfk.exe,
         // by scanning the header of all files in it's directory.

         // first continue processing real parameters, if any
         for (iDir++; iDir<argc; iDir++)
         {
            if (isChainStart(pszCmd, argv, argc, iDir, 0))
               break;
            return 9+perr("unexpected: %s\n", argv[iDir]);
         }
         if (btest) return 0;

         // create virual directory parms
         char *pSubArgv[10];
         pSubArgv[0] = "sfk-dummy";
         pSubArgv[1] = "alias-list";
         pSubArgv[2] = "-norec";
         pSubArgv[3] = szRefNameBuf;
         pSubArgv[4] = ".bat";
         #ifdef _WIN32
         int nSubArgc = 5; // win: reduce scan to .bat files
         #else
         int nSubArgc = 4; // linux: no specific file extension, scan all files
         #endif
         int iSubDir  = 3;
         printx("$current aliases from the sfk home %s :\n", szRefNameBuf);

         // process and walk virtual directory parameters
         if (lRC = processDirParms("alias-list", nSubArgc, pSubArgv, iSubDir, 3)) return lRC;
         lRC = walkAllTrees(eFunc_AliasList, lFiles, lDirs, nBytes);

         // complete real parameters, just to find iDirNext
         int iDirNext = 0;
         long lRC2 = 0;
         if (lRC2 = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext)) return lRC2;

         // now continue chain, e.g. filtering, if any
         if (chain.coldata) {
            STEP_CHAIN(iDirNext, 1);
         } else {
            STEP_CHAIN(iDirNext, 0);
         }

         bDone = 1;
      }
      else
      if ((argc > 3) && !strcmp(argv[2], "-del"))
      {
         // delete one or more aliases
         if (blockChain("alias -delete", iDir, argc, argv, 2)) // 2: no pinf
            return 9;
   
         for (iDir=3; iDir < argc; iDir++)
         {
            char *pszToDel = argv[iDir];
            sprintf(szLineBuf, "%s%s", szRefNameBuf, pszToDel);
            #ifdef _WIN32
            strcat(szLineBuf, ".bat");
            #endif

            // check if it's really an alias batch
            FILE *fin = fopen(szLineBuf, "r");
            if (!fin) 
               { perr("%s - no such file\n",szLineBuf); continue; }
            if (!fgets(szLineBuf2, sizeof(szLineBuf2), fin))
               { perr("%s - no data\n",szLineBuf); fclose(fin); continue; }
            fclose(fin);
            if (strncmp(szLineBuf2, pszGlblAliasBatchHead, strlen(pszGlblAliasBatchHead)))
               { perr("%s - no valid alias batch, will not delete.\n",szLineBuf); continue; }

            if (remove(szLineBuf))
               perr("%s - cannot delete file\n",szLineBuf);
            else
               printf("alias deleted: %s\n", szLineBuf);
         }
         bDone = 1;
      }
      else
      if ((argc >= 5) && !strcmp(argv[2], "-ren"))
      {
         // rename an alias
         if (blockChain("alias -rename", iDir, argc, argv, 2)) // 2: no pinf
            return 9;

         char *pszFrom = argv[3];
         char *pszTo   = argv[4];

         sprintf(szLineBuf, "%s%s", szRefNameBuf, pszFrom);
         #ifdef _WIN32
         strcat(szLineBuf, ".bat");
         #endif

         sprintf(szLineBuf2, "%s%s", szRefNameBuf, pszTo);
         #ifdef _WIN32
         strcat(szLineBuf2, ".bat");
         #endif

         if (fileExists(szLineBuf2))
            return 9+perr("%s already exists, rename failed.\n", szLineBuf2);

         // check if it's really an alias batch
         FILE *fin = fopen(szLineBuf, "r");
         if (!fin) 
            return 9+perr("%s - no such file\n",szLineBuf);
         if (!fgets((char*)abBuf, sizeof(abBuf), fin))
            { fclose(fin); return 9+perr("%s - no data\n",szLineBuf); }
         fclose(fin);
         if (strncmp((char*)abBuf, pszGlblAliasBatchHead, strlen(pszGlblAliasBatchHead)))
            return 9+perr("%s - no valid alias batch, will not rename.\n",szLineBuf);

         if (rename(szLineBuf, szLineBuf2))
            perr("%s - cannot rename to %s\n",szLineBuf,szLineBuf2);
         else
            printf("alias renamed: %s\n", szLineBuf2);

         bDone = 1;
      }
      else
      if (argc == 3)
      {
         // list single alias
         if (blockChain("alias [show]", iDir, argc, argv, 2)) // 2: no pinf
            return 9;

         char *pszAlias = argv[2];
         strcat(szRefNameBuf, pszAlias);
         char *pszRel = szRefNameBuf + strlen(szRefNameBuf);
         #ifdef _WIN32
         strcat(szRefNameBuf, ".bat");
         #endif
         bool bIsAlias = 0;
         execAliasList(szRefNameBuf, &bIsAlias);
         if (!bIsAlias)
         {
            printf("No sfk alias \"%s\" is defined", pszAlias);
            long nhits = listPathAny(pszAlias, 1); // silent
            if (nhits > 0) {
               printf(", but path contains:\n");
               listPathAny(pszAlias, 0); // loud
            }
            else printf(".\n");
         }
         bDone = 1;
      }
      else
      {
         // create new alias
         if (blockChain("alias [create]", iDir, argc, argv, 2)) // 2: no pinf
            return 9;

         if (checkArgCnt(argc, 4)) return 9;
         char *pszAlias = argv[2];
   
         // create batch filename parallel to sfk.exe
         char *pszRel = szRefNameBuf+strlen(szRefNameBuf);
         strcat(szRefNameBuf, pszAlias);
         #ifdef _WIN32
         strcat(szRefNameBuf, ".bat");
         #endif
         char nReply = 'y';
         if (fileExists(szRefNameBuf)) {
            printf("%s exists, overwrite? (yes/no) ",szRefNameBuf);
            fflush(stdout);
            nReply = getYNAchar();
         }
         if (nReply == 'y') 
         {
            // open output batchfile
            FILE *fout = fopen(szRefNameBuf, "w");
            if (!fout) return 9+perr("cannot write batch file: %s\n", szRefNameBuf);

            // write alias batch header for later re-identification.
            fprintf(fout, "%s\n", pszGlblAliasBatchHead);

            bool  bHaveAnySubst = 0;
            uchar aHaveSubst[20];
            memset(aHaveSubst, 0, sizeof(aHaveSubst));

            // collect ALL further parameters, add
            iDir = 3;
            int nAdd = 0;
            if (!strcmp(argv[iDir], "="))
                iDir++;
            #ifdef _WIN32
            fprintf(fout, "@"); // silent, don't list command on execution
            #endif
            while (iDir < argc) {
               char *psz3 = argv[iDir];
               // check if user supplies parameter substitution
               for (long i=1; i<10; i++) {
                  #ifdef _WIN32
                  sprintf(szLineBuf, "%%%ld", i);
                  #else
                  sprintf(szLineBuf, "$%ld", i);
                  #endif
                  if (strstr(psz3, szLineBuf)) {
                     bHaveAnySubst = 1;
                     aHaveSubst[i] = 1;
                  }
               }
               fprintf(fout, "%s ", argv[iDir]);
               iDir++;
               nAdd++;
            }
   
            if (nAdd == 0)
               perr("missing parameters after \"=\"\n");
            else {
               // finalize: add support for not yet used substitution parms
               if (!bHaveAnySubst) {
                  #ifdef _WIN32
                  fprintf(fout, "%%*");   // pass ALL parms (.bat)
                  #else
                  fprintf(fout, "$@");    // pass ALL parms (bash)
                  #endif
               }
               else
               for (long i=1; i<10; i++)
                  if (!aHaveSubst[i])
                     #ifdef _WIN32
                     fprintf(fout, "%%%ld ", i);
                     #else
                     fprintf(fout, "$%ld ", i);
                     #endif
            }
   
            fclose(fout);

            #ifndef _WIN32
            chmod(szRefNameBuf, S_IREAD | S_IWRITE | S_IEXEC);
            #endif

            printx("$batch created: %s\n", szRefNameBuf);
            char *pszTmp = loadFile(szRefNameBuf);
            if (pszTmp) {
               printf("%s",pszTmp);
               long nLen = strlen(pszTmp);
               if ((nLen > 0) && (pszTmp[nLen-1] != '\n'))
                  printf("\n");
               delete [] pszTmp;
            }
            printx("$type \"%s\" to use.\n", pszAlias);
         }
         bDone = 1;
      }
   }

   regtest("replace -text /src/dst/ -file xfile1 xfile2");
   regtest("rep -binary /A0A1A2/B5B6B7/ -dir xdir -file .dat -yes");
   regtest("rep -dump -wide -context=20 -bylist xreplist.txt -dir . -file xfile1 xfile2");
   regtest("list xdir .txt +rep /foo/bar/");

   bool bIsHexFind = 0;

   ifcmd (   !strcmp(pszCmd, "rep") || !strcmp(pszCmd, "replace")    // +chaining
          || !strcmp(pszCmd, "hexfind")
         )
   {
      bool bIsFind = bIsHexFind = !strcmp(pszCmd, "hexfind");

      ifhelp (   ( chain.usefiles && (nparm < 1))
              || (!chain.usefiles && (nparm < 2))
             )
      printx("<help>$sfk replace singleFile [-text] /src/dst/ [pattern2] [...] [-yes]\n"
             "$sfk rep[lace] -[s]pat -bin[ary] /A0A1A2/B5B6B7/ -dir anydir -file .ext1 [-yes]\n"
             "$sfk hexfind [-nodump] -pat /pattern/ -dir anydir -file .ext1 [.ext2]\n"
             "$sfk replace [-dump [-wide]]]] -bylist words.txt file1 [file2 ...] [-yes]\n"
             "\n"
             "   search and replace text or byte blocks (specified as hex code)\n"
             "   within text or binary files. if multiple patterns are given,\n"
             "   then each of them is searched independently (OR combination).\n"
             "\n"
             "   by default, this function runs in SIMULATION mode, previewing hits\n"
             "   without changing anything. specify -yes to really apply the changes.\n"
             "\n"
             "   multiple patterns are executed in the given sequence. Mind this if they\n"
             "   overlap, e.g. /foo/bar/ /foosys/thesys/ makes no sense (foo is replaced\n"
             "   by the first expression, so the 2nd one will always fail to match).\n"
             "\n"
             "   replacing source / target patterns #of different length<def> is slower\n"
             "   and may require much memory compared to replacements #of same length<def>.\n"
             "\n"
             "   #no wildcards are supported.<def> if you need to replace text by wildcards\n"
             "   within ASCII text files, use \"sfk filter\" with -replace ... -write.\n"
             "\n"
             "   $subdirectories are included by default!\n"
             "      the sfk default for most commands is to process the given directories,\n"
             "      #as well as all subdirs within them<def>. specify -nosub to disable this.\n"
             "\n"
             "   $options:\n");
             #ifdef VFILEBASE
      if (cs.xelike)
      printx("      -arc          : hexfind only: include content of .zip .jar etc. archives.\n");
             #endif // VFILEBASE
      printx("      -nosub        : do not include files in subdirectories.\n"
             "      -quiet        : do not print progress status and total hits statistics.\n"
             "      -case         : case-sensitive text comparison. default is case-insensitive\n"
             "                      comparison for all -text strings, but NOT for -bin blocks.\n"
             "                      case-sensitive comparison is faster then case-insensitive.\n"
             "      -nocase       : force case-insensitive comparison ALSO on -bin patterns.\n"
             "      -pat          : starts a list of text replacement patterns of the form\n"
             "                      xsrcxdstx where x is the separator char, src the source\n"
             "                      to search for, and dst the destination to replace it with.\n"
             "                      e.g. /foo/bar/ or _foo_bar_ both replace foo by bar.\n"
             "                      -pat is not required if a singleFile name is given.\n"
             "      -text         : the same as -pat, starting a text replace pattern list.\n"
             "      -spat         : the same, but also activates slash patterns like \\t\n"
             "      -bin[ary]     : starts a list of binary replace patterns, specified\n"
             "                      as hexcode like /0A0D/2020/\n"
             "      -dump [-lean] : create hexdump of hits, listing  8 bytes per line.\n"
             "                      also previews changes on replacements of same length.\n"
             "      -dump -wide   : create hexdump of hits, listing 16 bytes per line;\n"
             "                      requires a shell window with at least 120 columns.\n"
             "      -nodump       : hexfind dumps by default. specify -nodump to disable.\n"
             "      -reldist      : for each hit, tell relative distance to previous hit.\n"
             "      -context=n    : with -dump, show additional n bytes of context.\n"
             "      -bylist x.txt : read replacement patterns from a file (example below).\n"
             "      -memlimit=nm  : with different-length replacements, files must be loaded\n"
             "                      into memory for processing. the default limit for memory\n"
             "                      use is 300 MB. set -memlimit=500m to select 500 MB.\n"
             "\n"
             "   #Run a simulation first,<def> to see what would be changed. Changing binaries\n"
             "   may lead to unpredictable results, therefore keep backups in any case.\n"
             "\n"
             "   $return codes for batch files\n"
             "      0 = no matches, 1 = matches found, >1 = major error occurred.\n"
             "      see also \"sfk help opt\" on how to influence error processing.\n"
             "\n");
      printx("   $see also\n"
             "      #sfk filter mytext.txt -replace _from_to_ -write\n"
             "      #sfk select mydir .txt +ffilter -replace _from_to_ -write\n"
             "         flexible, line based text processing which also supports\n"
             "         the * and ? wildcards. type \"sfk filter\" for more.\n"
             "\n"
             );
      printx("   $examples\n"
             "      #sfk replace myfile.dat /Lemon/Curry/\n"
             "         replace Lemon by Curry within myfile.dat. search is\n"
             "         case-insensitive, therefore \"lemon\" will be replaced as well.\n"
             "      #sfk replace -pat /FooCase// -dir . -file .txt\n"
             "         search for FooCase in all .txt files below current directory.\n"
             "         note that if you leave out the single fileOrDir parameter,\n"
             "         you have to say -[s]pat, -bin or -text first to tell clearly\n"
             "         that you will specify the target fileset later on.\n"
             "      #sfk rep -spat \"/The foo/The\\tbar/\" -dir mydocs\n"
             "         replaces \"The foo\" by \"The\" and \"bar\" separated by TAB char,\n"
             "         within all files within mydocs.\n"
             "      #sfk rep -binary /1A/20/ -dir docs -file .txt .info .note\n"
             "         replaces all bytes with code 0x1A by code 0x20, in all .txt,\n"
             "         .info and .note files, in directory docs and all subdirectories.\n"
             "      #sfk replace tmp\\image.dat -bylist patches.txt\n"
             "         searches for source patterns in file tmp\\image.dat,\n"
             "         replaces by patterns specified in patches.txt\n"
             "\n"
             "      #example for a -bylist replacement pattern file:\n"
             "         :text\n"
             "         /foobar/barfoo/\n"
             "         _the test_the text_\n"
             "         :binary\n"
             "         /0d0a/200a/\n"
             );
      printx("         :# remark and blank lines are skipped.\n");
      printx("\n"
             "      #sfk hexfind mydir -pat /FooCase/ +list -late\n"
             "         do not replace, just find binary files containing \"FooCase\",\n"
             "         then list them sorted by time. also accepts -bylist files.\n"
             "\n");
      ehelp;

      char *pszRepFile  = 0;
      bool  bRevert     = 0;
      long  nstate      = 0;
      char *pszFirstPat = 0;
      bool bGotFileDir  = 0;
      bool bcolpat      = 0;
      bool bforcedump   = 0;

      cs.repDumpHalve   = bIsHexFind;

      #ifdef VFILEBASE
      if (bIsHexFind) cs.precachezip = 1;
      #endif // VFILEBASE

      memset(abBuf, 0, sizeof(abBuf)); // for direct patterns

      // autoselect hex dump width by console width
      if (bGlblConsColumnsSet && (nGlblConsColumns >= 120))
         bGlblHexDumpWide = 1;

      // autoselect dump with binfind
      if (bIsHexFind) cs.repDump = 1;

      int iDirFirst = iDir;
      for (; iDir<argc; iDir++) 
      {
         // "-" parms
         // if (!strncmp(argv[iDir], "-", 1))
         //   bcolpat = 0; // no options between patterns
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-bylist", &pszParm)) {
            if (!pszParm) return 9;
            pszRepFile = pszParm;
            continue;
         }
         if (!strcmp(argv[iDir], "-revert")) {
            bRevert = 1; // internal
            continue;
         }
         if (!strcmp(argv[iDir], "-text")) {
            bcolpat = 1;
            nstate = 1;
            strcat((char*)abBuf, ":text\n");
            continue;
         }
         if (!strncmp(argv[iDir], "-bin", 4)) {
            bcolpat = 1;
            nstate = 2;
            strcat((char*)abBuf, ":binary\n");
            continue;
         }
         if (!strcmp(argv[iDir], "-dump")) {
            cs.repDump = 1;
            bforcedump = 1;
            continue;
         }
         if (!strcmp(argv[iDir], "-nodump")) {
            cs.repDump = 0;
            continue;
         }
         if (!strcmp(argv[iDir], "-wide")) {
            bGlblHexDumpWide = 1;
            continue;
         }
         if (!strncmp(argv[iDir], "-pat", 4)) {
            bcolpat = 1;
            continue;
         }
         if (!strncmp(argv[iDir], "-spat", 5)) {
            bcolpat = 1;
            cs.spat = 1;
            continue;
         }
         if (!strcmp(argv[iDir], "-reldist")) {
            cs.reldist = 1;
            continue;
         }
         if (!strcmp(argv[iDir], "-lean") || !strcmp(argv[iDir], "-narrow"))
         {
            bGlblHexDumpWide = 0;
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-context", &pszParm)) {
            if (!pszParm) return 9;
            nGlblDumpCtx = atol(pszParm);
            continue;
         }
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir])) {
               break; // fall through
            }
            if (setGeneralOption(argv, argc, iDir)) {
               continue;
            } else {
               return 9+perr("unknown option: %s\n", argv[iDir]);
            }
         }
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
 
         // non "-" parms
         if (!bcolpat && !chain.usefiles && !bGotFileDir) // && (iDir == iDirFirst)
         {
            // single dir or file specified.
            bGotFileDir = 1;
            Coi ocoi(argv[iDir], 0);
            if (ocoi.isTravelDir()) {
                if (bIsHexFind) {
                   if (lRC = setProcessSingleDir(argv[iDir]))
                      return lRC;
                } else {
                   perr("no single directory supported with replace.\n");
                   pinf("specify -dir %s -file ... after the patterns.\n", argv[iDir]);
                   return 9;
                }
            } else {
                if (!ocoi.existsFile()) {
                   perr("no such file or dir: %s\n", argv[iDir]);
                   pinf("if this is a pattern, say -pat %s\n", argv[iDir]);
                   return 9;
                }
                glblSFL.addEntry(ocoi); // is copied
                // cs.pure = 1;
            }
            bGlblShortSyntax = 1;
            continue;
         }
 
         // expecting patterns either after fileOrDir or -pat
         if (!pszRepFile) {
            if (nstate == 0) {
               // implicitely guess -text by default
               nstate = 1;
               strcat((char*)abBuf, ":text\n");
               bcolpat = 1;
            }
            if (bcolpat) {
               // add another /src/dst/ pattern string
               if (!pszFirstPat) pszFirstPat = argv[iDir];
               strcat((char*)abBuf, argv[iDir]);
               strcat((char*)abBuf, "\n");
               continue;
            }
         }
 
         return 9+perr("unexpected: %s\n", argv[iDir]);
         // continue w/next pattern, option or chain cmd.
      }
 
      if (btest) return 0;

      char *pszRepList = 0;

      if (pszRepFile) {
         if (strlen((char*)abBuf))
            return 9+perr("cannot combine patterns on command line with -bylist file.\n");
         pszRepList = loadFile(pszRepFile);
         if (!pszRepList)
            return 9+perr("unable to load -bylist file \"%s\"\n",pszRepFile);
      } else {
         if (!strlen((char*)abBuf)) {
            perr("no patterns found for processing.\n");
            pinf("say -text /src/dst/ or -binary _src_dst_ or -bylist file.txt\n");
            pinf("specify -dir or -file after patterns only.\n");
            return 9;
         }
         pszRepList = strdup((char*)abBuf);
      }
 
      // create replacement expression table

      // 1. estimate size, allocate
      long nLines = 0;
      char *psz1 = pszRepList;
      for (; *psz1; psz1++) if (*psz1 == '\n') nLines++;
      long nMaxExp = nLines; // max. replacement array entries
      apRepSrcExp = new uchar*[nMaxExp];
      apRepDstExp = new uchar*[nMaxExp];
      apRepSrcLen = new long[nMaxExp];
      apRepDstLen = new long[nMaxExp];
      apRepFlags  = new long[nMaxExp];
      apRepOffs   = new num[nMaxExp];
      memset(apRepFlags, 0, sizeof(long)*nMaxExp);
      if (!apRepSrcExp || !apRepDstExp || !apRepSrcLen || !apRepDstLen || !apRepFlags)
         return 9+perr("out of memory\n");

      // REMEMBER PATTERN MEMORY ON RETURN.
      // In case of parameter errors, nGlblError must be set,
      // to avoid memory leak checks on exit.

      long nLenErrLine = -1;
      bool btold1 = 0;
      bool bVarMode = 0;
 
      // 2. parse expressions
      nstate = 0;
      char *psz2  = 0;
      long nLine  = 0;
      for (psz1 = pszRepList; psz1 && (*psz1); psz1=psz2) 
      {
         // fetch and prepare line
         nLine++;
         psz2 = strchr(psz1, '\n');
         if (!psz2) psz2 = psz1+strlen(psz1);
         *psz2++ = '\0';
         char *psz3 = strchr(psz1, '\r');
         if (psz3) *psz3 = '\0';
         if (!*psz1) continue; // empty line
         if (!strncmp(psz1, ":#", 2)) continue; // remark
         // process line
         if (!strcmp(psz1, ":text"))
            { nstate=1; continue; }
         else
         if (!strcmp(psz1, ":binary"))
            { nstate=2; continue; }
         else
         if (!nstate || (*psz1 == ':')) {
            nGlblError=1;
            return 9+perr("unexpected command in replacement table: %s (use :text or :binary)\n",psz1);
         }
         // within expression block /from/tooo/
         char *pszfs = psz1; // from, start
         char cLimit = *pszfs++;
         if (!cLimit) break;
         if (!*pszfs) return 9+reperr("incomplete replacement pattern", psz1);
         char *pszfe = strchr(pszfs, cLimit);
         if (!pszfe) return 9+reperr("incomplete replacement pattern", psz1);
         char *pszts = pszfe+1;
         char *pszte = strchr(pszts, cLimit);
         if (!pszte) {
            if (bIsHexFind) {
               // accept /foo/ and /foo// but not /foo/any
               if (*pszts)
                  return 9+reperr("wrong find pattern, missing delimiter", psz1);
               pszte = pszts;
            } else {
               return 9+reperr("incomplete replacement pattern", psz1);
            }
         }
         // check for garbage after closing delimiter
         if (pszte && (strlen(pszte) > 1))
            return 9+reperr("wrong pattern, check delimiters", psz1);
         // pszfs is exact start of from
         // pszfe is one after end of from
         *pszfe = '\0';
         // same for pszts, pszte
         *pszte = '\0';
         // shrink \\t and the like in both expressions
         long nFromLen = pszfe-pszfs;
         long nToLen   = pszte-pszts;
         if (shrinkFormTextBlock(pszfs, nFromLen)) return 9+reperr("wrong syntax in pattern", pszfs);
         if (shrinkFormTextBlock(pszts, nToLen))   return 9+reperr("wrong syntax in pattern", pszts);
         // => nFromLen, nToLen may have been reduced.
         if (!bIsHexFind && nFromLen != nToLen && nLenErrLine == -1) {
            // different source / pattern length: select variable mode
            bVarMode = 1;
            cs.repDumpHalve = 1;
         }
         if (bRevert) {
            long nSwap=nFromLen; nFromLen=nToLen; nToLen=nSwap;
            char *pSwap=pszfs; pszfs=pszts; pszts=pSwap;
                  pSwap=pszfe; pszfe=pszte; pszte=pSwap;
         }
         // store source and target.
         if (nstate == 1) {
            // as text
            apRepSrcLen[nBinRepExp] = nFromLen;
            apRepDstLen[nBinRepExp] = nToLen;
            apRepSrcExp[nBinRepExp] = (uchar*)mymemdup(pszfs, nFromLen);
            apRepDstExp[nBinRepExp] = (uchar*)mymemdup(pszts, nToLen);
            apRepFlags[nBinRepExp]  = (0 << 0); // is text
            nBinRepExp++;
         } else {
            // as binary
            if (nFromLen & 1) return 9+reperr("wrong length of hex expression",pszfs,nLine);
            if (nToLen   & 1) return 9+reperr("wrong length of hex expression",pszts,nLine);
            long nSrcBinLen = nFromLen / 2;
            long nDstBinLen = nToLen   / 2;
            apRepSrcLen[nBinRepExp] = nSrcBinLen;
            apRepDstLen[nBinRepExp] = nDstBinLen;
            apRepSrcExp[nBinRepExp] = new uchar[nSrcBinLen+10];
            apRepDstExp[nBinRepExp] = new uchar[nDstBinLen+10];
            if (hexToBin(pszfs, apRepSrcExp[nBinRepExp], nSrcBinLen))
               return 9+reperr("syntax error in hex expression",pszfs,nLine);
            if (hexToBin(pszts, apRepDstExp[nBinRepExp], nDstBinLen))
               return 9+reperr("syntax error in hex expression",pszts,nLine);
            apRepFlags[nBinRepExp]  = (1 << 0); // is binary
            nBinRepExp++;
         }
      }

      if (!nBinRepExp)
         { nGlblError=1; return 9+perr("no patterns for replacement, nothing to do.\n"); }

      int iDirNext=0;
      if (iDir < argc)
         if (lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext))
            { nGlblError=1; return lRC; }

      if (!chain.usefiles && !bGotFileDir && !glblFileSet.rootDirs().numberOfEntries()) {
         perr("please specify a fileset using -dir ... -file ...\n");
         if (pszFirstPat)
            pinf("if %s is a filename, specify it BEFORE -spat or -pat.\n", pszFirstPat);
         nGlblError=1;
         return 9;
      }

      if (cs.yes && (nLenErrLine != -1)) {
         nGlblError=1;
         if (pszRepFile)
            return 9+perr("length mismatch in line %ld: source and target pattern must have same length\n",nLine);
         else
            return 9+perr("length mismatch: source and target pattern must have same length\n");
      }

      cs.sim = !cs.yes;

      // plausi checks:
      if (chain.colfiles) {
         if (cs.sim && !bIsHexFind) {
            perr("cannot chain output this way. say \"hexfind\" instead.\n");
            nGlblError=1;
            return 9;
         }
         cs.nohead  = 1;
         cs.quiet = 1;
         // if collecting filenames, hexdump only if requested.
         cs.repDump = bforcedump;
      }
      // - no replace with binfind
      if (bIsHexFind) {
         if (!cs.sim) {
            nGlblError=1;
            return 9+perr("cannot replace with hexfind. say \"replace\" instead.\n");
         }
         cs.nohead = 1;
         bGlblHexDumpWide = 1; // always wide, listing just source part
      }
      // -to ... not yet supported
      if (cs.tomask)
         { nGlblError=1; return 9+perr("-to not yet supported with %s\n", pszCmd); }

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      if (!cs.quiet)
         chain.print('h', 0, "[total hits/matching patterns/non-matching patterns]\n");

      if (bVarMode && cs.sim && cs.repDump) {
         bVarMode = 0;        // varrep in simulation: use replacefix for hexdump
         cs.repDumpHalve = 1; // only source hits, no replacement preview
      }

      if (bVarMode)
         lRC = walkAllTrees(eFunc_ReplaceVar, lFiles, lDirs, nBytes);
      else
         lRC = walkAllTrees(eFunc_ReplaceFix, lFiles, lDirs, nBytes);
      if (!lRC && (cs.filesChg > 0)) lRC = 1; // any hits or changes

      if (!chain.colfiles) {
         if (bIsHexFind)
            chain.print("%ld files checked, %ld files matched.\n", cs.files, cs.filesChg);
         else
            chain.print("%ld files checked, %ld%s changed.\n", cs.files, cs.filesChg, cs.sim?" would be":"");
      }

      if (nLenErrLine != -1) {
         setTextColor(nGlblTimeColor);
         const char *pextinf = cs.verbose ? "" : " (-verbose for more)";
         if (pszRepFile)
            printf("source and target patterns have differing length, line %ld%s.\n",nLine,pextinf);
         else
            printf("source and target patterns have differing length%s.\n",pextinf);
         setTextColor(-1);
      }

      if (cs.sim && bVarMode && cs.verbose) {
         pinf("source and target patterns have differing lengths. replacement may be slow.\n");
      }

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      for (long i=0; i<nBinRepExp; i++) {
         delete [] apRepSrcExp[i];
         delete [] apRepDstExp[i];
      }

      delete [] apRepSrcExp;
      delete [] apRepDstExp;
      delete [] apRepSrcLen;
      delete [] apRepDstLen;
      delete [] apRepFlags;
      delete [] apRepOffs;
      delete [] pszRepList;

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }
  
   // internal
   if (!strcmp(pszCmd, "touch"))
   {
      if (argc < 3) return 9+perr("supply yyyymmddhhmmss file\n");
      char *pszTime = 0;
      char *pszSrc = 0;
      char *pszDst = 0;
      num nTime = 0;
      if (argc == 3) {
         pszSrc = argv[2];
         pszDst = argv[2];
         nTime = (num)getSystemTime();
      }
      else 
      if (argc == 4) {
         pszTime = argv[2];
         pszSrc  = argv[3];
         pszDst  = argv[3];
         if (timeFromString(pszTime, nTime)) return 9;
      }
      else {
         if (strcmp(argv[2], "-from")) return 9+perr("unknown option, -from expected: %s\n",argv[2]);
         pszSrc  = argv[3];
         pszDst  = argv[4];
      }
      FileStat ofs;
      if (ofs.readFrom(pszSrc))  return 9;
      if (nTime) {
         ofs.src.nMTime = nTime;
         ofs.src.nCTime = nTime;
         #ifdef _WIN32
         ofs.src.nHaveWFT = 0;
         #endif
      }
      if (ofs.writeTo(pszDst, __LINE__))   return 9;
      bDone = 1;
   }

   // internal
   if (!strcmp(pszCmd, "nmatch"))
   {
      char *pszMask = argv[2];
      char *pszStr  = argv[3];
      bool bPart    = 0;
      bool bmatch   = matchesName(pszStr, pszMask, &bPart);
      printf("%d = match(mask %s,str %s) %d\n",bmatch,pszMask,pszStr,bPart);
      return 0;
   }

   // internal
   if (!strcmp(pszCmd, "striq"))
   {
      char *pszHay = argv[2];
      char *pszNed = argv[3];
      long npos = 0;
      long nrc = mystrstriq(pszHay, pszNed, &npos);
      printf("%d = mystrstriq(str %s,mask %s) @%ld\n",nrc,pszHay,pszNed,npos);
      return 0;
   }

   // internal
   if (!strcmp(pszCmd, "info"))
   {
      printf("testing getCurrentTime():\n");
      #ifndef _WIN32
      struct timeval tv;
      gettimeofday(&tv, NULL);
      printf("tv_sec %ld usec %ld\n",tv.tv_sec,tv.tv_usec);
      num nval = tv.tv_sec + tv.tv_usec / 1000;
      printf("nval dec %s\n",numtoa(nval));
      printf("nval hex %s\n",numtohex(nval));
      #endif
      printf("testing info:\n");
      info.setStatus("verb", "subject", "addinfo", eNoCycle);
      info.printLine();
      printf("interactiveConsole=%d\n",bGlblHaveInteractiveConsole);
      return 0;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "ansitooem"))
   {
      char szBuf[20];
      for (ulong i=0; i<256; i++) {
         uchar cansi = (uchar)i;
         szBuf[0] = (char)cansi;
         szBuf[1] = '\0';
         CharToOemA(szBuf, szBuf+10);
         uchar coem = szBuf[10];
         printf("0x%02lX,0x%02lX, ", (ulong)cansi, (ulong)coem);
      }
      return 0;
   }
   #endif

   #ifdef _WIN32
   if (!strcmp(pszCmd, "mdx"))
   {
      char *pszFile = argv[2];
      uchar abmd[20];
      memset(abmd, 0, sizeof(abmd));
      long lrc = getFileMD5NoCache(pszFile, abmd, 0);
      printf("%ld = md5nocache: ", lrc);
      for (long i=0; i<16; i++)
         printf("%02X",abmd[i]);
      printf(" errno %ld lasterr %ld\n",(long)errno, GetLastError());
      return 0;
   }
   #endif

   if (!strcmp(pszCmd, "fileage"))
   {
      char *pszFile = argv[2];
      num nage = getFileAge(pszFile);
      printf("%s sec, %ld days\n", numtoa(nage), (long)(nage / (24 * 3600)));
      return 0;
   }

   #ifdef _WIN32
   ifcmd (!strcmp(pszCmd, "toclip"))
   {
      ifhelp ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
      printx("<help>$sfk toclip<def>\n"
             "\n"
             "   copy text to clipboard.\n"
             "\n"
             "   $examples\n"
             "      #echo hello | sfk toclip\n"
             "         copy the word hello to clipboard\n"
             "\n"
             "      #sfk sel mydir +toclip\n"
             "         copy a directory listing to clipboard\n"
            );
      ehelp;

      // copy stdin or chain text to clipboard

      // calling this only for chaining support:
      int iDirNext=0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 0, &iDirNext))
         return lRC;

      StringTable st;
      long nSize = 0;

      if (chain.usedata) {
         // take text from chain
         while (!chain.indata->eod()) {
            char *psz = chain.indata->read(0);
            mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
            removeCRLF(szLineBuf);
            st.addEntry(szLineBuf);
            nSize += strlen(szLineBuf) + 2;
         }
      } else {
         myfgets_init();
         while (myfgets(szLineBuf, MAX_LINE_LEN, stdin))
         {
            szLineBuf[MAX_LINE_LEN] = '\0';
            removeCRLF(szLineBuf);
            st.addEntry(szLineBuf);
            nSize += strlen(szLineBuf) + 2;
         }
      }

      char *pszTmp = new char[nSize+1000];
      if (!pszTmp) return 9+perr("out of memory\n");
      pszTmp[0] = '\0';
      long nLines = st.numberOfEntries();
      long iout=0;
      for (long i=0; i<nLines; i++)
      {
         char *psz = st.getEntry(i, __LINE__);
         long nLen = (long)strlen(psz);
         if (iout+nLen < nSize)
         {
            strcat(pszTmp, psz);
            strcat(pszTmp, "\r\n");
            iout = strlen(pszTmp);
         }
         else
            break;
      }
      putClipboard(pszTmp);
      delete [] pszTmp;

      STEP_CHAIN(iDirNext, 0);   // no chain output was created

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "fromclip"))
   {
      ifhelp ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
      printx("<help>$sfk fromclip [-wait] [-clear]<def>\n"
             "\n"
             "   dump plain text from clip to terminal.\n"
             "\n"
             "   $options\n"
             "\n"
             "      - wait   wait until plain text is available.\n"
             "      - clear  empty clipboard after use.\n"
             "\n"
             "   $examples\n"
             "\n"
             "      #sfk fromclip +filter -rep x/x\\x +toclip\n"
             "         change all / into \\ within the clipboard text\n"
            );
      ehelp;

      bool bWait = 0;
      bool bClear = 0;
      int iChainNext = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-wait"))
            bWait = 1;
         else
         if (!strcmp(argv[iDir], "-clear"))
            bClear = 1;
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (btest) return 0;

      // now get the clipboard data:

      char *pszClip = 0;

      while (!IsClipboardFormatAvailable(CF_TEXT)) {
         if (!bWait)
            return 5+perr("no plain text in clipboard\n");
         Sleep(250);
      }

      if (!OpenClipboard(0)) // GetDesktopWindow())) 
         return 5+perr("failed to open clipboard\n");
      HGLOBAL hglb = GetClipboardData(CF_TEXT); 
      if (hglb == NULL) {
         perr("no clipboard data available\n");
      } else {
         char *pMem = (char*)GlobalLock(hglb); 
         if (pMem != NULL)
            pszClip = strdup(pMem);
         GlobalUnlock(hglb);
      }

      // clear the clipboard?
      if (bClear)
         EmptyClipboard();

      CloseClipboard();

      // we're now owner of pszClip.
 
      if (chain.colany()) {
         // do not dump to terminal, but to chain buffer:
         num nlen = strlen(pszClip);
         num iin  = 0;
         // split into buffer records.
         while (iin<nlen) {
            long ibuf = 0;
            for (; iin<nlen; iin++) {
               char c = pszClip[iin];
               if (c == '\r')
                  continue;
               if (c == '\n')
                  { iin++; break; }
               szLineBuf[ibuf++] = c;
               if (ibuf >= MAX_LINE_LEN-10)
                  break; // hard line wrap
            }
            szLineBuf[ibuf] = '\0';
            chain.addLine(szLineBuf, "");
         }         
      } else {
         // pszClip MAY contain 0D0A format, but writing to stdout
         // also converts every 0A to 0D0A. filter 0D's out.
         num nlen = strlen(pszClip);
         for (num i=0; i<nlen; i++) {
            char c = pszClip[i];
            if (c == '\r')
               continue;
            putchar(c);
         }
      }
 
      delete [] pszClip;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "sleep")) // +chaining
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk sleep msec\n"
             "\n"
             "   delay execution for a number of milliseconds.\n"
             "\n"
             "   $usage example:\n"
             "\n"
             "      runapache.bat:\n"
             "      #start sfk sleep 3000 +tail -f logs\\access.log -pat \"GET * 404 \"\n"
             "      #apache.exe\n"
             "\n"
             "         creates an error log viewer, and runs apache in parallel.\n"
             "         sfk will wait 3 seconds before tail goes active.\n"
             );
      ehelp;

      long nmsec = -1;

      for (; iDir<argc; iDir++) 
      {
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
         }
         else
         if (nmsec < 0) {
            // process non-option keywords
            char *psz = argv[iDir];
            if (!isdigit(*psz))
               return 9+perr("wrong number format: %s\n", psz);
            nmsec = atol(psz);
            continue;
         }
         return 9+perr("unexpected parameter: \"%s\" (8)\n", argv[iDir]);
      }

      doSleep(nmsec);

      // calling this only for chaining support:
      int iDirNext=0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext)) return lRC;

      // we haven't collected any filenames, but maybe previous
      // commands have, so keep chain list as it is.
      STEP_CHAIN(iDirNext, 0);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "pause")) // +chaining
   {
      ifhelp ((iDir < argc) && isHelpOpt(argv[iDir]))
      printx("<help>$sfk pause [text]<def>\n"
             "\n"
             "   wait for user input before continuing command execution.\n"
      //     "\n"
      //     "   $options\n"
      //     "      -maxwait=n   without input, continue after n milliseconds.\n"
             "\n"
             "   $see also\n"
             "      sfk sleep    delay execution for a given time.\n"
             "\n"
             "   $examples\n"
             "      #sfk echo hello +pause\n"
             "         prints hello and then waits.\n"
            );
      ehelp;

      char *pszText  = 0;
      long  ntimeout = 0;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-maxwait", &pszParm)) {
            if (!pszParm) return 9;
            ntimeout = atol(pszParm);
            continue;
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
         }
         else
         if (!pszText) {
            pszText = argv[iDir];
            continue;
         }
         return 9+perr("unexpected parameter: \"%s\" (8)\n", argv[iDir]);
      }

      if (!pszText && !cs.quiet) {
         #ifdef _WIN32  
         pszText = "Press any key to continue, CTRL+C or ESC to stop.";
         #else
         pszText = "Press ENTER to continue, or CTRL+C to stop.";
         #endif
      }

      // wait for user input:
      long nkey   = 0;
      num  nstart = getCurrentTime();
      #ifdef _WIN32
      if (pszText)
         { printf("%s\r", pszText); fflush(stdout); }
      while (true) {
         nkey = getKeyPress(1); // only DOWN events
         if (nkey > 0) {
            if (cs.verbose) printf("[key 0x%lx]\n", (ulong)nkey);
            if (nkey >= 0x20) break;
            if (nkey == '\n' || nkey == '\r' || nkey == '\t' || nkey == 0x1B)
               break;
            // else ignore non-printable keys, esp. CTRL (0x11)
         }
         long ndelay = ntimeout ? 500 : 100;
         doSleep(ndelay);
         num nelapsed = getCurrentTime() - nstart;
         if (ntimeout) {
            if (nelapsed > ntimeout) break;
            num nremain = ntimeout - nelapsed;
            printf("[%ld] - %s\r",(long)(nremain/1000),pszText);
            fflush(stdout);
         }
      }
      printf("\n");
      #else
      if (pszText) printf("%s\n", pszText);
      nkey = (long)getchar(); // requires enter
      #endif

      // calling this only for chaining support:
      int iDirNext=0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext)) return lRC;

      // continue chain processing only if no ESCAPE pressed
      if (nkey != 0x1B) {
         STEP_CHAIN(iDirNext, 0);
      } else {
         lRC = nkey;
      }

      bDone = 1;
   }

   regtest("tail -lines=10 -follow -quiet -polltime=500 xfile");

   bool bIsTail = 0;

   ifcmd (   !strcmp(pszCmd, "tail") || !strcmp(pszCmd, "head")
          || !strcmp(pszCmd, "ttail") || !strcmp(pszCmd, "thead")
         )
   {
      bool bTail = bIsTail = (strstr(pszCmd, "tail") ? 1 : 0);

      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk head [-lines=n] [-f[ollow]] [filename]\n"
             "$sfk tail [-lines=n] [-f[ollow]] [filename]\n"
             "$sfk ... +[t]head | +[t]tail [-lines=n]\n"
             "\n"
             "   1. print first or last lines of a file, optionally following changes.\n"
             "      to use file content processing, provide a single filename.\n"
             "\n"
             "   2. print first or last text lines procuded by a previous command.\n"
             "      to process chain text, thead or ttail are recommended.\n"
             "\n"
             "   $options\n"
             "      -lines=n     print first or last n lines (default is 10).\n"
             "      -follow      or -f waits for file changes, printing them endlessly.\n"
             "                   if file is recreated or shrunk, rereads the last lines.\n"
             "                   if file is changed, head will always reread from front.\n"
             "                   to post-process tail output, e.g. with +filter, always\n"
             "                   add +loop at the end of the command sequence.\n"
             "      -quiet       do not tell verbosely about read restarts.\n"
             "      -polltime=n  with -follow, specifies the delay in milliseconds before\n"
             "                   the file is checked again for changes. default is 500.\n"
             "      -altsize     use a different method to determine the file size\n"
             "                   (stat instead of seek). may help if the default method\n"
             "                   fails to read the file, or to improve performance.\n"
             "\n"
             "   $examples\n"
             "      #sfk tail -follow logs\\access.log\n"
             "         immediately lists last lines, then all added lines over time.\n"
             "      #sfk tail -f c:\\temp\\log.txt +filter -+error: -+warning: +loop\n"
             "         endless filter of error and warning messages from log.txt.\n"
             "      #type myfile.txt | sfk filter +thead -lines=50\n"
             "         filter first 50 lines from stdin, via sfk filter.\n"
             "\n"
             "   $example sfk script with conditional execution\n"
             "     #file logfilter.txt:\n"
             "       sfk label checklog\n"
             "          +tail -follow logfile.txt\n"
             "          +tee toterm +filter -+error:\n"
             "          +if \"rc>0\" call myalert\n"
             "          +loop +end\n"
             "       sfk label myalert\n"
             "          +run -yes \"myalert.bat\" +end\n"
             "     #sfk script logfilter.txt\n"
             "        will run myalert.bat whenever errors appear in logfile.txt.\n"
             );
      ehelp;

      char *pszFile   =   0;
      long nLastLines =  10;
      long nPollTime  = 500;
      bool bFollow    =   0;
      long nMaxLines  = 10000;
      int  iChainNext =   0;
      bool bUseSeek   =   1;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-lines", &pszParm)) {
            if (!pszParm) return 9;
            nLastLines = atol(pszParm);
            if (!chain.usedata && bIsTail && (nLastLines > nMaxLines))
               pwarn("tail supports only %ld -lines at maximum.\n", nMaxLines);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-polltime", &pszParm)) {
            if (!pszParm) return 9;
            nPollTime = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-f", 2)) {
            if (chain.usedata) {
               perr("-f[ollow] not supported with chain text input");
               pinf("check if previous commands produce filenames or text");
               return 9;
            }
            bFollow = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-altsize")) {
            bUseSeek = 0;
            if (cs.verbose) pinf("using fseek file size detect\n");
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszFile) {
            pszFile = argv[iDir];
            continue;
         }
         return 9+perr("unexpected parameter: \"%s\" (9)\n", argv[iDir]);
      }

      if (btest) return 0;

      if (chain.usedata) 
      {
         // head or tail the chain text
         long nsize = chain.indata->numberOfEntries();
         long nfrom = 0, nto = nsize;
         if (bIsTail) {
            nfrom = nsize - nLastLines;
            if (nfrom < 0) nfrom = 0;
         } else {
            nto = nLastLines;
            if (nto > nsize) nto = nsize;
         }
         for (long i=nfrom; i<nto; i++) {
            char *ptext=0, *pattr=0;
            ptext = chain.indata->getEntry(i, __LINE__, &pattr);
            if (!ptext) return 9+perr("int. #168281112");
            if (chain.coldata)
               chain.addLine(ptext, pattr);
            else
               printColorText(ptext, pattr, 1); // with lf
         }
      }
      else 
      {
         // head or tail file contents
         if (!pszFile) {
            if (chain.usefiles && chain.numberOfInFiles() == 1) {
               Coi *pcoi = chain.getFile(0);
               if (!pcoi) return 9;
               pszFile = pcoi->name();
            } else {
               const char *pcmd = bIsTail ? "tail" : "head";
               perr("too many input filenames for %s (%ld)",pcmd,chain.numberOfInFiles());
               pinf("%s can only process a single input filename.\n",pcmd);
               pinf("use +t%s instead of %s if you want to process text.\n",pcmd,pcmd);
               pinf("try +ftt to convert filenames to text. see also \"sfk help chain\".\n");
               return 9;
            }
         }
   
         if (!cperm.tailnsize) {
            cperm.tailnsize = bUseSeek ? getFileSizeSeek(pszFile) : getFileSize(pszFile);
            if (cperm.tailnsize < 0) return 9+perr("cannot read: %s\n", pszFile);
         }
   
         // keyword +loop supplied?
         bool bHaveLoop = 0;
         if (argc > 0) {
            for (int iback=argc-1; iback > 0; iback--)
               if (!strcmp(argv[iback], "+loop"))
                  {  bHaveLoop = 1; break; }
         }
   
         if (!bHaveLoop && bFollow && iChainNext && !cs.quiet)
            pwarn("chain commands after tail -follow may not work as expected without +loop.\n");
   
         do
         {
            if (bIsTail)
            {
               if (!cperm.tailnpos)
               {
                  // find initial position of nLastLines from end
                  num *ppos = new num[nMaxLines+10]; // with tolerance
                  if (!ppos) return 9+perr("out of memory\n");
                  memset(ppos, 0, sizeof(num)*nMaxLines);
                  long nbufpos = 0;
         
                  // scan all line positions
                  FILE *fin = fopen(pszFile, "rb");
                  if (!fin) return 9+perr("unable to read: %s\n", pszFile);
                  myfgets_init();
                  while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin))
                  {
                     removeCRLF(szLineBuf);
                     // cannot use mygetpos here, as myfgets caches.
                     num npos2 = nGlblGetFPos;
                     memmove(&ppos[1], &ppos[0], sizeof(num) * nbufpos);
                     ppos[0] = npos2;
                     if (nbufpos < nMaxLines)
                        nbufpos++;
                     if (cs.debug)
                        printf("line %ld pos %s \"%s\"\n",nbufpos,numtoa(npos2),szLineBuf);
                  }
                  fclose(fin);
         
                  // fetch requested line position
                  if (nLastLines > nbufpos)
                     nLastLines = nbufpos;
                  if (nLastLines > nMaxLines)
                     return 9+perr("overflow, too many lines from file end specified.\n");
                  cperm.tailnpos = ppos[nLastLines];
         
                  if (cs.debug)
                     printf("\ntake pos %s from offset %ld\n",numtoa(cperm.tailnpos),nLastLines);
         
                  delete [] ppos;
               } 
               else
               {
                  // wait until file changes, then proceed
                  bool bTold  = 0;
                  long iturn  = 0;
                  char *aturn = "\\|/-";
                  while (!userInterrupt()) 
                  {
                     doSleep(nPollTime);
                     num nsize2 = bUseSeek ? getFileSizeSeek(pszFile) : getFileSize(pszFile);
                     if (nsize2 < 0) {
                        if (!cs.quiet && !bTold)
                           printf("[file removed, waiting for recreation]\n");
                        bTold = 1;
                        continue;
                     }
                     if (nsize2 != cperm.tailnsize) {
                        if (bIsTail && (nsize2 < cperm.tailnsize)) {
                           if (!cs.quiet)
                              printf("[file %srecreated, rereading last %ld lines]\n", bTold?"":"shrunk or ",nLastLines);
                           cperm.tailnsize = nsize2;
                           cperm.tailnpos = 0;
                           break;
                        }
                        if (!bIsTail) {
                           if (!cs.quiet)
                              printf("[file changed, restarting read]\n");
                        }
                        cperm.tailnsize = nsize2;
                        break;
                     }
                     bTold = 0;
                     if (cs.verbose)
                        printf("[%c %s bytes filesize]\r",aturn[iturn++%4],numtoa(nsize2));
                  }
               }
            }
      
            long nrc = 0;
      
            // dump new content, from pos to end
            FILE *fin = fopen(pszFile, "rb");
            if (!fin) return 9+perr("unable to read: %s\n", pszFile);
   
            if (bIsTail) {
               nrc = mysetpos(fin, cperm.tailnpos, pszFile);
               if (nrc) {
                  fclose(fin);
                  return 9+perr("unable to set position: %s\n", pszFile);
               }
            }
   
            // dump from current position until end (if tail)
            long nLocLine = 0;
            myfgets_init();
            while (myfgets(szLineBuf, MAX_LINE_LEN-10, fin))
            {
               szLineBuf[MAX_LINE_LEN-10] = '\0';
               removeCRLF(szLineBuf);
               nLocLine++;
   
               if (chain.coldata)
                  chain.addLine(szLineBuf, "");
               else
                  printf("%s\n", szLineBuf);
   
               if (!bIsTail && nLocLine >= nLastLines)
                  break;
            }
   
            if (nrc) {
               fclose(fin);
               return 9+perr("error while filtering, rc %ld\n", nrc);
            }
   
            // remember end position of read.
            // can NOT use nGlblGetFPos here as it's relative.
            nrc = mygetpos(fin, cperm.tailnpos, pszFile);
            fclose(fin);
            if (nrc) return 9+perr("unable to read position: %s\n", pszFile);
         }
         while (bFollow && !bHaveLoop && !userInterrupt());
      }
   
      // if -follow is not selected
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "view") || !strncmp(pszCmd, "fv", 2))
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk list ... +[f]view [-noshl|-nocol] [\"-...\"]\n"
             "\n"
             "   Depeche View is a high speed text browser and editor,\n"
             "   available from http://stahlworks.com/dev/\n"
             "\n"
             "   It is used to search, filter and edit huge amounts of ASCII text,\n"
             "   like source code, log files, or html documentation. The tool loads\n"
             "   every text from a folder, showing all content as one huge text,\n"
             "   allowing instant interactive search as you type.\n"
             "   \n"
             "   Depeche View integrates with SFK through command chaining.\n"
             "   Many SFK commands allow to add \"+view\" to have their output\n"
             "   shown instantly in DView. This requires dview, dview.exe\n"
             "   or dview.bat being located in the PATH. If you have downloaded\n"
             "   an executable like dview143.exe, rename it before use.\n"
             "   To run Depeche View under linux, WINE must be installed. Google\n"
             "   for \"linux wine\" or search \"wine\" in your package manager.\n"
             "\n"
             "   $use as a chain command, or to display stdin:\n"
             "\n"
             "      +[f]view can be used only #after another command<def>\n"
             "      producing a list of filenames or plain text data:\n"
             "\n"
             "         #+view<def>  expects text as input.\n"
             "         #+fview<def> expects a list of filenames.\n"
             "\n"
             "      or use \"sfk view -i\" to display text from stdin.\n"
             "\n"
             "   $options\n"
             "      -nocol[or]   disable colored output and display.\n"
             "                   set this if you're using dview < 1.1.4\n"
             "                   or any other viewer.\n"
             "      -wrap[=n]    wrap lines at column n. currently, this feature\n"
             "                   disables colors (implies -nocol), but depending\n"
             "                   on the content processed, dview may still show\n"
             "                   colors based on syntax highlighting.\n"
             "      -noshl       disable syntax highlighting at dview.\n"
             "      \"-x1 -x2\"    all other options are passed through unchanged\n"
             "                   to the viewer application. if multiple parameters\n"
             "                   have to be passed, surround them by double quotes.\n"
             "      -verbose     tell verbosely which target binary is invoked.\n"
             #ifdef _WIN32
             "      -noback      by default, dview is run as a background process,\n"
             "                   by prefixing the overall command with \"start \".\n"
             "                   say -noback to let sfk wait until dview is stopped.\n"
             #else
             "      -noback      by default, dview is run as a background process,\n"
             "                   by appending ampersand & to the overall command.\n"
             "                   say -noback to let sfk wait until dview is stopped.\n"
             "      -nowine      sfk for linux creates a command \"wine dview ...\" to\n"
             "                   make sure Depeche View is run in the wine environment.\n"
             "                   specify -nowine to disable this.\n"
             "      -nolinux     sfk for linux adds option -linux when calling dview\n"
             "                   or dview.exe. specify -nolinux to disable this.\n"
             "      -plain       combines -nowine, -nolinux.\n"
             #endif
             "\n"
             "   $temporary files\n"
             "      this command #creates a temporary file<def> which is currently\n"
             "      not deleted. type \"sfk help options\" for options on that.\n"
             "\n"
             "   $using a different viewer\n"
             "      when viewing a list of files, this command runs\n"
             "         \"dview -flist tmpfilename\"\n"
             "      with tmpfilename containing a list of filenames.\n"
             "\n"
             "      when viewing text line output, this command runs\n"
             "         \"dview tmpfilename\"\n"
             "      with tmpfilename containing ascii text data.\n"
             "\n"
             "      specify -verbose to see what is invoked in detail.\n"
             "\n"
             "   $examples\n"
             "      #sfk list docs .txt +fview\n"
             "         view content of all .txt files in directory docs.\n"
             "\n"
             "      #sfk echo x +view -verbose\n"
             "         tell verbosely which dview(.exe?) executable is actually used.\n"
             "\n"
             "      #sfk list docs .txt +ffilter -+foo -hitfiles +fview \"-max -over\"\n"
             "         view all .txt $files<def> from docs containing \"foo\", pass options\n"
             "         -max -over to the viewer, showing a maximized window in overscan\n"
             "         mode (without any title bar).\n"
             "\n"
             "      #sfk list docs .txt +ffilter -+foo +view \"-space 0:0:40\"\n"
             "         view only text $lines<def> from docs containing \"foo\", in a window\n"
             "         covering the whole desktop, except for 40 pixels at the bottom.\n"
             #ifdef _WIN32
             "\n"
             "      #sfk fromclip +view\n"
             "         display current clipboard content (plain text only).\n"
             #endif
             "\n"
             "      #tar tvf foo.tar | sfk view -i\n"
             "         display a tar file's content listing.\n"
             "\n"
             "      #sfk larc -size -time -withdirs foo.tar +view\n"
             "         the same, with sfk reading the .tar directly.\n"
            );
      ehelp;

      bool bback    = 0;
      bool bcolor   = 1;
      long bcompact = 1;
      bool bnoshl   = 0;
      #ifdef _WIN32
      char *pszsopt = "start ";
      char *pszwopt = "";
      char *pszxopt = "";
      #else
      char *pszsopt = " &";
      char *pszwopt = "wine ";
      char *pszxopt = " -linux";
      #endif

      // additional dview options are collected in abBuf:
      strcpy((char*)abBuf, " ");

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-back")) {
            bback = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nocol", 6)) {
            bcolor = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-col", 4)) {
            bcolor = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-snap", 5)) {
            bcompact = 0; // normal snapfile format
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-comp", 5)) {
            bcompact = 2; // leave out blank lines before files
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-noba", 5)) {
            pszsopt = "";
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-noli", 5)) {
            pszxopt = "";
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nowi", 5)) {
            pszwopt = "";
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-plain")) {
            pszwopt = "";
            pszxopt = "";
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            // if (isDirParm(argv[iDir]))
            //   break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            // all other options:
            //   return 9+perr("unknown option: %s\n", argv[iDir]);
            // collect and pass through to dview
            strcat((char*)abBuf, " ");
            strcat((char*)abBuf, argv[iDir]);
            continue;
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      // render extra options for dview
      if (cs.wrapcol) {
         char *psz = (char*)abBuf;
         sprintf(&psz[strlen(psz)], " -wrap=%ld", cs.wrapcol);
         bcolor = 0; // todo: -wrap with color support
      }
      // if (bnoshl) {
      //   strcat((char*)abBuf, " -noshl");
      // }

      // find the target executable:
      // dview, dview.bat, dview.exe [but not dview120.exe]
      // does not search for other extensions like .cmd.
      char *pszTarg    = "dview";

      char *pszTargAbs = findPathLocation(pszTarg, 0);

      if (!pszTargAbs)
         pszTargAbs = findPathLocation("dview.exe", 0);

      if (!pszTargAbs)
         if (pszTargAbs = findPathLocation("dview.bat", 0)) {
            pszwopt    = "";
            pszxopt    = "";
         }

      if (pszTargAbs)
         pszTarg = pszTargAbs;

      if (cs.verbose) {
         if (!pszTargAbs) {
            pinf("dview, dview.exe or dview.bat not found directly, but trying\n");
            pinf("anyway, in case another extensions is present within PATH.\n");
         }
      }

      if (chain.usefiles)
      {
         if (chain.numberOfInFiles()) 
         {
            SFTmpFile tmp(1, 1); // 1: nodelete, 1: fixed file number
            char *pszTmpFile = tmp.name();
            if (!pszTmpFile) return 9;
   
            FILE *fout = fopen(pszTmpFile, "w");
            if (!fout) return 9+perr("cannot write temporary file: %s\n", pszTmpFile);
   
            for (long i=0; i<chain.numberOfInFiles(); i++) {
               Coi *pcoi = chain.getFile(i);
               if (!pcoi) return 9+perr("int. #141271853\n");
               fprintf(fout, "%s\n", pcoi->name());
            }
            fclose(fout);
   
            #ifdef VFILEBASE
            // cleanup possible connections to sfk ftp server
            mtklog("view: cleanup connections");
            resetLoadCaches(0);
            #endif // VFILEBASE

            #ifdef _WIN32
            sprintf(szLineBuf2, "%s%s%s -flist %s", pszsopt, pszTarg, (char*)abBuf, pszTmpFile);
            #else
            sprintf(szLineBuf2, "%s%s%s%s -flist %s%s", pszwopt, pszTarg, pszxopt, (char*)abBuf, pszTmpFile, pszsopt);
            #endif
            if (cs.verbose) pinf("[nopre] running: %s\n", szLineBuf2);
            system(szLineBuf2);
         } else {
            printf("%s: received no input files for viewing.\n", pszCmd);
         }
      }
      else
      if (   (chain.usedata && chain.indata->numberOfEntries())
          ||  bGlblStdInAny
         )
      {
         SFTmpFile tmp(1, 1); // 1: nodelete, 1: fixed file number
         char *pszTmpFile = tmp.name();
         if (!pszTmpFile) return 9;

         // write text data to temporary file
         FILE *fout = fopen(pszTmpFile, "w");
         if (!fout) return 9+perr("cannot write temporary file: %s\n", pszTmpFile);

         if (chain.usedata)
         {   
            if (bcolor)
               fprintf(fout, "<interleaved-attributes-text version=\"1.0\" prefix=\"\">\n");
   
            bool bsnap = 0;
   
            for (long i=0; i<chain.indata->numberOfEntries(); i++) 
            {
               char *pattr = 0;
               strcopy(szLineBuf2, chain.indata->getEntry(i, __LINE__, &pattr));
               removeCRLF(szLineBuf2);
   
               // if the first text record is a :file header
               bool bsubhead = 0;

               // :file text records with 'f' in rightmost extended attribute area
               // are real subfile headers.
               if (pattr) {
                  long natrlen = strlen(pattr);
                  if (natrlen > 0 && pattr[natrlen-1] == 'f' && !strncmp(szLineBuf2, ":file ", 6))
                     bsubhead = 1;
               }

               if (i==0 && bsubhead)
               {
                  // create snapfile format.
                  if (bcompact) {
                     fprintf(fout, ":snapfile sfk,1.1,prefix=:file: ,\n");
                     if (bcolor)
                     fprintf(fout, "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n");
                  } else {
                     fprintf(fout, ":snapfile sfk,1.1,lprefix=:file:\n");
                     if (bcolor)
                     fprintf(fout, "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n");
                  }
                  bsnap = 1;
               }
   
               // if creating snapfile, reformat every file header
               if (bsnap && bsubhead) {
                  if (bcompact) {
                     // 1. optional blank line
                     // 2. :file: filename
                     if (bcompact < 2) {
                        fprintf(fout, "\n"); if (bcolor) fprintf(fout, "\n");
                     }
                     fprintf(fout, ":file: %s\n", szLineBuf2+6); 
                     if (bcolor) {
                        for (long k=7+strlen(szLineBuf2+6); k>0; k--)
                           fputc('b',fout);
                        fputc('\n',fout);
                     }
                  } else {
                     // 1. blank line
                     // 2. :file:
                     // 3. filename
                     fprintf(fout, "\n");       if (bcolor) fprintf(fout, "\n");
                     fprintf(fout, ":file:\n"); if (bcolor) fprintf(fout, "\n");
                     fprintf(fout, "%s\n", szLineBuf2+6); 
                     if (bcolor) {
                        for (long k=strlen(szLineBuf2+6); k>0; k--)
                           fputc('b',fout);
                        fputc('\n',fout);
                     }
                  }
               } else {
                  mtklog("vtext: %04ld \"%s\"",(long)strlen(szLineBuf2),szLineBuf2);
                  fprintf(fout, "%s\n", szLineBuf2);
                  if (bcolor) {
                     // map and print color attribute codes. dview displays only:
                     // r,g,b,y,c,m for red,green,blue,yellow,cyan,magenta
                     // therefore logical attributes must be mapped.
                     szAttrBuf[0] = '\0';
                     if (pattr) strcopy(szAttrBuf, pattr);
                     for (char *psz=szAttrBuf; *psz; psz++)
                        switch (*psz) {
                           case 'f': *psz = 'B'; break; // nGlblFileColor 
                           case 'l': *psz = 'C'; break; // nGlblLinkColor 
                           case 'h': *psz = 'g'; break; // nGlblHeadColor 
                           case 'i': *psz = 'g'; break; // nGlblHitColor  
                           case 'a': *psz = 'M'; break; // nGlblRepColor  
                           case 'x': *psz = 'M'; break; // nGlblExampColor
                           case 'e': *psz = 'R'; break; // nGlblErrColor  
                           case 'w': *psz = 'Y'; break; // nGlblWarnColor 
                           case 't': *psz = 'B'; break; // nGlblTimeColor 
                           case 'p': *psz = 'B'; break; // nGlblPreColor
                           // map white codes to default
                           case 'v': *psz = ' '; break;
                           case 'V': *psz = ' '; break;
                        }
                     mtklog("vattr: %04ld \"%s\"",(long)strlen(szAttrBuf),szAttrBuf);
                     fprintf(fout, "%s\n", szAttrBuf);
                  }
               }
            }
         }
         else
         {
            // copy from stdin
            size_t nread = 0;
            while ((nread = fread(szAttrBuf, 1, MAX_LINE_LEN, stdin)) > 0)
               myfwrite((uchar*)szAttrBuf, nread, fout);
         }

         fclose(fout);

         #ifdef _WIN32
         sprintf(szLineBuf3, "%s%s%s %s", pszsopt, pszTarg, (char*)abBuf, pszTmpFile);
         #else
         sprintf(szLineBuf3, "%s%s%s%s %s%s", pszwopt, pszTarg, pszxopt, (char*)abBuf, pszTmpFile, pszsopt);
         #endif
         if (cs.verbose) pinf("[nopre] running: %s\n", szLineBuf3);
         system(szLineBuf3);
      }
      else 
      {
         printf("%s: received no input text for viewing.\n", pszCmd);
      }

      bDone = 1;
   }

   #ifdef _WIN32
   if (!strcmp(pszCmd, "beep")) // +chaining
   {
      if (nparm < 1) {
      printx("<help>$sfk beep messageid\n"
             "\n"
             "   play a system sound. possible id's are:\n"
             "\n"
             "       0  default sound\n"
             "      10  SystemHand\n"
             "      20  SystemQuestion\n"
             "      30  SystemExclamation\n"
             "      40  SystemAsterisk\n"
             );
      return 9;
      }
      long nid = -1; // default id
      bool breadid = 0;
      for (; iDir<argc; iDir++) 
      {
         if (   !strncmp(argv[iDir], "-", 1)
             && strcmp(argv[iDir], "-1")
            )
         {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
         // process non-option keywords:
         if (!breadid) {
            breadid = 1;
            char *psz = argv[iDir];
            if (strlen(psz) == 1 || psz[0] == '-')
               nid = atol(argv[iDir]);
            else
               nid = getTwoDigitHex(argv[iDir]); // -1 on error
         }
         else
            return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      int iDirNext = 0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext)) return lRC;
      if (btest) return 0;

      MessageBeep(nid);

      STEP_CHAIN(iDirNext, 0);

      bDone = 1;
   }
   #endif

   regtest("filefind -time -size foo bar");

   // easy dir lister: sfk :pattern
   ifcmd (   !strcmp(pszCmd, "filefind") || !strcmp(pszCmd, "ff")
          || (iDir == 2 && pszCmd[0] == ':')
         )
   {
      ifhelp (!strcmp(pszCmd, ":") || (pszCmd[0] != ':' && nparm < 1))
      printx("<help>$sfk filefind [or ff] pattern [pattern2 <not>pattern3 ...] [opts]\n"
             "\n"
             "   easy file name finder for the current directory tree.\n"
             "   if you remember any words of a filename, or it's path,\n"
             "   type \"sfk ff \" and the words to find matching filenames.\n"
             "   to type even less, try \"sfk :\" followed by the first word,\n"
             "   without blank: \"sfk :word1 word2 ...\"\n"
             "\n"
             "   $note:\n"
             "   - searches the current directory \".\" and all subdirectories.\n"
             "   - the full filename paths, including relative filenames,\n"
             "     are compared (not just the relative filenames).\n"
             "   - the patterns are AND combined (not OR as with list),\n"
             "     meaning that ALL given patterns must appear in a path\n"
             "     to have it listed. the pattern sequence is ignored.\n"
             "   - options may appear anywhere.\n"
             "   - exclude patterns starting with <not> are also supported.\n"
             "\n"
             "   $options\n"
             "      -time  list also file times.\n"
             "      -size  list also file sizes.\n"
             );
             #ifdef VFILEBASE
      if (cs.xelike)
      printx("      -arc   include .zip .jar .tar etc. archive contents.\n");
             #endif // VFILEBASE
      printx("\n"
             "   $chaining support\n"
             "      output chaining is supported.\n"
             "\n"
             "   $examples\n"
             "      #sfk filefind foo bar <not>save\n"
             "         lists all files in the current directory tree having both\n"
             "         foo and bar in their path+filename, regardless of sequence.\n"
             "         files having \"save\" in their path (or name) are excluded.\n"
             "\n"
             "      #sfk ff foo<wild>bar thing +fview\n"
             "         similar to the above, lists all files having bar AFTER foo\n"
             "         in their path+filename. thing must also be present.\n"
             "         resulting files are loaded and shown in Depeche View.\n"
             "\n"
             "      #sfk :.pdf\n"
             "         list all .pdf files down somewhere in the directory tree.\n"
             "\n"
             "      #sfk :debug<wild>.o +del\n"
             "         delete all debug executables in the current directory tree.\n"
             );
      ehelp;

      bool bShortForm = (pszCmd[0] == ':');

      if (glblFileSet.beginLayer(false, __LINE__)) return 9;
      if (glblFileSet.addRootDir(".", __LINE__, false)) return 9;
      if (bShortForm) {
         char *pszpat = pszCmd+1;
         sprintf(szLineBuf, "*%s*", pszpat);
         glblFileSet.addDirMask(szLineBuf);
      }
      glblFileSet.addFileMask("*"); // dummy

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-size")) {
            // do not just remember the flag, but also option sequence.
            cs.listForm = ((cs.listForm << 8) | 0x01);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-time")) {
            // do not just remember the flag, but also option sequence.
            cs.listForm = ((cs.listForm << 8) | 0x02);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         char *pszmask = argv[iDir];
         if (pszmask[0] == glblNotChar) {
            // mask parts starting with "!" are negative dir AND file masks.
            glblFileSet.addDirMask(pszmask);
            glblFileSet.addFileMask(pszmask);
         } else {
            // anything else is a PATH mask.
            sprintf(szLineBuf, "*%s*", pszmask);
            glblFileSet.addDirMask(szLineBuf);
         }
      }

      if (btest) return 0;

      glblFileSet.setBaseLayer();

      if (chain.colany())
         cs.nohead = 1;

      nGlblListMode = 2;
      cs.pathMaskAndMatch = 1;
      cs.incFNameInPath   = 1;
      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);
      info.clear();

      if (!cs.quiet) {
         if (cs.noFiles)
            printf("%lu non-regular files skipped.\n", cs.noFiles);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "phrase"))
   {
      if (nparm < 1) {
      printx("<help>$sfk phrase grammar.txt [numrec]\n"
             "\n"
             "   create numrec records of random text, as defined in grammar.txt,\n"
             "   to produce synthetic test case data, e.g. csv tables.\n"
             "\n"
             "   $grammar.txt syntax example:\n"
             "\n");
      printf("      all: \"$company inc\"\\,\"$street\"\\,\"$city\"\\,\"$country\"\n"
             "      $name: $syl$syl$syl\n"
             "      $syl: che,wo,fi,gu,kan,sel,ben,chong,ching,wing,fon,bun\n"
             "      $company: $name\n"
             "      $street: $name $stype $num3\n"
             "      $stype: street, road, boulevard\n"
             "      $num3: $dig$dig$dig\n"
             "      $dig: 1,2,3,4,5,6,7,8,9,0\n"
             "      $city: $name city\n"
             "      $country: hong kong, shanghai, taiwan\n"
             "\n");
      printx("   $usage example:\n"
             "\n"
             "      #sfk phrase grammar.txt 3\n"
             "\n"
             "      produces 3 test data output records like:\n"
             "\n"
             "      \"fichebun inc\",\"fibengu road 928\",\"chingbunching city\",\"hong kong\"\n"
             "      \"chingwosel inc\",\"selkankan boulevard 895\",\"fonwochong city\",\"hong kong\"\n"
             "      \"chingkanche inc\",\"benbenfon street 226\",\"benselgu city\",\"shanghai\"\n"
             );
      return 9;
      }

      char *pszFile = argv[iDir];
      long nnum = 1;
      if (nparm >= 2)
           nnum = atol(argv[++iDir]);

      Phraser *p = new Phraser();
      if (p->load(pszFile)) return 9;

      srand((unsigned)time(NULL));

      for (long i=0; i<nnum; i++) {
         char *pres = p->solve("all");
         if (!pres) return 9+perr("cannot solve 'all'\n");
         printf("%s\n", pres);
      }

      p->reset();
      delete p;

      bDone = 1;
   }

   // yet internal
   if (strBegins(pszCmd, "tobase64") || strBegins(pszCmd, "frombase64"))
   {
      if (nparm < 1) {
         printx("<help>$sfk tobase64 infile [outfile]\n"
            "$sfk frombase64 infile outfile\n"
            );
         return 9;
      }

      bool bencode = strBegins(pszCmd, "tobase64");

      char *pszInFile  = 0; 
      char *pszOutFile = 0;
      int iChainNext   = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszInFile)  pszInFile = argv[iDir];
         else
         if (!pszOutFile) pszOutFile = argv[iDir];
         else
            return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (!pszInFile)  return 9+perr("missing input filename.\n");
      if (!bencode && !pszOutFile) return 9+perr("missing output filename.\n");

      num nFileSize = 0;
      uchar *pdata = loadBinaryFile(pszInFile, nFileSize);
      if (!pdata) return 9;

      num nOutSize = nFileSize * 2; // approx.
      uchar *pout = new uchar[nOutSize+100];
      if (!pout) return 9+perr("out of memory.\n");

      long nrc = 0;
      long nsave = -1;
      if (bencode) {
         nrc = encode64(pdata, nFileSize, pout, nOutSize, 40);
         if (nrc)
            perr("encoding failed, rc %ld\n", nrc);
         else
            nsave = strlen((char*)pout);
      } else {
         nrc = decode64(pdata, nFileSize, pout, nOutSize);
         if (nrc < 0)
            perr("decoding failed.");
         else
            nsave = nrc;
      }

      if (nsave >= 0)
      {
         if (!pszOutFile) {
            printf("%s",pout);
         } else {
            FILE *fout = fopen(pszOutFile, "wb");
            if (fout) {
               long ndone = myfwrite(pout, nsave, fout);
               if (ndone != nsave)
                  perr("failed to fully write output file");
               fclose(fout);
            }
         }
      }

      delete [] pdata;
      delete [] pout;

      bDone = 1;      
   }

   ifcmd (strBegins(pszCmd, "char"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk char[s] word\n"
             "\n"
             "   print ascii codes of all chars of a word,\n"
             "   or print chars for the given code(s).\n"
             "\n"
             "   $options\n"
             "      -codes    force listing of character codes,\n"
             "                do not check if word is a number.\n"
             "      -literal  or -lit stops interpretation of any further\n"
             "                options or chain commands. required if you\n"
             "                need the code of \"-\" or \"+\".\n"
             "\n"
             "   $examples\n"
             "      #sfk chars hello\n"
             "         prints 5 lines of codes, one for each char.\n"
             "\n"
             "      #sfk chars 0x53464b\n"
             "         prints 'SFK', the letters for these hex codes.\n"
             "         any number of hex values can be provided.\n"
             "\n"
             "      #sfk char 65\n"
             "         prints 'A', the letter for that decimal code.\n"
             "         only a single decimal value can be provided.\n"
             "\n"
             "      #sfk char -lit +\n"
             "         print the code of the plus char.\n"
             );
      ehelp;
      
      char *pword  = 0;
      bool bdecode = 0;
      bool blit    = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!blit) {
            if (strBegins(argv[iDir], "-code")) {
               bdecode = 1;
               continue;
            }
            else
            if (strBegins(argv[iDir], "-lit")) {
               blit = 1;
               continue;
            }
            else
            if (!strncmp(argv[iDir], "-", 1)) {
               if (isDirParm(argv[iDir]))
                  break; // fall through
               if (setGeneralOption(argv, argc, iDir))
                  continue;
               else
                  return 9+perr("unknown option: %s\n", argv[iDir]);
            }
            else
            if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
               break;
         }
         // process non-option keywords:
         if (!pword)
            { pword = argv[iDir]; continue; }
         return 9+perr("unexpected parameter: %s\n", argv[iDir]);
      }

      if (!pword)
         return 9+perr("missing argument\n");

      char *psz = pword;
      bool bjustdigits = 1;
      for (; *psz; psz++)
         if (!isdigit(*psz))
            bjustdigits = 0;

      if (!bdecode && (bjustdigits || strBegins(pword, "0x")))
      {
         if (bjustdigits) {
            long npre = atol(pword);
            if (npre > 255)
               return 9+perr("value too large");
            uchar n = (uchar)npre;
            printf("%d\t0x%02X\t%c\n", n, n, (char)n);
         } else {
            pword += 2;
            for (; *pword; pword+=2) {
               if (strlen(pword) == 0)
                  break;
               if (strlen(pword) == 1)
                  return 9+perr("unexpected character: %s\n", pword);
               uchar n = (uchar)getTwoDigitHex(pword);
               printf("%d\t0x%02X\t%c\n", n, n, (char)n);
            }
         }
      }
      else
      {
         for (; *pword; pword++) {
            uchar uc = (uchar)*pword;
            printf("%d\t0x%02X\t%c\n", uc, uc, *pword);
         }
      }

      bDone = 1;
   }

   ifcmd (!strncmp(pszCmd, "hextobin", 9))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk ... +hextobin outfile\n"
             "\n"
             "   convert lines of text containing hexdump to binary.\n"
             "\n"
             "   $chain-only command.\n"
             "\n"
             "      hextobin can be used only #after another command<def>,\n"
             "      typically filter, which reads and prepares the input data.\n"
             "\n"
             "   $examples:\n"
             "\n"
             "      #sfk filter dump.txt +hextobin out.dat\n"
             "         requires dump.txt to contain pure hex data, e.g.\n"
             "\n"
             "            7466696C 65732F46 6F726D61 74732F31\n"
             "\n"
             "         blanks and some chars like <> are skipped automatically.\n"
             "\n"
             "      #sfk filter dump.txt \"-+ >\" -rep \"_<<wild>__\" +hextobin out.dat\n"
             "         takes a verbose hexdump produced by \"sfk hexump\":\n"
             "\n"
             "           >73746669 6C65732F 42617365 4C69622F< stfiles/BaseLib/ 00000020\n"
             "\n"
             "         using only lines starting with \" >\" (skipping a possible\n"
             "         filename line), stripping the ascii and offset infos after \"< \",\n"
             "         extracting and converting pure hex data.\n"
             #ifdef _WIN32
             "\n"
             "      #sfk fromclip +hextobin %%TEMP%%\\tmp1.dat +hexdump\n"
             "         takes a hex sequence like 22737769 73732066 from clipboard,\n"
             "         printing it's text via a temporary file and hexdump.\n"
             #endif
            );
      ehelp;

      if (!chain.usedata) {
         perr("%s needs input data from a previous command.\n", pszCmd);
         pinf("type \"sfk hextobin\" for help.\n");
         return 9;
      }

      char *pszOutFile = 0;
      int iChainNext = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         pszOutFile = argv[iDir];
      }

      if (!pszOutFile) return 9+perr("missing output filename.\n");

      FILE *fout = fopen(pszOutFile, "wb");
      if (!fout) return 9+perr("cannot write: %s\n", pszOutFile);

      SFKMD5 outmd;

      uchar *poutmax = abBuf + sizeof(abBuf) - 100;
      bool berr=0;
      long nConvLines=0, nSkippedLines=0;
      num nTotalBytes = 0;
      for (long i=0; !berr && i<chain.indata->numberOfEntries(); i++)
      {
         // fetch another hex input line
         char *pszLine = chain.indata->getEntry(i, __LINE__);
         // auto-skip filename header
         if (!strncmp(pszLine, ":file ", 6)) {
            pinf("skipping filename line on input\n");
            continue;
         }
         // >3135302E 38343820 42797465 73206672<
         char  *psz  = pszLine;
         uchar *pout = abBuf;
         char szByte[10];
         while (*psz) {
            while (*psz && !isxdigit(*psz)) psz++;
            if (!strncmp(psz, "0x", 2)) psz += 2; // 0x12,0x15, 0x19
            if (!*psz) break;
            szByte[0] = psz[0];
            if (isxdigit(psz[1])) {
               // two hex chars: 00 57 38 29
               szByte[1] = psz[1];
               szByte[2] = '\0';
               psz += 2;
            } else {
               perr("wrong hex format: \"%s\"\n", psz); 
               berr=1;
               break;
            }
            *pout++ = (uchar)strtol(szByte, 0, 0x10);
            if (pout >= poutmax) { perr("buffer overflow: input lines too large\n"); berr=1; break; }
         }
         // flush collected binary line
         long nBinSize = pout-abBuf;
         if (nBinSize > 0) {
            if (myfwrite(abBuf, nBinSize, fout) != nBinSize) {
               esys("fwrite", "failed to write %s   \n", pszOutFile);
               berr=1;
               break;
            }
            outmd.update(abBuf, nBinSize);
            nTotalBytes += pout-abBuf;
            nConvLines++;
         } else {
            nSkippedLines++;
         }
      }

      fclose(fout);

      if (!cs.quiet) {
         printf("%ld lines converted, %ld skipped, %s output bytes.\n", nConvLines, nSkippedLines, numtoa(nTotalBytes));
         unsigned char *pmd5 = outmd.digest();
         for (int i=0; i<16; i++)
            sprintf(&szLineBuf[i*2], "%02x", pmd5[i]);
         printf("md5: %s\n", szLineBuf);
      }

      // pass output filename if requested
      if (chain.colfiles) {
         Coi ocoi(pszOutFile, 0);
         chain.addFile(ocoi); // is copied
         STEP_CHAIN(iChainNext, 1);
      } else {
         STEP_CHAIN(iChainNext, 0);
      }

      bDone = 1;      
   }

   regtest("dupfind -listorg -minsize=3m");

   ifcmd (!strncmp(pszCmd, "dupfind", 3)) 
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk dupfind -dir anydir [-file .ext1 .ext2]\n"
             "\n"
             "   find and list duplicate files.\n"
             "\n"
             "   $options\n"
             "      -diffdirs    list only duplicates residing in different\n"
             "                   root directories. this option requires that\n"
             "                   you specify at least two dirs after -dir.\n"
             "      -listorg     list all original filenames,\n"
             "                   leave out any duplicate filenames.\n"
             "      -minsize=n   compare only files with size >= n.\n"
             "                   examples for n are:\n"
             "                      5m = 5000000 bytes (5 mbytes)\n"
             "                    100k =  100000 bytes (5 kbytes)\n"
             "                      1M = 1048576 bytes (2<<20 bytes)\n"
             "                   9000b =    9000 bytes\n"
             "\n"
             "   $command chaining\n"
             "      - by default, this command passes the names\n"
             "        of found duplicate files to the next command.\n"
             "\n"
             "      - option -listorg does the opposite: it passes\n"
             "        only original filenames, but no duplicates,\n"
             "        to the next chain command.\n"
             "\n"
             "   $NOTE:\n"
             "      if identical files are found, the decision what is listed\n"
             "      as \"original\" or \"duplicate\" is currently based on the\n"
             "      order in the file system: the file found first is listed as\n"
             "      \"original\". check carefully if this is what you think,\n"
             "      before cleaning up any duplicates.\n"
             "\n"
             "   $examples\n"
             "      #sfk dupfind .\n"
             "         find all duplicates within the current directory tree.\n"
             "\n"
             "      #sfk dupfind -dir docs1 docs2 docs3\n"
             "         find all dups across and within the given directories.\n"
             "\n"
             "      #sfk dupfind -diffdir -dir docs1 docs2 docs3\n"
             "         find dups between docs1/docs2, docs2/docs3, docs1/docs3,\n"
             "         but does NOT list dups within the same root directory.\n"
             "\n"
             "      #sfk dupfind docs .doc +del\n"
             "         find all duplicate .doc files, within the docs\n"
             "         directory tree, and delete them.\n"
             "\n"
             "      #sfk dupfind -listorg docs .doc +run \"copy <run>file docs2\"\n"
             "         copy all .doc files from docs to docs2,\n"
             "         but leave out any duplicate files.\n"
             "\n"
             "      #sfk dupfind -dir pic1 -dir pic2 -dir pic3\n"
             "         find duplicates across three different directory trees.\n"
             "         specifying multiple -dir's is also a way of influencing\n"
             "         the result order; if a file is found both in pic1 and pic3,\n"
             "         the file from pic1 will be listed as original, the other one\n"
             "         as the duplicate.\n"
             "\n"
             "      #sfk sel -dir pic1 pic2 pic3 -file .jpg +dup -minsize=1m\n"
             "         similar to the above, this example uses command chaining:\n"
             "         list all .jpg files from the pic directories, then pass\n"
             "         this to the dupfind command, also filtering by size.\n"
             );
      ehelp;

      bool blistorg = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-minsize", &pszParm)) {
            if (!pszParm) return 9;
            cs.selMinSize = numFromSizeStr(pszParm, "-minsize");
            if (cs.selMinSize < 0) return 9;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-diffdir")) {
            glblDupScan.clDiffDirs = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-listorg")) {
            blistorg = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break;
      }

      int iDirNext = 0;
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext)) return lRC;
      if (btest) return 0;

      if (glblDupScan.clDiffDirs && (glblFileSet.numberOfRootDirs() < 2))
         return 9+perr("need at least two -dir's with option -diffdir.");

      lRC = walkAllTrees(eFunc_DupScan, lFiles, lDirs, nBytes);
      info.clear();

      glblDupScan.analyze(blistorg);
      info.clear();

      if (!chain.colany() && !cs.quiet) {
         printx("$%ld duplicates with %ld mb.", glblDupScan.clNumDups,(long)(glblDupScan.clDupBytes/1000000));
         if (blistorg)
            printx(" $%ld originals with %ld mb.\n",glblDupScan.clNumOrgs,(long)(glblDupScan.clOrgBytes/1000000));
         else
            printf("\n");
      }

      glblDupScan.reset();

      STEP_CHAIN(iDirNext, 1);
      
      bDone = 1;
   }

   ifcmd (   !strncmp(pszCmd, "samp", 4) || !strncmp(pszCmd, "examp", 5)
          || !strcmp(pszCmd, "batch")
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk sample java|cpp|... [outfile.java|.cpp|...]\n"
             "\n"
             "   print a short example code in a programming language.\n"
             "\n"
             "   $supported parameters:\n"
             "      java      - create a java class doing text  file I/O\n"
             "      javaimg   - create a java class doing image file I/O\n"
             "      javahex   - create a hexdump of binary data in java\n"
             "      javagui   - create a simple java gui application\n"
             "      cpp       - create a c++ text file I/O example\n"
             "      php       - create command line php code for text I/O\n"
             "      phpimg    - create php example for image processing\n"
             "      cmd       - create a windows .cmd or .bat file\n"
             "      bash      - create a linux bash script\n"
             "      sfk       - create an sfk script\n"
             "      sfkcmd    - sfk script embedded in a .cmd or .bat\n"
             "      sfkbash   - sfk script embedded in a bash script\n"
         //  "      sfkcmdphp - mixture of windows .bat, sfk and php,\n"
         //  "                  to list pixel sizes of images in a dir.\n"
         //  "      html      - simple html page with css and javascript.\n"
             "      firefox   - create a simple firefox extension, onto\n"
             "                  terminal by default. add parameter \"write\"\n"
             "                  to really write the listed files.\n"
             "\n"
             "   $options:\n"
             "      -force    if output file exists already, overwrite it.\n"
             "\n"
             "   $command shortcut:\n"
             #ifdef _WIN32
             "      #sfk batch myscript.bat\n"
             "         does the same as \"sfk samp sfkcmd myscript.bat\"\n"
             #else
             "      #sfk batch myscript\n"
             "         does the same as \"sfk samp sfkbash myscript\"\n"
             #endif
             "\n"
             "   $examples:\n"
             "      #sfk samp sfkcmd foo.bat\n"
             "         creates batch file foo.bat with embedded sfk script.\n"
             "         type \"foo.bat\" to run the created script. note that\n"
             "         foo.bat must be created in a directory of your PATH,\n"
             "         or in the current directory.\n"
             "\n"
             "      #sfk batch foo.bat -force\n"
             "         the same as above, and overwrites an existing file.\n"
             "\n"
             "      #sfk samp java foo.java\n"
             "         create a java class foo. if the java JDK is available,\n"
             "         type \"javac foo.java\" and then \"java foo\" to run it.\n"
             "\n"
             "      #sfk samp phpimg doimg.php\n"
             "         create image processing script that can be run by:\n"
             "         #php doimg.php\n"
             "         if php.exe is in your PATH (read remarks in the script).\n"
             "\n"
             #ifdef _WIN32
             "      #sfk samp javahex +toclip\n"
             "         copy example for java hexdump creation to the clipboard.\n"
             #endif
             "\n"
             "      #sfk samp firefox write\n"
             "         create an empty firefox extension named \"myext@mydomain.org\",\n"
             "         that adds a popup menu function \"Say Hello\".\n"
             "         you SHOULD do this only within the \"extensions\" directory of\n"
             "         your Firefox installation. after creation, replace every \"myext\"\n"
             "         and/or mydomain.org you can find by the name of your project.\n"
             "         see also \"sfk help firefox\".\n"
             );
      ehelp;

      bool bbatch = !strcmp(pszCmd, "batch");
      bool bWriteFile    = 0;
      long nlang         = 0;
      char *pszLang      = "";
      char *pszOutFile   = 0;
      char *pszClassName = "fileio";
      bool bLocalFile    = 0;

      #ifdef _WIN32
      if (bbatch) nlang = 6;
      #else
      if (bbatch) nlang = 7;
      #endif

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // template keywords are non-option keywords
         char *pszkey = argv[iDir];
         if (nlang == 0) {
            // expecting language as next key
            if (!strcmp(pszkey, "java"))      nlang =  1; else
            if (!strcmp(pszkey, "cpp"))       nlang =  2; else
            if (!strcmp(pszkey, "cmd"))       nlang =  3; else
            if (!strcmp(pszkey, "bash"))      nlang =  4; else
            if (!strcmp(pszkey, "sfk"))       nlang =  5; else
            if (!strcmp(pszkey, "sfkcmd"))    nlang =  6; else
            if (!strcmp(pszkey, "sfkbash"))   nlang =  7; else
            if (!strcmp(pszkey, "javaimg"))   nlang =  8; else
            if (!strcmp(pszkey, "php"))       nlang =  9; else
            if (!strcmp(pszkey, "phpimg"))    nlang = 10; else
            if (!strcmp(pszkey, "html"))      nlang = 11; else
            if (!strcmp(pszkey, "sfkcmdphp")) nlang = 12; else
            if (!strcmp(pszkey, "javahex"))   nlang = 13; else
            if (!strcmp(pszkey, "javagui"))   nlang = 14; else
            if (!strcmp(pszkey, "firefox")) { nlang = 15; bLocalFile = 1; pszLang = pszkey; }
            else return 9+perr("unknown language: %s\n", pszkey);
         } else {
            pszOutFile = pszkey;
         }
      }

      if (!bLocalFile && pszOutFile) {
         if (strchr(pszOutFile, glblPathChar))
            return 9+perr("no path allowed in output filename.\n");
         // isolate class name from output filename
         strcopy(szLineBuf, pszOutFile);
         char *psz = strchr(szLineBuf, '.');
         if (psz) {
            *psz = '\0';
            pszClassName = szLineBuf;
         }
         else
         if (nlang < 3)
            return 9+perr("need an output filename like x.java or x.cpp\n");
         if (!cs.force && fileExists(pszOutFile)) {
            perr("file already exists: %s\n", pszOutFile);
            pinf("add -force to overwrite.\n");
            return 9;
         }
         if (!(cs.outfile = fopen(pszOutFile, "w")))
            return 9+perr("cannot write: %s\n", pszOutFile);
      }

      if (bLocalFile && pszOutFile) {
         if (!strcmp(pszOutFile, "write"))
            bWriteFile = 1;
         else
            return 9+perr("specify \"write\" or nothing after %s\n", pszLang);
      }

      switch (nlang) {
      case 1:
      chain.print(
          "import java.io.*;\n"
          "\n"
          "public class %s\n"
          "{\n"
          "    static void log(String s) { System.out.println(\"main: \"+s); }\n"
          "\n"
          "    public static void main(String args[]) throws Throwable\n"
          "    {\n"
          "        if (args.length < 2)\n"
          "            { log(\"supply in- and output filename.\"); return; }\n"
          "\n"
          "        // copy or convert text file\n"
          "        BufferedReader rin = new BufferedReader(\n"
          "            new InputStreamReader(\n"
          "                new FileInputStream(args[0]), \"ISO-8859-1\"\n"
          "                // or US-ASCII,UTF-8,UTF-16BE,UTF-16LE,UTF-16\n"
          "                ));\n"
          "\n"
          "        PrintWriter pout = new PrintWriter(\n"
          "            new OutputStreamWriter(\n"
          "                new FileOutputStream(args[1]), \"ISO-8859-1\"\n"
          "                ));\n"
          "\n"
          "        while (true) {\n"
          "            String sline = rin.readLine();\n"
          "            if (sline == null) break; // EOD\n"
          "            log(\"copying line: \"+sline);\n"
          "            pout.println(sline);\n"
          "        }\n"
          "\n"
          "        pout.close();\n"
          "        rin.close();\n"
          "    }\n"
          "};\n",
          pszClassName
        );
         break;

      case 2:
      chain.print(
         "#include <stdio.h>\n"
         "#include <string.h>\n"
         "#include <stdarg.h>\n"
         "\n"
         "// print error message with variable parameters.\n"
         "long perr(const char *pszFormat, ...) {\n"
         "   va_list argList;\n"
         "   va_start(argList, pszFormat);\n"
         "   char szBuf[1024];\n"
         "   ::vsprintf(szBuf, pszFormat, argList);\n"
         "   fprintf(stderr, \"error: %%s\", szBuf);\n"
         "   return 0;\n"
         "}\n"
         "\n"
         "// copy text lines from one file into another.\n"
         "int main(int argc, char *argv[]) \n"
         "{\n"
         "  if (argc < 2) return 9+perr(\"specify input and output filename.\\n\");\n"
         "\n"
         "  char *pszInFile  = argv[1];\n"
         "  char *pszOutFile = argv[2];\n"
         "\n"
         "  FILE *fin  = fopen(pszInFile , \"rb\"); if (!fin ) return 9+perr(\"cannot read %%s\\n\" , pszInFile);\n"
         "  FILE *fout = fopen(pszOutFile, \"wb\"); if (!fout) return 9+perr(\"cannot write %%s\\n\", pszOutFile);\n"
         "\n"
         "  char szBuf[1024];\n"
         "  memset(szBuf, 0, sizeof(szBuf));\n"
         "  while (fgets(szBuf, sizeof(szBuf)-10, fin)) \n"
         "  {\n"
         "     char *psz = strchr(szBuf, '\\r'); if (psz) *psz = '\\0'; // strip cr\n"
         "           psz = strchr(szBuf, '\\n'); if (psz) *psz = '\\0'; // strip lf\n"
         "     printf(\"line: \\\"%%s\\\"\\n\", szBuf);\n"
         "     strcat(szBuf, \"\\n\");\n"
         "     long nlen = strlen(szBuf);\n"
         "     if (fwrite(szBuf, 1, nlen, fout) != nlen)\n"
         "        return 9+perr(\"failed to fully write %%s\\n\", pszOutFile);\n"
         "  }\n"
         "\n"
         "  fclose(fout);\n"
         "  fclose(fin);\n"
         "\n"
         "  return 0;\n"
         "}\n"
        );
         break;

      case 3:
      chain.print(
         "@rem windows command shell batch example\n"
         "@echo off\n"
         "IF \"%%1\"==\"\" GOTO xerr01\n"
         "echo \"parameter is %%1\"\n"
         "GOTO xdone\n"
         "\n"
         ":xerr01\n"
         "echo \"please supply a parameter.\"\n"
         "echo \"example: mybat parm123\"\n"
         "GOTO xdone\n"
         "\n"
         ":xdone\n"
         );
         break;

      case 4:
      chain.print(
         "#!/bin/bash\n"
         "\n"
         "function pmsg {\n"
         "   # uses a local variable mystr\n"
         "   local mystr=\"info: $1\"\n"
         "   echo $mystr\n"
         "}\n"
         "\n"
         "myparm1=\"$1 and $2\"       # no blanks around \"=\"\n"
         "\n"
         "if [ \"$2\" = \"\" ]; then    # requires all blanks\n"
         "   pmsg \"please supply two parameters.\"\n"
         "else\n"
         "   pmsg \"you supplied \\\"$myparm1\\\".\"\n"
         "\n"
         "   #  < -lt   > -gt   <= -le   >= -ge   == -eq   != -ne\n"
         "   i=1\n"
         "   while [ $i -le 5 ]; do # not \"$i < 5\"\n"
         "      echo counting: $i   # quotes are optional\n"
         "      let i+=1            # not \"i += 1\" or \"$i+=1\"\n"
         "   done\n"
         "fi\n"
         );
         break;

      case 5:
      chain.print(
         "sfk select testfiles .txt .hpp .cpp\n"
         "\n"
         "   // find words supplied by user.\n"
         "   // note that %%1 is the same as $1.\n"
         "   +find\n"
         "      %%1 %%2 %%3 $4 $5 $6\n"
         "\n"
         "   // process files containing hits\n"
         "   +run -quiet \"sfk echo \\\"Found hit in: [green]$file[def]\\\"\" -yes\n"
         "\n"
         "   // run the script by:\n"
         "   // \"sfk script %s pattern1 [pattern2 ...]\"\n",
         pszOutFile ? pszOutFile : "thisfile"
         );
         break;

      case 6:
      chain.print(
         "@echo off\n"
         "sfk script %s -from begin %%*\n"
         "GOTO xend\n"
         "\n"
         "sfk label begin\n"
         "\n"
         "   // select text files from testfiles:\n"
         "   +select testfiles .txt\n"
         "\n"
         "   // filter words foo, and user-supplied:\n"
         "   +ffilter\n"
         "      -+foo\n"
         "      %%1\n"
         "      %%2\n"
         "\n"
         "   // display results in depeche view:\n"
         "   +view\n"
         "\n"
         "   // end of sfk script:\n"
         "   +end\n"
         "\n"
         ":xend\n",
         pszOutFile ? pszOutFile : "thisfile.bat"
         );
         break;

      case 7:
      chain.print(
         "#!/bin/bash\n"
         "sfk script %s -from begin $@\n"
         "function skip_block\n"
         "{\n"
         "sfk label begin\n"
         "\n"
         "   // select text files from testfiles:\n"
         "   +select testfiles .txt\n"
         "\n"
         "#  // filter words foo, and user-supplied.\n"
         "#  // note that # lines are skipped by bash,\n"
         "#  // but not by sfk.\n"
         "#  +ffilter\n"
         "#     -+foo\n"
         "#     $1\n"
         "#     $2\n"
         "\n"
         "   // display results in depeche view:\n"
         "   +view\n"
         "\n"
         "   // end of sfk script:\n"
         "   +end\n"
         "}\n",
         pszOutFile ? pszOutFile : "thisfile.bat"
         );
         break;

      case 8:
      chain.print(
         "\n"
         "// Example source code for image file conversion\n"
         "// and simple image processing with Java.\n"
         "// Requires SUN's Java Advanced Imaging I/O Tools.\n"
         "// Usage: java imtool input.png outbase\n"
         "// Creates: outbase-jpg.jpg and further.\n"
         "\n"
         "import java.io.*;\n"
         "import java.awt.image.*;\n"
         "import javax.imageio.*;\n"
         "import com.sun.image.codec.jpeg.*;\n"
         "\n"
         "public class %s\n"
         "{\n"
         "    static void log(String s) { System.out.println(s); }\n"
         "\n"
         "    public static void main(String args[]) throws Throwable\n"
         "    {\n"
         "        if (args.length < 2)\n"
         "            throw new Exception(\"specify input filename and output basename.\");\n"
         "\n"
         "        String src  = args[0];\n"
         "        String dst1 = args[1]+\"-jpg.jpg\";\n"
         "        String dst2 = args[1]+\"-png.png\";\n"
         "        String dst3 = args[1]+\"-green.jpg\";\n"
         "        String dst4 = args[1]+\"-green.png\";\n"
         "\n"
         "        // load a PNG image, with or without transparency (alpha channel).\n"
         "        BufferedImage buf = ImageIO.read(new File(src));\n"
         "        int nwidth  = buf.getWidth();\n"
         "        int nheight = buf.getHeight();\n"
         "        log(\"width = \"+nwidth+\" pixels, height = \"+nheight);\n"
         "\n"
         "        // trivial file conversion: save as a JPEG or PNG image.\n"
         "        // JPEG will work only if input contained no transparency.\n"
         "        ImageIO.write(buf, \"jpg\", new File(dst1)); log(dst1);\n"
         "        ImageIO.write(buf, \"png\", new File(dst2)); log(dst2);\n"
         "\n"
         "        // image processing: turn all transparent pixels into green.\n"
         "\n"
         "        // 1. get access to main pixels, and transparency.\n"
         "        WritableRaster rmain = buf.getRaster();\n"
         "        WritableRaster rtran = buf.getAlphaRaster();\n"
         "\n"
         "        // 2. create a memory image to write to, WITHOUT transparency.\n"
         "        BufferedImage bout  = new BufferedImage(nwidth,nheight,BufferedImage.TYPE_INT_RGB);\n"
         "        WritableRaster rout = bout.getRaster();\n"
         "\n"
         "        int apixm[] = new int[4]; // main  pixel\n"
         "        int apixt[] = new int[4]; // trans pixel\n"
         "        int apixr[] = new int[4]; // repl. color\n"
         "\n"
         "        apixt[0] = 0xFF; // default is non-transparent\n"
         "        apixr[1] = 0xFF; // set replacement color to green\n"
         "\n"
         "        for (int y=0; y<nheight; y++)\n"
         "         for (int x=0; x<nwidth; x++) \n"
         "         {\n"
         "            rmain.getPixel(x,y,apixm);\n"
         "            if (rtran != null)\n"
         "                rtran.getPixel(x,y,apixt);\n"
         "            if (apixt[0] == 0x00)\n"
         "                // pixel is fully transparent: set to green\n"
         "                rout.setPixel(x,y,apixr);\n"
         "            else\n"
         "                // else copy trough, do not change.\n"
         "                rout.setPixel(x,y,apixm);\n"
         "         }\n"
         "\n"
         "        // save memory image as JPEG, with control of quality.\n"
         "        File file = new File(dst3);\n"
         "        FileOutputStream out = new FileOutputStream(file);\n"
         "        JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);\n"
         "        JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(bout);\n"
         "        param.setQuality((float)90.0, false); // 90 percent quality\n"
         "        encoder.setJPEGEncodeParam(param);\n"
         "        encoder.encode(bout);\n"
         "        out.close();\n"
         "        log(dst3);\n"
         "\n"
         "        // save memory image as PNG.\n"
         "        ImageIO.write(bout, \"png\", new File(dst4)); log(dst4);\n"
         "    }\n"
         "};\n"
         ,pszClassName
         );
         break;

      case 9:
      chain.print(
         "<?php\n"
         "   // simple text file read and write in php.\n"
         "   // requires the php command line interface:\n"
         "   // 1. get the php 5.x zip package\n"
         "   // 2. unzip into a dir like c:\\app\\php\n"
         "   // 3. set PATH=%PATH%;c:\\app\\php;c:\\app\\php\\ext\n"
         "   // then run this script by \"php %s\"\n"
         "\n"
         "   if ($argc < 3) {\n"
         "      print(\"usage: php %s infile outfile\\n\");\n"
         "      return;\n"
         "   }\n"
         "\n"
         "   $ssrc = $argv[1];\n"
         "   $sdst = $argv[2];\n"
         "\n"
         "   if (($fsrc = fopen($ssrc, \"r\")) === false) die(\"cannot read $ssrc\\n\");\n"
         "   if (($fdst = fopen($sdst, \"w\")) === false) die(\"cannot write $sdst\\n\");\n"
         "\n"
         "   $nlines = 0;\n"
         "   while (!feof($fsrc)) {\n"
         "      $sline = fgets($fsrc, 4096);\n"
         "      if (fputs($fdst, $sline) === false)\n"
         "         { print(\"failed to write (disk full?)\\n\"); break; }\n"
         "      $nlines++;\n"
         "   }\n"
         "\n"
         "   fclose($fdst);\n"
         "   fclose($fsrc);\n"
         "\n"
         "   print(\"$nlines lines copied from $ssrc to $sdst.\\n\");\n"
         "?>\n"
         ,pszOutFile ? pszOutFile : "thisfile.php"
         ,pszOutFile ? pszOutFile : "thisfile.php"
         );
         break;

      case 10:
      chain.print(
         "<?php\n"
         "   // create a thumbnail image from a large image.\n"
         "   // requires the php command line interface:\n"
         "   // 1. get the php 5.x zip package\n"
         "   // 2. unzip into a dir like c:\\app\\php\n"
         "   // 3. set PATH=PATH;c:\\app\\php;c:\\app\\php\\ext\n"
         "   // then run this script by \"php %s in.jpg out.jpg\"\n"
         "\n"
         "   if ($argc < 3) {\n"
         "      print(\"usage: php %s input.jpg output.jpg [targetwidth quality]\\n\");\n"
         "      return;\n"
         "   }\n"
         "\n"
         "   $ssrc = $argv[1];\n"
         "   $sdst = $argv[2];\n"
         "   $wdst = isset($argv[3]) ? $argv[3] : 100;\n"
         "   $nqty = isset($argv[4]) ? $argv[4] :  80;\n"
         "\n"
         "   if (strstr($ssrc, \".jpg\"))\n"
         "      $isrc = ImageCreateFromJPEG($ssrc);\n"
         "   else\n"
         "      $isrc = ImageCreateFromPNG($ssrc);\n"
         "   if ($isrc === false) die(\"cannot load: $ssrc\");\n"
         "\n"
         "   $nsrcw = ImageSX($isrc);\n"
         "   $nsrch = ImageSY($isrc);\n"
         "   print(\"input: $ssrc with $nsrcw\".\"x$nsrch pixels\\n\");\n"
         "\n"
         "   $hdst  = intval($wdst * $nsrch / $nsrcw);\n"
         "   $idst  = ImageCreateTrueColor($wdst, $hdst);\n"
         "   if ($idst === false) die(\"cannot create thumb\");\n"
         "\n"
         "   imagecopyresampled($idst, $isrc, 0,0,0,0, $wdst,$hdst, $nsrcw, $nsrch);\n"
         "   imagejpeg($idst, $sdst, $nqty);\n"
         "   print(\"thumb: $sdst with $wdst\".\"x$hdst pixels, quality=$nqty\\n\");\n"
         "\n"
         "   imagedestroy($idst);\n"
         "   imagedestroy($isrc);\n"
         "?>\n"
         ,pszOutFile ? pszOutFile : "thisfile.php"
         ,pszOutFile ? pszOutFile : "thisfile.php"
         );
         break;

      case 11:
      chain.print(
         "<html>\n"
         " <head>\n"
         "  <title>Welcome to FooBar</title>\n"
         "   <style type=\"text/css\">\n"
         "      body     { font: 12px verdana,arial; }\n"
         "      table    { font: 12px verdana,arial; }\n"
         "      h1       { font: 16px verdana,arial; font-weight: bold; }\n"
         "      b.red    { color: #ee6622; }\n"
         "   </style>\n"
         "   <script type=\"text/javascript\">\n"
         "      function hello() {\n"
         "         document.write(\"hello from JavaScript.\");\n"
         "      }\n"
         "   </script>\n"
         " </head>\n"
         "<body leftmargin=\"0\" topmargin=\"0\" marginwidth=\"0\" marginheight=\"0\">\n"
         "\n"
         "<table width=\"980\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\" border=\"0\">\n"
         "\n"
         " <tr>\n"
         "  <td width=\"120\" align=\"center\" valign=\"middle\">\n"
         "  &nbsp;<br>\n"
         "  home\n"
         "  </td>\n"
         "  <td width=\"740\" align=\"center\" valign=\"top\">\n"
         "  &nbsp;<br>\n"
         "  <h1>Welcome to FooBar.</h1>\n"
         "  </td>\n"
         "  <td width=\"120\" align=\"center\" valign=\"middle\">\n"
         "  &nbsp;<br>\n"
         "  other\n"
         "  </td>\n"
         " </tr>\n"
         "\n"
         " <tr>\n"
         "  <td align=\"center\" valign=\"top\">&nbsp;</td>\n"
         "  <td>\n"
         "      <b class=\"red\">bold</b> and normal text.\n"
         "      <p>\n"
         "      <script type=\"text/javascript\">\n"
         "         hello();\n"
         "      </script>\n"
         "  </td>\n"
         "  <td align=\"center\" valign=\"top>&nbsp;</td>\n"
         " </tr>\n"
         "\n"
         "</table>\n"
         "\n"
         "</body>\n"
         "</html>\n"
         );
         break;

      case 12:
      chain.print(
         "@rem <?php print(\"\\r\"); /*\n"
         "@echo off\n"
         "\n"
         "IF \"%%1\"==\"\" GOTO xerr01\n"
         "\n"
         "sfk script %s -from begin %%*\n"
         "GOTO xend\n"
         "\n"
         ":xerr01\n"
         "sfk echo \"[green]jpeg image size lister.[def]\"\n"
         "sfk echo \"lists width, height of all .jpg in a dir.\"\n"
         "sfk echo \"usage: %s dirname\"\n"
         "GOTO xend\n"
         "\n"
         "   // this script requires the php command line interface:\n"
         "   // 1. get the php 5.x zip package\n"
         "   // 2. unzip into a dir like c:\\app\\php\n"
         "   // 3. set PATH=PATH;c:\\app\\php;c:\\app\\php\\ext\n"
         "\n"
         "   // ----- begin of sfk script code -----\n"
         "\n"
         "sfk label begin\n"
         "\n"
         "   +sel %%1 .jpg\n"
         "\n"
         "   +run -quiet -yes \"php %s $file\"\n"
         "\n"
         "   +end\n"
         "\n"
         "*/ // ----- end of sfk, begin of php script -----\n"
         "\n"
         "   // print the width and height in pixel\n"
         "   // of the supplied image file name:\n"
         "\n"
         "   $asize = getimagesize($argv[1]);\n"
         "   printf(\"w=%%04ld h=%%04ld %%s\\n\", $asize[0], $asize[1], $argv[1]);\n"
         "\n"
         "/* // ----- end of php script, end of batch -----\n"
         ":xend\n"
         "@rem */ ?>\n"
         ,pszOutFile ? pszOutFile : "thisfile.bat"
         ,pszOutFile ? pszOutFile : "thisfile.bat"
         ,pszOutFile ? pszOutFile : "thisfile.bat"
         );
         break;

      case 13:
      chain.print(
         "import java.io.*;\n"
         "\n"
         "public class %s\n"
         "{\n"
         "    static void log(String s) { System.out.println(s); }\n"
         "\n"
         "    // convert a single byte record into a hexdump record.\n"
         "    // by default, set nrec to 16, and ndoff to 0.\n"
         "    public static String hexRecord(byte ab[], int noffset, int nlen, int nrec, int ndoff)\n"
         "    {\n"
         "        // create hex and text representation\n"
         "        StringBuffer sline = new StringBuffer();\n"
         "        StringBuffer stext = new StringBuffer();\n"
         "        for (int i=0; i<nlen; i++) {\n"
         "            int nval = ab[noffset+i] & 0xFF;\n"
         "            if (nval < 0x10) sline.append(\"0\");\n"
         "            sline.append(Integer.toString(nval, 0x10));\n"
         "            sline.append(\" \");\n"
         "            if (Character.isLetter(nval))\n"
         "                stext.append((char)nval);\n"
         "            else\n"
         "                stext.append('.');\n"
         "        }\n"
         "        // fill rest of line, if any\n"
         "        int npadlen = nrec;\n"
         "        while (stext.length() < npadlen) stext.append(' ');\n"
         "        npadlen *= 3;\n"
         "        while (sline.length() < npadlen) sline.append(' ');\n"
         "        sline.setLength(sline.length()-1);\n"
         "        // create offset as hex value\n"
         "        String soffset = \"\";\n"
         "        soffset = Integer.toString(ndoff, 0x10).toUpperCase();\n"
         "        while (soffset.length() < 10) soffset = \"0\"+soffset;\n"
         "        // combine hex, text and offset\n"
         "        return \">\"+sline.toString().toUpperCase()+\"< \"+stext+\" \"+soffset;\n"
         "    }\n"
         "    \n"
         "    // hexdump a whole byte array, from a given offset.\n"
         "    // nrec is the number of bytes per output record, use 16 by default.\n"
         "    // ndosv is the display offset start value, use 0 by default.\n"
         "    public static void hexDump(byte ab[], int noffset, int nlen, int nrec, int ndoff)\n"
         "    {\n"
         "        while (nlen > 0) {\n"
         "            int nblock  = (nlen < nrec) ? nlen : nrec;\n"
         "            String srec = hexRecord(ab, noffset, nblock, nrec, ndoff);\n"
         "            System.out.println(srec);\n"
         "            noffset += nblock;\n"
         "            ndoff   += nblock;\n"
         "            nlen    -= nblock;\n"
         "        }\n"
         "    }\n"
         "\n"
         "    // hex dump a whole binary file's content\n"
         "    public static void main(String args[]) throws Throwable\n"
         "    {\n"
         "        if (args.length < 1)\n"
         "            { log(\"usage: java %s inputfilename\"); return; }\n"
         "\n"
         "        byte abBuf[] = new byte[1600];\n"
         "\n"
         "        FileInputStream oin = new FileInputStream(args[0]);\n"
         "\n"
         "        int nread  = 0;\n"
         "        int ntotal = 0;\n"
         "        do {\n"
         "            nread = oin.read(abBuf, 0, abBuf.length);\n"
         "            if (nread > 0) hexDump(abBuf, 0, nread, 16, ntotal);\n"
         "            ntotal += nread;\n"
         "        }   while (nread > 0);\n"
         "\n"
         "        oin.close();\n"
         "    }\n"
         "}\n"
          ,pszClassName,pszClassName
        );
         break;

      case 14:
      chain.print(
         "\n"
         "import java.awt.*;\n"
         "import java.awt.event.*;\n"
         "import java.io.*;\n"
         "import javax.swing.*;\n"
         "import java.util.*;\n"
         "\n"
         "// can be run both as an applet and a command line application\n"
         "public class %s extends JApplet implements ActionListener\n"
         "{\n"
         "    // a panel to collect all objects for display\n"
         "    Container clPane = null;\n"
         "\n"
         "    // a hashmap to collect the same objects for retrieval by an id\n"
         "    HashMap<String,Component> clComp = new HashMap<String,Component>();\n"
         "    // HashMap clComp = new HashMap(); // for JDK 1.4.2\n"
         "\n"
         "    // the current add position\n"
         "    int xadd = 0, yadd = 0;\n"
         "\n"
         "    // set component placement cursor to a position\n"
         "    void setPos(int x,int y) { xadd=x; yadd=y; }\n"
         "    \n"
         "    // add and remember a generic component for display.\n"
         "    // steps the placement cursor w pixels to the right.\n"
         "    void add(int x,int y,int w,int h,String id,Component o) {\n"
         "        o.setBounds(x,y,w,h);   // set absolute position of object\n"
         "        clPane.add(o);          // add to panel to display object\n"
         "        clComp.put(id, o);      // and remember object in a hashmap\n"
         "        xadd += w;              // step add position horizontally\n"
         "    }\n"
         "    \n"
         "    // add a non-editable text label\n"
         "    void addLabel(int w, int h, String id, String text)\n"
         "        { add(xadd,yadd,w,h, id, new JLabel(text)); }\n"
         "\n"
         "    // add a single line editable text field    \n"
         "    void addTextField(int w, int h, String id, String text)\n"
         "        { add(xadd,yadd,w,h, id, new JTextField(text)); }\n"
         "\n"
         "    // add a multi linex editable text area\n"
         "    void addTextArea(int w, int h, String id, String text) {\n"
         "        JTextArea   oarea   = new JTextArea(text);\n"
         "        JScrollPane oscroll = new JScrollPane(oarea);\n"
         "        oscroll.setBounds(xadd,yadd,w,h);\n"
         "        clPane.add(oscroll);\n"
         "        clComp.put(id,oarea);\n"
         "    }\n"
         "\n"
         "    // add a push button\n"
         "    void addButton(int w, int h, String id, String text) {\n"
         "        JButton o = new JButton(text);\n"
         "        o.addActionListener(this);\n"
         "        add(xadd,yadd,w,h, id, o);\n"
         "    }\n"
         "\n"
         "    // easy access to any object by it's id\n"
         "    JTextField getTextField(String id) { return (JTextField)clComp.get(id); }\n"
         "    JTextArea  getTextArea (String id) { return (JTextArea )clComp.get(id); }\n"
         "    JLabel     getLabel    (String id) { return (JLabel    )clComp.get(id); }\n"
         "\n"
         "    // setup visible objects at absolute positions\n"
         "    private void fillPane() \n"
         "    {        \n"
         "        clPane.setLayout(null); // absolute positioning layout\n"
         "        \n"
         "        setPos      ( 20, 20);\n"
         "        addLabel    ( 70, 20, \"lname\", \"filename\");\n"
         "        addTextField(620, 20, \"tname\", \"c:\\\\test.txt\");\n"
         "\n"
         "        setPos      ( 90, yadd + 30);\n"
         "        addButton   (620, 20, \"bload\", \"load\");\n"
         "\n"
         "        setPos      ( 20, yadd + 30);\n"
         "        addLabel    ( 70, 20, \"lcont\", \"content\");\n"
         "        addTextArea (620,400, \"acont\", \"\");\n"
         "    }\n"
         "\n"
         ,pszClassName);
    chain.print(
         "    // process push button command    \n"
         "    public void actionPerformed(ActionEvent e) \n"
         "    {\n"
         "        String sout = \"\";\n"
         "        try {\n"
         "            String scmd = e.getActionCommand();\n"
         "            if (scmd.equals(\"load\")) \n"
         "            {\n"
         "                String sFilename = getTextField(\"tname\").getText();\n"
         "                BufferedReader rin = new BufferedReader(\n"
         "                    new InputStreamReader(new FileInputStream(sFilename), \"ISO-8859-1\"));\n"
         "                while (true) {\n"
         "                    String sline = rin.readLine();\n"
         "                    if (sline == null) break; // EOD\n"
         "                    sout += sline + \"\\n\";\n"
         "                }\n"
         "                rin.close();\n"
         "            }\n"
         "        } catch (Throwable t) {\n"
         "            sout = \"\"+t;\n"
         "        }\n"
         "        getTextArea(\"acont\").setText(sout);\n"
         "    }\n"
         "\n"
         "    // to run it from the command line:\n"
         "    public static void main(String[] args)\n"
         "        { new %s().main2(args); }\n"
         "\n"
         "    public void main2(String[] args) {\n"
         "        JFrame frame = new JFrame(\"Simple File Viewer\");\n"
         "        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n"
         "        clPane = frame.getContentPane();\n"
         "        fillPane();\n"
         "        frame.setSize(760, 560);\n"
         "        frame.setVisible(true);\n"
         "    }\n"
         "\n"
         "    // to run it as an applet:\n"
         "  public void init() {\n"
         "     clPane = new JPanel();\n"
         "     this.setContentPane(clPane);\n"
         "     fillPane();\n"
         "  }\n"
         "    /*\n"
         "       create a page \"show.html\" containing\n"
         "\n"
         "       <html><body>\n"
         "          <Applet Code=\"%s.class\" width=800 height=600></Applet>\n"
         "       </body></html>\n"
         "      \n"
         "       and then type \"appletviewer show.html\"\n"
         "    */\n"
         "}\n"
          ,pszClassName,pszClassName
        );
        break;

      case 15:
      chain.printFile(
"myext@mydomain.org\\chrome\\content\\myext.xul", bWriteFile,
"<overlay id=\"myextOverlay\" xmlns=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n"
"   <script type=\"application/x-javascript\" src=\"chrome://myext/content/myextOverlay.js\"/>\n"
"   <popup id=\"contentAreaContextMenu\">\n"
"      <menuitem id=\"myext-sayhello\" label=\"Say Hello\" oncommand=\"sayHello(event);\" />\n"
"   </popup>\n"
"</overlay>\n"
         );
      chain.printFile(
"myext@mydomain.org\\chrome\\content\\myextOverlay.js", bWriteFile,
"function sayHello(event) {\n"
"   alert(\"hello.\");\n"
"}\n"
         );
      chain.printFile(
"myext@mydomain.org\\chrome.manifest", bWriteFile,
"content myext chrome/content/\n"
"overlay chrome://browser/content/browser.xul chrome://myext/content/myext.xul\n"
         );
      chain.printFile(
"myext@mydomain.org\\install.rdf", bWriteFile,
"<?xml version=\"1.0\"?>\n"
"<RDF xmlns=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n"
"     xmlns:em=\"http://www.mozilla.org/2004/em-rdf#\">\n"
"  <Description about=\"urn:mozilla:install-manifest\">\n"
"    <em:id>myext@mydomain.org</em:id>\n"
"    <em:version>0.1.0</em:version>\n"
"    <em:type>2</em:type>\n"
"    <em:targetApplication>\n"
"      <Description>\n"
"        <em:id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</em:id> <!-- Firefox -->\n"
"        <em:minVersion>1.0</em:minVersion>\n"
"        <em:maxVersion>3.0.*</em:maxVersion>\n"
"      </Description>\n"
"    </em:targetApplication>\n"
"    <em:name>MyExt</em:name>\n"
"    <em:description>A very simple demo extension</em:description>\n"
"    <em:creator>My Self</em:creator>\n"
"    <em:homepageURL>http://mydomain.org/myext/</em:homepageURL>\n"
"  </Description>      \n"
"</RDF>\n"
         );
         break;
      }

      // sfk filt src -rep "_%_%%_" -srep "_\\_\\\\_" -srep "_\q_\\\q_" -sform "         \q$col1\\n\q" +toclip

      if (cs.outfile) {
         fclose(cs.outfile);
         cs.outfile = 0;
         if (!bLocalFile)
            printf("written: %s\n", pszOutFile);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "memerrtest"))
   {
      char *p = new char[1024];
      // fall through, expect mem leak message
      bDone=1;
   }

   if (!strcmp(pszCmd, "keytest")) 
   {
      StringMap omap;
      long i=0;
      for (i=0; i<1000; i++) 
      {
         char szKey[100];
         char szVal[100];
         sprintf(szKey, "key_%03ld", (long)(rand() % 1000));
         sprintf(szVal, "val_%03ld", (long)(rand() % 1000));
         if (omap.put(szKey, szVal))
            return 9+perr("fail.1");
      }

      printf("%ld entries in keymap\n", omap.size());

      for (i=0; i<omap.size(); i++) {
         char *pkey = 0;
         char *pval = omap.iget(i, &pkey);
         printf("%s %s\n",pkey,pval);
      }

      bDone=1;
   }

   if (!strcmp(pszCmd, "zipdump")) 
   {
      if (nparm < 1) return -1;

      cs.travelzips = 1;

      // ZipReader ozip;
      // ozip.list(argv[2]);
      // ozip.dump(argv[2], argv[3]);

      Coi ozip(argv[2], 0);
      if (!ozip.isTravelDir())
         {  perr("no directory: %s",argv[2]); return 9; }

      if (ozip.openDir())
         {  perr("cannot open"); return 9; }

      for (Coi *psub=0; psub=ozip.nextEntry();) 
      {
         // psub is owned by caller!
         printf("entry: %s dir=%d size=%ld time=%lu\n", psub->name(), psub->isTravelDir(), (long)psub->getSize(), (long)psub->getTime());
         if (!psub->isTravelDir()) {
            long nrc = psub->open("rb");
            if (nrc) {
               printf("   ... open rc %ld\n", nrc);
            } else {
               char abtmp[1024];
               long nread = psub->readLine(abtmp, 100);
               if (nread >= 4) {
                  execHexdump(0, (uchar*)abtmp, nread);
               } else {
                  printf("   ... nread %ld\n", nread);
               }
               psub->close();
            }
         }
         delete psub;
      }

      ozip.closeDir();

      bDone = 1;
   }

   if (!strcmp(pszCmd, "match")) {
      char *phay = argv[2];
      char *ppat = argv[3];
      long nlen  = strlen(phay);
      memset(szAttrBuf, ' ', nlen);
      szAttrBuf[nlen] = '\0';
      long ifirst=0, ilen=0;
      if (matchstr(phay, ppat, 5, ifirst, ilen)) {
         if (ifirst+ilen < MAX_LINE_LEN)
            memset(szAttrBuf+ifirst, 'i', ilen);
         printColorText(phay, szAttrBuf);
      } else {
         printf("no hit\n");
      }
      bDone = 1;
   }

   if (!strcmp(pszCmd, "time")) {
      char *psz = argv[2];
      if (tryGetRelTime(psz, cs.sincetime)) {
         printf("%s\n", timeAsString(cs.sincetime));
      }
      bDone = 1;
   }

   if (!strcmp(pszCmd, "errortest"))
   {
      if (nparm < 1) {
      printx("<help>$sfk [options] errortest mask\n"
             "\n"
             "   produces test error(s), showing return codes.\n"
             "   this command implies -showrc.\n"
             "\n"
             "   $mask\n"
             "   may contain one or more characters to select\n"
             "   a test case from:\n"
             "\n"
             "      n   normal file processing (no error).\n"
             "      e   produce a syntax error.\n"
             "      w   produce a general warning.\n"
             "      f   simulate (skipped) unreadable file.\n"
             "      m   simulate out of memory.\n"
             "      l   simulate general error with low rc.\n"
             "\n"
             "   $options\n"
             "      -rcfromerr   on skipped errors, pass rc to shell.\n"
             "      -stoponerr   stop on first unreadable file.\n"
             "\n"
             "   $example\n"
             "      #sfk -rcfromerr errortest nnnfnn\n"
             "         simulates five successful and one erroneous file\n"
             "         processings, changing the shell rc on any errors.\n"
             );
      return 9;
      }

      char *pmask = "";
      gs.showrc   = 1;

      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unexpected: %s\n", argv[iDir]);
         }
         pmask = argv[iDir];
      }

      bool bstop = 0;
      while (!bstop && *pmask)
      {
         switch (*pmask++)
         {
            case 'n':
            {
               long nFuncRC = 0;
               printf("file processed, ");
               bstop = cs.stopTree(nFuncRC);
               printf("processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%ld)\n",bstop,nFuncRC);
               break;
            }
            case 'e': lRC = 9+perr("syntax test error"); break;
            case 'w': lRC = 5+pwarn("general test warning"); break;
            case 'f':
            {
               long nFuncRC = 9+perr("file unreadable.\n");
               bstop = cs.stopTree(nFuncRC);
               printf("   processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%ld)\n",bstop,nFuncRC);
               break;
            }
            case 'm':
            {
               long nFuncRC = 19+perr("out of memory.\n");
               bstop = cs.stopTree(nFuncRC);
               printf("   processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%ld)\n",bstop,nFuncRC);
               break;
            }
            case 'l':
            {
               long nFuncRC = 5+perr("non-fatal fn error.\n");
               bstop = cs.stopTree(nFuncRC);
               printf("   processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%ld)\n",bstop,nFuncRC);
               break;
            }
         }
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "cat")) 
   {
      if (!chain.usefiles && (nparm < 1)) {
      printx("<help>$sfk cat filename\n"
             "\n"
             "   dump content of a text file.\n"
             );
      return 9;
      }

      char *pfile = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (pfile)
            return 9+perr("unexpected: %s\n", argv[iDir]);
         pfile = argv[iDir];
      }
      if (!pfile) return 9+perr("missing filename.");

      Coi *pcoi = new Coi(pfile, 0);
      pcoi->incref("main");

      uchar *pdata = 0; // managed by COI!
      num    nsize = 0;
      if (pcoi->getContent(&pdata, nsize))
         perr("cannot get content of: %s", pcoi->name());
      else {
         // dump text content, line by line.
         char *psz1 = (char*)pdata;
         while (*psz1) {
            char *psz2 = psz1;
            while (*psz2 && *psz2 != '\n') psz2++;
            long nlen = psz2 - psz1;
            chain.print("%.*s\n", (int)nlen, psz1);
            if (*psz2) psz2++;
            psz1 = psz2;
         }
      }

      if (!pcoi->decref())
         delete pcoi; // no refs remaining, not cached

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "tcping")) 
   {
      if (!chain.usefiles && (nparm < 1)) {
      printx("<help>$sfk tcping host:port [options]\n"
             "\n"
             "   check if a host accepts tcp/ip connections\n"
             "\n"
             "   $options\n"
             "      -loop     retry endlessly until connect\n"
             "      -delay=n  delay seconds between tries\n"
             "\n"
             "   $examples\n"
             "      #sfk tcping myhost:80 -loop\n"
             "         try to connect until service is available\n"
             );
      return 9;
      }

      char *phostport = 0;
      bool bloop      = 0;
      long ndelay     = 1000;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-delay", &pszParm)) {
            if (!pszParm) return 9;
            ndelay = atol(pszParm) * 1000;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-loop")) {
            bloop = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!phostport) {
            phostport = argv[iDir];
            continue;
         }
         return 9+perr("unexpected parameter: %s\n", argv[iDir]);
      }

      if (!phostport)
         return 9+perr("missing host:port\n");

      long nPort = 80;

      char szHost[200];
      strcopy(szHost, phostport);
      char *psz1 = strchr(szHost, ':');
      if (psz1) {
         *psz1++ = '\0';
         nPort = atol(psz1);
      }

      SOCKET hSock = 0;

      prepareTCP();
   
      struct hostent *pTarget;
      struct sockaddr_in sock;
      hSock = socket(AF_INET, SOCK_STREAM, 0);
      if (hSock == INVALID_SOCKET) return 9+perr("cannot create socket\n");
   
      if ((pTarget = sfkhostbyname(szHost)) == NULL)
         return 9+perr("cannot get host\n");
   
      memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
      sock.sin_family = AF_INET;
      sock.sin_port = htons((unsigned short)nPort);

      // TODO: set shorter connection timeout

      long ncnt = 1;
      while (1)
      {
         if (connect(hSock, (struct sockaddr *)&sock, sizeof(sock)) != -1)
            break; // success

         if (bloop) {
            printf("not yet available, retrying (%ld)   \r",ncnt++);
            fflush(stdout);
            doSleep(ndelay);
         } else {
            perr("cannot connect to %s:%lu, %s\n", szHost, nPort, netErrStr());
            return 9;
         }
      }

      printf("connected.                              \n");

      closesocket(hSock);
   
      #ifdef _WIN32
      WSACleanup();
      #endif

      bDone = 1;
   }

   if (!strcmp(pszCmd, "cmptime")) 
   {
      if (nparm < 2) return 9;
      char *pszFile1 = argv[iDir+0];
      char *pszFile2 = argv[iDir+1];
      FileStat fs1; if (fs1.readFrom(pszFile1)) return 9+perr("1");
      FileStat fs2; if (fs2.readFrom(pszFile2)) return 9+perr("2");

      cs.verbose = 9;
      bool bSrcIsOlder = 0;
      long nrc = fs1.differs(fs2, 1, &bSrcIsOlder);
      printf("rc %ld srcio %d\n",nrc,bSrcIsOlder);

      bDone = 1;
   }

   #ifndef _WIN32
   if (!strcmp(pszCmd, "tellnode")) 
   {
      if (nparm < 1) return 9;
      char *pszFile = argv[iDir];

      struct stat64 buf;
      if (stat64(pszFile, &buf)) return 9;
      num nnode = (num)buf.st_ino;
      printf("%s (%lu) %s\n", numtohex(nnode,16),(ulong)nnode,pszFile);

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "script") || !strcmp(pszCmd, "fscript"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk [f]script [opts] file [-from=label] [parm1] [parm2] [...]\n"
             "\n"
             "   execute sfk command(s) from a script file, which can be\n"
             "   -  an absolute filename, e.g. C:\\scripts\\thescript.txt\n"
             "   -  a relative filename. in this case, the file is searched\n"
             "      in the current dir \".\" first, and then in the PATH.\n"
             "\n"
             "   $parameters:\n"
             "   -  if \"-from=label\" is given, the script file is searched\n"
             "      for a statement \"label mylabel\", and script execution runs\n"
             "      from this point until +end is reached.\n"
             "\n"
             "   -  all other words after -from, or instead of from, are passed\n"
             "      as parameters to the script, with one exception:\n"
             "      a word starting with a \"+\" continues the sfk command chain.\n"
             "      if you need to pass words starting with \"+\" to the script,\n"
             "      set option -literal (disallowing further chain commands).\n"
             "\n"
             "   $command chaining:\n"
             "      with ...  +script name, text data is passed to the script.\n"
             "      with ... +fscript name, filenames are passed to the script.\n"
             "\n"
             "   $script file syntax:\n"
             "      - lines having // as first text are ignored.\n"
             "      - command line parameters 1 to 9 can be addressed both\n"
             "        by expressions %%1 to %%9, or $$1 to $$9.\n"
             "      - any whitespace is skipped unless surrounded by quotes \"\n"
             "      - escaped quotes \\\" are changed into normal quotes \"\n"
             "      - line ends are ignored. in general, lines are combined\n"
             "        into one large command chain, just like typing them all\n"
             "        into one line of unlimited length.\n"
             "      - character ## at column 1 of any line is skipped, which\n"
             "        allows bash-embedded scripts to have sfk statements\n"
             "        outcommented if necessary.\n"
             "\n"
             "      $parameter name collisions:\n"
             "        if your script contains phrases like\n"
             "           #+filter -form \"$$10.10col1 ...\"\n"
             "        then \"$$1\" will be misinterpreted as an input parameter\n"
             "        into the script. to get around this problem, redefine the\n"
             "        parameter name prefix at the script's \"sfk label\" line.\n"
             "        type \"sfk label\" for more on that.\n"
             "\n"
             "   $options:\n"
             "      -verbose  tell in detail which words are used from script.\n"
             "      -literal  also pass words to the script that start with \"+\".\n"
          // "\n"
          // "   $setting global options for all commands within a script:\n"
          // "      supply them directly after \"sfk\" of the calling command:\n"
          // "      #sfk -yes script myscript.txt -from=mylabel\n"
          // "         runs myscript.txt with -yes active for every command.\n"
             "\n"
             "   $for script examples, type:\n"
             "      sfk samp sfk       - create sfk sample script\n"
             "      sfk samp sfkcmd    - sample script embedded in windows batch\n"
             "      sfk samp sfkbash   - sample script embedded in bash script\n"
             "      sfk samp           - more about the sfk sample syntax\n"
             "\n"
             "   $recommended use:\n"
             "      if you want to create an easy-to-use script on the fly,\n"
             "      1. create an embedded script in a batch file:\n"
             #ifdef _WIN32
             "         #sfk samp sfkcmd myscript.bat\n"
             #else
             "         #sfk samp sfkbash myscript.bat\n"
             #endif
             "      2. edit myscript.bat with any text editor.\n"
             "      3. run the script just by typing \"myscript.bat\".\n"
             );
      ehelp;

      char *pszScriptFile = 0;
      char *pszLabel      = 0;
      char *pszFlatParms  = 0;

      int  iChainNext =  0;
      int  iLocalParm = -1;
      int  nLocalParm =  0;
      int  nState     =  0;
      bool bliteral   =  0;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (nState < 2 && haveParmOption(argv, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            pszLabel = pszParm;
            nState = 2;
            continue;
         }
         else
         if (nState < 1 && !strncmp(argv[iDir], "-", 1)) {
            // general options are interpreted only before script name,
            // i.e. as long as nState == 0.
            if (strBegins(argv[iDir], "-lit")) {
               bliteral = 1;
               continue;
            }
            else
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (!bliteral && isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszScriptFile) {
            pszScriptFile = argv[iDir];
            nState = 1;
         }
         else
         if (iLocalParm < 0) {
            iLocalParm = iDir;
            nLocalParm = 1;
            nState = 2;
         }
         else
            nLocalParm++;
      }

      if (!pszScriptFile) return 9+perr("missing script file name.");

      char *pszAbsScript = pszScriptFile;
      if (!fileExists(pszAbsScript) && !isAbsolutePath(pszAbsScript)) {
         pszAbsScript = findPathLocation(pszScriptFile, 0);
         if (!pszAbsScript) return 9+perr("%s not found in current dir or PATH.\n", pszScriptFile);
      }

      char *pScriptRaw = loadFile(pszAbsScript);
      if (!pScriptRaw)
         return 9+perr("failed to load script file: %s\n", pszAbsScript);

      // pScriptRaw is the original script data.
      // pScript will be stuffed with terminators
      // and therefore is not reusable.
      char *pScript = strdup(pScriptRaw);

      // auto delete all script data on return.
      CharAutoDel odel1(pScriptRaw);
      CharAutoDel odel2(pScript);

      // in case "call" is used inside script:
      CharAutoRestore oclear(&pGlblCurrentScript);
      pGlblCurrentScript = pScriptRaw;
      // on return, pGlbl will have it's old value set.

      lRC = 0;

      // create temporary argv[] from script file
      StringTable oDynaStrings;
      char **psubargv = 0;
      int    nsubargc = 0;
      for (long npass=0; npass<2; npass++) 
      {
         char *psz1 = pScript;
         char  cold = 0; // old char before current one
         // jump to start label, if any.
         if (pszLabel) {
            sprintf(szLineBuf, "label %s", pszLabel);
            psz1 = strstr(pScript, szLineBuf);
            if (!psz1) {
               perr("label not found: %s\n", pszLabel);
               pinf("use \"sfk label %s +...\" to start with a label.\n", pszLabel);
               pinf("use \"sfk ... +label %s +...\" to insert a label.\n", pszLabel);
               lRC = 9;
               break;
            }
            // do NOT skip anything, let the chain
            // start with the "label" command.
            cold = '\0';
         }
         // main processing, until +end token.
         while (*psz1)
         {
            bool bnewline = 0;
            nextToken(&psz1, cold, bnewline);
            if (*psz1) 
            {
               // on next (non-blank) token
               char *ptok = psz1;
               if (bnewline && !strncmp(ptok, "//", 2)) {
                  // skip remark line
                  while (*ptok && *ptok != '\n') ptok++;
                  // do NOT skip lf, set newline on next cycle
                  psz1 = ptok;
                  continue;
               }

               // find end of token
               skipPastToken(&psz1, cold);
               long ntoklen = psz1 ? (psz1-ptok) : 0;

               long nrc = 0;
               if (npass && *psz1) {
                  cold = *psz1;   // e.g. lf will be overwritten
                  *psz1++ = '\0';
                  // post-process token: strip quotes, transform inner quotes,
                  // substitute parameters.
                  // uses: szLineBuf
                  nrc = postProcessToken(&ptok, oDynaStrings, argc, argv, iLocalParm, nLocalParm);
                  if (nrc >= 9) return 9+perr("unexpected format: \"%s\"\n", ptok);
                  // nrc==1 means skip EMPTY token.
               }

               // special first token "-prefix=..." ?
               // printf("tok %d: \"%s\"\n",nsubargc,ptok);
               if (!nrc && nsubargc<3 && strBegins(ptok, "-prefix=")) {
                  // give script input parameters a user-defined name
                  if (npass) { // not in prescan phase
                     strcopy(cs.paramprefix, ptok+8);
                  }
                  continue;
               }

               // count and register token
               if (!nrc) {
                  if (npass)
                     psubargv[nsubargc] = ptok;
                  nsubargc++;
               }

               // reached "+end"?
               if (ntoklen==4 && !strncmp(ptok, "+end", 4))
                  break;

            }  // endif *psz1

         }  // endwhile *psz1

         // at end of first pass, alloc token array
         if (!npass) {
            psubargv = new char*[nsubargc+10];
            nsubargc = 0;
         }
      }

      if (!lRC && (cs.verbose > 0)) {
         printf("loaded %d words from %s:\n   ", nsubargc, pszScriptFile);
         for (long i=0; i<nsubargc; i++)
            printf("%s,",psubargv[i]);
         printf("\n");
         // printf("iLocalParm %d nLocalParm %d\n",iLocalParm,nLocalParm);
      }

      if (!lRC) 
      {
         char *pszSubCmd = psubargv[0];
         int iSubDir = 1;
         // if chain starts like "sfk ...", skip "sfk":
         if (!strcmp(pszSubCmd, "sfk")) {
            pszSubCmd = psubargv[1];
            iSubDir = 2;
         }
         if (cs.verbose > 0)
            printf("  run from \"%s\" (index %d)\n", pszSubCmd, iSubDir);
         lRC = submain(nsubargc, psubargv, penv, pszSubCmd, iSubDir, bFatal);
      }

      if (psubargv) delete [] psubargv;
      oDynaStrings.resetEntries();

      // pScript is auto deleted.
      // pGlblCurrentScript is auto restored to old value,
      // in case that nested script commands are used.

      if (lRC >= 9) return lRC;

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "hex") || !strcmp(pszCmd, "dec"))
   {
      ifhelp (!chain.usedata && nparm < 1)
      printx("<help>$sfk hex value1 [value2] [...]\n"
             "$sfk dec value1 [value2] [...]\n"
             "$sfk ... +dec [+hex] -digits=n\n"
             "\n"
             "   convert numbers between decimal and hexadecimal.\n"
             "   largest convertable number is ((2 << 64) - 1).\n"
             "\n"
             "   $options:\n"
             "      -digits=n  format output numbers with n digits\n"
             "\n"
             "   $examples:\n"
             "      #sfk hex 1048576 98765 234567\n"
             "         convert 3 decimal numbers.\n"
             "\n"
             "      #sfk filt csv.txt -ssep \"\\t\" -form \"$$col3\" +hex\n"
             "         convert 3rd column from csv.txt to hex.\n"
             );
      ehelp;

      bool btodec = !strcmp(pszCmd, "dec");

      int  iChainNext = 0;
      int  iVal       = iDir;
      int  iValMax    = iDir;
      long ndigits    = 1;

      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-digits", &pszParm)) {
            if (!pszParm) return 9;
            ndigits = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               return 9+perr("unexpected option: %s\n", argv[iDir]);
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // skip number parms, maybe until a chain cmd
         iValMax = iDir;
      }

      if (chain.usedata) {
         // convert chain text
         for (long i=0; i<chain.indata->numberOfEntries(); i++) {
            szLineBuf[0]  = '\0';
            char *psz = chain.indata->getEntry(i, __LINE__);
            if (!psz) return 9+perr("int. #58282010");
            if (btodec) {
               // hex to dec
               num nval = hextonum(psz);
               numtoa(nval, ndigits, szLineBuf);
            } else {
               // dec to hex
               num nval = atonum(psz);
               numtohex(nval, ndigits, szLineBuf);
            }
            if (chain.coldata) {
               if (szLineBuf[0])
                  chain.addLine(szLineBuf, "");
            } else {
               printf("%s\n", szLineBuf);
            }
         }
      } else {
         // convert direct parameters
         nparm = (iValMax - iVal) + 1;
         for (; nparm > 0; nparm--) 
         {
            szLineBuf[0]  = '\0';
            char *psz = argv[iVal++];
            if (btodec) {
               // hex to dec
               num nval = hextonum(psz);
               numtoa(nval, ndigits, szLineBuf);
            } else {
               // dec to hex
               num nval = atonum(psz);
               numtohex(nval, ndigits, szLineBuf);
            }
            if (chain.coldata) {
               if (nparm >= 2) strcat(szLineBuf, " ");
               chain.addToCurLine(szLineBuf, "");
            } else {
               printf("%s ", szLineBuf);
            }
         }
         if (!chain.coldata)
            printf("\n");
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "env"))
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk env [-all] [word] [word2] [...] +...\n"
             "\n"
             "   list contents of environment variables having\n"
             "   all supplied words in their name or content.\n"
             "\n"
             "   $options\n"
             "      -all   dump contents of all env variables. when chaining\n"
             "             output to another command, and no words are given,\n"
             "             specifying -all is optional (see example below).\n"
             "\n"
             "   $examples\n"
             "      #sfk env path\n"
             "         lists anything with PATH in name or content,\n"
             "         e.g. CLASSPATH, HOMEPATH, or PATHEXT.\n"
             "\n"
             "      #sfk env +filter -ls+path=\n"
             "         lists content of the PATH variable.\n"
             );
      ehelp;

      int iPatMin = 0;
      int iPatMax = 0;
      bool ball   = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) {
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         if (!strcmp(argv[iDir], "-all"))
            { ball = 1; continue; }
         // take all non-chaining parms as patterns
         if (!iPatMin) iPatMin = iDir;
         iPatMax = iDir;
      }

      // dump environment variables to chain text output
      if (!penv) return 9+perr("missing environment");

      memset(szAttrBuf, 0, sizeof(szAttrBuf));
      for (long i=0; penv[i] != 0; i++) 
      {
         char *psz = penv[i];

         long nlen = strlen(psz);
         memset(szAttrBuf, ' ', nlen);
         szAttrBuf[nlen] = '\0';

         bool bbail = 0;
         if (iPatMin)
         for (int ipat=iPatMin; !bbail && (ipat<=iPatMax); ipat++)
         {
            char *pszPat = argv[ipat];
            long ipos = 0;
            long ibas = 0;
            bool bhit = (bool)mystrstri(psz+ibas, pszPat, &ipos);
            if (!bhit) { bbail=1; continue; }
            while (bhit) {
               memset(szAttrBuf+ibas+ipos, 'i', strlen(pszPat));
               ibas += ipos+strlen(pszPat);
               bhit  = (bool)mystrstri(psz+ibas, pszPat, &ipos);
            }
         }
         if (bbail) continue;

         if (chain.coldata)
            chain.addLine(psz, szAttrBuf);
         else
            printColorText(psz, szAttrBuf);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "label"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk label name [options] +...\n"
             "$sfk ... +label name +...\n"
             "\n"
             "   define a label at the beginning or within an sfk script.\n"
             "   a label is a user-defined name that can be jumped to\n"
             "   by the sfk script command.\n"
             "\n"
             "   $options\n"
             "\n"
             "      -prefix=s    set user-defined input parameter name prefix\n"
             "\n"
             "      by default, parameters passed into sfk scripts are called $$1 to $$9,\n"
             "      or %%1 to %%9. with -prefix, you can define your own parameter names,\n"
             "      e.g. if you rewrite the sfk label line like this:\n"
             "\n"
             "         sfk label begin -prefix=$$parm\n"
             "\n"
             "      then the input parameters are renamed to $$parm1, $$parm2, ...\n"
             "      accepting no other names. or simply say\n"
             "\n"
             "         sfk label begin -prefix=%%\n"
             "\n"
             "      to accept ONLY %%1 to %%9 but NOT $$1 to $$9, to get around conflicts\n"
             "      with script commands using expressions like \"$$10.10col1\".\n"
             "\n"
             "   $examples\n"
             "      #sfk samp sfkcmd mytest.bat\n"
             "         creates a windows batch file mytest.bat\n"
             "         with an embedded sfk command script.\n"
             "\n"
             "      #sfk samp sfkbash mytest\n"
             "         creates a linux batch file mytest\n"
             "         with an embedded sfk command script.\n"
             "\n"
             "   $see also\n"
             "      #sfk script<def> - how to run sfk scripts.\n"
             );
      ehelp;

      char *pszName = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         // do NOT use generic isChainStart here:
         // any "+command" is allowed after labelname to enable
         // easy starting of sfk scripts.
         char *psz = argv[iDir];
         if (psz[0] == '+') {
            if (!pszName) return 9+perr("missing labelname before %s\n",psz);
            iChainNext = iDir;
            break;
         }
         if (pszName) {
            perr("unexpected parameter: %s\n", psz);
            pinf("if %s is a command, try +%s\n", psz, psz);
            return 9;
         }
         pszName = argv[iDir];
      }

      if (cs.verbose > 1)
         pinf("[nopre] label: %s\n", pszName);

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   bool bTeeMode = 0;

   ifcmd (!strcmp(pszCmd, "tee") || !strcmp(pszCmd, "ftee"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk ... +tee [tofile] filename.txt\n"
             "$sfk ... +tee toterm\n"
             "\n"
             "   split current command chain data into two streams.\n"
             "   stream one is passed to the next command in the chain.\n"
             "   stream two is written to file, or printed to terminal.\n"
             "\n"
             "   $see also\n"
             "      sfk tofile      for file output options\n"
             "      sfk toterm      for terminal output options\n"
             "\n"
             "   $examples\n"
             "      #sfk list testfiles .txt +tee toterm +fview\n"
             "         list selected files on terminal AND open in dview.\n"
             );
      ehelp;

      // tee tofile filename OR tee toterm
      bTeeMode = 1;
      pszCmd = argv[iDir];
      if (pszCmd[0] == '+') pszCmd++;
      if (strcmp(pszCmd, "tofile") && strcmp(pszCmd, "toterm"))
         pszCmd = "tofile"; // expecting immediate filename
      else
         iDir++;
      // fall through
   }

   ifcmd (!strcmp(pszCmd, "tofile") || !strcmp(pszCmd, "toterm"))
   {
      ifhelp (!chain.useany())
      printx("<help>$sfk ... +tofile filename\n"
             "$sfk ... +toterm\n"
             "\n"
             "   save current command chain data in a file, or print it to terminal,\n"
             "   and then clear the chain. (next command in the chain will start\n"
             "   without any chain input data).\n"
             "\n"
             "   $options\n"
             "      -append      append to output file, instead of overwriting.\n"
             "\n"
             "   $see also\n"
             "      sfk tee      same as tofile, toterm but also passes chain data\n"
             "                   to the next chain command (no clearing of chain).\n"
             "\n"
             "   $examples\n"
             "      #sfk list testfiles +toterm +run \"sfk echo [[Blue]]done[[def]]\" -yes\n"
             "         list selected files on terminal, then run a completely\n"
             "         independent command which does NOT use chain input.\n"
             );
      ehelp;

      bool btofile  = !strcmp(pszCmd, "tofile");
      char *pszFile = 0;
      char *pszMode = "w";
      bool bappend  = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-append")) {
            pszMode = "a";
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (btofile && !pszFile)
            pszFile = argv[iDir];
         else
            return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (btofile && !pszFile) return 9+perr("+tofile: missing output filename.\n");

      if (!bTeeMode) {
         chain.coldata  = 0;
         chain.colfiles = 0;
      }

      FILE *fout = 0;

      if (pszFile)
         if (!(fout = fopen(pszFile, pszMode))) 
            return 9+perr("cannot write: %s\n", pszFile);

      // tpl for chain text filter:
      if (chain.usedata) {
         for (long i=0; i<chain.indata->numberOfEntries(); i++) {
            char *pattr = "";
            char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
            if (ptext) {
               if (fout)
                  fprintf(fout, "%s\n", ptext);
               else
                  printColorText(ptext, pattr, 1); // with lf
               if (bTeeMode)
                  chain.addLine(ptext, pattr);
            }
         }         
      }
      else
      if (chain.usefiles) {
         for (long i=0; i<chain.numberOfInFiles(); i++) {
            Coi *pcoi = chain.getFile(i);
            if (pcoi) {
               if (fout)
                  fprintf(fout, "%s\n", pcoi->name());
               else
                  oprintf("%s\n", pcoi->name());
               if (bTeeMode)
                  chain.addFile(*pcoi);
            }
         }
      }

      if (fout) fclose(fout);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "sort"))
   {
      ifhelp (!chain.usedata || (nparm >= 1 && isHelpOpt(argv[iDir])))
      printx("<help>$sfk ... +sort\n"
             "\n"
             "   sort text lines, case insensitive by default.\n"
             "   requires a previous command producing text output.\n"
             "\n"
             "   $options\n"
             "      -case        case sensitive text comparison\n"
             "      -rev[erse]   reverse sorting order\n"
             "\n"
             "   $examples\n"
             "      #sfk filter csv.txt +sort\n"
             "         print sorted contents of csv.txt\n"
             );
      ehelp;

      if (!chain.usedata) {
         perr("missing chain text input for +sort");
         pinf("need a previous command producing text output\n");
         return 9;
      }

      bool brev = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (strBegins(argv[iDir], "-rev")) {
            brev = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (groupChainText(pszCmd, brev, 0, 0)) return 9;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "count"))
   {
      ifhelp (!chain.usedata || (nparm >= 1 && isHelpOpt(argv[iDir])))
      printx("<help>$sfk ... +count [-same[lines]]\n"
             "\n"
             "   count total number of text lines, or group identical\n"
             "   text lines, counting the number of occurences per line.\n"
             "\n"
             "   $options\n"
             "      -samelines count number of occurences per line, then\n"
             "                 prefix lines by TAB separated counter.\n"
             "      -digits=n  with -samelines, change no. of counter digits\n"
             "      -case      case sensitive text comparison\n"
             "\n"
             "   $see also\n"
             "      \"sfk filter\" with -unique, to strip duplicate lines\n"
             "\n"
             "   $examples\n"
             "      #sfk filter words.txt +count -same -digits=10\n"
             "         tell how often each line occurs in words.txt,\n"
             "         and format the occurence counter with 10 digits.\n"
             );
      ehelp;

      if (!chain.usedata) {
         perr("missing chain text input for +count");
         pinf("need a previous command producing text output\n");
         return 9;
      }

      bool bsame = 0;
      long ndig  = 5;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (!strncmp(argv[iDir], "-same", 5)) {
            bsame = 1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-digits", &pszParm)) {
            if (!pszParm) return 9;
            ndig = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (!bsame) {
         sprintf(szLineBuf, "%ld", chain.indata->numberOfEntries());
         if (chain.colany())
            chain.addLine(szLineBuf, "");
         else
            printColorText(szLineBuf, "", 1); // with lf
      } else {
         if (groupChainText(pszCmd, 0, bsame, ndig)) return 9;
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "sfk") || !strcmp(pszCmd, "then")) // actually +sfk
   {
      int iChainNext = iDir;

      if (iChainNext >= argc)
         return 9+perr("missing command after \"sfk\"");

      chain.reset();

      STEP_CHAIN(iChainNext, 0);

      lRC = 0;
      bDone = 1;
   }

   if (!strcmp(pszCmd, "end"))
   {
      lRC = 0;
      bDone = 1;
      // fall through to exit
   }

   ifcmd (!strcmp(pszCmd, "dump-main-help"))
   {
      ifhelp (1)
      printx("<help>$SFK" SFK_BRANCH " - The Swiss File Knife File Tree Processor.\n");
      char *pfix = SFK_FIXPACK;
      sprintf(szLineBuf, "Release " SFK_VERSION " %s%s%s of " __DATE__ ".",
         pszGlblVerType, pfix[0] ? " Revision ":"", pfix);
      printx("%s\n", szLineBuf);
      printf("this binary was compiled and provided by " SFK_PROVIDER ".\n");
      printf("original source and binary package available on sourceforge,\n");
      printf("http://swissfileknife.sourceforge.net\n");

      #ifndef NO_BSD_INFO
      printx("Distributed for free under the BSD License, without any warranty.\n");
      #endif

      #ifdef MAC_OS_X
      printx("SFK for Apple Macintosh is experimental and unsupported.\n");
      #endif

      #ifdef _WIN32
      if (sizeof(mytime_t) < 8) {
         // if you see this warning, sfk list -time may fail on file dates > 2038.
         // 64-bit times with unix are an sfk issue left open, so there is no warning.
         printx("\ninfo: compile with latest msvc for 64-bit time and size support.\n");
      }
      #endif

      if (bhelp)
      printx("\n$sfk main help (just type \"sfk\"):\n");
      else
      printx("\n<file>usage:<def>\n");
      printx("   $sfk list [-late|-old|-big|-small] [...] dir [mask]\n"
             "       list latest, oldest or biggest files within a directory tree.\n"
             "       find identical files. list changed files between directories.\n");
      #ifdef VFILEBASE
      printx("       list zip jar tar gz bz2 contents. type \"sfk list\" for more.\n");
      if (0) // skip next printx
      #endif // VFILEBASE
      printx("       list zip and jar contents. type \"sfk list\" for more.\n");
      printx("          #sfk list -dir src1 -file .cpp -dir src2 -file .hpp\n"
             "          #sfk list -late=20 -pure\n"
             "          #sfk list -arc mydir .zip .jar\n"
             "   $sfk stat [-minsize=mb] dir [-i]\n"
             "       show directory tree size statistics in mbytes.\n"
             "       minsize: list only dirs and files >= minsize mbytes.\n"
             "       -i: read list of files and directories from stdin.\n"
             "          #sfk stat -minsize=10m\n"
             "          #type dirlist.txt | sfk stat -quiet -i\n"
             "   $sfk find [-c] singledir pattern [pattern2] [pattern3] ...\n"
             "   $sfk grep [-c] -pat pattern [pattern2] -dir dir1 [-file] [.ext1] ...\n"
             "       case-insensitive pattern search for text and binary.\n"
             "       type \"sfk find\" for details. \"sfk grep\" is the same.\n"
             "          #sfk find . foobar docs\n"
             "          #sfk find -pat text1 text2 -dir src1 src2 -file .cpp .hpp\n"
             "          #sfk grep -pat mytext -dir . -file .txt -norec\n"
             );
      printx("   $sfk filter <input >output [-lnum] [-c] -+orpat [++andpat] [-<not>nopat] [...]\n"
             "   $sfk filter infile -+pattern\n"
             "       filter and process text lines, from file(s) or from standard input.\n"
             "       find, replace, highlight words and ex*pre??ions, split and reformat\n"
             "       text columns. type \"sfk filter\" for more.\n"
             "          #anyprog | sfk filter -+mypat -<not>otherpat\n"
             "          #sfk filter result.txt -rep _\\_/_ -rep xC:\\xD:\\x\n"
             "   $sfk filefind [or ff] [pattern2 <not>pattern3 ...] [options]\n"
             "       easy filename finder by path patterns. \"sfk ff\" for more.\n"
             "   $sfk env [-all] [word] [...]<def> search within environment variables.\n"
             );
      printx(
             "   $sfk run \"your command <run>file [<run>qfile] [...]\" [-yes] [-quiet]\n"
             "   $sfk runloop ifrom ito \"your command <run>[digits]i\" [-yes] [-quiet] [-nohead]\n"
             "       run self-defined command, on files or directories, or by counter.\n"
             "       type \"sfk run\" or \"sfk runloop\" for details.\n"
             #ifdef WITH_TCP
             "   $sfk ftpserv [-h|-help] [-port=nport] [-rw] [-maxsize=n]\n"
             "       run simple ftp server, providing access to current directory.\n"
             "       type \"sfk ftpserv -help\" for details.\n"
             "   $sfk ftp host[:port] [put|get filename]\n"
             "       simple ftp client. if connecting to sfk server, this client uses\n"
             "       sfk/sft protocol, which should always work even if ftp doesn't.\n"
             "       type \"sfk ftp\" for details.\n"
             "   $sfk httpserv [-h|-help] [-port=nport] [-rw]\n"
             "       instant http server, providing access to current directory.\n"
             "       type \"sfk httpserv -help\" for details.\n"
             #endif
             #ifdef VFILENET
             "   $sfk wget url [outdir] [-fullpath]\n"
             "       download http:// content. type \"sfk wget\" for more.\n"
             #endif // VFILENET
             #ifdef WITH_TCP
             "   $sfk webrequest http://host[:port]/path\n"
             "       send an HTTP request and show the detailed reply text.\n"
             #endif
             "   $sfk split 2000m infile.dat [outfile.dat]\n"
             "   $sfk join infile.dat.part1 [outfile.dat]\n"
             "       split and join large binary files. \"sfk split\" for more.\n"
             "   $sfk copy<def>     copy or synchronize files and dir trees.\n"
             "   $sfk partcopy<def> copy some bytes from a file into another file.\n"
             );
      printx("   $sfk detab=tabsize dir ext1 [ext2 ...]\n"
             "       replace tabs by spaces within file(s).\n"
             "          #sfk detab=3 sources .cpp .hpp\n"
             "          #sfk detab=3 singleFileName.txt\n"
             "   $sfk scantab -dir dir1 dir2 -file ext1 [ext2 ...]\n"
             "       check if files contain tabs. \"sfk scantab\" for more.\n"
             "          #sfk scantab -dir src1 src2 -file .cpp .hpp\n"
             "          #sfk scantab . .cpp .hpp\n"
             );
      printx("   $sfk lf-to-crlf [or addcr] [dir .ext1 .ext2] or [singlefile]\n"
             "   $sfk crlf-to-lf [or remcr] [dir .ext1 .ext2] or [singlefile]\n"
             "       convert between CR/LF and just LF text format.\n"
             "          #sfk remcr batches .bat .cmd\n"
             "          #sfk remcr mybatch.bat\n"
             "   $sfk joinlines infile outfile\n"
             "       for text with lines split by email reformatting.\n"
             "   $sfk rep[lace] [...] -text /src/dst/ -dir mydir -file .ext1 [-yes]\n"
             "       replace strings or byte blocks in files.  \"sfk rep\" for more.\n"
             "   $sfk hexdump [-showle] [...] dir .ext1 .ext2 .ext3\n"
             "   $sfk bin-to-src [-java] [-pack] [...] infile outfile namePrefix\n"
             "       create hexdump, C or Java source code from binary data.\n"
             "       type \"sfk hexdump\" or \"sfk bin-to-src\" for more.\n"
             "   $sfk tcpdump [-showle] [...] targetserver:port [-timeout msec] [-wide]\n"
             "       create hexdump of a tcp connection. \"sfk tcpdump\" for more.\n"
             "   $sfk hextobin<def>   convert hexdump to binary data.\n"
             );
      printx("   $sfk tail [head] [-lines=n] [-f[ollow]] filename [filter options]\n"
             "       print and follow last lines of a file. \"sfk tail\" for more.\n");
      printx("   $sfk addhead <in >out [-noblank] string1 string2 ...\n"
             "   $sfk addtail <in >out [-noblank] string1 string2 ...\n"
             "       add string(s) at start or end of lines.\n"
             "       with noblank specified, does not add blank char.\n"
             "   $sfk strings [-umlauts] [-wrapbin=n] filename\n"
             "       extract strings from a binary file. resulting text lines are split\n"
             "       at column 80 by default, which can be changed by -wrapbin or -wrap.\n"
             "          #sfk strings test.exe | sfk filter -+VersionInfo\n"
             "   $sfk pathfind anycmd.exe | sfk where anycmd.exe\n"
             "       tells location of anycmd.exe within PATH.\n"
             "   $sfk deblank [-yes]\n"
             "       replace blanks in filenames by \"_\" character.\n"
             "       command only simulates. specify -yes to really rename.\n"
             "   $sfk del[ete] dir .ext1 .ext2\n"
             "       delete selected files. \"sfk del\" for more.\n"
             );
      printx("   $sfk color colorname\n"
             "       set text color to white, grey, red, green, blue, yellow, black.\n"
             );
      printx("   $sfk echo [[color]]text[[def]] [text2] [...]\n"
             "       print colored text onto console. \"sfk echo\" for details.\n"
             "   $sfk sleep msec<def>   delay execution for a number of milliseconds.\n"
             #ifdef _WIN32
             "   $sfk pause [-quiet|mytext]<def>  wait until user presses any key.\n"
             #else
             "   $sfk pause [-quiet|mytext]<def>  wait until user presses enter key.\n"
             #endif
             );
      printx("   $sfk snapto=outfile [-pure] [-norec] -dir mydir1 -file .ext1 .ext2\n"
             "       collect many files into one large text file. \"sfk snapto\" for more.\n"
            );
      printx("   $sfk synctext=dbfile [-stop] dir mask [<not>mask2]\n"
             "       edit many files in parallel, by editing a single collection file.\n"
             "       type \"sfk synctext\" for details.\n"
            );
      printx("   $sfk md5gento=outfile dir [mask] [mask2] [<not>mask3] [...]\n"
             "   $sfk md5gento outfile -dir dir1 dir2 -file mask1 mask2 <not>mask3 [...]\n"
             "       create list of md5 checksums over all files.\n"
             "          #sfk md5gento=md5.dat .\n"
             "   $sfk md5check infile [-skip=n] [-skip n]\n"
             "       verify list of md5 checksums. to speed up verifys by spot checking,\n"
             "       specify -skip=n: after every checked file, n files will be skipped.\n"
             "          #sfk md5check md5.dat\n"
             "   $sfk md5 [-quiet] [-verify md5sum] filename [filename2 filename3 ...]\n"
             "       create md5 of file(s), without a list. \"sfk md5\" for details.\n"
             );

      #ifdef SFINT
      printx(
             "   $sfk freezeto=targetdir [-quiet][-hidden][-verbose] -dir src1 -copy|zip\n"
             "       create self-verifying archive tree, prepared for dvd burning.\n"
             "       type \"sfk freezeto\" for details.\n"
             );
      #endif

      printx("   $sfk dupfind [-minsize=n] -dir dir1 -file .ext1 -dir dir2 -file .ext2\n"
             "       find duplicate files. \"sfk dupfind\" for details.\n"
             );

      printx("   $sfk reflist [-abs] [-wide] -dir sdir -file .ext1 -dir tdir -file .ext2\n"
             "   $sfk deplist [-abs] [-wide] -dir sdir -dir tdir1 tdir2 [-file .ext]\n"
             "       find file references or dependencies. \"sfk reflist\" for help.\n"

             "   $sfk alias [-list|-del|-ren] [shortname] [=] [command]\n"
             "       create command aliases to save typing effort. \"sfk alias\" for help.\n"
             "   $sfk cd, getcwd<def>   change dir in command chain, get current work dir.\n"
             "   $sfk mkdir path<def>   create directory, or tree of directories.\n"
             "   $sfk mkcd cdname<def>  create an alias remembering the current dir.\n"
             "   $sfk ... +view<def>    show results in Depeche View. \"sfk view\" for more.\n"
             );

      printx("   $sfk patch [...]<def>  dynamic source file patching. \"sfk patch\" for more.\n"
             "   $sfk sample<def>       create java, c++, php etc. example source code.\n"
             "   $sfk batch<def>        create a batch file with embedded sfk commands.\n"
             "   $sfk script<def>       execute sfk commands from a script file.\n"
             "   $sfk linelen<def>      tell minimum or maximum length of string(s).\n"
             "   $sfk hex [or dec]<def> convert numbers between decimal and hexadecimal.\n"
             "   $sfk ... +sort<def>    sort text output of a previous command.\n"
             "   $sfk ... +count<def>   count no. of lines, or duplicate occurences.\n"
             "   $sfk ... +loop<def>    repeat the execution of command(s).\n"
             "   $sfk ... +if ...<def>  conditional execution. \"sfk if\" for more.\n"
             "   $sfk ... +call<def>    call script functions. \"sfk call\" for more.\n"
             );

      printx(
             #ifdef WITH_FN_INST
             "   $sfk inst<def>         instrument c++ source code with tracing calls.\n"
             #endif

             "   $sfk make-random-file<def>   create a file full of random data.\n"
             "   $sfk ownip<def>        print ip address(es) of own machine.\n"
             "   $sfk udpdump<def>      print content of incoming UDP packets.\n"

             #ifdef _WIN32
             "\n"
             "   $sfk toclip<def>   - copy stdin to clipboard as plain text (windows only).\n"
             "   $sfk fromclip<def> - get text from clipboard. \"sfk fromclip -h\" for more.\n"
             "\n"
             #endif

             #ifdef _WIN32
             "   $sfk [help] ascii [-ansi|-dos]<def> - list ascii character set.\n"
             "   $sfk help shell<def>   - how to optimize your windows Command Prompt.\n"
             #else
             "   $sfk [help] ascii<def> - list ascii character set.\n"
             #endif
             "   $sfk chars phrase<def> - list character codes of given phrase.\n"

             "\n"
             "   $All tree walking commands support file selection this way:\n"
             "   1. short format with ONE directory tree and MANY file name patterns:\n"
             "      #src1dir .cpp .hpp .xml bigbar <not>footmp\n"
             "   2. short format with a list of explicite file names:\n"
             "      #letter1.txt revenues9.xls report3<sla>turnover5.ppt\n"
             "   3. long format with MANY dir trees and file masks PER dir tree:\n"
             "      #-dir src1 src2 <not>src<sla>save -file foosys .cpp -dir bin5 -file .exe\n"
             "\n");
      printx("   %s and ? wildcards are supported within filenames. \"foo\" is interpreted\n"
             "   as \"%cfoo%c\", so you can leave out %s completely to search a part of a name.\n"
             "   For name start comparison, say \"%cfoo\" (finds foo.txt but not anyfoo.txt).\n"
             "   When you supply a directory name, by default this means \"take all files\".\n"
             "   The snapto function also supports option -all, meaning \"all text files\".\n"
             ,glblWildInfoStr,glblWildChar,glblWildChar,glblWildInfoStr,glblPathChar);
      #ifndef _WIN32
      if (!bhelp) setTextColor(nGlblWarnColor);
      printx("   Use %c or \\* instead of *, and \\? instead of ?, as * and ? are eaten by the\n"
             "   command shell. You may also redefine %c through export SFK_CONFIG=wildstar:c\n"
             ,glblWildChar,glblWildChar);
      if (!bhelp) setTextColor(-1);
      #endif
      printx("\n"
             "      #sfk list mydir<def>                   lists ALL  files of mydir, no * needed.\n"
             "      #sfk list mydir .cpp .hpp<def>         lists SOME files of mydir, by extension.\n"
             "      #sfk list mydir <not>.cfg<def>             lists all  files of mydir  EXCEPT .cfg\n"
             "      #sfk snapto=a.txt mydir .doc<def>      collect ONLY .doc (which are binaries).\n"
             "      #sfk snapto=a.txt mydir -all .doc<def> collect all text files, AND also .doc\n"
             "\n"
             );
      printx("   $general options:\n"
             "      -tracesel tells in detail which files and/or directories are included\n"
             "                or excluded, and why (due to which user-supplied mask).\n"
             "      -nosub    do not process files within subdirectories.\n"
             "      -nocol    before any command switches off color output.\n"
             "      -quiet    or -nohead shows less output on some commands.\n"

             #ifdef _WIN32
             "      -hidden   includes hidden and system files and dirs.\n"
             #endif
             "\n"
             "   type \"sfk help colors\"    about how to change result colors.\n"
             "   type \"sfk help select\"    for more on how to select files.\n"
             "   type \"sfk help options\"   to list all general options and configs.\n"
             "   type \"sfk help chain\"     about how to combine multiple commands.\n"
             "   type \"sfk help patterns\"  for supported wildcards and slash patterns.\n"
             #ifdef VFILEBASE
             #endif // VFILEBASE
          // "   type \"sfk help fileset\"   for how to list dir names in a text file.\n"
            );
      printx("\n"
             "   type #\"sfk ask word1 word2 ...\"<def>   to search ALL help text for words.\n"
             "   type #\"sfk dumphelp\"<def>              to print  ALL help text.\n"
            );
      ehelp;
      // no real action here
      return 9;
   }

   ifcmd (!strcmp(argv[1], "help") || !strcmp(argv[1], "ascii"))
   {
      bool bShortAscii = strcmp(argv[1], "ascii") ? 0 : 1;

      if (!bhelp && !bShortAscii && (nparm < 1)) {
         fprintf(stderr, "please type just \"sfk\" to list the sfk main help.\n");
         return 9; 
      }

      char *pszSub = "";

      if (bShortAscii)
         pszSub = "ascii";
      else
         pszSub = bhelp ? (char*)"" : argv[2];

      #ifdef _WIN32
      char *pszSet = "set";
      #else
      char *pszSet = "export";
      #endif

      if (bhelp || !strncmp(pszSub, "color", 5))
      {
         #ifdef _WIN32
         printx("%s SFK_COLORS=off|on,err:n,warn:n,head:n,examp:n,file:n,hit:n,rep:n,pre:n\n", pszSet);
         #else
         printx("%s SFK_COLORS=off|on,def:n,err:n,warn:n,head:n,examp:n,file:n,hit:n,rep:n,pre:n\n", pszSet);
         #endif
         printx("%s SFK_COLORS=bright|dark,theme:black|theme:white\n", pszSet);
         printx("\n"
                "   color identifiers are\n"
                #ifndef _WIN32
                "      def       default color (black by default)\n"
                #endif
                "      err       error   messages\n"
                "      warn      warning messages\n"
                "      head      headlines in help text\n"
                "      examp     examples  in help text\n"
                "      file      filename listings in find\n"
                #ifndef _WIN32
                "      link      symbolic link files or directories\n"
                #endif
                "      hit       text pattern hits in find and filter\n"
                "      rep       replaced patterns in filter\n"
                "      pre       line prefix symbols in find\n"
                "      time      time or low-prio status infos\n"
                "      traceinc  with -tracesel, included names\n"
                "      traceexc  with -tracesel, excluded names\n"
                "\n"
                "   color code n is a combination of these values:\n"
                "      0 = black\n"
                "      1 = bright\n"
                "      2 = red\n"
                "      4 = green\n"
                "      8 = blue\n"
                "\n"
                "   some commands like \"sfk echo\" also accept direct color names:\n"
                "   red,green,blue,yellow,cyan,magenta,default,Red,Green,Blue...\n"
                "   sfk for windows tries to autoselect color brightness if a black\n"
                "   or white shell background is found. otherwise the spelling matters:\n"
                "   red means dark red, and Red means bright red.\n"
                "   you may also set SFK_COLORS to bright or dark, or specify options\n"
                "   -bright or -dark in your command, to force all plain text colors\n"
                "   to the same brightness, regardless of spelling.\n"
                "\n"
                "   examples for color schemes:\n"
                "\n"
                );
         printx("      default, compatible to black and white backgrounds:\n"
                "         %s SFK_COLORS=head:5,examp:11,file:11,hit:5,rep:7\n", pszSet);
         printx("      black background optimized theme:\n"
                "         %s SFK_COLORS=theme:black\n"
                ,pszSet);
         printx("      white background optimized theme:\n"
                "         %s SFK_COLORS=theme:white\n"
                ,pszSet);
         #ifdef _WIN32
         printx("\n"
                "      with sfk for windows, themes are autoselected if a black\n"
                "      or white background is detected.\n"
                "\n"
                );
         #endif
         printx("      switch off colored output:\n"
                "         %s SFK_COLORS=off\n\n",pszSet);
         #ifdef _WIN32
         printx("   to switch off colors per command, use general option -nocol .\n");
         #else
         printx("   by default, colors are inactive on unix, as there are some potential problems\n"
                "   depending on the background color of your shell, and if you want to post-process\n"
                "   command output. if you feel lucky, add -col in front of a command, or say\n"
                "\n"
                "      export SFK_COLORS=on,def:0      or    export SFK_COLORS=on,def:14\n"
                "      with bright shell backgrounds         with black shell backgrounds\n"
                );
         #endif

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp)
      {
         printx("<help>$sfk help ascii  (or just \"sfk ascii\")\n"
                "\n"
                "   print a table of ASCII characters with their codes.\n"
                "\n"
               );
      }

      if (!strcmp(pszSub, "ascii") || !strcmp(pszSub, "ASCII"))
      {
         char *pszSubSub = "";

         int iDir = bShortAscii ? 2 : 3;

         for (; iDir<argc; iDir++) 
         {
            if (!strcmp(argv[iDir], "-ansi")) { pszSubSub=argv[iDir]; continue; }
            else
            if (!strcmp(argv[iDir], "-dos")) { pszSubSub=argv[iDir]; continue; }
            else
            if (!strncmp(argv[iDir], "-", 1)) {
               if (setGeneralOption(argv, argc, iDir))
                  continue;
               else
                  return 9+perr("unknown option: %s\n", argv[iDir]);
            }
         }
 
         bool bAnsiToOem = 0;
         bool bOemToAnsi = 0;

         #ifdef _WIN32
         if (!bGlblEnableOPrintf) {
            if (pszSubSub[0]) pwarn("-nocconv overrides -ansi or -dos. no conversions are done.\n");
            printf("Character set: ASCII from 0 to 127, codes above depending on your terminal.\n");
         }
         else
         if (bGlblHaveInteractiveConsole) {
            // dumping to interactive Windows console
            if (!strcmp(pszSubSub, "-dos")) {
               printf("Character set: ASCII from 0 to 126, codes above DOS (OEM codepage 850).\n");
            } else {
               bAnsiToOem = 1;
               printf("Character set: ASCII from 0 to 126, codes above ANSI (displayed in DOS console).\n");
            }
         } else {
            // dumping into a file
            if (!strcmp(pszSubSub, "-dos")) {
               bOemToAnsi = 1;
               printf("Character set: ASCII from 0 to 126, codes above DOS (OEM codepage 850).\n");
            } else {
               printf("Character set: ASCII from 0 to 126, codes above ANSI (1250 unconverted).\n");
            }
         }
         // printf("Character set: ASCII from 0 to 126, codes above are DOS specific. To see the Windows\n"
         //       "characters for codes >= 127, say \"sfk help ascii >x.txt\" then load x.txt in notepad.\n"
         //       );
         #else
         printf("Character set: ASCII from 0 to 127, codes above depending on your terminal.\n");
         #endif
         long nCharCols = 8;
         long nCharRows = 0x20; // (255 / nCharCols) + 1;
         for (long irow=0; irow<nCharRows; irow++) 
         {
            for (long icol=0; icol<nCharCols; icol++) 
            {
               long i = icol * nCharRows + irow;
               if (i > 255)
                  printf("        ");
               else {
                  uchar c = (uchar)i;
                  setTextColor(nGlblHitColor);
                  if (i < 10 ) putchar(' ');
                  if (i < 100) putchar(' ');
                  printf("%ld ",i);
                  setTextColor(nGlblRepColor);
                  printf("%X ",i);
                  setTextColor(-1);
                  #ifdef _WIN32
                  if (c >= 0x20)
                  #else
                  if (c >= 0x20 && !(c >= 0x7F && c < 0xA0))
                  #endif
                  {
                     setTextColor(nGlblFileColor);
                     #ifdef _WIN32
                     if (bAnsiToOem) c = ansiCharToOEM(c);
                     if (bOemToAnsi) c = oemCharToAnsi(c);
                     #endif
                     putchar(c);
                     setTextColor(-1);
                     if (icol < nCharCols)
                        printf("  ");
                  }
                  else
                  switch (c) {
                     case 4   : printf("EOT "); break;
                     case 7   : printf("BEL "); break;
                     case 8   : printf("BS  "); break;
                     case 12  : printf("FF  "); break;
                     case 0x1A: printf("EOF");  break;
                     case 27  : printf("ESC");  break;
                     case 127 : printf("DEL");  break;
                     case '\r': printf("CR  "); break;
                     case '\n': printf("LF  "); break;
                     case '\t': printf("TAB "); break;
                     default:
                        putchar('.');
                        if (icol < nCharCols)
                           if (c < 0x10)
                              printf("   ");
                           else
                              printf("  ");
                        break;
                  }
               }
            }
            printf("\n");
         }

         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "opt", 3))
      {
      printx("$sfk general options reference%s:\n",
             bhelp ? " (type \"sfk help options\")":"");
      printx("\n"
         "   $-nosub<def>     or -norec does not include subdirectories (subfolders).\n"
         "              processing of subdirs is DEFAULT with most commands,\n"
         "              therefore you must specify -nosub to switch it off.\n"
         "   $-sub<def>       include subdirs. is DEFAULT with most commands.\n"
         "   $-verbose<def>   print additional infos while running a command.\n"
         "              helpful if a command doesn't work as expected.\n"
         "              only some commands support -verbose. try also -verbose=2.\n"
         #if (!defined(_WIN32) && !defined(SFK_LIB5))
         "   $-nofollow<def>  or -nofo does not follow symbolic directory links.\n"
         "              this option may NOT work with older Linux versions,\n"
         "              esp. those needing the \"lib5\" binary version of sfk.\n"
         #endif
         #ifndef _WIN32
         "   $-showskip<def>  tell whenever directory contents are skipped to avoid\n"
         "              double processing caused by symbolic links.\n"
         "   $-allowdups<def> disable detection of duplicate directory contents.\n"
         "                 may cause endless recursion on links like \"X11\"->\".\"\n"
         #endif
         "   $-quiet<def>     reduce output on some commands. e.g. the find command will\n"
         "              not display the \"scan\" status info while searching files.\n"
         "   $-quiet=2<def>   reduce output even more on some commands.\n"
         "   $-nohead<def>    no not list header/trailer info on some commands: the run cmd\n"
         "              will not tell \"simulating\" even if it's in simulation mode.\n"
         "   $-case<def>      activate case sensitive text comparison with some commands.\n"
         "              most text processing commands are case-insensitive by default.\n"
         "              filename comparison is always case insensitive.\n"
         "   $-hidden<def>    include hidden and system files.\n"
         "   $-nohidden<def>  exclude hidden and system files.\n"
         "   $-yes<def>       fully execute the command. some commands like \"run\" are\n"
         "              running in simulation mode by default, to avoid damage to your\n"
         "              files, as long as you're unsure which files and dirs to select.\n"
         "              as soon as you add -yes, however, everything is fully executed.\n"
      // "   $-nonames<def>   or -nofile[names] does not create :file name records when\n"
      // "              chaining text data from one command to another.\n"
         "   $-textfiles<def> process only text files, no binaries. -text is the same,\n"
         "              but this may interfere with some command's local -text option.\n"
         "              text/binary detection only checks the file's first 4096 bytes.\n"
         "   $-binfiles<def>  process only binary files. -bin is the same, but this may\n"
         "              interfere with some command's local -bin option.\n"
         "   $-umlauts<def>   with binary-to-text conversion, include german characters.\n"
         "   $-nocol<def>     disable all colored output. important if your shell has\n"
         "              a background color incompatible to the default color scheme,\n"
         "              or (under linux) if the sfk output text must be processed\n"
         "              further through pipelining, and needs to be stripped from\n"
         "              the color escape sequences.\n"
         "   $-col<def>       switch on colored output. \"sfk help colors\" for more.\n"
         "   $-html<def>      dump sfk help text (color control) in html format.\n"
         "   $-sincedir<def>  or -sincedif/add/chg: compare directory tree against\n"
         "              a reference tree, process only changed or added files.\n"
         "              see \"sfk list\" for details.\n"
         "   $-tracesel<def>  give verbose infos why directories and files have been\n"
         "              selected or excluded. -tracedirs lists only directories,\n"
         "              -tracefiles lists only files.\n"
         "   $-since<def>     process only files changed on or after the supplied\n"
         "              date/timestamp. \"sfk list\" for details.\n"
         "   $-before<def>    process only files changed before that date/timestamp.\n"
         "   $-flist fn<def>  or \"-fl fn\" reads list of filenames from file fn.\n"
      // "   $-fileset<def>   use a textfile with dir- and filenames, instead of\n"
      // "              providing them as parameters. \"sfk help fileset\" for more.\n"
         "   $-spat<def>      activates interpretation of slash patterns:\n"
         "              \\t=TAB \\q=\" \\r=CR \\n=LF \\\\=\\ \\xnn=any char w/hex code nn\n"
         "              with some commands like replace, filter -form and -replace.\n"
         "   $-literal<def>   or -lit disables interpretation of wildcards * and ?\n"
         "              and slash patterns, if they were activated previously.\n"
         "   $-nospat<def>    disables only slash patterns.\n"
         );
         #ifdef _WIN32
  printx("   $-nocconv<def>   when printing output to the windows console, sfk tries\n"
         "              to convert umlaut and accent characters to display them\n"
         "              correctly with codepage 850. set -nocconv to disable this.\n"
         "              whenever output is redirected to file, no conversion is done.\n"
         "   $-cconv<def>     force codepage conversions: if command output is redirected\n"
         "              to a file, codepage conversion is disabled by default.\n"
         "              use this option to activate, e.g. when post-processing\n"
         "              sfk run output which produced filename lists.\n"
         );
         #endif
  printx("   $-noipex<def>    disable automatic IP expansion with some commands.\n");
  printx("   $-arc<def>       with sfk list, lists also archive file contents.\n");
  #ifdef VFILEBASE
  printx("              with some other commands, also process archive file contents.\n"
         "              archives recognized by sfk must have one of these extensions:\n"
         "              .zip .jar .ear .war .aar .xpi .tar .tar.gz .tar.bz2 .tgz .gz .bz2\n"
         "              to include further extensions, read below about SFK_ZIP_EXT.\n"
   #ifndef VFILEMAX
         "              this binary (SFK Base/XD) can read only the first 1000 bytes\n"
         "              of every archive entry. listing of contents is not limited.\n"
   #endif
         "              type \"sfk help xe\" for all details and restrictions.\n"
         );
  if (0) // skip next printx
  #endif // VFILEBASE
  printx("              zip files recognized by sfk must have one of these extensions:\n"
         "              .zip .jar .ear .war .aar .xpi\n");
  printx("   $-utf<def>       activate EXPERIMENTAL utf-16 (ucs-2, wide char) decoding,\n"
         "              allowing sfk find or filter to search text in utf-16 files.\n"
         "              should not be used when (re)writing files. get more infos\n"
         "              by typing \"sfk help unicode\".\n"
         "   $-to mask<def>   specify where to write output files with some commands.\n"
         "              mask supports <run>file, <run>path, <run>base, <run>ext and more.\n"
         "              say \"sfk run\" for a list of possible keywords.\n"
         "   $-tmpdir x<def>  set directory x as temporary file directory. default is\n"
         #ifdef _WIN32
         "              to use the path specified by TEMP or TMP env variable.\n"
         #else
         "              to use the path specified by TEMP or TMP env variable,\n"
         "              or the /tmp directory, if no such variable is defined.\n"
         #endif
         "   $-keeptmp<def>   do not delete the temporary files, e.g. after \"run\".\n"
         "   $-showtmp<def>   tell verbosely which temporary files are created.\n"
         "   $-nowarn<def>    and -noerr, -nonote disable warn, error and note messages.\n");
  printx("   $-memlimit=n<def> set the caching memory limit to n mbytes (default=%ld).\n"
         "              used if a function needs to load whole files into memory.\n"
         ,(long)(nGlblMemLimit / 1048576));
         #ifdef VFILEBASE
  printx("              if zip etc. archive processing is very slow, it may be caused by\n"
         "              a cache overflow. try to increase the -memlimit then.\n"
         "              if you think sfk uses too much memory while processing files,\n"
         "              try to reduce -memlimit (values below 200 are not recommended).\n"
         "   $-cachestat<def> at program end, tell amount of memory used by the cache.\n"
         "   $-nocache<def>   disable the disk cache (for network files).\n"
         );
         #endif // VFILEBASE
  printx("\n"
         "   $shell return code handling and error processing:\n"
         "\n"
         "   $-showrc<def>    print sfk return code at program end. may not print anything\n"
         "              in case of fatal errors, like wrong syntax (usually rc 9).\n"
         "   $-exterr<def>    in case of operating system related errors like file access,\n"
         "              prints extended error information, if available.\n"
         "   $-waitonerr<def> wait for user input on every error.\n"
         "   $-waitonend<def> wait for user input at program end.\n"
         "   $-stoponerr<def> stop directory tree processing on first unreadable file.\n"
         "              default is to process as many files as possible, skipping\n"
         "              unreadable files and directories.\n"
         "   $-rcfromerr<def> some commands like filter, find, hexfind tell by shell rc\n"
         "              that something was found. by default, skipped errors like\n"
         "              unredable files do NOT change this rc. with -rcfromerr,\n"
         "              skipped errors do override the resulting shell rc.\n"
         "\n"
         "   to experiment with the above options, try \"sfk errortest\".\n"
         "\n");

  printx("   $command local versus global scope:\n"
         "\n"
         "      within a command chain, many options have an effect only locally\n"
         "      with the command where they are specified, e.g. in\n"
         "\n"
         "         #sfk filt x.txt -case -high red FooCase +filt -high blue TheBar\n"
         "\n"
         "      the \"-case\" is valid only for the first filter command.\n"
         "      but the following options can also be used globally, if specified\n"
         "      directly after \"sfk\":\n"
         "\n"
         "         $-nohead -noinfo -nofile -case -literal -spat\n"
         "\n"
         "      for example, in\n"
         "\n"
         "         #sfk -case filt x.txt -high red FooCase +filt -high blue TheBar\n"
         "\n"
         "      the \"-case\" is valid for ALL commands in the command chain.\n"
         "\n"
         );

  printx("   $environment configuration:\n"
         "\n"
         "      $%s SFK_CONFIG=columns:n,active-file-age:n,memtrace\n"
         "        columns:\n"
         "          sfk (for windows) tries to autodetect the no. of console columns,\n"
         "          but you may also set this value through this config parm.\n",
         pszSet
         );
  printx("        active-file-age:n\n"
         "          some functions need to tell if a file is 'recently edited' or rather\n"
         "          old and inactive. by default, files > 30 days of age are considered\n"
         "          non-active. reconfigure the no. of days threshold here.\n"
         "\n"
         );
  /*
  printx("        memtrace:\n"
         "          sfk always runs a low-overhead memory check, counting the number\n"
         "          of blocks allocated and released. should memory errors appear,\n"
         "          activate deep memory tracing by this switch for more details.\n"
         );
  */
         if (bGlblIgnore3600)
            printx("   info: files with a time difference of 1 hour AND an age > %ld days\n"
                   "         are skipped by some commands, e.g. list -sincedir.\n\n", nGlblActiveFileAgeLimit);

         if (nGlblActiveFileAgeLimit != 30)
            printx("   info: active file age limit is currently set to %ld days.\n", nGlblActiveFileAgeLimit);
   
         #ifndef _WIN32
         if (glblWildChar != '%') {
            if (!bhelp) setTextColor(nGlblWarnColor);
            printx("   info: wildcard star '*' is currently configured as %c\n", glblWildChar);
            if (!bhelp) setTextColor(-1);
         }
         #endif

  printx("      $%s SFK_ZIP_EXT=\".foo .bar .myext\"\n"
         "        set additional, user defined zip file extensions. in this example,\n"
         "        files ending with .foo, .bar or .myext are also treated like zip files.\n"
         "        for the list of default extensions, look above at the -arc option.\n"
         "\n"
         ,pszSet
         );
   
         if (bGlblConsColumnsSet)
            printx("   sfk currently uses %ld console columns for output with some commands.\n", nGlblConsColumns);

         if (bhelp) printx("\n");
         bDone = 1;
      }

      #ifdef _WIN32
      if (bhelp) {
      printx("<help>$sfk help shell\n"
             "\n"
             "   how to configure the windows command prompt "
                "for best productivity\n"
             "\n"
            );
      }
      if (!strncmp(pszSub, "shell", strlen("shell"))) {
      printx(
         "$Configure the windows Command Prompt this way:\n"
         "\n"
         "  1. create a shell shortcut on your desktop:\n"
         "     - Start/Programs/Accessories/Command Prompt,\n"
         "       right mouse button, select Copy.\n"
         "     - go to an empty place on the desktop.\n"
         "     - select Paste.\n"
         "\n"
         "  2. on the new desktop shortcut,\n"
         "     - right mouse button, select Properties.\n"
         "\n"
         "  3. in the Command Prompt Properties, set\n"
         "     - #Options: activate QuickEdit and Insert mode\n"
         "     - #Font   : select 7 x 12\n"
         "     - #Layout : Screen buffer size: Width 160, Height 3000\n"
         "       #         Window size       : Width 160, Height   30\n"
         "\n"
         "  4. close Properties by clicking OK.\n"
         "\n"
         "  5. double-click on the Command Prompt icon to open a shell.\n"
         "\n"
         "$Now you have a well configured power shell:\n"
         "\n"
         "   - any command output is remembered #up to 3000 lines<def>.\n"
         "\n"
         "   - you may select command output anytime with left mouse button,\n"
         "     then click right button #to copy to clipboard<def>.\n"
         "\n"
         "   - to #pause<def> a program that dumps output to the shell,\n"
         "     do a #dummy-select<def> of text with the left mouse button.\n"
         "     to continue program execution, press right button, or enter.\n"
         "\n"
         "$Automatic Command Completion\n"
         "\n"
         "   Question: #how do you enter the directory VeryMuchToTypeFooBarSystem ?\n"
         "\n"
         "   Answer 1: type \"cd verymuchtotypefoobarsystem\"\n"
         "\n"
         "             this is actually what most users do, and it's a waste of time.\n"
         "\n"
         "   Answer 2: #type \"cd very\" and then press the TAB key.\n"
         "\n"
         "             since Windows XP, command completion is default.\n"
         "\n"
         "   Under Win98 and Win2k, completion it is NOT default. As a workaround,\n"
         "   you may type \"cd very*\", or run regedit and set the registry key value\n"
         "   HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\CompletionChar to 9.\n"
         );

         bDone = 1;
      }
      #endif

      if (strBegins(pszSub, "firefox")) {
      printx(
         "$Essential Mozilla Firefox (3.x and higher) tips:\n"
         "\n"
         "  $Creating a profile in a self-defined folder:\n"
         "\n"
         "    By default, Firefox creates a \"default\" profile with the Cache hidden under\n"
         "    $C:\\Documents and Settings\\USERNAME\\Local Settings\\Application Data\\...\n"
         "    and installed extensions and config files hidden under\n"
         "    $C:\\Documents and Settings\\USERNAME\\Application Data\\...\n"
         "    making it very diffcult to access those files directly.\n"
         "    On the command line, enter the Firefox application directory and type\n"
         "    #firefox -profilemanager\n"
         "    then click create/next, type a name like \"foo\", click \"choose folder\"\n"
         "    and select an easy-to-reach directory. After profile creation, type\n"
         "    #firefox -P foo -no-remote<def> to use it. Option -no-remote allows to run\n"
         "    multiple Ffox instances with different profiles.\n"
         "\n"
         "  $Basic settings for Firefox extension developers:\n"
         "\n"
         "    By default, errors in self-written extensions are not shown.\n"
         "    Therefore in the address bar, type #about:config<def> and then\n"
         "    #javascript.options.showInConsole = true\n"
         "    #extensions.logging.enabled = true\n"
         "\n"
         "  $Creating own Firefox extensions:\n"
         "\n"
         "    In the new profile directory, you find an empty diretory \"extensions\".\n"
         "    The best way to start developing an extension is to search for \"firefox addons\"\n"
         "    and install an existing small, simple extensions. During the installation,\n"
         "    - an \".xpi\" file is downloaded by Firefox. this is basically a .zip file.\n"
         "    - the file is extracted, the contents are placed within \"extensions\".\n"
         "    So after installation, you find a new folder under \"extensions\",\n"
         "    containing all source code files of that extension. To fly over the code,\n"
         "    get the free Depeche View, and type #dview foldername<def> to have all\n"
         "    text files from within that folder loaded and shown instantly.\n"
         "    The important starting points are #install.rdf<def> and #chrome.manifest<def> .\n"
         "    Whenever you change anything in the code, you have to restart Firefox\n"
         "    to apply those changes.\n"
         "\n"
         "    See also: \"sfk sample\", \"sfk sample firefox\".\n"
         );
         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "chain", 5))
      {
      printx("$sfk command chaining reference%s:\n",
             bhelp ? " (type \"sfk help chain\")":"");
      printx("\n"
         "   several commands can be combined in a so-called \"command chain\".\n"
         "   this is done by appending command names prefixed by \"+\", for example:\n"
         "\n"
         "   #sfk list docs .txt +ffilter -+foo\n"
         "      \"list\" produces a filename list and passes this to \"filefilter\".\n"
         "      ffilter reads the contents of these files, looking for the word \"foo\".\n"
         "\n"
         "   $chain data types\n"
         "      there are two types of data which can be passed from one command to another:\n"
         "\n"
         "         #- filename lists.\n"
         "         #- lines of plain text data.\n"
         "\n"
         "      some commands produce filename lists, other text data, some both, some none.\n"
         "\n"
         "   $chain data type conversion\n"
         "      vice versa, some commands accept filenames, or text input, or even both.\n"
         "      depending on what you want to do, it may be necessary to convert between\n"
         "      this types of data. this can be done by the keywords:\n"
         "\n"
         "         #+texttofilenames<def> or #+ttf<def>\n"
         "         #+filenamestotext<def> or #+ftt<def>\n"
         "\n"
         "      however, most sfk commands try to do such conversions automatically.\n"
         "\n"
         "   $dumping chain data between commands\n"
         "      #sfk ... +toterm<def>           dumps current chain content to terminal.\n"
         "      #sfk ... +tofile outfile<def>   dumps chain content to file outfile.\n"
         "      #sfk cmd1 ... +then cmd2<def>   does NOT pass any data to cmd2.\n"
         "      in all cases, the chain is cleared. if another command is following,\n"
         "      it will receive no input from the chain.\n"
         "\n"
         "   $scope and lifetime of options\n"
         "      most options are valid only for the command where they are specified.\n"
         "      if another command follows in the chain, the option is reset.\n"
         "      but some options may also be specified on a global scope.\n"
         "      read more on that under \"$sfk help options<def>\".\n"
         "\n"
         "   $more syntax details\n"
         "      further chain control commands are listed where they make sense.\n"
         "      for example, \"sfk tail\" shows an example on command chain looping.\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "sel", 3))
      {
  printx("$sfk file selection reference%s:\n"
         "\n"
         "   $default principles of most sfk commands:\n"
         "\n"
         "      - subdirectory (subfolder) processing is done by default.\n"
         "      - filename comparison is case insensitive.\n"
         "      - hidden and system files are not processed,\n"
         "        except for some commands like copy.\n"
         "      - symbolic links are followed.\n"
         "\n"
         "        type \"sfk help options\" on how to change that.\n"
         "\n"
         "   $how to select directories and contained filenames:\n"
         "\n"
         "   sfk provides many ways of specifying which files you want to process,\n"
         "   from very simple but unflexible to very detailed.\n"
         "\n",
         bhelp ? " (type \"sfk help select\")":""
         );
  printx("   $1. short format file selection:\n"
         "\n"
         "      $dirname [filemask1] [filemask2] [<not>fileexcludemask] [...]\n"
         "\n"
         "      this format supports ONE directory name, followed by many file masks.\n"
         "      it can be used with most commands processing directory trees.\n"
         "\n"
         "      example:\n"
         "\n"
         "      #sfk list mydir foo bar <not>-tmp .txt .zip\n"
         "         selects all files\n"
         "         - in directory mydir and all it's subdirectories\n"
         "         - having foo OR bar in their filename (no * required)\n"
         "         - but not having -tmp in their filename\n"
         "         - and ending with .txt OR .zip (no *.txt required)\n"
         "\n"
         "      supported by commands:\n"
         "         list, select, stat, run, detab, scantab, hexdump and some more.\n"
         "\n"
         );
  printx("   $2. long format file selection:\n"
         "\n"
         "      $-dir root1 [root2] [<wild>pathmask<wild>] [...] [-file mask1 [mask2] [...]]\n"
         "         $[-dir root3 root4 <not>direxcludemask -file mask3 <not>xmask4] [...]\n"
         "\n"
         "      this format supports\n"
         "\n"
         "      - several root directory sets, starting with -dir, each of them\n"
         "        containing many directories, path masks or dir exclusion masks.\n"
         "        a path mask is an expression in a directory set containing a\n"
         "        wildcard character \"<wild>\". a dir exclusion mask is started\n"
         "        by <not> and may be surrounded by <sla> to select exact dir names.\n"
         "\n"
         "      - a file mask set per root directory set, starting with -file.\n"
         "        this may also contain file exclusions starting with <not>\n"
         "\n");
  printx("      example:\n"
         "\n"
         "      #sfk scantab -dir mydir1 mydir2 *include* -file foo bar .hpp\n"
         "         scans all files for TAB characters\n"
         "         - in directory mydir1 and all it's subdirectories\n"
         "           AND\n"
         "         - in directory mydir2 and all it's subdirectories\n"
         "           IF\n"
         "           - 1. the file path contains the word \"include\",\n"
         "             e.g. mydir1\\core\\include\\foosys.hpp\n"
         "           - 2. the filename contains foo OR bar\n"
         "           - 3. the filename ends with .hpp\n"
         "\n"
         "      #sfk scantab -dir mydir1 <not>include -file <not>.tmp <not>.save\n"
         "         scans all files for TAB characters in folder mydir1,\n"
         "         excluding all sub dirs having \"include\" in their name,\n"
         "         and excluding all .tmp and .save files.\n"
         "\n"
         "      supported by:\n"
         "         nearly every command than can process file sets.\n"
         "\n"
         );
  printx("   $3. single parameter file set selection:\n"
         "\n"
         "      some commands like find, filter or tail do not accept the full\n"
         "      short format, but only a single file or dir parameter, as it\n"
         "      would get too complicated mixing the short format with local\n"
         "      options. find more on that in the command's local help.\n"
         "\n"
         );
  printx("   $4. passing filename lists in command chains:\n"
         "\n"
         "      instead of selecting files in the current command, you may use\n"
         "      a filename list created by a previous command, for example:\n"
         "\n"
         "      #sfk select mydir .txt +detab=3\n"
         "         selects all .txt files from directory mydir, then passes\n"
         "         this file list to detab, where the files are detabbed.\n"
         "\n"
         "      command chaining is more intuitive, as you can play around\n"
         "      with different file sets before executing actual changes\n"
         "      on the selected files.\n"
         "\n"
         "      #sfk filter names.txt +texttofilenames +list -late\n"
         "         provided that names.txt contains a list of filenames,\n"
         "         this command chain lists the most recent of these files.\n"
         "         note that in this case, it is unclear if to pass\n"
         "         - the filename \"names.txt\" or\n"
         "         - the line contents from within names.txt\n"
         "         as filenames to \"list\", therefore we need to insert\n"
         "         +texttofilenames or +ttf to enforce a conversion.\n"
         "\n"
         "      supported by:\n"
         "         some commands. check each command's local help for more.\n"
         "\n"
         );
  printx("   $see also:\n"
         "      #sfk help options<def>  general options for most commands.\n"
         "      #sfk list<def>          for more file selection examples.\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "pat", 3))
      {
      printx("$sfk wildcards and text patterns%s:\n",
             bhelp ? " (type \"sfk help patterns\")":"");
      printx("\n"
         "   $available wildcards:\n"
         "      * = any number of characters.\n"
         "      ? = a single character.\n"
         "\n"
         "   $available slash patterns:\n"
         "      \\t   = TAB\n"
         "      \\q   = double quote \"\n"
         "      \\r   = carriage return\n"
         "      \\n   = linefeed\n"
         "      \\xnn = any character with hexadecimal value nn,\n"
         "             e.g. \\x09 is the same as \\t (TAB)\n"
         "      \\\\   = the backslash \\ itself\n"
         "      \\\\*   = the star '*' itself     [only with some commands]\n"
         "      \\?   = quotation mark '?'      [only with some commands]\n"
         "\n"
         "   $support by commands:\n"
         "\n"
         "      if any command supports slash patterns,\n"
         "\n"
         "      - they are NOT active by default.\n"
         "\n"
         "      - to use, say -spat directly after the command name:\n"
         "        #sfk echo -spat \"three\\tlittle\\ttabs\\t.\"\n"
         "        prints: #three   little  tabs    .\n"
         "\n"
         "      - to activate slash patterns globally over multiple commands\n"
         "        of a command chain, say -spat directly after \"sfk\":\n"
         "        #sfk -spat echo \"two\\ttabs\" +filter -rep \"x\\tx_x\"\n"
         "        prints: #two_tabs\n"
         "\n"
         "      if any command supports wildcards,\n"
         "\n"
         "      - they are active by default.\n"
         "\n"
         "      - they can be deactivated by option -literal or -lit,\n"
         "        if you need to find/replace '*' or '?' characters themselves:\n"
         "        #sfk echo \"*** ok ***\" +filter -lit -rep \"_*_=_\"\n"
         "        prints: #=== ok ===\n"
         "\n"
         "      - to deactivate globally over multiple commands of a chain,\n"
         "        say -literal directly after \"sfk\":\n"
         "        #sfk -literal echo \"*** ok ???\" +filter -lit -rep \"_?_!_\"\n"
         "        prints: #*** ok !!!\n"
         "\n"
         "      - another way to find/replace '*' or '?' is to say -spat\n"
         "        and then to use \\\\* and \\? patterns:\n"
         "        #sfk echo \"*** ok ***\" +filter -spat -rep \"_\\\\*_=_\"\n"
         "        prints: #=== ok ===\n"
         "\n"
         "      further reading:\n"
         "\n"
         "         $sfk help options<def> - general options reference\n"
         "         $sfk help chain<def>   - about command chaining\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || strBegins(pszSub, "uni") || strBegins(pszSub, "utf"))
      {
      printx("$sfk unicode file read support%s:\n",
             bhelp ? " (type \"sfk help unicode\")":"");
      printx("\n"
         "   by default, sfk commands that need to read TEXT files will\n"
         "   skip utf-16 (ucs-2, wide char) files, as they look like binary,\n"
         "   containing zero bytes.\n"
         "\n"
         "   you may set option \"#-utf<def>\" to activate utf-16 detection and decoding\n"
         "   for file READING, allowing to search for words also in unicode files.\n"
         "\n"
         "   -utf works with text processing commands like sfk filter and sfk find.\n"
         "   (sfk hexfind will ignore the option, as it reads everything as binary)\n"
         "\n"
         "   the decoding is primitive and simply strips every 2nd byte,\n"
         "   meaning that only the lowest code points are supported.\n"
         "\n"
         "   $NOTE:<def> option \"-utf\" is #experimental<def> and shall #not<def> be used if you want\n"
         "         to #write<def> any text file contents! (e.g. with sfk filter ... -write)\n"
         "         during write, the utf-16 format will be replaced by a primitive\n"
         "         plain ascii format (NOT a proper conversion - sfk will just\n"
         "         drop every 2nd byte from the file) which is often not desirable.\n"
         "\n"
         "   $examples\n"
         "      #sfk -utf filter mydir -+foo\n"
         "         filter \"foo\" in all text files of mydir, including utf-16.\n"
         "      #sfk -utf find mydir foobar\n"
         "         find \"foobar\" in all files of mydir, including utf-16.\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      #ifdef VFILEBASE
      #endif // VFILEBASE

      if (bhelp || !strcmp(pszSub, "fileset"))
      {
      printx("$using filesets%s:\n",
             bhelp ? " (type \"sfk help fileset\")":"");
      printx("\n"
             "   if you want to process many directory trees and dir/file masks,\n"
             "   you may create a fileset, which is a text file containing directories\n"
             "   and file masks, as well as remark and blank lines for better readability.\n"
             "\n"
             "   $example file zz-myfiles.txt:\n"
             "\n"
             "      ## stat the fooproj folders.\n"
             "      ## this is a remark line.\n"
             "\n"
             "      -dir fooproj\\src\n"
             "             !\\save\\\n"
             "             !\\tmp\\\n"
             "           -file .hpp .cpp !.bak\n"
             "\n"
             "      -dir \"C:\\Docs With Blanks\"\n"
             "           -file !.tmp\n"
             "\n"
             "   $this can be used in a command like:\n"
             "\n"
             "      #sfk stat -fileset zz-myfiles.txt\n"
             "\n"
             "         lists size statistics of directory trees x:\\fooproj\\src\n"
             "         and x:\\foodb to z:\\ . any directory \"\\save\" or \"\\tmp\" within\n"
             "         fooproj\\src is excluded. within foodb, everything is included,\n"
             "         except .tmp files. you can also add remarks starting with \"##\"\n"
             "\n"
             "   $using flat filename lists:\n"
             "\n"
             "      as an alternative to specifying dir- and file masks,\n"
             "      option -fileset also accepts a flat filename list, like:\n"
             "\n"
             "         foo1.txt\n"
             "         foo2.txt\n"
             "         mydir1\\foo\\bar2.txt\n"
             "\n"
             "   the -fileset option is supported by most commands that accept\n"
             "   the -dir ... -file ... syntax, e.g. list, snapto, md5gento,\n"
             "   but not yet with sfk find or grep.\n"
             );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (!bhelp) {
         if (!bDone) {
            fprintf(stderr, "unknown help subject: %s.\n", pszSub);
            fprintf(stderr, "type just \"sfk\" for the main help.\n");
            fprintf(stderr, "type \"sfk ask %s\" to search all help text.\n", pszSub);
         }
         return 9;
      }
   }

   ifcmd (!strcmp(pszCmd, "faq")) 
   {
      ifhelp (1)
      printx(

// 
"start of filename comparison: use \"\\pattern\". see also \"name start\"\n"
"traveling, walking subdirectories or subfolders: is default. type \"sfk help select\"\n"
"find in text files: \"sfk find\", \"sfk hexfind\", \"sfk filter\"\n"
"find text, data in binary files, binaries: \"sfk find\", \"sfk hexfind\"\n"
"find same, identical, duplicate files: \"sfk dupfind\"\n"
"compare directories, folders, differences: \"sfk list\" with -sincedir option\n"
"find different files, differences: \"sfk md5check\", \"sfk list\" with -sincedir\n"
"list, find newest, oldest, latest files of dir: \"sfk list\" with -late, -old\n"
"list, find most recent files of dir: \"sfk list\" with -late, -old\n"
"list, sort, order dir files by date, timestamp: \"sfk list\" with -late, -old\n"
"list, find largest, biggest, smallest dir files: \"sfk list\" with -big, -small\n"
"list, find files changed today, since a date: \"sfk list\" with -since\n"
"sort dir contents by date, time, size: \"sfk list\" with -late, -big\n"
"symbolic links: no option under windows. under linux (not lib5) see \"sfk help opt\"\n"
"regular expressions: not supported, but see \"sfk help patterns\"\n"
"list, show files, directory tree size, largest dirtree: see \"sfk stat\"\n"
"split text lines, column data by characters: \"sfk filter\" with -sep, -form\n"
"extract, remove text blocks between marker lines: \"sfk filter\" with -inc, -cut\n"
"create, verify md5sum, md5 checksum for dir, files: \"sfk md5gento\", \"sfk md5check\", \"sfk md5\"\n"
"convert binary to c++, cpp, java sourcecode: \"sfk bin-to-src\"\n"
"split large text or binary files: \"sfk split\"\n"
"transfer files from windows host to linux vmware: \"sfk ftpserv\", \"sfk ftp\"\n"
"find, where are classes inside, within jar files tree: \"sfk list\" with -arc\n"
"all class packages in jar dirs: \"sfk list\" with -arc\n"
"list, get all files in jars in all dirs: \"sfk list -arc . .jar\"\n"
"find, replace words in text, binary files: \"sfk replace\", \"sfk filter\"\n"
"find, replace hex pattern in binary files: \"sfk hexfind\", \"sfk replace\"\n"
"patch binary file contents: \"sfk replace\"\n"
"convert text file, dos, windows, linux crlf line endings, format: \"sfk addcr\", \"sfk remcr\"\n"
"replace, add, remove, strip, convert text file crlf line endings: \"sfk addcr\", \"sfk remcr\"\n"
"find, print, read first, last lines of text files: \"sfk head\", \"sfk tail\"\n"
"print, read head or tail of files: \"sfk head\", \"sfk tail\"\n"
"find command, cmd, bat, exe file in path: \"sfk pathfind\"\n"
"remove, replace tabs by spaces in text file lines: \"sfk detab\"\n"
"insert, remove text in files: \"sfk replace\", \"sfk filter\" with -write\n"
"find, list files in a dir sorted by size, time: \"sfk list\" with -big, -late\n"
"copy content, extract, view text of a binary file: \"sfk partcopy\", \"sfk strings\"\n"
"run user defined command, processing many files: \"sfk run\"\n"
"run a command on each file, line of file: \"sfk run\", \"sfk filter thefile.txt +run \"mycmd <run>text\"\"\n"
"replace, remove spaces in filenames, dir names: \"sfk deblank\"\n"
"join, add text, binary files: \"sfk snapto\", \"sfk join\"\n"
"adding delay, pause to command file: \"sfk sleep\", \"sfk pause\"\n"
"set, create, define alias for .cmd, .bat, command path in shell: \"sfk alias\"\n"
"delete .bak, .tmp, temporary files: \"sfk sel . .bak +del\"\n"
"convert binary file to text, source code: \"sfk hexdump\", \"sfk bin-to-src\"\n"
"hex to byte, convert hex dump, file into binary file: \"sfk hextobin\"\n"
"count files in dir tree: \"sfk list ... +count\"\n"
"create text file from dir listing: \"sfk list ... +tofile\"\n"
"create large text, binary file for tests: \"sfk make-random-file\"\n"
"delete files by extension: \"sfk del mydir .ext\"\n"
"trace, hexdump, dump TCP data, browser connection: \"sfk tcpdump\"\n"
"tcpdump of http request in plain text: \"sfk tcpdump\" with -flat\n"
"echo staying on same line, without lf: \"sfk echo\" with -noline\n"
"shell echo with colored words in red, green, blue: \"sfk echo\"\n"
"open, read text from clipboard: \"sfk fromclip\"\n"
"file copy to clipboard: \"sfk filter ... +toclip\"\n");
printx(
"find unprintable, nonprintable characters : \"sfk hexfind\" with -bin\n"
"find duplicate lines in a text file: \"sfk count\" with -samelines\n"
"find data, hex numbers in binary files: \"sfk hexfind\"\n"
"find, replace text with wildcards: \"sfk filter\"\n"
"find, get, list files matching patterns: \"sfk list\"\n"
"cut, remove, filter empty, blank lines from text files: \"sfk filter\" with -no-blank-lines\n"
"replace any, accent, umlaut characters in text files: \"sfk replace\"\n"
"check, find dependencies of binaries, executables files: \"sfk deplist\"\n"
"find, list number of files in a directory: \"sfk list mydir +count\"\n"
"add current, any dir to a file list: \"sfk list . >>myfilelist.txt\"\n"
"strip, skip text file lines by filter, markers: \"sfk filter\" with -!mypattern or -cut\n"
"cut, strip, exclude lines by words from text files: \"sfk filter\" with -!word1 -!word2\n"
"list files of dir needing no wildcard: \"sfk list mydir *foo*\" == \"sfk list mydir foo\"\n"
"write shell script with command chaining: \"sfk script\", \"sfk samp\"\n"
#ifdef _WIN32
"to create multi line commands, use ^ at the end of .bat lines, or \"sfk script\"\n"
#else
"to create multi line commands, use \"sfk script\"\n"
#endif
"if content(s) are too large to load, see -memlimit under \"sfk help opt\"\n"
"replace colors in text lines: \"sfk filter\" with -highlight\n"
"jpeg, jpg, png image processing, conversion: \"sfk samp javaimg\", \"sfk samp phpimg\""
 " or google for imagemagick.\n"
"all zip tar gz bz2 file extensions recognized by sfk: type \"sfk help opt\"\n"
"process files changed from, until a date: see option -since and -before\n"

      );
#ifdef _WIN32
      printx(
"print, get, dump clipboard contents: \"sfk fromclip\"\n"
      );
#endif
      ehelp;
      // no real action here
      return 9;
   }

   if (!strcmp(pszCmd, "syntest")) {
      lRC = runSyntaxTests(penv);
      bDone = 1;
      // fall through to exit
   }

   ifcmd (!strcmp(pszCmd, "loop"))
   {
      ifhelp (iDir == iDirStart)
      printx("<help>$sfk ... +loop\n"
             "\n"
             "   repeat (loop) the execution of a command chain.\n"
             "\n"
             "   when using +loop in an sfk script file,\n"
             "   always add +end after it (+loop +end).\n"
             "\n"
             "   $see also\n"
             "      sfk tail - a script example with looping\n"
             "\n"
             "   $examples\n"
             "      #sfk list -late mydir +sleep 5000 +loop\n"
             "         list most recent files of mydir every 5 sec.\n"
             );
      ehelp;

      if (!userInterrupt()) {
         // dump pending text data from the pipes
         // chain.flush();
         // restart command sequence
         pszCmd = pszCmdStart;
         iDir   = iDirStart;
         nparm  = argc - iDir;
         // reset all chain settings
         chain.reset();
         // rerun from start (past global prefix options)
         bChainCycle = 1;
      }
      bDone = 1;
   }

   if (!strcmp(pszCmd, "dumphelp") || !strcmp(pszCmd, "ask"))
   {
      // chain data is now filled with help text
      bhelp = bGlblCollectHelp = 0;

      bool bdump = !strcmp(pszCmd, "dumphelp");

      StringTable apat;
      char *ppre1=0, *ppre2=0;
      bool bdumpmiss = 0; // internal: only tell if a miss occured
      bool bhit      = 0;
      int  iDirRaw   = iDir;
      bool bprocopt  = 0;
      int  nrawpat   = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-dumpmiss")) {
            bdumpmiss  = 1;
            cs.quiet = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-opt")) {
            bprocopt = 1;
            continue;
         }
         else
         if (bprocopt && !strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // else
         // if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
         //    break;
         // process non-option keywords:
         nrawpat++;
         char *prawpat  = argv[iDir];
         char *pfiltpat = filterAskPattern(prawpat, ppre1, ppre2);
         if (pfiltpat) apat.addEntry(pfiltpat);
         ppre2 = ppre1;
         ppre1 = prawpat;
      }

      // did user supply a useable query phrase?
      long npat = apat.numberOfEntries();
      if (nrawpat > 0 && !npat) {
         perr("the given words are too generic, and cannot be used for search.");
         pinf("please rephrase your query with more precise words.\n");
         return 9;
      }

      // just for chaining:
      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 0, &iChainNext)) return lRC;

      // if search terms are supplied
      if (!iChainNext || (npat > 0))
      {
         // dump help contents now, optionally filtered by words
         long i=0,k=0,nlastdump=-1;

         if (!bdump && !iChainNext && !cs.quiet)
         {
            // tell short info what is really used for search
            setTextColor(nGlblTimeColor, 1);
            printf("using: ");
            for (i=0; i<npat; i++) {
               printf("%s ", apat.getEntry(i, __LINE__));
            }
            printf("\n");
            setTextColor(-1, 1);
         }

         StringPipe *phelp = chain.outdata;
         bool bfirst=1,bpostlf=0;
         for (i=0; i<phelp->numberOfEntries(); i++) 
         {
            char *pattr = 0;
            char *pline = phelp->getEntry(i, __LINE__, &pattr);

            if (pattr) strcopy(szAttrBuf, pattr);
            else { mclear(szAttrBuf); }

            long nhit=0,npos=0;
            for (k=0; k<npat; k++) {
               char *ppat = apat.getEntry(k, __LINE__);
               if (mystrstri(pline, ppat, &npos)) {
                  nhit++;
                  if (npos + strlen(ppat) < MAX_LINE_LEN)
                     memset(szAttrBuf+npos, 'f', strlen(ppat));
               }
            }

            if (bdump)
               printColorText(pline, szAttrBuf);
            else
            if (nhit == npat) 
            {
               long nindmax = indent(pline);

               char *pcachetxt = 0;
               char *pcacheatt = 0;

               if (nindmax <= 0) {
                  if (bfirst)
                     bfirst=0;
                  else
                  if (bpostlf) {
                     if (!bdumpmiss)
                        printf("\n");
                  }
                  bpostlf = (szAttrBuf[0] == 'i');
               }
               else
               {
                  bpostlf = 1;

                  // dump context before hit line
                  char *papre=0, *plpre=0;
                  long ictx=0,ifwd=0;
   
                  // 1. walk back to zero indent
                  for (ictx=i-1; ictx>=0 && ictx>nlastdump; ictx--) 
                  {
                     plpre = phelp->getEntry(ictx, __LINE__, &papre);
                     if (plpre[0] && plpre[0] != ' ' && plpre[0] != '\t')
                        break;
                  }
                  if (ictx < 0) return 9+perr("int. #148281153");
   
                  // 2. walk forward, dump every indent change
                  if (ictx > nlastdump) 
                  {
                     if (bfirst) bfirst=0; else {
                        if (!bdumpmiss)
                           printf("\n");
                     }
                     long nindcur=0;
                     for (ifwd=ictx; ifwd<i; ifwd++) 
                     {
                        plpre = phelp->getEntry(ifwd, __LINE__, &papre);
                        long nindfwd = indent(plpre);
                        // whenever indent changes, dump previous.
                        // also dump zero indent line.
                        if (ifwd==ictx || (nindfwd >= nindcur && nindfwd < nindmax))
                        {
                           if ((nindfwd > nindcur) && pcachetxt) {
                              if (bdumpmiss) bhit=1; else
                              printColorText(pcachetxt, pcacheatt);
                           }
                           pcachetxt = plpre;
                           pcacheatt = papre;
                           nindcur = nindfwd;
                        }
                     }
                  }
               }
               // previous context remaining?
               if (pcachetxt) {
                  if (bdumpmiss) bhit=1; else
                  printColorText(pcachetxt, pcacheatt);
               }
               // dump hit line
               if (bdumpmiss) bhit=1; else
                  printColorText(pline, szAttrBuf);
               nlastdump = i;
            }
         }
         chain.reset();
      }

      if (bdumpmiss && !bhit) {
         printf("miss: sfk ask ");
         for (; iDirRaw<argc; iDirRaw++) 
            if (!strBegins(argv[iDirRaw], "-dump"))
               printf("%s ",argv[iDirRaw]);
         printf("\n");
         return 1;
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }
 }
 while (bChainCycle);

   if (!bDone) {
      perr("unknown command: %s\n", pszCmd);
      lRC = 9;
      #ifdef SFINT
      if (paliasv && argc >= 2) {
         pwarn("this executable's name is not sfk, therefore sfk tries to run \"sfk %s\".\n", argv[1]);
         pwarn("you may set SFK_CONFIG=ignore-exec-name to disable this behaviour.\n");
         pinf("type \"sfk alias\" for more help about aliasing.\n");
      }
      #endif
   }

   return lRC;
}
#endif // USE_SFK_BASE


