/*
   The Swiss File Knife Command Line Multi Function Tool
   =====================================================
   StahlWorks Technologies, http://stahlworks.com/
   Provided under the BSD license.

   The whole source code was created with Depeche View Professional,
   the world's fastest text file browser and editor.

   1.7.3
   -  CHG: SYNTAX CHANGE: by default, sfk xfind and xtext now show
           complete text lines containing one or more search hits.
           add option -pure to show only search hits as before,
           or change defaults by an environment variable
           SET SFK_CONFIG=xfind:pure,xtext:pure
           sfk xtext is now an alias of xfind -nobin,
           i.e. it searches only in text files.
   -  CHG: COMPLETE REWORK OF SEARCH FUNCTIONS:
           xfind, xtext, xhexfind, extract.
           output may look completely different now.
           many new options. reworked help text.
           CHECK YOUR BATCH FILES if the new outputs
           still work for you as expected.
   -  CHG: SYNTAX CHANGE: sfk find: patterns starting with "-" 
           are no longer supported directly but must be prefixed by "\".
           options can now be given after search patterns.
   -  add: sfk csvtotab to convert comma separated data.
   -  add: sfk tabtocsv to convert tab separated data to csv.
   -  add: sfk filter -trim, -ltrim, -rtrim to remove blanks
           and tab characters at start or end of lines.
   -  add: sfk fromclip: option -ltrim and alias "sfk lclip"
           to remove blanks and tabs at start of lines.
   -  add: sfk xfind/xex -bylinelist to specify a simplified
           list of search terms without any totext.
   -  add: sfk extract is now available in base/xd.
   -  add: sfk view: improved help if dview is not found.
   -  add: xed, xex: direct reading of zip file entries.
   -  chg: sfk view: now passing through all non sfk options
           and parameters as is, like "-tab 8".
           parms with blanks are enquoted.
   -  chg: source code cleanup: removed patch.cpp and inst.cpp,
           integrated them into sfknet.cpp and renamed this to
           sfkext.cpp for easy compilation.
   -  chg: default replace color with theme:white now purple
           on windows and linux.
   -  chg: sfk xex -showparts now shows only part numbers
           then stops processing.
   -  chg: xreplace: improved [lstart] handling.
   -  fix: xreplace: character classes at start of pattern
           with a zero min length like in "/[0.100 white]foo/"
           did not work in case of zero length hit.
   -  chg: hexfind: now using wide hexdump.
   -  chg: xed, xex: without any patterns it now passes through
           input unmodified.
   -  fix: filter +xed produced LF i/o CRLF under windows.
   -  fix: (x)hexfind: did not show absolute offset in file.
   -  fix: (x)hexfind: ignored windows console width.
   -  fix: extract, xfind -tofile: -nofile was ignored.
   -  add: sfk cmd n, print a command n from the help text
           as one long line.
   -  add: web reference info per command.
   internal:
   -  fix: zip sub entry direct read: missing set of size
           and time after provideInput.
   -  fix: line start state after [lend] match.
   -  del: unused internal command freezeto.

   1.7.2
   Revision 3:
   -  fix: addcr, remcr: did not work with mixed format files.
   -  dep: option -utf is now deprecated, use -wchar instead
           as this does not at all decode UTF-16 but just reads
           plain ASCII from wide character files.
   -  fix: xe: non speaking error 21212902 on missing -usetmp.
   Revision 2:
   -  chg: sfk tail: extended example to show how to stop
           file filtering on a specific text.
   -  add: chaining support commands: storetext and gettext
           to remember the current chain text.
   -  add: chaining support command: stop to finish
           execution within a chain.
   -  add: sfk list -kb[ytes], -mbytes, -gbytes
           to list file sizes in larger units then bytes.
   Initial Release:
   -  CHG: lf-to-crlf, crlf-to-lf, addcr, remcr SYNTAX CHANGE: 
           now runs in simulation mode if a directory is given.
           if a single filename, or a list of filenames is given
           then conversion is done immediately.
   -  chg: sfk base+xd: xfind and xex now support full reformatting
           of found text patterns by [part...] statements.
   -  add: addcr, remcr: no longer rewriting files that
           need no changes.
   -  chg: addcr, remcr: no longer adding a line ending
           at the last line if there was none. added
           option -forceend to always force a line ending
           at the last line.
   -  fix: addcr, remcr: truncation of binary files.
           now all binary files are skipped.
   -  fix: xfind: crash on incomplete "chars of" pattern.
   -  chg: sfk source files now all with lf-only line endings.
   -  add: sfk help compile info how to compile sfk on linux.
   internal:
   Revision 3:
   -  add: proper blocking of -fast with xrep.
   -  add: rep -fast no longer requires -case.
   -  add: sfk (x)replace -spats: support for \d255 slash patterns,
           only available with strict slash patterns.
           sfk replace: -fast option for fast search.
   Initial Release:
   -  fix: read from zip with sfk x64: wrong data.
   -  chg: zlib crc32 name adaptions for improved ux64 build.
   -  chg: SFKMatch code rework.

   1.7.1
   Revision 2:
   -  add: base+xd and xe: sfk xfind, search in text and
           binary files using wildcards and sfk expressions,
           with colored text output to terminal.
   -  dep: deprecated: sfk find -text should no longer
           be used to read only text files, as the option
           interferes with xfind -text patterns.
           use sfk ftext to read only text files.
   -  fix: compile warnings: unsequenced access
   Initial Release:
   -  CHG: sfk find: no longer applying soft word wrap
           at characters .,; by default. 
           use option -delim=.,; for old behaviour.
   -  chg: sfk find: search within binary files: no longer
           lists a previous and current line but joins
           them automatically for output.
   -  add: sfk find: option -delim to specify delimiters
           for soft word wrapping.
   -  add: sfk split: option -text to split text files
           at line boundaries.
   -  fix: sfk ftpserv: handling of ALLO command.
           this now produces a normal 200 OK reply.
   -  fix: sfk find: search for long strings failed
           even with -wrap(bin)=n change due to limited
           internal buffer sizes. now result strings
           can be up to 800 characters approx.
   -  fix: sfk find singleFile pattern +command
           chaining did not work.
   -  chg: sfk xhexfind: -quiet now also disables the
           files checked info.
   -  add: sfk filter: -toutf to convert iso-8859-1
           text to utf-8.
   -  add: sfk runloop: now accepts $$ to print the
           character $ in output text.
   -  chg: sfk runloop: no longer tells "error" on
           non zero rc from called program.
   -  fix: sfk entab did not show help text.
   -  chg: sfk entab: complete rework, now writing
           only files containing changes.
   -  fix: fixed some compile warnings.
   internal:
   Revision 2:
   -  fix: expr: now always copying fromtext.
   -  fix: group addresses 225. to 239. not detected
           as multicast in some cases.
   -  fix: xe replace: possible memcpy/memmove issue.
   -  add: sfk echo: [white] color support,
           inofficial as it does not work
           with some shell backgrounds.

   1.7.0
   Revision 2:
   -  fix: sfk fromnet +filter +loop did not work
           with multi line text messages.
   -  fix: sfk fromnet did not stop on escape
           under windows.
   -  add: sfk unixtime, print the unix timestamp
   -  chg: sfk tonetlog -h: rework of help text.
   -  chg: udpsend/dump: rework of knx help.
   Initial Release:
   -  add: sfk fromnet: print incoming network text
           sent by sfk tolog or tonetlog.
   -  chg: sfk tonetlog: one msec of delay after each
           package sent, by default, to avoid package
           losses on long text transfers. can be
           changed by option -delay=n.
   -  add: sfk tonetlog: options -nolf and -usecr.
           option -noline is deprecated.
   -  add: sfk filter, sfk tonetlog: option -toiso for
           simple conversion of UTF8 text to ISO-8859-1.
   -  add: sfk chars: option -fromutf to list code points
           of characters from UTF8 sequences.
   -  add: udpdump: -tofile output option.
   -  add: netlog: extended help text with sample scripts
           how to compile remote and receive output.
   -  chg: macintosh: optimized color scheme.
   -  fix: udpdump ... -data missing highlight of text.
   -  fix: sfk xed ... +run, +ffilter etc. did not work.
*/

// NOTE: if you change the source and create your own derivate,
// fill in the following infos before releasing your version of sfk.
#define SFK_BRANCH   ""
#define SFK_VERSION  "1.7.3" // ver_ and check the _PRE definition
#define SFK_FIXPACK  ""
#ifndef SFK_PROVIDER
#define SFK_PROVIDER "unknown"
#endif

// in case of linking problems concerning libsocket etc.,
// you may out-comment this to compile without tcp support:
#ifndef USE_SFK_BASE
 #define WITH_TCP
 #define SFK_FTP_TIMEOUT "30" // seconds, as string
#endif // USE_SFK_BASE

#define USE_SFT_UPDATE
#define SFK_CCDIRTIME   // copy over created dir time

// should you get problems with fsetpos/fgetpos compile,
// activate this to disable zip/jar file content listing:
// #define NO_ZIP_LIST

#ifdef SFK64
 #define SFK_OS_BITSTR "-64"
#else
 #define SFK_OS_BITSTR ""
#endif

#if defined(__APPLE__) && !defined(MAC_OS_X)
 #define MAC_OS_X
#endif

#if !defined(VER_STR_OS) && defined(_WIN32)
 #define VER_STR_OS "windows-any"
 #define _WIN32_WINNT 0x0400 // for copyFileEx
#endif

#if !defined(VER_STR_OS) && defined(MAC_OS_X)
  #ifdef MAC_OS_X_PPC
   #define VER_STR_OS "mac-osx-ppc"
  #endif
  #ifdef MAC_OS_X_I686
   #define VER_STR_OS "mac-osx-i686"
  #endif
  #ifndef VER_STR_OS
   #define VER_STR_OS "mac-osx"
  #endif
#endif

// generic ARM linux, "soft float" or float independent
#if !defined(VER_STR_OS) && defined(LINUX_ARM)
 #define VER_STR_OS "linux-arm"
#endif

// if doing an explicite "hard float" compile
#if !defined(VER_STR_OS) && defined(LINUX_ARM_HF)
 #define VER_STR_OS "linux-arm-hf"
#endif

#if !defined(VER_STR_OS) && defined(SOLARIS)
 #define VER_STR_OS "solaris"
#endif

#if !defined(VER_STR_OS)
 #ifdef SFK_LIB5
  #define VER_STR_OS "linux-lib5"
 #else
  #define VER_STR_OS "linux-lib6" SFK_OS_BITSTR
  #define SFK_LINUX_FULL
 #endif
#endif

#if defined(SFK_STATIC)
 #define SFK_BUILD_INFO "static"
#else
 #define SFK_BUILD_INFO "-"
#endif

// SFK_PRE_RELEASE?
// #define SFK_VERTYPE "Pre"

#define VER_DAT_STR "date=" __DATE__

#define  MTKTRACE_CODE
#include "sfkbase.hpp"

#ifdef VFILEBASE
#endif // VFILEBASE

#ifdef USE_SFK_BASE
 #define NO_VER_STR
#endif

#ifndef NO_VER_STR
// binary version tag, is also parsed in version command.
// $version:vernum,shortid,full name,type$\0"
 #ifndef SFK_VERTYPE
  #define SFK_VERTYPE "Base" // version type
 #endif
 #ifndef SFK_VERTEXT
  #define SFK_VERTEXT "/OSE" // open source edition
 #endif
static const char *pszGlblVersion =
   "$version:vernum=" SFK_VERSION ",name=sfk,title=Swiss File Knife,"
   "info=" SFK_BUILD_INFO ","
   "os=" VER_STR_OS ",type=" SFK_VERTYPE SFK_VERTEXT ",fix=" SFK_FIXPACK "," VER_DAT_STR "$\0";
static const char *pszGlblVerType = SFK_VERTYPE;
#endif

#define SFK_BOTH_RUNCHARS
// #define SFK_STRICT_MATCH

#ifndef USE_SFK_BASE
 #define WITH_FN_INST
#endif // USE_SFK_BASE

#ifdef _WIN32
 #ifdef SFK_MEMTRACE
  #include "memdeb.cpp"
 #endif
#endif
#ifndef SFK_MEMTRACE
void sfkmem_checklist(const char *pszCheckPoint) { }
#endif

#ifdef _WIN32
const char  glblPathChar    = '\\';
const char  glblWrongPChar  = '/';
const char *glblPathStr     = "\\";
const char *glblAddWildCard = "*";
const char *glblDotSlash    = ".\\";
      char  glblNotChar     = '!';
      char  glblRunChar     = '$';
const char *glblWildStr     = "*";
const char  glblWildChar    = '*';
const char *glblWildInfoStr = "*";
const char *glblLineEnd     = "\r\n";
#else
const char  glblPathChar    = '/';
const char  glblWrongPChar  = '\\';
const char *glblPathStr     = "/";
const char *glblAddWildCard = "";    // not used w/ linux
const char *glblDotSlash    = "./";
      char  glblNotChar     = ':';
      char  glblRunChar     = '#';
      char  glblWildStr[10];       // "+";
      char  glblWildChar;          // '+';
      char  glblWildInfoStr[20];   // "+ or \\*";
const char *glblLineEnd     = "\n";
#endif

bool glblMixedSyntax = 0; // support both ! and : for file masks

void initWildCards() {
   #ifndef _WIN32
   char c = '%'; // linux wildcard default
   char *pszWC = getenv("SFK_CONFIG");
   if (pszWC) pszWC  = strstr(pszWC, "wildstar:");
   if (pszWC) pszWC += strlen("wildstar:");
   if (pszWC) c = *pszWC;
   memset(glblWildStr    , 0, sizeof(glblWildStr));
   memset(glblWildInfoStr, 0, sizeof(glblWildInfoStr));
   glblWildStr[0]     = c;
   glblWildChar       = c;
   glblWildInfoStr[0] = c;
   #endif
}

bool isWildChar(char c) {
   #ifdef _WIN32
   return (c == glblWildChar);
   #else
   return (c == '*' || c == glblWildChar);
   #endif
}
bool isWildStr(char *p) {
   if (strlen(p) != 1) return false;
   return isWildChar(p[0]);
}

bool isNotChar(char c) {
   if (glblMixedSyntax != 0 && c == ':')
      return 1;
   return (c == glblNotChar) ? 1 : 0;
}

void setTextColor(int n, bool bStdErr=0);
int perr(const char *pszFormat, ...);
int pwarn(const char *pszFormat, ...);
int pinf(const char *pszFormat, ...);
int containsWildCards(char *pszName);
num numFromSizeStr(char *psz, cchar *pszLoudInfo=0, bool bRelaxed=0);

// ========== lowest level printf redirect ============

#ifdef printf
 #undef printf
#endif
int sfkprintf(const char *pszFormat, ...);
#define printf sfkprintf

// ========== 64 bit abstraction layer begin ==========

char *numtostr(num n, int nDigits, char *pszBuf, int nRadix)
{
   static char szBuf[100];
   if (!pszBuf)
        pszBuf = szBuf;

   #ifdef _WIN32
   if (nRadix == 10)
      sprintf(pszBuf, "%0*I64d", nDigits, n);
   else
      sprintf(pszBuf, "%0*I64X", nDigits, n);
   return pszBuf;
   #else
   if (nRadix == 10)
      sprintf(pszBuf, "%0*lld", nDigits, n);
   else
      sprintf(pszBuf, "%0*llX", nDigits, n);
   return pszBuf;
   #endif
}

char *numtoa_blank(num n, int nDigits)
{
   static char szBuf2[100];
   #ifdef _WIN32
   sprintf(szBuf2, "%*I64d", nDigits, n); // FIX: 1674
   return szBuf2;
   #else
   sprintf(szBuf2, "%*lld", nDigits, n);  // FIX: 1674
   return szBuf2;
   #endif
}

char *numtoa(num n, int nDigits, char *pszBuf) {
   return numtostr(n, nDigits, pszBuf, 10);
}

char *numtohex(num n, int nDigits, char *pszBuf) {
   return numtostr(n, nDigits, pszBuf, 0x10);
}

num atonum(char *psz)
{
   #ifdef _WIN32
   return _atoi64(psz);
   #else
   return atoll(psz);
   #endif
}

// atonum with support for decimal and 0x hex values
num myatonum(char *psz)
{
   if (!strncmp(psz, "0x", 2)) {
      #ifdef _MSC_VER
      return _strtoui64(psz+2, 0, 0x10);
      #else
      return strtoull(psz+2, 0, 0x10);
      #endif
   } else {
      return atonum(psz);
   }
}

mytime_t getSystemTime()
{
   static mytime_t stSysTime = 0;
   #ifdef SFK_W64
   return _time64(&stSysTime);
   #else
   return time(&stSysTime);
   #endif
}

// ========== 64 bit abstraction layer end ============

// ====== SFK primitive function library begin ========

// #undef  _
// #define _ printf("[%d]\n",__LINE__);

char *ownIPList(int &rhowmany, uint nPort=0, const char *psep=" or ");

#if (defined(WITH_TCP) || defined(VFILENET) || defined(DV_TCP))

bool bGlblTCPInitialized = 0;

int prepareTCP()
{
   if (!bGlblTCPInitialized)
   {
      bGlblTCPInitialized = 1;

      #ifdef _WIN32
      WORD wVersionRequested = MAKEWORD(1,1);
      WSADATA wsaData;
      if (WSAStartup(wVersionRequested, &wsaData)!=0)
         return 9+perr("WSAStartup failed\n");
      #endif
   }
   return 0;
}

void shutdownTCP()
{
   if (!bGlblTCPInitialized)
      return;

   bGlblTCPInitialized = 0;

   // not yet done central due to side effects
   // #ifdef _WIN32
   // WSACleanup();
   // #endif
}

// all closesocket calls are redirected to:
void myclosesocket(SOCKET hsock, bool bread, bool bwrite)
{
   int nmode = 0;

   if (bread  && !bwrite)
      nmode = SHUT_RD;     // no more receptions
   else
   if (!bread && bwrite)
      nmode = SHUT_WR;     // no more transmissions
   else
   if (bread  && bwrite)
      nmode = SHUT_RDWR;   // no more transfers at all

   // signal the tcp stack that transmission stops,
   // so the receiver side may receive remaining data.
   shutdown(hsock, nmode);

   #ifdef _WIN32
   closesocket(hsock);
   #else
   close(hsock);
   #endif
}

#endif // WITH_TCP or VFILENET

// just close on a socket is not enough.
// myclosesocket also does the shutdown().
#define closesocket myclosesocket

num getCurrentTime()
{
   #ifdef _WIN32
   return (num)GetTickCount();
   #else
   struct timeval tv;
   gettimeofday(&tv, NULL);
   return ((num)tv.tv_sec) * 1000 + ((num)tv.tv_usec) / 1000;
   #endif
}

// returns high resolution timer ticks, if available
num getCurrentTicks()
{
   #ifdef _WIN32
   LARGE_INTEGER val1;
   QueryPerformanceCounter(&val1);
   return val1.QuadPart;
   #else
   struct timeval tv;
   gettimeofday(&tv, NULL);
   return ((num)tv.tv_sec) * 1000 + ((num)tv.tv_usec) / 1000;
   #endif
}

num msecFromTicks(num nTicksDiff)
{
   #ifdef _WIN32
   LARGE_INTEGER val1;
   QueryPerformanceFrequency(&val1);
   num nMicroSecPeriod = val1.QuadPart;

   if (nMicroSecPeriod <= 0)
      return 1;

   num nMSecDiff = nTicksDiff * 1000 / nMicroSecPeriod;

   if (nMSecDiff <= 0)
      return 1;

   return nMSecDiff;
   #else
   return nTicksDiff;
   #endif
}

class StopWatch {
public:
   StopWatch   (num &rAddTicksToThis)
      : rOutputAddRef(rAddTicksToThis)
      { nClStart = getCurrentTicks(); }
  ~StopWatch   ( )
      { rOutputAddRef += (getCurrentTicks() - nClStart); }
num nClStart, &rOutputAddRef;
};

// copies a maximum of nMaxDst MINUS ONE chars,
// AND adds a zero terminator at pszDst (within nMaxDst range!).
// to use this like strncpy, always add +1 to nMaxDst.
// NOTE: if nMaxDst == 0, NO zero terminator is added.
void mystrcopy(char *pszDst, cchar *pszSrc, int nMaxDst) {
   if (nMaxDst < 2) {
      if (nMaxDst >= 1)
         pszDst[0] = '\0';
      return;
   }
   int nLen = strlen(pszSrc);
   if (nLen > nMaxDst-1)
      nLen = nMaxDst-1;
   memcpy(pszDst, pszSrc, nLen);
   pszDst[nLen] = '\0';
}
#define strcopy(dst,src) mystrcopy(dst,src,sizeof(dst)-10)

uchar *mymemdup(char *psz, int nlen)
{
   uchar *p = new uchar[nlen+2];
   if (!p) return p;
   memcpy(p, psz, nlen);
   p[nlen] = '\0'; // tolerance
   return p;
}

// remove blanks from right side of a string
void myrtrim(char *pszBuf) {
   int nlen = strlen(pszBuf);
   while (nlen > 0 && pszBuf[nlen-1] == ' ') {
      pszBuf[nlen-1] = '\0';
      nlen--;
   }
}

void skipUntil(char **pp, cchar *pdelim) {
   char *p = *pp;
   while (*p && !strchr(pdelim, *p))
      p++;
   *pp = p;
}

void skipOver(char **pp, cchar *pdelim) {
   char *p = *pp;
   while (*p && strchr(pdelim, *p))
      p++;
   *pp = p;
}

void skipToWhite(char **pp) { skipUntil(pp, " \t\r\n"); }
void skipWhite(char **pp)   { skipOver(pp, " \t\r\n");  }

int nextLine(char **pp) {
   char *p = *pp;
   while (*p!=0 && *p!='\r' && *p!='\n')
      p++;
   if (*p!='\r' && *p!='\n')
      return 1;
   while (*p!=0 && (*p=='\r' || *p=='\n'))
      *p++ = '\0';
   *pp = p;
   return 0;
}

bool alldigits(char *psz) {
   for (; *psz; psz++)
      if (!isdigit(*psz))
         return 0;
   return 1;
}

struct tm *mylocaltime(mytime_t *ptime)
{
   #ifdef SFK_W64
   return _localtime64(ptime);
   #else
   return localtime(ptime);
   #endif
}

struct tm *mygmtime(mytime_t *ptime)
{
   #ifdef SFK_W64
   return _gmtime64(ptime);
   #else
   return gmtime(ptime);
   #endif
}

#ifdef _WIN32
 #define getcwd _getcwd
 #define rmdir  _rmdir
#endif

uchar *newBitField(int iTotalEntries)
{
   int iByteSize = (iTotalEntries / 8) + 1;
   int iTolerance= 4;
   uchar *pField = new uchar[iByteSize+iTolerance];
   if (!pField)
      return 0;
   memset(pField, 0, iByteSize+iTolerance);
   int *pSize = (int *)pField;
   *pSize = iTotalEntries;
   return pField;
}
// can be freed by delete [] pField
// sfkSetBit, sfkGetBit see sfkbase.hpp

UTF8Codec::UTF8Codec(char *pOptInData, int iOptionalInputLength)
{
   memset(this, 0, sizeof(*this));

   if (pOptInData)
      init(pOptInData, iOptionalInputLength);
}

void UTF8Codec::init(char *p, int ilen)
{
   icur = 0;
   psrc = (uchar*)p;

   if (ilen < 0)
      imax = strlen(p);
   else
      imax = ilen;
}

int UTF8Codec::readRaw()
{
   if (icur >= imax)
      return 0;
   return psrc[icur++] & 0xFF;
}

int UTF8Codec::readSeq()
{
   int c = readRaw();
   return ((c & 0xC0) == 0x80) ? (c & 0x3F) : -1;
}

bool UTF8Codec::hasChar() { return (icur < imax) ? 1 : 0; }

bool UTF8Codec::eod() { return (icur >= imax) ? 1 : 0; }

int  UTF8Codec::validSeqLen(char *pszSrc, int iMaxSrc)
{
   UTF8Codec obj;
   return obj.validSeqLenInt(pszSrc, iMaxSrc);
}

int  UTF8Codec::validSeqLenInt(char *pszSrc, int iMaxSrc)
{
   if (iMaxSrc < 2)
      return 0;

   init(pszSrc, iMaxSrc);

   if (icur >= imax)
        return 0;

   int c = readRaw();

   int iold = icur;

   if ((c & 0x80) == 0)
      return 0;

   int c1,c2,c3,n;

   if ((c & 0xE0) == 0xC0) {
      if ((c1 = readSeq()) < 0)
         return 0;
      n = ((c & 0x1F) << 6) | c1;
      if (n >= 128)
         return 2;
      return 0;
   } else if ((c & 0xF0) == 0xE0) {
      if ((c1 = readSeq()) < 0)
         return 0;
      if ((c2 = readSeq()) < 0)
         return 0;
      n = ((c & 0x0F) << 12) | (c1 << 6) | c2;
      if (n >= 0x800 && (n < 0xD800 || n > 0xDFFF))
         return 3;
      return 0;
   } else if ((c & 0xF8) == 0xF0) {
      if ((c1 = readSeq()) < 0)
         return 0;
      if ((c2 = readSeq()) < 0)
         return 0;
      if ((c3 = readSeq()) < 0)
         return 0;
      return 4;
   }

   return 0;
}

uint UTF8Codec::nextChar() 
{
   if (icur >= imax)
        return 0;

   int c = readRaw();

   int iold = icur;

   if ((c & 0x80) == 0)
      return c;

   int c1,c2,c3,n;

   do {
      if ((c & 0xE0) == 0xC0) {
         if ((c1 = readSeq()) < 0)
            break;
         n = ((c & 0x1F) << 6) | c1;
         if (n >= 128)
            return n;
      } else if ((c & 0xF0) == 0xE0) {
         if ((c1 = readSeq()) < 0)
            break;
         if ((c2 = readSeq()) < 0)
            break;
         n = ((c & 0x0F) << 12) | (c1 << 6) | c2;
         if (n >= 0x800 && (n < 0xD800 || n > 0xDFFF))
            return n;
      } else if ((c & 0xF8) == 0xF0) {
         if ((c1 = readSeq()) < 0)
            break;
         if ((c2 = readSeq()) < 0)
            break;
         if ((c3 = readSeq()) < 0)
            break;
         return (((c & 0x0F) << 18) | (c1 << 12) | (c2 << 6) | c3) + 0x10000;
      }
   }
   while (0);

   // invalid sequence: return undecoded text
   icur = iold;

   return c;
}

int UTF8Codec::toutf8(char *pszOut, int iMaxOut, uint ch)
{
   uint c = ch;
   int len = 0;
   uint first = 0;
   
   if (c < 0x80) {
      first = 0;
      len = 1;
   }
   else if (c < 0x800) {
      first = 0xc0;
      len = 2;
   } else if (c < 0x10000) {
      first = 0xe0;
      len = 3;
   } else if (c < 0x200000) {
      first = 0xf0;
      len = 4;
   } else if (c < 0x4000000) {
      first = 0xf8;
      len = 5;
   } else {
      first = 0xfc;
      len = 6;
   }

   if (len >= iMaxOut)
      return 0;

   if (!pszOut)
      return 0;

   for (int i = len - 1; i > 0; i--)
   {
      pszOut[i] = (char)((c & 0x3f) | 0x80);
      c >>= 6;
   }
   pszOut[0] = c | first;
   
   return len;
}

int UTF8Codec::toutf8(char *pszOut, int iMaxOut, char *pszSrc, bool bSafe)
{
   if (iMaxOut < 2)
      return 0;

   *pszOut = '\0';

   char *pDstCur = pszOut;
   char *pDstMax = pszOut+iMaxOut;
   int   iSrcLen = strlen(pszSrc);

   uchar *pSrcCur = (uchar*)pszSrc;
   uchar *pSrcMax = pSrcCur + iSrcLen;

   UTF8Codec obj;

   while (pSrcCur<pSrcMax && *pSrcCur != 0)
   {
      if (bSafe) {
         // skip existing utf8 sequences in mixed text
         int l = obj.validSeqLenInt((char*)pSrcCur, pSrcMax-pSrcCur);
         if (l > 0) {
            if (pDstCur+l >= pDstMax)
               break;
            memcpy(pDstCur, pSrcCur, l);
            pDstCur += l;
            pSrcCur += l;
            continue;
         }
      }

      uint c = *pSrcCur;
      int  n = toutf8(pDstCur, pDstMax-pDstCur, c);
      if (n < 1)
         break;
      if (pDstCur >= pDstMax)
         break;
      pDstCur += n;
      pSrcCur++;
   }

   if (pDstCur >= pDstMax)
      pDstCur = pDstMax-1;

   *pDstCur = '\0';

   return pDstCur - pszOut;
}

// ====== SFK primitive function library end   ========

// =========== Profiling ==========

#ifdef SFK_PROFILING

// CRITICAL: static constructor sequence
// <-> StaticPerformancePoint
StaticPerformanceStats glblPerfStats;

StaticPerformanceStats::StaticPerformanceStats( )
{
   memset(this, 0, sizeof(*this));
}

void StaticPerformanceStats::addPoint(StaticPerformancePoint *pPoint)
{
   if (iClPoints >= MAX_PERF_POINTS) 
   {
      fprintf(stdout, "ERROR: too many profiling points\n");
      fprintf(stderr, "ERROR: too many profiling points\n");
      return;
   }

   apClPoints[iClPoints++] = pPoint;
}

int StaticPerformanceStats::numberOfPoints( )
   { return iClPoints; }

StaticPerformancePoint *StaticPerformanceStats::getPoint(int iIndex)
   { return apClPoints[iIndex]; }

// CRITICAL: static constructor sequence
// <-> StaticPerformanceStats
StaticPerformancePoint::StaticPerformancePoint(const char *pszID,
   const char *pszFile, int iTraceLine)
{
   pszClID = pszID;
   pszClFile = pszFile;
   iClTraceLine = iTraceLine;
   iClHits = 0;
   iClTotalTime = 0;
   iClSubTimes = 0;
   glblPerfStats.addPoint(this);
}

void StaticPerformancePoint::blockEntry( )
   { iClHits++; }

void StaticPerformancePoint::blockExit(int iElapsedTicks)
   { iClTotalTime += iElapsedTicks; }

DynamicPerformancePoint::DynamicPerformancePoint(StaticPerformancePoint *pStaticPoint)
{
   nClEntryTickCount = getPerfCnt();
   pClStaticPoint = pStaticPoint;

   // enter next level
   pClStaticParent = glblPerfStats.pClCurrentPoint;
   glblPerfStats.pClCurrentPoint = pClStaticPoint;

   pClStaticPoint->blockEntry();
}

DynamicPerformancePoint::~DynamicPerformancePoint( )
{
   num iElapsed = getPerfCnt() - nClEntryTickCount;

   pClStaticPoint->blockExit((int)iElapsed);

   // up one level
   if (pClStaticParent)
      pClStaticParent->iClSubTimes += iElapsed;
   glblPerfStats.pClCurrentPoint = pClStaticParent;
}

void logProfile( )
{
   num nTicksPerMSec = getPerfFreq() / 1000;
   if (!nTicksPerMSec)
       nTicksPerMSec = 1;

   printf("performance (%d points):\n", glblPerfStats.numberOfPoints());

   int iTotalMSec = 0;
   int iTotalPerc = 0;

   for (int ipass=0; ipass<2; ipass++)
   for (int i=0; i<glblPerfStats.numberOfPoints(); i++)
   {
      StaticPerformancePoint *p = glblPerfStats.getPoint(i);

      num nNetto = p->iClTotalTime - p->iClSubTimes;
      num nMSec  = nNetto / nTicksPerMSec;

      if (!ipass) {
         iTotalMSec += (int)nMSec;
      } else {
         int iPerc = nMSec * 100 / (iTotalMSec ? iTotalMSec : 1);
         iTotalPerc += iPerc;
         printf("% 10s : % 10I64d % 5d % 3d%% % 8I64d   %s:%d   (%d-%d)\n",
            p->pszClID,
            nNetto, (int)nMSec, iPerc,
            p->iClHits,
            p->pszClFile,
            p->iClTraceLine,
            (int)p->iClTotalTime, (int)p->iClSubTimes
            );
      }
   }

      printf("% 10s : % 10I64d % 5d % 3d%% % 8I64d   %s:%d   (%d-%d)\n",
         "total",
         (num)0, iTotalMSec, iTotalPerc,
         (num)0,
         "any",
         0,
         0, 0
         );
}

#else

void logProfile( )
{
}

#endif

// ====== SFK crash handler begin ========

struct SFKSysLog
{
   SFKSysLog ( );

   uint aSysLog[256];
   unsigned char iSysLog;
};

char *pszGlblSysLogFileName = 0;

SFKSysLog::SFKSysLog( ) { memset(this, 0, sizeof(*this)); }

struct SFKSysLog glblDefaultSysLog, glblDummySysLog;

struct SFKSysLog *pGlblSysLog = &glblDefaultSysLog;

#define MyModuleId 0 // not yet used

#ifndef MTK_TRACE
 #ifndef USE_SFK_BASE
  #undef __
  #define __                 \
     pGlblSysLog->aSysLog[pGlblSysLog->iSysLog++] = \
        (__LINE__     << 16) \
      | (MyModuleId & 0xFFFFU);
 #endif
#endif

static void showSysLog( )
{
   static char szBuf[2048];
   static char szWord[100];
   static const char *ahex = "0123456789ABCDEF";

   struct SFKSysLog *pCurLog = pGlblSysLog;

   // disable further writes to main log
   pGlblSysLog = &glblDummySysLog;

   int istart=0,icur=0,isteps=0;
   uint imix,iline=0,ithread=0;
   char *pdst=0,*pmax=szBuf+sizeof(szBuf)-100;

   istart = pCurLog->iSysLog;
   icur   = istart;
   if (icur > 0) icur--; else icur = 0xFFU;

   pdst = szBuf;

   strcat(pdst, "program version: SFK " SFK_VERSION SFK_FIXPACK "\n"
                "\n=== last steps: ===\n");
   pdst += strlen(pdst);

   for (; isteps < 100 && pdst < pmax; isteps++)
   {
      imix = pCurLog->aSysLog[icur];
      iline = (imix >> 16) & 0xFFFFU;
      ithread = (imix & 0xFFFFU);

      // 01.00000
      // 012345678
      pdst[0+1]  = ahex[(ithread >>  0) & 0x0F];
      pdst[0+0]  = ahex[(ithread >>  4) & 0x0F];
      pdst[0+2]  = '.';
      pdst[3+4]  = ahex[(iline /     1) % 10];
      pdst[3+3]  = ahex[(iline /    10) % 10];
      pdst[3+2]  = ahex[(iline /   100) % 10];
      pdst[3+1]  = ahex[(iline /  1000) % 10];
      pdst[3+0]  = ahex[(iline / 10000) % 10];
      pdst[8]    = ((isteps % 5)==4) ? '\n' : ' ';
      pdst += 9;

      if (icur > 0) icur--; else icur = 0xFFU;
   }

   *pdst = '\0';

   if (pszGlblSysLogFileName)
   {
      strcat(pdst, "=== see also: ");
      strcat(pdst, pszGlblSysLogFileName);
      strcat(pdst, " ===\n");
   
      // try to write a report file
      FILE *fout = fopen(pszGlblSysLogFileName,"w");
      if (fout)
      {
         fwrite(szBuf, 1, strlen(szBuf), fout);
         fclose(fout);
      }
   }
   
   #ifdef _WIN32

   MessageBox(0, szBuf, "fatal error", MB_OK);

   #else

   fprintf(stderr, "=== fatal error during execution ===\n%s\n", szBuf);

   #endif   

   exit(-1);
}

// - - - - -

static void crashTest( )
{
   char *p = 0;
   *p = 'a';
}

static void traceModeCrashHandler(int sig)
{
   static int crashRecursionCounter = 0;
   crashRecursionCounter++;
   if (crashRecursionCounter < 2)
   {
      crashRecursionCounter++;

      #ifdef WITH_TRACING
      // dump stack trace to error log
      mtkDumpStackTrace(0);
      mtkDumpLastSteps(0);
      #else
      showSysLog();
      #endif
   }
   printf("sfk exits due to segment violation.\n");
   exit(255);
}

#ifndef USE_SFK_BASE
void initCrashHandler(char *pszDumpFile)
{
   pszGlblSysLogFileName = pszDumpFile; // if any

   void (*pfhand)(int) = traceModeCrashHandler;
   sigset_t mask;
   sigemptyset(&mask);
#ifdef SIGSEGV
   signal (SIGSEGV, pfhand);
   sigaddset(&mask, SIGSEGV);
#else
   #error no_sigsegv_defined
#endif
#ifdef SIGFPE
   signal (SIGFPE, pfhand);
   sigaddset(&mask, SIGFPE);
#else
   #error no_sigfpe_defined
#endif
#ifdef SIGILL
   signal (SIGILL, pfhand);
   sigaddset(&mask, SIGILL);
#else
   #error no_sigill_defined
#endif
#ifdef SIGABRT
   signal (SIGABRT, pfhand);
   sigaddset(&mask, SIGABRT);
#else
   #error no_sigabrt_defined
#endif
   sigprocmask(SIG_UNBLOCK, &mask, 0);
}
#endif // USE_SFK_BASE

// ====== SFK trace mode crash handler end ========

static bool bGlblCurCmdSet = 0;
static char szGlblCurCmd[50];

class CommandScope {
public:
      CommandScope (cchar *pszcmd);
     ~CommandScope ( );
};

CommandScope::CommandScope(cchar *pszcmd) {
   strcopy(szGlblCurCmd, pszcmd);
   bGlblCurCmdSet = 1;
}

CommandScope::~CommandScope() {
   bGlblCurCmdSet = 0;
}

#ifdef VFILEBASE

const char *pGlblHttpUserAgent = 0;

static char szGlblUserAgent[100];

void setHTTPUserAgent(const char *psz)
   { pGlblHttpUserAgent = psz; }

char *getHTTPUserAgent() 
{

   if (pGlblHttpUserAgent)
      return (char*)pGlblHttpUserAgent;

   if (bGlblCurCmdSet)
      snprintf(szGlblUserAgent, sizeof(szGlblUserAgent)-10,
         "Swiss File Knife " SFK_VERSION " %s (" VER_STR_OS ")",
            szGlblCurCmd);
   else
      snprintf(szGlblUserAgent, sizeof(szGlblUserAgent)-10,
         "Swiss File Knife " SFK_VERSION " (" VER_STR_OS ")");

   // capialize os info
   char *pbra = strchr(szGlblUserAgent, '(');
   if (pbra) {
      pbra++;
      bool bfirst=1;
      while (*pbra) {
         char c = *pbra;
         if (isalpha(c) && bfirst)
            { bfirst=0; *pbra=toupper(c); }
         if (!isalpha(c)) bfirst=1;
         pbra++; 
      }
   }

   return szGlblUserAgent;
}

#endif // VFILEBASE

// fwrite on windows network drives may fail with blocks > 60 MB,
// therefore a single block write is limited to this size:
#define SFK_IO_BLOCK_SIZE 10000000 // about 10 MB

// optional callback tracing for hot spots
void (*pGlblTraceCallback)(char *pmsg) = 0;
static char szTraceBuf[1024+10];
void cbtrace(const char *pszFormat, ...)
{
   if (!pGlblTraceCallback) return;
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szTraceBuf, sizeof(szTraceBuf)-10, pszFormat, argList);
   szTraceBuf[sizeof(szTraceBuf)-10] = '\0';
   pGlblTraceCallback(szTraceBuf);
}

int getFileStat( // RC == 0 if exists anything
   char  *pszName,
   int   &rbIsDirectory,
   int   &rbCanRead,
   int   &rbCanWrite,
   num   &rlFileTime,
   num   &rlFileSize,
   num   *ppcatimes  = 0,  // optional: creation and access time
   void  *prawstat   = 0,  // optional: create copy of stat structure
   int    nrawstatmax= 0,  // size of above buffer
   uint   nmodeflags = 0   // bit 0: use alternative stat, if available 
   );

#define delstring(x) \
   if (x) {          \
      delete [] x;   \
      x = 0;         \
   }

// this also sets zero terminator at end of string,
// i.e. nmaxlen means including zero terminator.
void setattr(char *pdst, uchar uc, uint nlen, uint nmaxlen)
{
   if (nlen > nmaxlen) nlen = nmaxlen;
   if (nlen > 0) {
      memset(pdst, uc, nlen-1);
      pdst[nlen-1] = '\0';
   } else {
      pdst[0] = '\0';
   }
}

bool myisxdigit(char c) {
   if (c >= '0' && c <= '9') return 1;
   if (c >= 'a' && c <= 'f') return 1;
   if (c >= 'A' && c <= 'F') return 1;
   return 0;
}

bool iseol(char c) {
   if (c == '\r') return 1;
   if (c == '\n') return 1;
   return 0;
}

int getTwoDigitHex(char *psz)
{
   char szHex[10];

   if (!*psz) return -1;
   szHex[0] = tolower(*psz++);
   if (!myisxdigit(szHex[0])) return -1;

   if (!*psz) return -1;
   szHex[1] = tolower(*psz++);
   if (!myisxdigit(szHex[1])) return -1;

   szHex[2] = '\0';

   return (int)strtoul(szHex,0,0x10);
}

int getThreeDigitDec(char *psz)
{
   char szDec[10];

   if (!*psz) return -1;
   szDec[0] = tolower(*psz++);
   if (!isdigit(szDec[0])) return -1;

   if (!*psz) return -1;
   szDec[1] = tolower(*psz++);
   if (!isdigit(szDec[1])) return -1;

   if (!*psz) return -1;
   szDec[2] = tolower(*psz++);
   if (!isdigit(szDec[2])) return -1;

   szDec[3] = '\0';

   return (int)strtoul(szDec,0,10);
}

void doSleep(int nmsec) 
{
   #ifdef _WIN32
   Sleep(nmsec);
   #else
   // sleep(1);
   const timespec ts = { nmsec / 1000, nmsec % 1000 * 1000000 };
   nanosleep(&ts, NULL);  
   #endif
}

enum eWalkTreeFuncs {
   eFunc_MD5Write = 1,
   eFunc_JamFile  = 2,  // fixed value
   eFunc_CallBack = 3,  // fixed value
   eFunc_Detab       ,
   eFunc_Entab       ,
   eFunc_JamIndex    ,
   eFunc_SnapAdd     ,
   eFunc_FileStat    ,
   eFunc_FileTime    ,
   eFunc_Touch       ,
   eFunc_Find        ,
   eFunc_Mirror      ,  // deprecated
   eFunc_Run         ,
   eFunc_FormConv    ,
   eFunc_Inst        ,
   eFunc_RefColSrc   ,  // collect reflist sources
   eFunc_RefColDst   ,  // collect reflist targets
   eFunc_Deblank     ,
   #ifdef WITH_TCP
   eFunc_FTPList     ,
   eFunc_FTPNList    ,
   eFunc_FTPLocList  ,
   #endif // WITH_TCP
   eFunc_Hexdump     ,
   eFunc_Copy        ,
   eFunc_Cleanup     ,
   eFunc_AliasList   ,
   eFunc_ReplaceFix  ,
   eFunc_ReplaceVar  ,
   eFunc_MetaUpd     ,
   eFunc_MetaCheck   ,
   eFunc_Scantab     ,
   eFunc_Filter      ,
   eFunc_Delete      ,
   eFunc_DupScan     ,
   eFunc_Version     ,
   eFunc_Media       ,
};

enum eConvTargetFormats 
{
   eConvFormat_LF     = 1,
   eConvFormat_CRLF   = 2,
   eConvFormat_ShowLE = 4
};

int nGlblShellRC = 0;

struct CommandStats 
{
public:
   CommandStats   ( );
   void reset     ( );

   int debug     ;
   int memcheck  ;
   int verbose   ;  // 0,1,2
   bool delStaleFiles      ;
   bool skipOwnMetaDir     ;
   bool blockAutoComplete  ;
   int tabSize   ;
   int tabsDone  ;
   int tabFiles  ;
   int scanTabs  ;
   bool scanIndent;
   int indentFilt;

   int files     ; // visible plus hidden
   int filesChg  ; // no. of files changed
   int noFiles   ; // fnames that failed to stat etc.
   int dirs      ; // visible plus hidden
   int filesCloned ; // no. of files with attributes copied
   int dirsCloned  ; // no. of dirs with attributes copied
   bool hidden    ; // include hidden files and dirs
   int numHiddenFiles ; // for list stats
   int numHiddenDirs  ; // for list stats
   int numHiddenFilesSkipped ;
   int numHiddenDirsSkipped  ;
   int binariesSkipped ;
   int addedFilesSkipped ; // on -sincedif
   int shadowsWritten ;
   int shadowFallbacks ;
   int filesDeleted ;
   int filesDeletedWP;
   int dirsDeleted  ;
   int dirsDeletedWP;
   int filesScanned ;
   int dirsScanned  ;
   int filesNewerInDst ;
   int filesStale ; // deletion candidate
   int lines    ;
   num  maxFileTime;
   uint listForm;   // list -size etc.
   bool listTabs;   // split columns by tab char
   int  flatTime;   // show flat file times
   bool sim   ;      // just simulate command
   bool nohead;      // leave out some header, trailer info
   bool pure  ;      // extra info if -pure was specified
   bool dostat;      // copy: list just size statistics
   bool tailTail;    // running tail, not head
   int tailLines;   // head, tail
   bool tailFollow;  // head, tail
   char *tomask;     // output filename mask
   bool  tomaskfile; // -to mask is a single filename
   char *curcmd;     // current command
   bool rootrelname; // use filenames relative to root dir
   bool rootabsname; // force absolute names
   bool writeall;    // write all files, not only changed ones
   bool spat;        // enable slash patterns \t etc.
   bool wpat;        // support * and ?
   bool xpat;        // dummy within base
   bool usecase;     // case-sensitive search or not
   bool nocase;      // optional: forced nocase on binary search
   int blankRunFiles;  // no. of filenames w/blanks passing run
   int wrongpcRunFiles;// no. of filenames w/wrong path chars
   int badNameForm;    // set by execRunFile on bad filename formats
   bool nocheck;     // do not perform any checks
   bool noinfo;      // do not tell infos
   bool nochain;     // disable command chains
   bool useJustNames;// create a list of filenames
   bool countMatchLines; // count no. of matching lines
   bool yes;
   bool force;
   bool syncFiles;   // sync files instead of copy
   bool syncOlder;   // with sync, copy older over newer files
   bool nonames;     // do NOT print/pass :file records
   bool noind;       // no indentation
   char *runCmd;     // default: "" if not set.
   bool printcmd;    // run: print raw command
   int stoprc;      // run: stop on rc >= stoprc
   bool anymatches;  // find: found at least 1 matching line in 1 file
   bool showrc;      // print rc at program end
   bool deplist;     // deplist command selected
   int refsrccnt;   // reflist, deplist: no. of sources
   bool depsingle;   // process dependencies of a single file
   bool coldstnames; // reflist, deplist: execRefColSrc also collects DstNames
   bool refstripsrc; // strip source file contents from unused chars
   int listByTime;
   bool listByTimeAll;
   int listBySize;
   bool listBySizeAll;
   int listByName;
   bool listByNameAll;
   bool tellExecTime;
   int timeOutMSec;
   bool timeOutAutoSelect;
   num  selMinSize;  // consider only files >= so many bytes
   bool nowarn;      // disable all warning output
   bool noerr;       // disalbe all error output
   bool nonotes;     // disalbe all note output
   bool skipLinks;   // do not follow symbolic directory links
   bool traceFileFlags;
   bool fileMaskAndMatch;  // AND match of file mask parts
   bool dirMaskAndMatch;  // AND match of path mask parts
   bool incFNameInPath;    // include filename in path mask check
   bool verifyEarly;       // copy: verify directly after write
   bool verifyLate;        // copy: verify in a separate pass
   FILE *outfile;          // can be used by chain.print
   bool listTargets;       // force target name listing i/o src
   int idleMode;          // low prio processing, 0 (off) to 2
   int walkDirDelay;      // low prio file processing with delays
   int walkFileDelay;     // low prio file processing with delays
   int treeStopRC;        // stop tree processing on internal RC >= this
   bool stopTree(int nrc, bool *psilent=0); // tells if to stop on the supplied rc
   bool toldTreeStop;
   bool skipDirFileColl;   // optim: do not collect flist per dir.
   // cannot be set w/functions that strictly need those lists.
   bool rcFromError;       // change shell rc on skipped errors
   bool repDump;           // replace: create hexdump of hits
   bool repDumpHalve;      // replace: hexdump only source side
   bool useFirstHitOnly;   // skip to next file after first hit
   bool withdirs;          // include directories in command
   bool withrootdirs;      // if withdirs is used, include root dirs?
   bool justdirs;          // process only directories
   bool usesnap;           // interpret snapfile format and list titles
   bool usesnapfiltname;   // filter filenames as well
   int addsnapraw;        // snapto raw mode 1 or 2
   const char *addsnaplf;  // "\n" or "\r\n" depending on mode and OS
   uint addsnapmeta;      // bit 0:time 1:size 2:encoding
   int stathilitelevel;   // stat command: highlight dirs <= this
   bool travelzips;        // traverse zipfile contents
   bool incbin;            // include binary files in processing
   bool reldist;           // hexfind: tell also relative distances
   #ifdef VFILEBASE
   bool shallowzips;       // list only first level of zips
   bool precachezip;
   bool extdomref;         // include external domain refs
   bool xelike;            // set xe default behaviour and help text
   bool cacheall;          // no direct processing of files
   bool cachestat;         // cache statistics at program end
   bool travelHttp;        // decided per command, esp. list
   #endif // VFILEBASE
   bool subdirs;           // process subdirs
   bool utf8dec;           // utf-8  detect and decode (not yet impl.)
   bool wchardec;          // utf-16 detect and decode
   int utf16found;         // statistic for post-command info
   int utf16read;          // statistic for post-command info
   bool showdupdirs;       // linux: tell if dir link contents are skipped
   bool usecirclemap;      // linux: allow circle map, on by default
   num  sincetime;         // process only files modified since that time
   num  untiltime;         // process only files modified until that time
   bool usectime;          // use creation time instead of modification time
   bool useutc;            // all times in UTC/GMT instead of local
   char paramprefix[30];   // for user defined script input parameter names
   int wrapcol;            // if >0, auto-wrap lines in snapfile
   int wrapbincol;         // only on binary to text conversion
   bool rewrap;            // ignore linefeeds, rewrap all
   char listunit;          // stat output in 'b'ytes, 'k'bytes or default.
   bool flatdirstat;       // list no. of files per dir, not dir tree
   int flatfilecnt;        // global stats if flatdirstat is set
   int flatdircnt;         // "
   num  flatbytecnt;       // "
   bool statonlysum;       // sfk stat: quiet except summary
   int quiet;              // quiet mode
   bool ftpupdate;         // mput, mget: explicite -update
   bool ftpall;            // mput, mget: disable -update mode
   bool noclone;           // disable time stamp replication
   bool preserve;          // copy full attributes with sft
   int fast;               // command dependent optimization
   bool verify;            // command dependent optimization
   bool prog;              // with progress indicator
   bool noprog;            // no progress indicator
   bool notext;            // no result text
   bool test;              // filter: run in test mode
   bool copyLinks;         // copy symlinks     , windows only, untested
   bool copyNoBuf;         // copy w/o buffering, windows only, untested
   bool copyDecrypt;       // copy and decrypt  , windows only, untested
   bool intrun;            // sfk run -internal option
   bool textfiles;         // process only textfiles
   bool binaryfiles;       // process only binaryfiles
   bool packalnum;         // deblank: reduce filenames to alnum
   bool noipexpand;        // disallow ip number expansion
   int  stopcnt;           // stop command after n events
   char szownip[60];       // manually set own ip
   bool anyFileTooLarge;   // info after command execution
   bool crashtest;         // enforce crash to test handling
   bool justvernum;        // version command
   bool separator;         // print separator between outputs
   char szseparator[100];  // with xfind
   bool nolf;              // skip lf output on some commands
   bool multicast;         // udpclient
   int  dumptrail;         // hexdump: trailing chars at line end
   int  bytesperline;      // hexdump: when using hex/decsrc
   num  recordsize;        // for some commands
   bool usetmp;            // use temporary file
   bool knx;               // internal
   char *knxtext;          // internal
   bool ntp;               // internal
   bool echoonerr;         // echo whole command on error
   int  argc;              // copy of main() argument
   char **argv;            // copy of main() argument
   int  selfilenum;        // current processed file number
   int  selfileoff;        // process only files from this offset
   int  selfilerange;      // process only so many files
   bool stopfiletree;      // stop dir tree processing silently
   bool showip;            // show automatic ip expansion result
   bool justrc;            // no terminal output on filter
   num  minsize;           // select only files >= that size
   num  maxsize;           // select only files <= that size
   bool keeptime;          // keep input filetime on output file
   uint timemask;          // bit mask of what times to list
   bool tabform;           // use tab separators
   bool autoclose;         // ftpserv: on second client
   num  diskspace;         // required free disk space for writing
   bool xchars;            // treat \xnn as characters
   bool extract;           // replace, hexfind
   FILE *extractOutFile;   // ""
   int  xmaxlen;           // xpat default maxlen
   int  xmaxlit;           // xpat max literal size
   bool nodirtime;         // copy should not clone dir times
   bool tolines;           // with extract
   bool fixedbylist;       // force fixed record -bylist file
   bool showpre;           // replace
   bool showpost;          // replace
   bool showlist;          // replace
   bool rawfilename;       // with hexdump
   bool hexfind;           // running (x)hexfind
   bool xtext;             // running xtext
   bool xfind;             // running xfind
   char placeholder;       // for null bytes
   bool rawterm;           // dump output as is
   bool usefilehead;       // use mask given below
   char szfilehead[200];   // per result file header with "%s" internal
   bool maxdump;           // tcpdump -maxdump
   bool fullhelp;
   int  reprep;            // repeat replace option
   bool perf;              // performance statistics
   char szeol[10];         // crlf or lf
   bool toiso;             // utf8 to iso conversion
   char toisodef;          // default character '.'
   bool toutf;             // iso to utf8 conversion
   char *delim;            // list of delimiters for soft word wrapping
   bool astext;            // with xhexdump
   bool joinlines;         // with find
   int  rtrim;             // with find
   bool nostat;            // xhexfind: no no. of hits statistics
   char litattr;           // literal highlight attribute, or 0 for none
   char leattr;            // line end attribute, or 0 for none
   bool forcele;           // force line endings with addcr/remcr
   int  fastopt;           // fast option, function specific
   // csvtotab, tabtocsv
   char cinsep;
   char coutsep;
   char cquote;
   char coutsepesc;
   bool quotetext;
   bool quoteall;
   int  contextlines;      // xfind: 1=currentline 2=previous and post line
   int  contextchars;      // max chars of all context lines together
   int  indent;
};

struct CommandStats gs; // global settings accross whole chain
struct CommandStats cs; // command local statistics or settings

bool infoAllowed() {
   if (cs.quiet)  return 0;
   if (cs.noinfo) return 0;
   return 1;
}

int quietMode() { return cs.quiet; }
int fastMode()  { return cs.fast;  }

#ifdef VFILEBASE
bool csExtDomRef() { return cs.extdomref; }
void setxelike(bool byes) { gs.xelike = cs.xelike = byes; }
bool httpTravel()  { return cs.travelHttp; }
#endif // VFILEBASE

#if (defined(WITH_TCP) || defined(VFILENET) || defined(DV_TCP))

// IN: flags bit 0: include port
//           bit 1: triple digits
char *ipAsString(struct sockaddr_in *pAddr, char *pszBuffer, int iBufferSize, uint uiFlags=0)
{
   if (iBufferSize > 0)
      pszBuffer[0] = '\0'; // safety
   
   if (iBufferSize < 20) 
      return str("?");

   uint uiIP  = pAddr->sin_addr.s_addr;
   int  iPort = ntohs(pAddr->sin_port);

   char szPortInfo[50];
   if (uiFlags & 1)
      sprintf(szPortInfo, ":%d", iPort);
   else
      szPortInfo[0] = '\0';  
      
   snprintf(pszBuffer, iBufferSize-4,
      (uiFlags & 2) ? "%03u.%03u.%03u.%03u%s" : "%u.%u.%u.%u%s",
      (uiIP >>  0) & 0xFFU,
      (uiIP >>  8) & 0xFFU,
      (uiIP >> 16) & 0xFFU,
      (uiIP >> 24) & 0xFFU,
      szPortInfo
      );
         
   return pszBuffer;   
}

// IN: howmany==0 : list all ip's separated by psep,
//                  return amount in howmany
//     howmany==1 : list first ip only, ignore port
char *ownIPList(int &rhowmany, uint nPort, const char *psep)
{
   static char szIPListBuf[200];
   szIPListBuf[0] = '\0';

   // if option -ownip=x is given
   if (cs.szownip[0]) {
      strcopy(szIPListBuf, cs.szownip);
      return szIPListBuf;
   }

   bool bsingle = (rhowmany == 1) ? 1 : 0;

   prepareTCP();

   char szPortStr[50];
   szPortStr[0] = '\0';
   if (nPort > 0)
      sprintf(szPortStr, ":%u", nPort);

   char *psz = 0;

   #ifdef _WIN32

   struct in_addr addr;

   hostent *pinfo = gethostbyname(""); // fails under linux
   if (pinfo) {
      memcpy(&addr,pinfo->h_addr_list[0],sizeof(struct in_addr));
      char *pownip = inet_ntoa(addr);
      strcopy(szIPListBuf, pownip);
      if (bsingle)
         return szIPListBuf;
      strcat(szIPListBuf, szPortStr); // if any
      rhowmany = 1;
   }

   #else

   // linux: list all existing interface IPV4 addresses
   struct ifaddrs *pAdrObj = NULL;
   char szAdrBuf[200]; mclear(szAdrBuf);
   getifaddrs(&pAdrObj);
   const char *pprefix = "";
   int ndone = 0;
   while (pAdrObj != NULL) 
   {
     if (   pAdrObj->ifa_addr != 0
         && pAdrObj->ifa_addr->sa_family == AF_INET
         && pAdrObj->ifa_name != 0
         && strcmp(pAdrObj->ifa_name, "lo0")
        ) 
     {
       void *pIPData = &((struct sockaddr_in *)pAdrObj->ifa_addr)->sin_addr;
       const char *pszIP = inet_ntop(AF_INET, pIPData, szAdrBuf, sizeof(szAdrBuf)-10);
       if (strcmp(pszIP, "127.0.0.1")) {
          int nlen = strlen(pszIP);
          int nrem = (int)sizeof(szIPListBuf) - (int)strlen(szIPListBuf);
          if (nlen < nrem - 10) {
             strcat(szIPListBuf, pprefix);
             strcat(szIPListBuf, pszIP);
             if (bsingle)
               return szIPListBuf;
             strcat(szIPListBuf, szPortStr); // if any
             pprefix = psep;
             ndone++;
          }
       }
     }
     pAdrObj = pAdrObj->ifa_next;
   }
   rhowmany = ndone;

   #endif
   
   return szIPListBuf;
}

#endif // WITH_TCP or VFILENET

void setArcTravel(bool bYesNo, bool bPreCache) 
{
   mtklog(("setarctravel %d %d", bYesNo, bPreCache));
   gs.travelzips  = bYesNo;
   cs.travelzips  = bYesNo;
   #ifdef VFILEBASE
   cs.precachezip = bPreCache;
   #endif // VFILEBASE
}

bool getArcTravel( ) { return cs.travelzips; }

void setSubLoad(bool bYesNo) {
   mtklog(("setsubload %d", bYesNo));
   gs.subdirs = bYesNo;
   cs.subdirs = bYesNo;
}

void setHiddenLoad(bool bYesNo) {
   mtklog(("sethidload %d", bYesNo));
   gs.hidden = bYesNo;
   cs.hidden = bYesNo;
}

void setBinaryLoad(bool bYesNo) {
   mtklog(("setbinload %d", bYesNo));
   gs.incbin = bYesNo;
   cs.incbin = bYesNo;
}

void setUTFLoad(bool bYesNo) {
   mtklog(("setutfload %d", bYesNo));
   gs.wchardec = bYesNo;
   cs.wchardec = bYesNo;
}

int getWrapLoad(bool &rrewrap) {
   rrewrap = cs.rewrap;
   return cs.wrapcol; 
}
void setWrapLoad(int n, bool brewrap) { 
   cs.wrapcol = n;
   gs.wrapcol = n;
   cs.wrapbincol = (n >= 80) ? ((n * 90) / 100 - 10) : 80;
   gs.wrapbincol = cs.wrapbincol;
   cs.rewrap = brewrap;
   gs.rewrap = brewrap;
}
void addLinuxSyntax() {
   glblMixedSyntax = 1;
}
void setLinuxSyntax() {
   glblNotChar = ':';
   glblRunChar = '#';
}

// tells if cur matches mask, including variations:
// if mask="-sep" then "-sep" and "-ssep" is allowed.
bool isxopt(char *pszcur, cchar *pszmask)
{
   char szBuf[100];
   if (pszmask[0] != '-') return 0;
   if (strlen(pszmask) > sizeof(szBuf)-10) return 0;

   // check for indirect hit: "-seps".
   // if so, auto-activate slash patterns for this command.
   sprintf(szBuf, "%ss", pszmask);
   if (!strncmp(pszcur, szBuf, strlen(szBuf))) {
      cs.spat = 1;
      return 1;
   }

   // check for direct hit: "-sep"
   if (!strncmp(pszcur, pszmask, strlen(pszmask))) return 1;

   // check for indirect hit: "-ssep"
   cchar *pszbase = pszmask+1;

   // if so, auto-activate slash patterns for this command.
   sprintf(szBuf, "-s%s", pszbase);
   if (!strncmp(pszcur, szBuf, strlen(szBuf))) {
      cs.spat = 1;
      return 1; 
   }

   // check for "-uform" to activate -upat syntax.
   sprintf(szBuf, "-u%s", pszbase);
   if (!strncmp(pszcur, szBuf, strlen(szBuf))) {
      setLinuxSyntax();
      return 1; 
   }

   return 0;
}

// tells if cur matches mask, without variations.
bool isopt(char *pszcur, char *pszmask) {
   if (!strncmp(pszcur, pszmask, strlen(pszmask))) return 1;
   return 0;
}

CommandStats::CommandStats() { reset(); }

void CommandStats::reset()
{ 
   memset(this, 0, sizeof(*this)); 
   wpat        =  1;
   runCmd      = str("");
   treeStopRC  = 19; // NOT 9
   subdirs     =  1;
   utf8dec     =  0;
   wchardec    =  0; // experimental, NOT yet default
   usecirclemap=  1;
   wrapbincol  = 80; // default
   addsnaplf   = "\n";
   withrootdirs=  1;
   #ifdef _WIN32
   strcpy(szeol, "\r\n");
   #else
   strcpy(szeol, "\n");
   #endif
   toisodef    = '.';
}

bool CommandStats::stopTree(int nrc, bool *psilent) 
{
   int lRC = 0;
   int nShellRC = 0;
   if (cs.stopfiletree) {
      if (psilent)
         *psilent = 1;
      return 1;
   }
   if (nrc >= treeStopRC) {
      if (!toldTreeStop) {
         toldTreeStop = 1;
         #ifndef USE_SFK_BASE
         int pinf(const char *pszFormat, ...);
         pinf("directory tree processing stopped by error.\n");
         #endif // USE_SFK_BASE
      }
      lRC = 1;
      // on stop, always map fatal rc to shell rc
      if (nrc >= 9) nShellRC = 9;   // error occurred, processing stopped.
      else          nShellRC = nrc; // should not happen
   } else {
      // map masked rc to shell rc
      if (cs.rcFromError) {
         if (nrc >= 7) nShellRC = 7;   // error occurred, processing continued.
         else          nShellRC = nrc; // any other code below 7
      }
   }
   // build maximum shell rc, if any
   if (nShellRC > nGlblShellRC)
      nGlblShellRC = nShellRC;
   // continue or stop tree processing
   return lRC ? 1 : 0;
}

struct CommandPermamentStorage
{
public:
   CommandPermamentStorage ( );

   num  tailnsize;   // current file size of tail
   num  tailnpos;    // current read position of tail
   bool keeptmp;     // do not autodelete tmp files
   bool showtmp;     // verbosely list names of created tmpfiles
}
   cperm;

CommandPermamentStorage::CommandPermamentStorage() { memset(this, 0, sizeof(*this)); }

#if (defined(WITH_TCP) || defined(VFILENET) || defined(DV_TCP))
// a hostbyname with automatic extension of "22" to "192.168.1.22"
struct hostent *sfkhostbyname(const char *pstr, bool bsilent)
{
   char szExpBuf[100];

   char *psz = (char*)pstr;

   bool bdotfirst = 0;
   if (*psz == '.')
      { bdotfirst = 1; psz++; }
   char *ppart = psz;

   bool balldigit = 1;
   for (; *psz; psz++)
      if (!isdigit(*psz))
         { balldigit = 0; break; }
 
   if (!cs.noipexpand && balldigit)
   {
      // auto expand "22" or ".22" to "192.168.1.22"
      mclear(szExpBuf);
      int   nnum  = 0; // number of own ip's
      char *plist = ownIPList(nnum, 0, "\t");
      // copy first 3 segments of own ip, if any
      char *pseg  = strchr(plist, '.');
      if (pseg) pseg = strchr(pseg+1, '.');
      if (pseg) pseg = strchr(pseg+1, '.');
      if (pseg)
      {
         int nlen = (pseg - plist) + 1;
         memcpy(szExpBuf, plist, nlen);
         strcpy(szExpBuf+nlen, ppart);
         if (cs.showip)
            pinf("[nopre] [using %s]\n", szExpBuf);
         pstr = szExpBuf;
      }
   }

   return gethostbyname(pstr);
}

// simple ping, requires admin rights
#ifdef _WIN32

#define ICMP_ECHO_REPLY    0
#define ICMP_DEST_UNREACH  3
#define ICMP_ECHO_REQUEST  8
#define ICMP_TTL_EXPIRE    11

#ifndef ICMP_MINLEN
 #define ICMP_MINLEN 8
#endif
#ifndef ICMP_ECHOREPLY
 #define ICMP_ECHOREPLY 0
#endif
#ifndef ICMP_ECHO
 #define ICMP_ECHO 8
#endif

#ifdef _MSC_VER
 #pragma pack(1)
#endif

struct icmp {
    BYTE icmp_type;          // ICMP packet type
    BYTE icmp_code;          // Type sub code
    USHORT icmp_cksum;
    USHORT icmp_id;
    USHORT icmp_seq;
    ULONG timestamp;    // not part of ICMP, but we need it
};

struct ip { // IPHeader {
    BYTE h_len:4;           // Length of the header in dwords
    BYTE version:4;         // Version of IP
    BYTE tos;               // Type of service
    USHORT total_len;       // Length of the packet in dwords
    USHORT ident;           // unique identifier
    USHORT flags;           // Flags
    BYTE ttl;               // Time to live
    BYTE proto;             // Protocol number (TCP, UDP etc)
    USHORT checksum;        // IP checksum
    ULONG source_ip;
    ULONG dest_ip;
};

#else

 #include <sys/param.h>
 #include <sys/file.h>
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/ip_icmp.h>

// some linux/mac sys\param.h define that:
#ifdef isset
 #undef isset
#endif

#endif

#define	DEFDATALEN	(64-ICMP_MINLEN)	/* default data length */
#define	MAXIPLEN	60
#define	MAXICMPLEN	76
#define	MAXPACKET	(65536 - 60 - ICMP_MINLEN)/* max packet size */

ushort in_cksum(ushort *addr, unsigned len)
{
   ushort answer = 0;
   uint sum = 0;
   while (len > 1)  {
      sum += *addr++;
      len -= 2;
   }
   if (len == 1) {
      *(unsigned char *)&answer = *(unsigned char *)addr ;
      sum += answer;
   }
   sum = (sum >> 16) + (sum & 0xffff);
   sum += (sum >> 16);
   answer = ~sum;
   return answer;
}

// result: 
//   >= 0 : elapsed msec until reply
//     -1 : no reply
//     -2 : and below: any error
int sfkping(char *target, int iMaxWaitMSec)
{
   int s, i, cc, packlen, datalen = DEFDATALEN;
	struct hostent *hp;
	struct sockaddr_in to, from;
	struct ip *ip;
	u_char *packet, outpack[MAXPACKET];
	char hnamebuf[200];
	char  *hostname;
	struct icmp *icp;
	int ret, fromlen, hlen;
	fd_set rfds;
	struct timeval tv;
	int retval;
	int end_t;
   num tstart, tend;
	bool cont = true;
   bool bverbose = (cs.verbose >= 2) ? 1 : 0;

   prepareTCP();

   memset(outpack, 0, sizeof(outpack));

	to.sin_family = AF_INET;

	to.sin_addr.s_addr = inet_addr(target);

	if (to.sin_addr.s_addr != (u_int)-1)
		hostname = target;
	else
	{
		hp = gethostbyname(target);
		if (!hp)
         return -2+perr("ping: unknown host %s\n", target);

		to.sin_family = hp->h_addrtype;
		memcpy(&hp->h_addr, &to.sin_addr, hp->h_length);
		strncpy(hnamebuf, hp->h_name, sizeof(hnamebuf) - 1);
		hostname = hnamebuf;
	}

	packlen = datalen + MAXIPLEN + MAXICMPLEN;

	if ((packet = (u_char *)malloc((u_int)packlen)) == NULL)
      return -3+perr("ping: out of memory\n");

   memset(packet, 0, packlen);

	if ((s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
      return -4+perr("ping: missing admin rights\n");

	icp = (struct icmp *)outpack;
	icp->icmp_type = ICMP_ECHO;
	icp->icmp_code = 0;
	icp->icmp_cksum = 0;
	icp->icmp_seq = 123;	/* seq and id must be reflected */
	icp->icmp_id = getpid();

	cc = datalen + ICMP_MINLEN;
	icp->icmp_cksum = in_cksum((unsigned short *)icp,cc);

   tstart = getCurrentTime();

	i = sendto(s, (char *)outpack, cc, 0, (struct sockaddr*)&to, (socklen_t)sizeof(struct sockaddr_in));

	if (i < 0 || i != cc)
	{
		if (i < 0)
         perr("ping: sendto error\n");
	}
	
	FD_ZERO(&rfds);
	FD_SET(s, &rfds);

	tv.tv_sec  = iMaxWaitMSec/1000;
	tv.tv_usec = (iMaxWaitMSec < 1000) ? iMaxWaitMSec * 1000 : 0;

	while(cont)
	{
		retval = select(s+1, &rfds, NULL, NULL, &tv);

		if (retval == -1)
		{
			perror("select()");
			return -5;
		}
		else if (retval)
		{
			fromlen = sizeof(sockaddr_in);
			if ((ret = recvfrom(s, (char *)packet, packlen, 0,(struct sockaddr *)&from, (socklen_t*)&fromlen)) < 0)
            return -6+perr("ping: receive error\n");

			ip = (struct ip *)((char*)packet);

			hlen = sizeof( struct ip );

			if (ret < (hlen + ICMP_MINLEN))
            return -7+perr("ping: reply too short\n");

			icp = (struct icmp *)(packet + hlen);
			if (icp->icmp_type == ICMP_ECHOREPLY)
			{
            if (bverbose)
   				printf("ping: got an echo reply\n");

				if (icp->icmp_seq != 123)
				{
               if (bverbose)
   					printf("ping: received sequence #%u\n", icp->icmp_seq);
					continue;
				}
				if (icp->icmp_id != getpid())
				{
               if (bverbose)
   					printf("ping: received id %u\n", icp->icmp_id);
					continue;
				}
				cont = false;
			}
			else
			{
            if (bverbose)
   				printf("ping: received a non-echo reply\n");
				continue;
			}
	
			tend = getCurrentTime();
         end_t = (int)(tend-tstart);

         if (bverbose)
   			printf("ping: elapsed time = %u msec\n", end_t/1000);
			return end_t;
		}
		else
		{
         if (bverbose)
   			printf("ping: no reply within %d msec\n", iMaxWaitMSec);
			return -1;
		}
	}

	return 0;
}

#endif // WITH_TCP or VFILENET

void getUpto(int iMaxCopy, char *pszSrc, int iMaxSrc, char *pszBuf, int iMaxBuf)
{
   int i=0;
   for (i=0; (i<iMaxCopy) && (i<iMaxBuf-1); i++) 
   {
      if (iMaxSrc > 0) {
         pszBuf[i] = pszSrc[i];
         iMaxSrc--;
      } else {
         pszBuf[i] = ' ';
      }
   }
   pszBuf[i] = '\0';
}

int shrinkFormTextVar(char *psz, int &rLen, uchar **ppFlags)
{
   if (!cs.spat)
      return 0; // nothing to do

   bool bstrict = (cs.spat >= 2) ? 1 : 0;

   return shrinkFormTextBlock(psz, rLen, bstrict, cs.xchars, ppFlags);
}

// replace \\t and \\xnn by a single character,
// within a binary block that is not zero-terminated.
int shrinkFormTextBlock(char *psz, int &rLen, bool bstrict, bool xchars, uchar **ppFlags)
{
   char szBuf[20];

   int iCodePoints = 0;
   
   uchar uc = 0;
   bool bAnyX = 0;
   uchar *pFlags = 0;
   uchar *pDst = 0;

   char *pszMax = psz + rLen;

   for (int ipass=0; ipass<2; ipass++)
   {
      char *pszCur = psz;

      if (ipass)
      {
         if (!xchars && bAnyX && ppFlags) 
         {
            if (!(pFlags = newBitField(iCodePoints+4)))
               return 9+perr("out of memory");
            *ppFlags = pFlags;
         }

         pDst = (uchar*)psz;
      }

      iCodePoints = 0;

      while (pszCur < pszMax)
      {
         uc = *pszCur++;

         if (uc == '\\' && pszCur < pszMax)  // spat.1 shrinktext 2
         {
            switch (*pszCur++)
            {
               case '\\':  uc = '\\';  break;
               case 't' :  uc = '\t';  break;
               case 'q' :  uc = '"';   break;
               case 'n' :  uc = '\n';  break;
               case 'r' :  uc = '\r';  break;
               case ' ' :  uc = ' ';   break;
               case 'x' :
               {
                  if (pszCur+2 > pszMax) {
                     getUpto(4, pszCur-2, 4, szBuf, sizeof(szBuf)-4);
                     perr("incomplete hex slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                     return 9;
                  }
                  int n = getTwoDigitHex(pszCur);
                  if (n < 0) {
                     getUpto(4, pszCur-2, 4, szBuf, sizeof(szBuf)-4);
                     perr("wrong hex slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                     return 9;
                  }
                  pszCur += 2;
                  uc = (uchar)n;
                  if (pFlags)
                     sfkSetBit(pFlags, iCodePoints);
                  bAnyX = 1;
                  break;
               }
               case 'd' : // sfk 1723 added: "\d255"
               if (bstrict)
               {
                  if (pszCur+3 > pszMax) {
                     getUpto(5, pszCur-2, 5, szBuf, sizeof(szBuf)-4);
                     perr("incomplete decimal slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                     return 9;
                  }
                  int n = getThreeDigitDec(pszCur);
                  if (n < 0 || n > 255) {
                     getUpto(5, pszCur-2, 5, szBuf, sizeof(szBuf)-4);
                     perr("wrong decimal slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                     return 9;
                  }
                  pszCur += 3;
                  uc = (uchar)n;
                  if (pFlags)
                     sfkSetBit(pFlags, iCodePoints);
                  bAnyX = 1;
                  break;
               }
               default:
                  if (bstrict) {
                     getUpto(2, pszCur-1, 2, szBuf, sizeof(szBuf)-4);
                     perr("undefined slash pattern: %.2s   (use \\%.2s instead)\n", szBuf, szBuf);
                     return 9;
                  }
            }  // endswitch
         }  // endif

         if (ipass && pDst)
            *pDst++ = uc;

         iCodePoints++;
      }
   }

   if (pDst < (uchar*)pszMax)
      *pDst = '\0';

   rLen = (int)(pDst - (uchar*)psz);

   return 0;
}

int copyFromFormText(char *pSrc, int iMaxSrc, char *pDstIn, int iMaxDst, uint nflags=0)
{
   char szBuf[20];

   char *pszCur = pSrc;
   char *pszMax = pSrc+iMaxSrc;

   char *pDst   = pDstIn;
   char *pDstMax= pDstIn+iMaxDst;
   
   uchar uc;

   while (pszCur < pszMax && pDst+10 < pDstMax)
   {
      uc = *pszCur++;

      if (uc == '\\' && pszCur < pszMax)  // spat.2 copytext 2
      {
         // optionally escape phraser sequences
         char c = *pszCur;
         if ((nflags & 2) && (c==',' || c=='+' || c=='\t'))
            { }
         else
         switch (*pszCur++)
         {
            case '\\':  uc = '\\';  break;
            case 't' :  uc = '\t';  break;
            case 'q' :  uc = '"';   break;
            case 'n' :  uc = '\n';  break;
            case 'r' :  uc = '\r';  break;
            case ' ' :  uc = ' ';   break;
            case 'x' :
            {
               if (pszCur+2 > pszMax) {
                  getUpto(4, pszCur-2, 4, szBuf, sizeof(szBuf)-4);
                  perr("incomplete hex slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                  return -1;
               }
               int n = getTwoDigitHex(pszCur);
               if (n < 0) {
                  getUpto(4, pszCur-2, 4, szBuf, sizeof(szBuf)-4);
                  perr("wrong hex slash pattern: %.4s   (use \\%.4s instead?)\n", szBuf, szBuf);
                  return -1;
               }
               pszCur += 2;
               uc = (uchar)n;
               break;
            }
            case 'd' :
            {
               if (pszCur+3 > pszMax) {
                  getUpto(5, pszCur-2, 5, szBuf, sizeof(szBuf)-4);
                  perr("incomplete dec slash pattern: %.5s   (use \\%.5s instead?)\n", szBuf, szBuf);
                  return -1;
               }
               int n = getThreeDigitDec(pszCur);
               if (n < 0) {
                  getUpto(5, pszCur-2, 5, szBuf, sizeof(szBuf)-4);
                  perr("wrong dec slash pattern: %.5s   (use \\%.5s instead?)\n", szBuf, szBuf);
                  return -1;
               }
               pszCur += 3;
               uc = (uchar)n;
               break;
            }
            default:
               getUpto(2, pszCur-1, 2, szBuf, sizeof(szBuf)-4);
               perr("undefined slash pattern: %.2s   (use \\\\%.2s instead?)\n", szBuf, szBuf);
               return -1;
         }
      }

      *pDst++ = uc;
   }

   *pDst = '\0';

   return (int)(pDst-pDstIn);
}

int nGlblFunc         = 0;
bool bGlblSyntaxTest  = 0;
bool bGlblCollectHelp = 0;
int  iGlblCollectCmd  = 0;
int nGlblActiveFileAgeLimit = 30; // days
int nGlblErrors   = 0; // perr counter
int nGlblWarnings = 0;
int nGlblTraceSel = 0; // b0:dirs b1:files
bool bGlblMD5RelNames = 0;
bool bGlblHaveInteractiveConsole = 0;
bool bGlblStartedInEmptyConsole = 0;
bool bGlblEnableOPrintf = 1; // allow codepage conversion w/in oprintf
bool bGlblForceCConv = 0;    // enfore codepage conversion w/in oprintf
bool bGlblAllowGeneralPure = 0; // command dependent
bool bGlblPauseOnError = 0;  // pause after every error
bool bGlblPauseOnEnd   = 0;  // pause before program end
bool bGlblOldMD5 = 0;
char *pszGlblOutFile = 0;  // if set, some funcs will take care not to read this file
char *pszGlblSaveTo  = 0;  // if set, some funcs will save output files to this path
FILE *fGlblOut     = 0; // general use

#ifdef VFILEBASE
   #include "sfkext.hpp"
#endif // VFILEBASE

unsigned char abBuf[MAX_ABBUF_SIZE+100];
char szLineBuf[MAX_LINE_LEN+10];
char szLineBuf2[MAX_LINE_LEN+10];
char szLineBuf3[MAX_LINE_LEN+10];
char szAttrBuf[MAX_LINE_LEN+10];
char szAttrBuf2[MAX_LINE_LEN+10];
char szAttrBuf3[MAX_LINE_LEN+10];
char szRefNameBuf[MAX_LINE_LEN+10];
char szRefNameBuf2[MAX_LINE_LEN+10];
char szOutNameRecent[MAX_LINE_LEN+10];
bool bGlblToldAboutRecent = 0;
char szOutNameBuf[MAX_LINE_LEN+10];
char szRunCmdBuf[MAX_LINE_LEN+10];
#define MAX_MATCH_BUF 500
char szMatchBuf[MAX_MATCH_BUF+10];  // strmatch word buffer
bool szMatchEsc[MAX_MATCH_BUF+10];  // strmatch escape flags
char *pszGlblPreRoot = 0;
char szGlblMixRoot[MAX_LINE_LEN+10];
char *pGlblDumpBuf = 0;
int   iGlblDumpBufSize = 0;
bool bErrBufSet = 0;
cchar *pszGlblJamPrefix = ":file:";
char *pszGlblJamRoot = 0;
bool  bGlblJamPure = 0;
#define MAX_JAM_TARGETS 1000
char *apJamTargets[MAX_JAM_TARGETS];
num   alJamTargetTime[MAX_JAM_TARGETS];
num   nJamSnapTime = -1;
int  nJamTargets  = 0;
char *pszGlblRepSrc = 0;
char *pszGlblRepDst = 0;
cchar *pszGlblBlank =
   "                                                "
   "                                                ";
num  nGlblStartTime = 0;
num  nGlblListMinSize = 0; // in bytes
int nGlblListMode = 0;    // 1==stat 2==list
int  nGlblListDigits = 12;
bool bGlblEscape = 0;
char *pszGlblDstRoot = 0;
num nGlblBytes = 0;
char *pszGlblDirTimes = 0;
cchar *pszGlblTurn = "\\|/-";
int  nGlblTurnCnt = 0;
bool  bGlblQuoted     = 0; // list: add quotes around filenames
bool  bGlblNoRootDirFiles = 0; // list -dir +dirmask
uint nGlblConvTarget = 0; // see eConvTargetFormats
uint aGlblConvStat[10];
#ifdef WITH_FN_INST
bool  bGlblInstRevoke = 0;
bool  bGlblInstRedo   = 0;
bool  bGlblInstEol    = 0;
cchar *pszGlblInstInc  = "";
cchar *pszGlblInstMac  = "";
static bool bGlblTouchOnRevoke = 1;
#endif
bool  bGlblRefRelCmp    = 1;
bool  bGlblRefBaseCmp   = 0;
bool  bGlblRefWideInfo  = 0;
int  nGlblRefMaxSrc    = 10;
bool  bGlblRefLimitReached = 0;
bool  bGlblStdInAny     = 0;  // all cmd except run: take list from stdin
bool  bGlblStdInFiles   = 0;  // run only: take filename list from stdin
bool  bGlblStdInDirs    = 0;  // run only: take directory list from stdin
int  nGlblMD5Skip      = 0;
bool  bGlblMirrorByDate = 0;  // inofficial, might be removed.
int nGlblTCPMaxSizeMB   = 500; // MB
SOCKET hGlblTCPOutSocket = 0;
bool bGlblFTPReadWrite   = 0;
bool bGlblFTPSetAttribs  = 0;
bool bGlblFTPListFlatTS  = 0; // server: send flat timestamp on list
bool bGlblFTPListAsHTML  = 0;
bool bGlblFTPListTextBin = 0;
bool bGlblBinGrep           = 0;
bool bGlblBinGrepAutoDetect = 1;
uchar nGlblBinTextBinRange  = 0xFF;
int nGlblDarkColBase    = 0;
int nGlblBrightColBase  = 1;
bool bGlblSysErrDetail   = 0;

// highlight=1 red=2 green=4 blue=8
#ifdef _WIN32
bool bGlblUseColor       =  1;
bool bGlblUseHelpColor   =  1;
// windows default safety colors for ANY background.
// will be changed automatically if black background is detected.
// help part
int nGlblHeadColor      =  5; // green
int nGlblExampColor     = 11; // purple
// functional part
int nGlblFileColor      = 12; // cyan
int nGlblLinkColor      = 12; // cyan
int nGlblHitColor       =  5; // green
int nGlblRepColor       = 11; // purple
int nGlblErrColor       =  3; // red
int nGlblWarnColor      = 11; // purple
int nGlblPreColor       = 12; // cyan
int nGlblTimeColor      = 12; // cyan
int nGlblTraceIncColor  = 12; // cyan
int nGlblTraceExcColor  = 11; // purple
#else
bool bGlblUseColor       =  0;
bool bGlblUseHelpColor   =  0;
// unix default colors for white background
int nGlblDefColor       =  0; // default
int nGlblHeadColor      =  4; // green
int nGlblExampColor     = 10; // purple
// functional part
int nGlblFileColor      = 10; // purple
int nGlblLinkColor      = 12; // cyan
int nGlblHitColor       =  4; // green
int nGlblRepColor       = 12; // blue
int nGlblErrColor       =  2; // red
int nGlblWarnColor      =  2; // red
int nGlblPreColor       = 12; // blue
int nGlblTimeColor      = 12; // blue
int nGlblTraceIncColor  = 12; // cyan
int nGlblTraceExcColor  = 11; // purple
#endif

bool bGlblGrepLineNum    = 0;
bool bGlblHtml           = 0;  // for html help creation
bool bGlblShortSyntax    = 0;
bool bGlblAnyUsed        = 0;
bool bGlblAllowAllPlusPosFile = 0;
char *pszGlblSinceDir    = 0;
bool bGlblSinceDirIncRef = 0;
int nGlblMissingRefDirs  = 0;
int nGlblMatchingRefDirs = 0;
int nGlblSinceMode       = 0; // b0:add b1:dif
bool bGlblIgnoreTime     = 0;
bool bGlblIgnore3600     = 0;
bool bGlblHexDumpWide    = 0;
int nGlblHexDumpForm     = 0;
num  nGlblHexDumpOff     = 0;
num  nGlblHexDumpLen     = 0;
char  *pszGlblCopySrc    = 0;
char  *pszGlblCopyDst    = 0;
uchar *pGlblWorkBuf      = 0;
num    nGlblWorkBufSize  = 0;
int   nGlblCopyStyle     = 2; // how filenames are dumped onto terminal
int   nGlblCopyShadows   = 0;
num   nGlblShadowSizeLimit = 0;
bool  bGlblUseCopyCache  = 0;
bool  bGlblShowSyncDiff  = 0;
bool  bGlblHavePlusDirMasks = 0; // deprecated
num   nGlblMemLimit      = 300 * 1048576;
bool  bGlblMemLimitWasSet = 0;
bool  bGlblNoMemCheck     = 0;
char  *pGlblCurrentScript = 0; // while within a script command

#ifdef _WIN32
cchar *pszGlblAliasBatchHead = "@rem sfk alias batch";
#else
cchar *pszGlblAliasBatchHead = "# sfk alias batch";
#endif

int nGlblFzMisArcFiles = 0;
int nGlblFzConArcFiles = 0;
int nGlblFzConArchives = 0;
int nGlblFzMisCopFiles = 0;
int nGlblFzConCopFiles = 0;

void cleanupTmpCmdData();
void shutdownAllGlobalData();

// circular link processing blocker.
// used only in a vertical walkFiles() processing run,
// e.g. parameters -dir dir1 -file .cpp -dir dir1 -file .hpp
// will run walkFiles() twice, each time resetting this:
KeyMap glblCircleMap;

#ifndef USE_SFK_BASE
void resetStats()
{__
   void resetFileCounter();
   void resetFileSet();

   // reset command statistics:
   // copy global settings into local command settings
   memcpy(&cs, &gs, sizeof(cs));
   resetFileCounter();

   // reset command settings
   cs.quiet    = 0;
   pszGlblSaveTo = 0;
   if (pszGlblSinceDir) { delete [] pszGlblSinceDir; pszGlblSinceDir=0; }

   // reset selected dirs and files
   resetFileSet();

   // reset all temporary command data
   cleanupTmpCmdData();

   // reset circular dependency blocker
   glblCircleMap.reset();
}
#endif // USE_SFK_BASE

class FileList;
class StringPipe;
class Coi;

int decodeUrl       (char *pszInOut);
int execDetab       (char *pszFile, char *pszOutFile);
int execEntab       (char *pszFile, char *pszOutFile);
int execScantab     (char *pszFile);
int getFileMD5      (char *pszFile, SFKMD5 &md5, bool bSilent=0, bool bInfoCycle=0);
int getFileMD5      (Coi  *pcoi, SFKMD5 &md5, bool bSilent=0, bool bInfoCycle=0);
int execFormConv    (char *pszFile, char *pszOutFile);
int execHexdump     (Coi  *pcoi, uchar *pBuf, uint nBufSize, int iHighOff=-1, int iHighLen=0, FILE *fout=0, num nListOffset=0);
int walkFiles       (Coi  *pcoi, int lLevel, int &nGlobFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &ntime1, num &ntime2);
int execSingleFile  (Coi  *pcoi, int lLevel, int &lGlobFiles, int nDirFileCnt, int &lDirs, num &lBytes, num &ntime1, num &ntime2);
int execSingleDir   (Coi  *pcoi, int lLevel, int &lGlobFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &ntime1, num &ntime2);
int execFileCopy    (Coi  *pcoi);
int execDirCopy     (char *pszSrc, FileList &oDirFiles);
int execFileCleanup (char *pszFile);
int execDirCleanup  (char *pszSrc, FileList &oDirFiles);
int timeFromString  (char *psz, num &nRetTime);
bool tryGetRelTime  (cchar *psz, num &nRetTime);
int diffDump        (uchar *p1, uchar *p2, num nlen, num nListOffset, int iHiOff, int iHiLen);
int execReplaceFix  (Coi *pcoi);
int execReplaceVar  (Coi *pcoi);
int execReplaceNew  (Coi *pcoi, char *pszOptOutFile, bool bSameLengthAndFile);
size_t myfread       (uchar *pBuf, size_t nBytes, FILE *fin , num nMaxInfo=0, num nCur=0, SFKMD5 *pmd5=0);
size_t myfwrite      (uchar *pBuf, size_t nBytes, FILE *fout, num nMaxInfo=0, num nCur=0, SFKMD5 *pmd5=0);
char *rootRelativeName(char *pszFileName, char *pszOptRoot);
char *relativeFilename(char *pszPath);
void myfgets_init    ( );
int myfgets         (char *pszOutBuf, int nOutBufLen, FILE *fin, bool *rpBinary=0, char *pAttrBuf=0);
int execFilter      (Coi *pcoi, FILE *fin = 0, StringPipe *pin = 0, int nMaxLines = -1, char *pszOutFile = 0);
int execDelFile     (char *pszName);
int execDelDir      (char *pszName, int lLevel, int &lGlobFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2);
int execVersion     (Coi *pcoi);
int execMedia       (char *pszSrc, char *pszOutFile);
int execCsvConv     (bool bToCsv, Coi *pcoi, FILE *fin = 0, StringPipe *pin = 0, int nMaxLines = -1, char *pszOutFile = 0);

// set/provide a minimum info about the current I/O operation.
// if called multithreaded, this should not crash but in the
// worst case return only incomplete info strings.

class IOStatus {
public:
      IOStatus  ( );

      void   setInfo (cchar *pinfo);
      char  *getInfo (num &nagemsec, num &nbytes, num &nmaxbytes);

      num   countBytes  (num nbytes);
      void  setMaxBytes (num nbytes);
      void  resetBytes  ( );

private:
      char  szClStatus[200+20];
      num   nClSince;
      num   nClBytes;
      num   nClMaxBytes;
};
static IOStatus iostat;

IOStatus::IOStatus() {
   memset(this, 0, sizeof(*this));
}

void IOStatus::setInfo(cchar *pinfo) {
   memset(szClStatus, 0, sizeof(szClStatus));
   if (!pinfo) {
      nClSince = 0;
      return;
   }
   strncpy(szClStatus, pinfo, sizeof(szClStatus)-20);
   nClSince = getCurrentTime();
}

char *IOStatus::getInfo(num &nagemsec, num &nbytes, num &nmaxbytes) {
   if (!szClStatus[0]) return 0;
   if (nClSince > 0) {
      num nage  = getCurrentTime() - nClSince;
      nagemsec  = nage;
      nbytes    = nClBytes;
      nmaxbytes = nClMaxBytes;
   } else {
      nagemsec  = 0;
      nbytes    = 0;
      nmaxbytes = 0;
   }
   return szClStatus;
}

num IOStatus::countBytes(num nbytes) {
   nClBytes += nbytes;
   return nClBytes;
}

void IOStatus::setMaxBytes(num nbytes) {
   nClMaxBytes = nbytes;
}

void IOStatus::resetBytes() {
   nClBytes = 0; 
   nClMaxBytes = 0;
}

IOStatusPhase::IOStatusPhase(cchar *pinfo) {
   iostat.setInfo(pinfo);
}

IOStatusPhase::~IOStatusPhase( ) {
   // iostat.setInfo(0);
}

char *getIOStatus(num &nage, num &nbytes, num &nmaxbytes) {
   return iostat.getInfo(nage, nbytes, nmaxbytes); 
}
num   countIOBytes(num nbytes)   { return iostat.countBytes(nbytes); }
void  setIOStatMaxBytes(num n)   { iostat.setMaxBytes(n); }
void  resetIOBytes( )   { iostat.resetBytes(); }
void  resetIOStatus( )  { iostat.setInfo(0); iostat.resetBytes(); }

// extended skip functions, ignore line ends,
// handle quotes and escaped quotes:

void nextToken(char **pp, char &rclast, bool &rbnewline) 
{
   char *p = *pp;
   while (*p && ((*p == ' ') || (*p == '\t') || (*p == '\r') || (*p == '\n') || (*p == '#')) ) {
      // skip # only if it's first char of line
      if (*p == '#' && rclast != '\n')
         break;
      rclast = *p++;
      if (rclast == '\n')
         rbnewline = 1;
   }
   *pp = p;
}

void skipPastToken(char **pp, char &rclast)
{
   char *p = *pp;
   bool besc = 0;
   char cold = 0;
   while (*p) 
   {
      if (*p == '\"' && cold != '\\')
         besc ^= 0x1;
      if (!besc && ((*p == ' ') || (*p == '\t') || (*p == '\r') || (*p == '\n')) )
         break;
      rclast = cold = *p++;
   }
   *pp = p;
}

// strip quotes, transform inner quotes \" to normal quotes "
// uses: szLineBuf, szLineBuf2
int postProcessToken(char **pptok, StringTable &oDynaStrings, int argc, char *argv[], int iParmOffs, int nParm)
{
   char *ptok = *pptok;
   // strip outer quotes, if any
   if (*ptok == '\"') {
      int nlen = strlen(ptok);
      if (ptok[nlen-1] == '\"') {
         memmove(ptok, ptok+1, nlen-1);
         nlen -= 2;         // count both quotes
         ptok[nlen] = '\0'; // readjust terminator
      }
      else return 9; // missing end quote
   }
   // transform inner quotes, if any
   char *psz = ptok;
   while (*psz) {
      if (!strncmp(psz, "\\\"", 2)) {
         int nlen = strlen(psz);
         memmove(psz, psz+1, nlen-1);   // cut backslash
         psz[nlen-1] = '\0'; // new terminator
      }
      if (*psz) psz++;
   }

   // substitute parameters. accept both $1,$2,$3 and %1,%2,%3.
   strcopy(szLineBuf, ptok);
   char szName1[50],szName2[30];
   mclear(szName1);
   mclear(szName2);
   bool bDoneAny = 0;

   // accept "$" and "%" parameters, or user defined?
   bool buserpre = cs.paramprefix[0] ? 1 : 0;

   for (int iparm=0; iparm<9; iparm++)
   {
      char *pcur = szLineBuf;
      while (1)
      {
         int nlen1=0,nlen2=0;
         if (buserpre) {
            sprintf(szName1, "%.20s%d" , cs.paramprefix, (int)(iparm+1));
            nlen1 = strlen(szName1);
         } else {
            sprintf(szName1, "$%d" , (int)(iparm+1));
            sprintf(szName2, "%%%d", (int)(iparm+1));
            nlen1 = strlen(szName1);
            nlen2 = strlen(szName2);
         }
         char *psz  = pcur;
         char clast = (char)-1, cesc = 0;
         int nlenx = 0;
         while (*psz) {
            if (!strncmp(psz, szName1, nlen1)) {
               nlenx = nlen1;
               // allow escapes only if not user defined
               if (!buserpre) cesc = '$';
               break; 
            }
            if (!buserpre && !strncmp(psz, szName2, nlen2))
               { nlenx = nlen2; cesc = '%'; break; }
            clast = *psz++;
         }
         if (!*psz) break;
         if (clast == cesc) {
            /*
               // do NOT replace parm, just unescape it:
               psz--;
               memmove(psz, psz+1, strlen(psz+1)+1); // WITH terminator
               pcur = psz+1;
               // remember we have to dup szLineBuf
               bDoneAny = 1;
               continue;
            */
         }
         // replace $param... by actual value
         cchar *pval = "";
         if (iparm < nParm) pval = argv[iParmOffs+iparm];
         int nleft = psz-pcur;
         memcpy(szLineBuf2, pcur, nleft);
         int nmid  = strlen(pval);
         memcpy(szLineBuf2+nleft, pval, nmid);
         char *prite= psz+nlenx;
         strcpy(szLineBuf2+nleft+nmid, prite);
         strcpy(pcur, szLineBuf2);
         // step pcur, may have to replace $1 many times
         pcur += nleft+nmid;
         // remember we have to dup szLineBuf
         bDoneAny = 1;
      }
   }
   // do we have to manage a copy of the token?
   if (bDoneAny) {
      if (!strlen(szLineBuf))
         // subst lead to an EMPTY token:
         return 1;
      if (oDynaStrings.addEntry(szLineBuf, -1, &ptok)) // is copied
         return 9+perr("outofmem");
      // ptok should now contain the copy
      if (!ptok) return 9+perr("internal #2310271958");
      // write back ptok, in case it was changed:
      *pptok = ptok;
   }
   return 0;
}

char *mystrrstr(char *psrc, cchar *ppat) 
{
   if (!psrc || !ppat) return 0;

   char c = *ppat;
   int nsrclen = strlen(psrc);
   int npatlen = strlen(ppat);
   if (npatlen > nsrclen) return 0;

   char *pcur = psrc + nsrclen - npatlen;
   while (pcur >= psrc) {
      if (*pcur == c && !strncmp(pcur, ppat, npatlen))
         return pcur;
      pcur--;
   }
   return 0;
}

char *mystrristr(char *psrc, cchar *ppat)
{
   if (!psrc || !ppat) return 0;

   int nsrclen = strlen(psrc);
   int npatlen = strlen(ppat);
   if (npatlen > nsrclen) return 0;

   char *pcur = psrc + nsrclen - npatlen;
   while (pcur >= psrc) {
      if (!mystrnicmp(pcur, ppat, npatlen))
         return pcur;
      pcur--;
   }
   return 0;
}

int   nGlblConsColumns    = 80;
bool   bGlblConsColumnsSet =  0;

int setWriteEnabled(char *pszFile)
{
   #ifdef _WIN32

   BOOL bok = 0;

   #ifdef WINFULL
   WIN32_FILE_ATTRIBUTE_DATA oinf;
   bok = GetFileAttributesEx(pszFile, GetFileExInfoStandard, &oinf);
   if (!bok) return 9;

   oinf.dwFileAttributes &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);
   bok = SetFileAttributes(pszFile, oinf.dwFileAttributes);
   #else
   uint nattrib = GetFileAttributesA(pszFile);
   nattrib &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);
   SetFileAttributes(pszFile, nattrib);
   #endif

   if (!bok) return 9;

   #else

   struct stat64 buf;
   if (stat64(pszFile, &buf)) return 9;

   mode_t nmode = buf.st_mode | _S_IWRITE;
   if (chmod(pszFile, nmode)) return 9;
   
   #endif

   return 0;
}

FILE *pGlblOpenWriteFile   = 0;
char  szGlblOpenWriteName[MAX_LINE_LEN+10];

void beginFileWrite(char *pszName, FILE *p) {
   pGlblOpenWriteFile = p;
   strcopy(szGlblOpenWriteName, pszName);
}
void endFileWrite() {
   pGlblOpenWriteFile = 0;
   szGlblOpenWriteName[0] = 0;
}
void checkFileWrite() {
   if (pGlblOpenWriteFile)
      perr("unexpected: file left open for write: %s\n", szGlblOpenWriteName);
}
void cleanupFileWrite() {
   if (pGlblOpenWriteFile) {
      // close and remove incomplete (trash) file.
      // may not work here as this is called during interrupt.
      fclose(pGlblOpenWriteFile);
      remove(szGlblOpenWriteName);
   }
}
FILE *myfopen(char *pszName, cchar *pszMode) {
   FILE *f = fopen(pszName, pszMode);
   if (!f && !strcmp(pszMode, "wb") && fileExists(pszName)) {
      // file is probably write protected
      if (setWriteEnabled(pszName))
         return 0;
      // retry on write-enabled file
      f = fopen(pszName, pszMode);
   }
   if (f) {
      if (pGlblOpenWriteFile)
         pwarn("open for write on %s not registered\n", pszName);
      else
         beginFileWrite(pszName, f);
   }
   return f;
}
void myfclose(FILE *f) {
   if (f == pGlblOpenWriteFile)
      endFileWrite();
   fclose(f);
}

bool bGlblAllowCtrlCExit = 1;

class CtrlCCover {
public:
      CtrlCCover  (bool bAllowExit);
     ~CtrlCCover  ( );
};

CtrlCCover::CtrlCCover(bool b)
   { bGlblAllowCtrlCExit = b; }
   
CtrlCCover::~CtrlCCover( )
   { bGlblAllowCtrlCExit = 1; }

#define DisableCtrlCProcessExit() CtrlCCover oCtrlCCover(0)

#ifdef _WIN32
HANDLE hGlblConsole     =  0;
WORD   nGlblConsAttrib  =  0;

#define CCMASK_FOREGROUND (FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE|FOREGROUND_INTENSITY)
#define CCMASK_BACKGROUND (BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE|BACKGROUND_INTENSITY)
#define CCMASK_FORE_BACK  (CCMASK_FOREGROUND|CCMASK_BACKGROUND)
#define CCMASK_NOT_FGCOL  (0xFFFF ^ CCMASK_FOREGROUND)

// need this to ensure that commands dumping colored output
// do never leave the shell in a non-std color.
BOOL WINAPI ctrlcHandler(DWORD type)
{
   if (type != CTRL_C_EVENT && type != CTRL_BREAK_EVENT)
      return 0;

   bGlblEscape = 1;
   
   setTextColor(-1);

   if (bGlblAllowCtrlCExit)
   {
      // do this only with exit allowed,
      // otherwise main program may crash
      // as it continues on the file handle.
      cleanupFileWrite();
      ExitProcess(8);
   }

   return 1;
}
#else
// unix todo: ctrl+c handler to reset color
void ctrlcHandler(int sig_number)
{
   bGlblEscape = 1;
   
   setTextColor(-1, 0); // stdout
   setTextColor(-1, 1); // stderr

   if (bGlblAllowCtrlCExit)
   {
      // do this only with exit allowed,
      // otherwise main program may crash
      // as it continues on the file handle.
      cleanupFileWrite();
      exit(8);
   }
}
#endif

void setColorScheme(cchar *psz1)
{
   char *psz2 = 0;
   bool bany = 0;

   if (!strncmp(psz1, "off", 3))
   {  bGlblUseColor = bGlblUseHelpColor = 0; }
   else
   if (!strncmp(psz1, "on", 2))
      bGlblUseColor = 1;

   if (strstr(psz1, "bright"))
      { nGlblDarkColBase = 1; bany=1; }

   if (strstr(psz1, "dark"))
      { nGlblBrightColBase = 0; bany=1; }

   #ifdef MAC_OS_X // 1694
   if (strstr(psz1, "theme:black")) {
      nGlblDarkColBase    =  0;
      nGlblBrightColBase  =  0;
      nGlblHeadColor      =  4;
      nGlblExampColor     =  6;
      nGlblFileColor      = 10;
      nGlblHitColor       =  4;
      nGlblRepColor       =  6;
      nGlblLinkColor      = 12;
      nGlblWarnColor      =  6;
      nGlblDefColor       = 14;
      bany=1;
   }
   if (strstr(psz1, "theme:white")) {
      nGlblDarkColBase    =  0;
      nGlblBrightColBase  =  0;
      nGlblHeadColor      =  4;
      nGlblExampColor     = 10;
      nGlblFileColor      = 10;
      nGlblLinkColor      = 12;
      nGlblHitColor       =  4;
      nGlblRepColor       =  6;
      nGlblErrColor       =  2;
      nGlblWarnColor      = 10;
      nGlblPreColor       =  8;
      nGlblTimeColor      =  8;
      nGlblTraceIncColor  = 12;
      nGlblTraceExcColor  = 10;
      nGlblDefColor       =  0;
      bany=1;
   }
   #else
   if (strstr(psz1, "theme:black")) {
      // bright colors with black background
      nGlblDarkColBase =  1;
      nGlblExampColor  =  7; // bright yellow
      nGlblHeadColor   =  5; // green
      nGlblFileColor   =  5; // green
      nGlblHitColor    = 11; // purple
      nGlblRepColor    =  7; // bright yellow
      nGlblLinkColor   = 13; // bright cyan
      nGlblWarnColor   =  7; // bright yellow
      #ifndef _WIN32
      nGlblDefColor    = 14; // non bright white (gray)
      #endif
      bany=1;
   }
   if (strstr(psz1, "theme:white")) {
      // with white background, user may want to select
      // bright or dark colors case by case.
      nGlblHeadColor      =  4; // green
      nGlblExampColor     = 11; // purple
      nGlblFileColor      =  4; // green
      nGlblHitColor       = 11; // purple
      nGlblRepColor       =  3; // red
      nGlblLinkColor      = 12; // cyan
      nGlblErrColor       =  3; // red
      nGlblWarnColor      = 11; // purple
      nGlblPreColor       =  8; // blue
      nGlblTimeColor      =  8; // blue
      nGlblTraceIncColor  = 12; // dark magenta
      nGlblTraceExcColor  = 11; // purple
      bany=1;
   }
   #endif

   if (strstr(psz1, ",nobold")) // 1694
      { nGlblDarkColBase = 0; nGlblBrightColBase = 0; bany=1; }
   else
   if (strstr(psz1, ",bold"))   // 1694
      { nGlblDarkColBase = 1; nGlblBrightColBase = 1; bany=1; }

   psz2 = (char*)strstr(psz1, "head:");  if (psz2) { nGlblHeadColor  = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "examp:"); if (psz2) { nGlblExampColor = atol(psz2+6); bany=1; }
   psz2 = (char*)strstr(psz1, "file:");  if (psz2) { nGlblFileColor  = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "link:");  if (psz2) { nGlblLinkColor  = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "hit:");   if (psz2) { nGlblHitColor   = atol(psz2+4); bany=1; }
   psz2 = (char*)strstr(psz1, "rep:");   if (psz2) { nGlblRepColor   = atol(psz2+4); bany=1; }
   psz2 = (char*)strstr(psz1, "err:");   if (psz2) { nGlblErrColor   = atol(psz2+4); bany=1; }
   psz2 = (char*)strstr(psz1, "warn:");  if (psz2) { nGlblWarnColor  = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "pre:");   if (psz2) { nGlblPreColor   = atol(psz2+4); bany=1; }
   #ifndef _WIN32
   psz2 = (char*)strstr(psz1, "def:");   if (psz2) { nGlblDefColor   = atol(psz2+4); bany=1; }
   #endif
   //                   0123456789
   psz2 = (char*)strstr(psz1, "time:");     if (psz2) { nGlblTimeColor     = atol(psz2+5); bany=1; }
   psz2 = (char*)strstr(psz1, "traceinc:"); if (psz2) { nGlblTraceIncColor = atol(psz2+9); bany=1; }
   psz2 = (char*)strstr(psz1, "traceexc:"); if (psz2) { nGlblTraceExcColor = atol(psz2+9); bany=1; }
   
   if (bany)
      bGlblUseColor = 1;
}

int nGlblCurColor = -1; // currently active color

void setTextColor(int n, bool bStdErr)
{
   if (n == nGlblCurColor) {
      mtklog(("color: ignore %d, is set already", n));
      return;
   }
   nGlblCurColor = n;

   if (bGlblHtml) 
   {
      static bool bAnySet = 0;
      static bool bIsBold = 0;
      uint ncol = 0;
      if (bAnySet) { printf("</font>"); bAnySet=0; }
      if (bIsBold) { printf("</b>"); bIsBold=0; }
      if (n == -1)
         return;
      bAnySet=1;
      if (n == 1) { bIsBold=1; printf("<b>"); }
      if (n &  2) ncol |= (n&1) ? 0xFF0000 : 0x990000;
      if (n &  4) ncol |= (n&1) ? 0x00FF00 : 0x009900;
      if (n &  8) ncol |= (n&1) ? 0x0000FF : 0x000099;
      if (n & 16) { bIsBold=1; printf("<b>"); }
      printf("<font color=\"%06X\">", ncol);
      return;
   }

   if (!bGlblUseColor) {
      mtklog(("color: ignore %d, no colors used", n));
      return;
   }

   #ifdef _WIN32

   #ifdef WINFULL
   if (n == 0) {
      // FIX: n==0 produces invisible text both with a white
      //      or black background shell. a visible compromise:
      n = 14;
   }

   WORD nAttrib = 0;
   if (n & 1) nAttrib |= FOREGROUND_INTENSITY;
   if (n & 2) nAttrib |= FOREGROUND_RED;
   if (n & 4) nAttrib |= FOREGROUND_GREEN;
   if (n & 8) nAttrib |= FOREGROUND_BLUE;

   if (n == -1) {
      // default color: set all attribs as they were.
      SetConsoleTextAttribute(hGlblConsole, nGlblConsAttrib);
      mtklog(("color: scta %lxh (is default)", nGlblConsAttrib));
   } else {
      // set new FOREGROUND text color, but make sure that
      // background color and anything else stays unchanged.
      uint nval = (nGlblConsAttrib & CCMASK_NOT_FGCOL) | nAttrib;
      SetConsoleTextAttribute(hGlblConsole, nval);
      mtklog(("color: scta %lxh (default=%lxh)", nval, nGlblConsAttrib));
   }
   #endif

   #else

   #define UXATTR_RESET     0
   #define UXATTR_BRIGHT    1
   #define UXATTR_DIM       2
   #define UXATTR_UNDERLINE 3
   #define UXATTR_BLINK     4
   #define UXATTR_REVERSE   7
   #define UXATTR_HIDDEN    8

   #define UXCOL_BLACK      0
   #define UXCOL_RED        1
   #define UXCOL_GREEN      2
   #define UXCOL_YELLOW     3
   #define UXCOL_BLUE       4
   #define UXCOL_MAGENTA    5
   #define UXCOL_CYAN       6
   #define UXCOL_WHITE      7

   FILE *fout = stdout;
   if (bStdErr)
         fout = stderr;

   if (n==-1) {
      // unix: have to use a user-defined default color
      n = nGlblDefColor;
   }

   int nAttr = (n & 1) ? UXATTR_BRIGHT : UXATTR_RESET;

   switch (n & 14) {
      case  2: n = UXCOL_RED;     break;
      case  4: n = UXCOL_GREEN;   break;
      case  6: n = UXCOL_YELLOW;  break;
      case  8: n = UXCOL_BLUE;    break;
      case 10: n = UXCOL_MAGENTA; break;
      case 12: n = UXCOL_CYAN;    break;
      case 14: n = UXCOL_WHITE;   break;
      default: n = UXCOL_BLACK;   break;
   }
   fprintf(fout, "%c[%d;%dm", 0x1B, nAttr, n+30);

   #endif
}

// windows-1250 to dos-850 ANSI Central European mapping table.
// some mappings are approximations.
uchar aMapAnsi1250ToOEM850[] = {
0x80,0x5F, 0x81,0x5F, 0x82,0x27, 0x83,0x9F, 0x84,0x22, 0x85,0x2E, 0x86,0xC5, 0x87,0xCE, 
0x88,0x5E, 0x89,0x25, 0x8A,0x53, 0x8B,0x3C, 0x8C,0x4F, 0x8D,0x5F, 0x8E,0x5A, 0x8F,0x5F, 
0x90,0x5F, 0x91,0x27, 0x92,0x27, 0x93,0x22, 0x94,0x22,            0x96,0x2D, 0x97,0x2D, // 0x95,0x07,
0x98,0x7E, 0x99,0x54, 0x9A,0x73, 0x9B,0x3E, 0x9C,0x6F, 0x9D,0x5F, 0x9E,0x7A, 0x9F,0x59, 
0xA0,0xFF, 0xA1,0xAD, 0xA2,0xBD, 0xA3,0x9C, 0xA4,0xCF, 0xA5,0xBE, 0xA6,0xDD, 0xA7,0xF5, 
0xA8,0xF9, 0xA9,0xB8, 0xAA,0xA6, 0xAB,0xAE, 0xAC,0xAA, 0xAD,0xF0, 0xAE,0xA9, 0xAF,0xEE, 
0xB0,0xF8, 0xB1,0xF1, 0xB2,0xFD, 0xB3,0xFC, 0xB4,0xEF, 0xB5,0xE6, 0xB6,0xF4, 0xB7,0xFA, 
0xB8,0xF7, 0xB9,0xFB, 0xBA,0xA7, 0xBB,0xAF, 0xBC,0xAC, 0xBD,0xAB, 0xBE,0xF3, 0xBF,0xA8, 
0xC0,0xB7, 0xC1,0xB5, 0xC2,0xB6, 0xC3,0xC7, 0xC4,0x8E, 0xC5,0x8F, 0xC6,0x92, 0xC7,0x80, 
0xC8,0xD4, 0xC9,0x90, 0xCA,0xD2, 0xCB,0xD3, 0xCC,0xDE, 0xCD,0xD6, 0xCE,0xD7, 0xCF,0xD8, 
0xD0,0xD1, 0xD1,0xA5, 0xD2,0xE3, 0xD3,0xE0, 0xD4,0xE2, 0xD5,0xE5, 0xD6,0x99, 0xD7,0x9E, 
0xD8,0x9D, 0xD9,0xEB, 0xDA,0xE9, 0xDB,0xEA, 0xDC,0x9A, 0xDD,0xED, 0xDE,0xE8, 0xDF,0xE1, 
0xE0,0x85, 0xE1,0xA0, 0xE2,0x83, 0xE3,0xC6, 0xE4,0x84, 0xE5,0x86, 0xE6,0x91, 0xE7,0x87, 
0xE8,0x8A, 0xE9,0x82, 0xEA,0x88, 0xEB,0x89, 0xEC,0x8D, 0xED,0xA1, 0xEE,0x8C, 0xEF,0x8B, 
0xF0,0xD0, 0xF1,0xA4, 0xF2,0x95, 0xF3,0xA2, 0xF4,0x93, 0xF5,0xE4, 0xF6,0x94, 0xF7,0xF6, 
0xF8,0x9B, 0xF9,0x97, 0xFA,0xA3, 0xFB,0x96, 0xFC,0x81, 0xFD,0xEC, 0xFE,0xE7, 0xFF,0x98, 
};

char ansiCharToOEM(char c) {
   int nentries = sizeof(aMapAnsi1250ToOEM850) / 2;
   for (int i=0; i<nentries; i++)
      if (aMapAnsi1250ToOEM850[i*2+0] == (uchar)c)
         return aMapAnsi1250ToOEM850[i*2+1];
   return c;
}

char oemCharToAnsi(char c) {
   if (((uchar)c) < 0x80) return c;
   int nentries = sizeof(aMapAnsi1250ToOEM850) / 2;
   for (int i=0; i<nentries; i++)
      if (aMapAnsi1250ToOEM850[i*2+1] == (uchar)c)
         return aMapAnsi1250ToOEM850[i*2+0];
   return c;
}

void ansiToDos(char *psz) { for (;*psz;psz++) *psz = ansiCharToOEM(*psz); }
void dosToAnsi(char *psz) { for (;*psz;psz++) *psz = oemCharToAnsi(*psz); }
void oprintf(cchar *pszFormat, ...);
void oprintf(StringPipe *pOutData, cchar *pszFormat, ...);

uchar unicodeToIso(uint ucode)
{
   switch (ucode)
   {
      // normalize stupid apostrophes
      case 0x2018: ucode = 0x27; break;
      case 0x2019: ucode = 0x27; break;
      case 0x0000: ucode = cs.toisodef; break;
      default:
         // replace all non-8bit by default
         if (ucode >= 0x0100)
            ucode = cs.toisodef;
            break;
   }
   return (uchar)ucode;
}

void utf8ToIso(char *psz)
{
   UTF8Codec utf(psz);
   char *pDstCur = psz;
   char *pDstMax = psz+strlen(psz);
   uint ucode = 0;
   while (pDstCur<pDstMax && utf.hasChar()!=0)
   {
      *pDstCur++ = (char)unicodeToIso(utf.nextChar());
   }
   if (pDstCur<pDstMax)
      *pDstCur = '\0';
}

int csvToTab(char *psrc, char *pdst, int imaxdst)
{
   char cdelim     = cs.cinsep;
   char ctab       = cs.coutsep;
   char cquote     = cs.cquote;
   char ctabescape = cs.coutsepesc;

   /*
      5324,John Smith,Los Angeles
      7936,"James Foo, Dr.",Atlanta
      3297,"Jack ""Goo"" Bar",San Diego
      5239,,Nowhere
      5240,Empty{TAB}City,
   */

   char *pSrcCur = psrc;
   char *pSrcMax = psrc + strlen(psrc);
   char *pDstCur = pdst;
   char *pDstMax = pdst + (imaxdst - 20);

   int istate   = 0;
   int binquote = 0;

   while (pSrcCur < pSrcMax && pDstCur < pDstMax)
   {
      char c  = *pSrcCur++;
      char c2 = *pSrcCur;  // NULL if at end

      switch (istate)
      {
         case 0:  // expect quote, start of data, delimiter
            if (c == cquote) {
               binquote = 1;
               istate = 1;
               continue;
            }
            if (c == cdelim) {
               *pDstCur++ = ctab;
               continue;
            }
            istate = 1;
            // fall through

         case 1:  // expect data byte, escaped quote, delimiter, EOR
            if (c == cquote && c2 == cquote) {
               *pDstCur++ = cquote;
               pSrcCur++;
               continue;
            }
            if (binquote == 0 && c == cdelim) {
               *pDstCur++ = ctab;
               istate = 0;
               continue;
            }
            if (binquote == 1 && c == cquote) {
               // delimiter or EOR must be next
               binquote = 0;
               continue;
            }
            if (c == ctab) {
               // remove tabs from input
               c = ctabescape;
            }
            *pDstCur++ = c;
            continue;
      }
   }

   if (pSrcCur >= pSrcMax)
   {
      // end of record checks
      if (pDstCur >= pDstMax)
         return 10;

      switch (istate)
      {
         case 0:  // expect quote, data, delimiter
            *pDstCur++ = '\0';
            return 0;

         case 1:  // expect data byte, escaped quote, delimiter, EOR
            if (binquote)
               return 11;
            *pDstCur++ = '\0';
            return 0;
      }
   }

   return 12;
}

int ispuretext(char *psz, char ccurdelim, char coutdelim, char cquote)
{
   while (*psz)
   {
      char c = *psz++;
      if (c == ccurdelim)
         return 1;
      if (c == coutdelim)
         return 0;
      if (c == cquote)
         return 0;
   }

   return 1;
}

int ispurenum(char *psz, char ccurdelim, char coutdelim)
{
   /*
      +123.456e+10
      -234.387e3
      -234,387e-3
   */

   if (*psz=='+' || *psz=='-')
      psz++;

   int istate = 1;

   while (*psz != 0 && *psz != ccurdelim)
   {
      char c = *psz++;

      if (c == coutdelim)
         return 0;

      switch (istate)
      {
         case 1: // expect just digit
            if (isdigit(c)) {
               istate = 2;
               continue;
            }
            return 0;

         case 2: // expect digit . , e
            if (isdigit(c))
               continue;
            if (c == '.' || c == ',')
               continue;
            if (tolower(c) == 'e') {
               istate = 3;
               continue;
            }
            return 0;

         case 3: // after e: expect + - digit
            if (c == '+' || c == '-') {
               istate = 4;
               continue;
            }
         case 4:
            if (isdigit(c))
               continue;
            return 0;
      }
   }

   return 1;
}

int tabToCsv(char *psrc, char *pdst, int imaxdst)
{
   char ctab       = cs.cinsep;
   char cdelim     = cs.coutsep;
   char cquote     = cs.cquote;
   bool bquotetext = cs.quotetext;
   bool bfullquote = cs.quoteall;

   char *pSrcCur = psrc;
   char *pSrcMax = psrc + strlen(psrc);
   char *pDstCur = pdst;
   char *pDstMax = pdst + (imaxdst - 20);

   int istate   = 0;
   int binquote = 0;
   int boutquoteopen = 0;

   while (pSrcCur < pSrcMax && pDstCur < pDstMax)
   {
      char c  = *pSrcCur++;
      char c2 = *pSrcCur;  // NULL if at end

      switch (istate)
      {
         case 0:  // expect start of data, tab, quote-to-escape
            if (c == ctab) {
               if (bfullquote) {
                  *pDstCur++ = cquote;
                  *pDstCur++ = cquote;
               }
               *pDstCur++ = cdelim;
               continue;
            }
            // start of data, quote-to-escape
            if (   bfullquote == 1 
                || (bquotetext && !ispurenum(pSrcCur-1, ctab, cdelim))
                || (!ispuretext(pSrcCur-1, ctab, cdelim, cquote))
               )
            {
               *pDstCur++ = cquote;
               boutquoteopen = 1;
            }
            istate = 1;
            // fall through

         case 1:  // expect tab, data byte, quote-to-escape
            if (c == ctab) {
               if (boutquoteopen)
                  *pDstCur++ = cquote;
               *pDstCur++ = cdelim;
               boutquoteopen = 0;
               istate = 0;
               // tab at end of record?
               if (pSrcCur >= pSrcMax) {
                  // then it means a trailing empty field
                  if (bfullquote) {
                     *pDstCur++ = cquote;
                     *pDstCur++ = cquote;
                  }
                  // but without extra separator
               }
               continue;
            }
            if (c == cquote) {
               // escape quote
               *pDstCur++ = cquote;
               *pDstCur++ = cquote;
               continue;
            }
            // continue data
            *pDstCur++ = c;
            continue;
      }
   }

   if (pSrcCur >= pSrcMax)
   {
      // end of record checks
      if (pDstCur >= pDstMax)
         return 10;

      switch (istate)
      {
         case 0:  // expect start of data, tab
            *pDstCur++ = '\0';
            return 0;

         case 1:  // expect tab, data byte
            if (boutquoteopen)
               *pDstCur++ = cquote;
            *pDstCur++ = '\0';
            return 0;
      }
   }

   return 12;
}

void changeLineCase(char *psz, int iMode)
{ 
   switch (iMode) {
      case 1:
         for (;*psz;psz++) *psz = toupper(*psz); 
         break;
      case 2:
         for (;*psz;psz++) *psz = tolower(*psz);
         break;
   }
}

void trimLine(char *psz, int iMode)
{
   char *pleft  = psz;
   char *prite  = psz + strlen(psz);
   char *prite2 = prite;

   if (iMode & 1)
   {
      while (*pleft == ' ' || *pleft == '\t')
         pleft++;
   }

   if (iMode & 2)
   {
      while (prite > pleft && (prite[-1] == ' ' || prite[-1] == '\t'))
         prite--;
   }

   int ilen = prite - pleft;

   if (pleft != psz)
   {
      // move and terminate
      for (int i=0; i<ilen; i++)
         psz[i] = pleft[i];
      psz[ilen] = '\0';
   }
   else if (prite != prite2)
   {
      // just terminate
      *prite = '\0';
   }
}

char szPrintBufMap[MAX_LINE_LEN+10];

void mystrcatf(char *pOut, int nOutMax, cchar *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';
   char *psz = szPrintBufMap;

   if (nOutMax == 0) nOutMax = MAX_LINE_LEN;

   int nlen1 = strlen(pOut);
   int nrem1 = (nOutMax - nlen1) - 1; // including term.
   int nlen2 = strlen(psz);
   if (nlen2 > nrem1) nlen2 = nrem1;
   if (nlen2 > 0) {
      memcpy(pOut+nlen1, psz, nlen2);
      *(pOut+nlen1+nlen2) = '\0';
   }
}

// without zero termination, only for short fixed-size strings
void mystrplot(char *pOut, int iMaxOut, cchar *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';
   char *psz = szPrintBufMap;

   int iCopy = strlen(psz);
   if (iCopy > iMaxOut)
      iCopy = iMaxOut;
      
   memcpy(pOut, psz, iCopy);
}

char myrchar(char *psz)
{
   int ilen = strlen(psz);
   if (ilen > 0)
      return psz[ilen-1];
   return 0;
}

void printHtml(char *pszText, int iTextLen)
{
   for (int i=0; i<iTextLen; i++) {
      char c = pszText[i];
      switch (c) {
         case '>': printf("&gt;"); break;
         case '<': printf("&lt;"); break;
         case '&': printf("&amp;"); break;
         default : putchar(c); break;
      }
   }
}

int sfkMapAttrToColor(char cAttr)
{
   int d = nGlblDarkColBase;
   int b = nGlblBrightColBase;

   switch (cAttr) 
   {
      // sfk internal color codes. when extending this,
      // also adapt color mapping in the "view" command.

      case 'f': return nGlblFileColor ; break;
      case 'l': return nGlblLinkColor ; break;
      case 'h': return nGlblHeadColor ; break;
      case 'i': return nGlblHitColor  ; break;
      case 'a': return nGlblRepColor  ; break;
      case 'x': return nGlblExampColor; break;
      case 'e': return nGlblErrColor  ; break;
      case 'w': return nGlblWarnColor ; break;
      case 't': return nGlblTimeColor ; break;
      case 'p': return nGlblPreColor  ; break;

      // bright base colors
      case 'R': return b+2 ; break;
      case 'G': return b+4 ; break;
      case 'B': return b+8 ; break;
      case 'Y': return b+6 ; break;
      case 'C': return b+12; break;
      case 'M': return b+10; break;
      case 'V': return b+14; break;

      // dark base colors
      case 'r': return d+2 ; break;
      case 'g': return d+4 ; break;
      case 'b': return d+8 ; break;
      case 'y': return d+6 ; break;
      case 'c': return d+12; break;
      case 'm': return d+10; break;
      case 'v': return d+14; break;
   }

   // default:   
   return -1;
}

void printColorText(char *pszText, char *pszAttrib, bool bWithLF=1)
{
   // printf("\n\n\n--- pct.text/attr: ---\n%s\n", pszText);
   // printf("%s\n--- output: ---\n", pszAttrib);

   int nTextLen = strlen(pszText);
   int nAttrLen = strlen(pszAttrib);

   // if insufficient attribs provided, use no color
   if (nAttrLen < nTextLen) {
      oprintf("%s%s", pszText, bWithLF ? "\n":"");
      return;
   }

   int i1=0,i2=0;
   while (i1 < nTextLen)
   {
      // identify next phrase of same color
      uchar a1 = pszAttrib[i1];
      for (i2=1; i1+i2<nTextLen; i2++)
         if (pszAttrib[i1+i2] != a1)
            break;

      // dump next phrase with len i2.
      int ncolor = sfkMapAttrToColor(a1);
      setTextColor(ncolor);

      if (bGlblHtml)
         printHtml(pszText+i1, (int)i2);
      else
         oprintf("%.*s", (int)i2, pszText+i1);

      // step forward
      i1 += i2;
   }
   setTextColor(-1);
   if (bWithLF)
      putchar('\n');
}

char attribFromHumanColor(char *pszCol, char cDefault='i')
{
   // red -> dark red. Red or RED -> bright red.
   if (!mystricmp(pszCol, "red"))     return pszCol[0];
   if (!mystricmp(pszCol, "green"))   return pszCol[0];
   if (!mystricmp(pszCol, "blue"))    return pszCol[0];
   if (!mystricmp(pszCol, "yellow"))  return pszCol[0];
   if (!mystricmp(pszCol, "cyan"))    return pszCol[0];
   if (!mystricmp(pszCol, "magenta")) return pszCol[0];
   if (!mystricmp(pszCol, "def"))     return ' ';
   if (!mystricmp(pszCol, "default")) return ' ';
   if (!mystricmp(pszCol, "white"))   return (pszCol[0] == 'W') ? 'V':'v';

   // since 1.58 also supporting logical colors
   if (!mystricmp(pszCol, "err"))     return 'e';
   if (!mystricmp(pszCol, "warn"))    return 'w';
   if (!mystricmp(pszCol, "head"))    return 'h';
   if (!mystricmp(pszCol, "examp"))   return 'x';
   if (!mystricmp(pszCol, "file"))    return 'f';
   if (!mystricmp(pszCol, "hit"))     return 'i';
   if (!mystricmp(pszCol, "rep"))     return 'a';
   if (!mystricmp(pszCol, "pre"))     return 'p';
   if (!mystricmp(pszCol, "time"))    return 't';

   static bool btold = 0;
   if (!btold) 
   {
      btold = 1;
      pwarn("unsupported color name: %s (try \"sfk help color\")\n", pszCol);
   }

   return cDefault;
}

bool bGlblCheckPrintX = 0;

char szPrintBuf1[MAX_LINE_LEN+10];
char szPrintBuf2[MAX_LINE_LEN+10];
char szPrintAttr[MAX_LINE_LEN+10];

int printx(const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);

   if (bGlblCheckPrintX)
      szPrintBuf1[sizeof(szPrintBuf1)-12] = '\xFF';

   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';
   
   if (bGlblCheckPrintX)
      if (szPrintBuf1[sizeof(szPrintBuf1)-12] != '\xFF')
         fprintf(stderr, "printx overflow.1: %.30s ...\n", szPrintBuf1);

   char *pszSrc = szPrintBuf1;
   int iDst = 0;
   char nAttr = ' ';
   bool bResetOnLF = 0;
   while (*pszSrc && (iDst < (int)sizeof(szPrintBuf2)-10)) 
   {
      if (pszSrc[0] == '\\' && pszSrc[1] == '<') {
         pszSrc += 2;
         szPrintBuf2[iDst] = '<';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<help>", 6))  { pszSrc += 6; if (bGlblUseHelpColor) bGlblUseColor = 1; } else
      if (!strncmp(pszSrc, "<file>", 6))  { pszSrc += 6; nAttr = 'f'; } else
      if (!strncmp(pszSrc, "<head>", 6))  { pszSrc += 6; nAttr = 'h'; } else
      if (!strncmp(pszSrc, "<prefix>", 8)){ pszSrc += 8; nAttr = 'p'; } else
      if (!strncmp(pszSrc, "<examp>", 7)) { pszSrc += 7; nAttr = 'x'; } else
      if (!strncmp(pszSrc, "$$"    , 2))  {
         pszSrc += 2;
         szPrintBuf2[iDst] = '$';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "$"     , 1)) { pszSrc += 1; nAttr = 'h'; bResetOnLF = 1; } else
      if (!strncmp(pszSrc, "##"    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = '#';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (pszSrc[0] == '\\' && pszSrc[1] == glblWildChar) {
         pszSrc += 2;
         szPrintBuf2[iDst] = glblWildChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "#"     , 1)) { pszSrc += 1; nAttr = 'x'; bResetOnLF = 1; } else
      if (!strncmp(pszSrc, "<hit>" , 5)) { pszSrc += 5; nAttr = 'i'; } else
      if (!strncmp(pszSrc, "<rep>" , 5)) { pszSrc += 5; nAttr = 'a'; } else
      if (!strncmp(pszSrc, "<err>" , 5)) { pszSrc += 5; nAttr = 'e'; } else
      if (!strncmp(pszSrc, "<warn>", 6)) { pszSrc += 6; nAttr = 'w'; } else
      if (!strncmp(pszSrc, "<time>", 6)) { pszSrc += 6; nAttr = 't'; } else
      if (!strncmp(pszSrc, "<def>" , 5)) { pszSrc += 5; nAttr = ' '; } else

      if (!strncmp(pszSrc, "[["    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = '[';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "]]"    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = ']';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      // base colors are bright or dark depending on their first name char
      if (!mystrncmp(pszSrc, "[red]"    , 5)) { nAttr = pszSrc[1]; pszSrc += 5; } else
      if (!mystrncmp(pszSrc, "[green]"  , 7)) { nAttr = pszSrc[1]; pszSrc += 7; } else
      if (!mystrncmp(pszSrc, "[blue]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[yellow]" , 8)) { nAttr = pszSrc[1]; pszSrc += 8; } else
      if (!mystrncmp(pszSrc, "[cyan]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[magenta]", 9)) { nAttr = pszSrc[1]; pszSrc += 9; } else

      if (!strncmp(pszSrc, "[def]"    , 5)) { pszSrc += 5; nAttr = ' '; } else

      if (!strncmp(pszSrc, "[CR]"     , 4)) {
         pszSrc += 4;
         szPrintBuf2[iDst] = '\r';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "[LF]"     , 4)) {
         pszSrc += 4;
         szPrintBuf2[iDst] = '\n';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "<not>"    , 5)) {
         pszSrc += 5;
         szPrintBuf2[iDst] = glblNotChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<run>" , 5)) {
         pszSrc += 5;
         szPrintBuf2[iDst] = glblRunChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<wild>" , 6)) {
         pszSrc += 6;
         szPrintBuf2[iDst] = glblWildChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<sla>" , 5)) {
         pszSrc += 5;
         szPrintBuf2[iDst] = glblPathChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      if (!strncmp(pszSrc, "<exp>" , 5)) {
         pszSrc += 5;
         #ifdef _WIN32
         memcpy(szPrintBuf2+iDst, "set", 3);
         memset(szPrintAttr+iDst, nAttr, 3);
         iDst += 3;
         #else
         memcpy(szPrintBuf2+iDst, "export", 6);
         memset(szPrintAttr+iDst, nAttr   , 6);
         iDst += 6;
         #endif
      }
      else
      if (!strncmp(pszSrc, "<nofo>" , 6)) {
         pszSrc += 6;
         #ifndef _WIN32
         memcpy(szPrintBuf2+iDst, "-nofo ", 6);
         memset(szPrintAttr+iDst, nAttr   , 6);
         iDst += 6;
         #endif
      }
      else {
         szPrintBuf2[iDst] = *pszSrc;
         szPrintAttr[iDst] = nAttr;
         if (*pszSrc == '\n' && bResetOnLF) {
            nAttr = ' ';
            szPrintAttr[iDst] = nAttr;
            bResetOnLF = 0;
         }
         pszSrc++;
         iDst++;
      }
   }
   szPrintBuf2[iDst] = '\0';

   if (bGlblCheckPrintX)
      if (iDst >= (int)sizeof(szPrintBuf2)-10)
         fprintf(stderr, "printx overflow.2: %.30s ...\n", szPrintBuf2);

   if (iGlblCollectCmd)
   {
      if (iGlblCollectCmd == 1)
      {
         void addHelpCmdLines(char *pszRaw, char *pszForm);
         addHelpCmdLines((char*)pszFormat, szPrintBuf2);
      }
   }
   else
   if (bGlblCollectHelp)
   {
      int chainAddLine(char *pszText, char *pszAttr, bool bSplitByLF);
      chainAddLine(szPrintBuf2, szPrintAttr, 1);
   }
   else
   {
      printColorText(szPrintBuf2, szPrintAttr, 0);
   }

   return 0;
}

// print whole chapter from main help text
int printHelp(const char *pszFormat, ...)
{
   char *pszBuf  = (char*)abBuf;
   int   iMaxBuf = sizeof(abBuf) - 100;

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(pszBuf, iMaxBuf, pszFormat, argList);
   pszBuf[iMaxBuf] = '\0';

   /*
   file system
      sfk list       - list directory tree contents.
                       list latest, oldest or biggest files.
                       list changed or identical files.
      sfk filefind   - find files by filename
      sfk treesize   - show directory size statistics
   */

   cchar *pszind = "   ";

   char *psz1 = pszBuf;
   char *psz2 = 0;
   int   ilen = 0;
   for (; psz1 && *psz1; psz1=psz2)
   {
      if ((psz2 = strchr(psz1, '\n'))) {
         ilen = psz2 - psz1;
         psz2++; // skip LF
      } else {
         ilen = strlen(psz1);
      }
      char *pszLineEnd = psz1 + ilen;

      // process current line
      if (*psz1 != ' ') {
         // headline
         printx("%s<file>%.*s<def>\n",pszind,ilen,psz1);
         continue;
      }

      // split command entry
      char *pcmd=0, *pcmde=0, *ptext=0;

      pcmd = psz1;
      skipOver(&pcmd, " ");
      if (*pcmd=='\r' || *pcmd=='\n') {
         // no command name, but empty line
         printx("\n");
         continue;
      }
      if (pcmd > psz1+3) {
         // no command name, but continuation line
         printx("%s%.*s\n",pszind,ilen,psz1);
         continue;
      }

      ptext = strstr(pcmd, "- ");
      if (ptext) {
         // found "-" before info text
         pcmde = ptext;
         while (pcmde > pcmd && pcmde[-1] == ' ')
            pcmde--;
         // show name and text in two colors
         int icmdlen = pcmde - pcmd;
         int itxtlen = pszLineEnd - pcmde;
         printx("%s   #%.*s<def>%.*s\n",pszind,icmdlen,pcmd,itxtlen,pcmde);
      } else {
         // command name without info text
         printx("%s$%.*s<def>\n",pszind,ilen,psz1);
         continue;
      }
   }

   return 0;
}

static char szErrBuf[MAX_LINE_LEN+10];

cchar *sfkLastError()
{
   if (bErrBufSet)
      return szErrBuf;
   else
      return "";
}

ListEntry::ListEntry( )  { pClNext = pClPrevious = 0; data = 0; }
ListEntry::~ListEntry( ) { pClNext = pClPrevious = 0; data = 0; }

List::List( )  { reset(); }
List::~List( ) { reset(); }

// NOTE: caller MUST FREE all list elements before reset()!
void List::reset( ) {
   pClFirst = pClLast = 0;
}

void List::add(ListEntry* pNew)
{
   if (!pClFirst)
   {
      // yet empty list:
      pClFirst = pClLast = pNew;
      pNew->pClNext = pNew->pClPrevious = 0;
      return;
   }

   // append node at end of list:
   pClLast->pClNext   = pNew;
    pNew->pClPrevious = pClLast;
    pNew->pClNext     = 0;
   pClLast            = pNew;
}

void List::addAsFirst(ListEntry* pNew)
{
   // yet empty list?
   if (!pClFirst)
   {
      pClFirst = pClLast = pNew;
      pNew->pClNext = pNew->pClPrevious = 0;
      return;
   }

   // make node new front of list:
   ListEntry *n2 = pClFirst;
   n2->pClPrevious      = pNew;
    pNew->pClPrevious   = 0;
    pNew->pClNext       = n2;
   pClFirst             = pNew;
}

void List::addAfter(ListEntry *pAfter, ListEntry *pNew)
{
   ListEntry *pNext = pAfter->pClNext;  // might be 0

   pAfter->pClNext   = pNew;
   pNew->pClPrevious = pAfter;
   pNew->pClNext     = pNext;

   if (pNext)
      pNext->pClPrevious = pNew;
   else
      pClLast  = pNew;
}

void List::remove(ListEntry* pRemove)
{
   ListEntry *pPrevious = pRemove->pClPrevious;  // might be 0
   ListEntry *pNext     = pRemove->pClNext;      // might be 0

   pRemove->pClNext = pRemove->pClPrevious = 0;

   if (!pPrevious)   // if 'pRemove' at start of list
   {
      if ((pClFirst = pNext))    // new list start becomes pNext ...
         pNext->pClPrevious = 0; // ... and if pNext exists, adjust it,
      else
         pClLast  = 0;           // else list is empty.
   }
   else
   {
      // at least a 'pClPrevious' is given.
      if ((pPrevious->pClNext = pNext))   // let pPrevious' 'pClNext' ptr bypass 'pRemove' ...
         pNext->pClPrevious = pPrevious;  // ... and if pNext exists, adjust it,
      else
         pClLast  = pPrevious;            // else set new listend.
   }
}

KeyMap::KeyMap( ) {
   mtklog(("keymap ctr %p", this));
   wipe();
}

KeyMap::~KeyMap( ) {
   mtklog(("keymap dtr %p", this));
   reset();
   wipe();
}

void KeyMap::wipe( ) {
   nClArrayAlloc = 0;
   nClArrayUsed = 0;
   apClKey  = 0;
   apClVal  = 0;
   bClCase  = 1;
   bClRev   = 0;
}

void KeyMap::reset( ) 
{
   for (int i=0; i<nClArrayUsed; i++)
      delete [] apClKey[i];
   if (apClKey) delete [] apClKey;
   if (apClVal) delete [] apClVal;
   wipe();
}

void KeyMap::setcase(bool bYesNo)    { bClCase = bYesNo; }
void KeyMap::setreverse(bool bYesNo) { bClRev = bYesNo;  }

int KeyMap::expand(int nSoMuch)
{__
   // expand the key array
   char **apTmp1 = new char*[nClArrayAlloc+nSoMuch];
   if (!apTmp1) return 9;
   if (apClKey) {
      memcpy(apTmp1, apClKey, nClArrayUsed*sizeof(char*));
      delete [] apClKey;
   }
   apClKey = apTmp1;

   // expand the value array
   void **apTmp2 = new void*[nClArrayAlloc+nSoMuch];
   if (!apTmp2) return 9;
   if (apClVal) {
      memcpy(apTmp2, apClVal, nClArrayUsed*sizeof(void*));
      delete [] apClVal;
   }
   apClVal = apTmp2;

   // set new alloc size
   nClArrayAlloc += nSoMuch;

   return 0;
}

// rc =0:found_and_index_set
// rc <0:insert_before_index
// rc >0:insert_after_index
int KeyMap::bfind(char *pkey, int &rindex)
{
   // binary search for key, or insert position
   uint nbot=0,ndist=0,nhalf=0,imid=0;
   uint ntop=nClArrayUsed; // exclusive
   char  *ptmp=0;
   int    ncmp=-1;   // if empty, insert before index 0

   while (1)
   {
      if (nbot > ntop) // shouldn't happen
         { perr(0, "int. 187281850"); ncmp=-1; break; }

      ndist = ntop - nbot;
      // mtklog(("dist %d bot %d top %d",ndist,nbot,ntop));
      if (ndist == 0) break; // nothing left
      nhalf = ndist >> 1;
      imid  = nbot + nhalf;
      ptmp  = apClKey[imid];
      ncmp  = bClCase ? strcmp(pkey, ptmp) : mystricmp(pkey, ptmp);
      if (bClRev) ncmp = 0 - ncmp;
      
      if (ncmp < 0) {
         // select lower half, if any
         // mtklog((" take lower %lxh %lxh %d",nval,ntmp,imid));
         if (ntop == imid) break; // safety
         ntop = imid;
      }
      else
      if (ncmp > 0) {
         // select upper half, if any
         // mtklog((" take upper %lxh %lxh %d",nval,ntmp,imid));
         if (nbot == imid+1) break; // required
         nbot = imid+1;
      } else {
         // straight match
         mtklog(("%d = indexof(%.20s) used=%u",imid,pkey,nClArrayUsed));
         break; // found
      }
   }

   rindex = imid;
   return ncmp;
}

int KeyMap::put(char *pkey, void *pval)
{
   // assure space for insertion, incl. safety
   if (nClArrayUsed >= nClArrayAlloc-10) {
      if (nClArrayAlloc == 0) {
         if (expand(20)) return 9;
      } else {
         if (expand(nClArrayAlloc)) return 9;
      }
   }

   // search for key or insert position:
   int imid=0;
   int  nrc = bfind(pkey, imid);

   if (nrc) 
   {
      // no match, insert new entry:
      // if ncmp <= 0: before imid
      // if ncmp  > 0: after imid
      if (nrc > 0) imid++;
   
      // before imid as it is now
      uint ntomove = nClArrayUsed - imid;
      memmove(&apClKey[imid+1], &apClKey[imid], sizeof(char*) * ntomove);
      memmove(&apClVal[imid+1], &apClVal[imid], sizeof(void*) * ntomove);
      apClKey[imid] = strdup(pkey); // is COPIED.
      nClArrayUsed++;
   }

   // target position is now imid.
   apClVal[imid] = pval;
   // if there was an old pval, it is replaced.

   return 0; // done
}

void *KeyMap::get(char *pkey, int *poutidx)
{
   int imid=0;
   int  nrc = bfind(pkey, imid);
   // even on miss return last comparison index
   // to allow caller to find nearby words.
   if (poutidx) *poutidx = imid;
   if (nrc) return 0;
   if (imid < 0 || imid >= nClArrayUsed)
      {  perr("int. 187281919"); return 0; }
   return apClVal[imid]; // if any
}

bool KeyMap::isset(char *pkey) {
   int imid=0;
   return bfind(pkey, imid) ? 0 : 1;
}

int KeyMap::remove(int imid)
{
   // remove entry at imid
   delete [] apClKey[imid];
   if (imid < nClArrayUsed) {
      uint ntomove = nClArrayUsed - imid - 1;
      memmove(&apClKey[imid+0], &apClKey[imid+1], sizeof(char*) * ntomove);
      memmove(&apClVal[imid+0], &apClVal[imid+1], sizeof(void*) * ntomove);
   }
   nClArrayUsed--;
   return 0;
}

int KeyMap::remove(char *pkey) 
{
   int imid=0;
   int  nrc = bfind(pkey, imid);
   if (nrc) return 1; // no such key
   return remove(imid);
}

int KeyMap::size( ) {
   return nClArrayUsed;
}

void *KeyMap::iget(int nindex, char **ppkey)
{
   if (nindex < 0 || nindex >= nClArrayUsed)
      { if (ppkey) *ppkey = 0; return 0; }
   if (ppkey) *ppkey = apClKey[nindex];
   return apClVal[nindex];
}

// - - - keymap access with num keys: - -  -

// so far, the nums are simply converted into
// a hex string, prefixed by a non-printable 0x1.

inline void numToKey(num nkey, char *pbuf) {
   pbuf[0] = '\x01';
   pbuf[1] = '\0';
   numtohex(nkey, 16, pbuf+1);
}

int  KeyMap::put   (num nkey, void *pvalue) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return put(szBuf, pvalue);
}

void *KeyMap::get   (num nkey) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return get(szBuf);
}

bool  KeyMap::isset (num nkey) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return isset(szBuf);
}

int  KeyMap::remove(num nkey) {
   char szBuf[100];
   numToKey(nkey, szBuf);
   return remove(szBuf);
}

num hextonum(char *psz)
{
   #ifdef _MSC_VER
   return _strtoui64(psz, 0, 0x10);
   #else
   return strtoull(psz, 0, 0x10);
   #endif
}

void *KeyMap::iget  (int nindex, num *pkey) {
   char *pszkey = 0;
   void *pres = iget(nindex, &pszkey);
   if (pkey) {
      if (*pszkey == '\x01') {
         num nkey = hextonum(pszkey+1);
         *pkey = nkey;
      } else {
         perr("wrong keymap key for index %d", nindex);
         *pkey = 0;
      }
   }
   return pres;
}

// - - - keymap access with num keys end - -  -

StringMap::StringMap( )  { 
   mtklog(("strmap ctr %p", this));
}

StringMap::~StringMap( ) {
   mtklog(("strmap dtr %p", this));
   reset(); 
}

void StringMap::reset( ) 
{__
   mtklog(("strmap reset %p", this));
   for (int i=0; i<size(); i++)
      if (apClVal[i])
         delete [] (char*)apClVal[i];
   KeyMap::reset();
}

int StringMap::put(char *pkey, char *pvalin)
{
   // COPY the input string, but also accept NULL.
   char *pcopy = pvalin ? strdup(pvalin) : 0;

   mtklog(("strmap put this=%p %p key=%s",this,pcopy,pkey));

   // is the key is stored already?
   int imid=0;
   int  nrc = bfind(pkey, imid);
   if (!nrc)
   {
      // yes: if there is a value, delete it
      if (apClVal[imid])
         delete [] (char*)apClVal[imid];
      // and set new value, also accepting NULL.
      apClVal[imid] = pcopy;
      return 0;
   }

   // else add a copy
   return KeyMap::put(pkey, pcopy);
}

char *StringMap::get(char *pkey, char *pszOptDef)
{
   char *pres = (char*)KeyMap::get(pkey);
   if (!pres && pszOptDef) pres = pszOptDef;
   return pres;
}

int StringMap::remove(char *pkey) 
{
   int imid=0;
   int  nrc = bfind(pkey, imid);
   if (!nrc && apClVal[imid]) 
      delete [] (char*)apClVal[imid];
   return KeyMap::remove(pkey);
}

char *StringMap::iget(int nindex, char **ppkey)
{
   char *pkey = 0;
   char *pval = (char*)KeyMap::iget(nindex, &pkey);
   if (ppkey) *ppkey = pkey;
   return pval;
}

int StringMap::put(num nkey, char *pvalin) 
{
   // pvalin is dup'ed in the called put()

   mtklog(("strmap nput this=%p %lxh %p",this,(uint)nkey,pvalin));

   char szBuf[100];
   szBuf[0] = '\0';
   numtohex(nkey, 16, szBuf);

   return StringMap::put(szBuf, pvalin);
}

char *StringMap::get(num nkey) 
{
   char szBuf[100];
   szBuf[0] = '\0';
   numtohex(nkey, 16, szBuf);
   return (char*)get(szBuf);
}

char *StringMap::iget(int nindex, num *pkey) 
{
   char *pszkey = 0;
   void *pres = iget(nindex, &pszkey);
   if (pkey) {
      num nkey = hextonum(pszkey);
      *pkey = nkey;
   }
   return (char*)pres;
}

int StringMap::remove(num nkey) 
{
   char szBuf[100];
   szBuf[0] = '\0';
   numtohex(nkey, 16, szBuf);

   int imid=0;
   int  nrc = bfind(szBuf, imid);
   if (!nrc && apClVal[imid]) 
      delete [] (char*)apClVal[imid];

   return 0;
}

AttribStringMap::AttribStringMap( )  { }
AttribStringMap::~AttribStringMap( ) { }

char *AttribStringMap::mixdup(char *ptext, char *pattr)
{
   int nlen1 = strlen(ptext);
   int nlen2 = strlen(pattr);

   // mixed = TEXT + ZEROTERM + ATTR + ZEROTERM + MAGIC
   int nmix  = nlen1 + 1 + nlen2 + 1 + 1;

   char *pmix = new char[nmix];

   memcpy(pmix, ptext, nlen1);
   pmix[nlen1] = '\0';

   memcpy(pmix+nlen1+1, pattr, nlen2);
   pmix[nlen1+1+nlen2] = '\0';

   // to allow consistency checks:
   pmix[nlen1+1+nlen2+1] = (char)0xFF;

   return pmix;
}

int AttribStringMap::demix(char *pmixed, char **pptext, char **ppattr)
{
   // mixed = TEXT + ZEROTERM + ATTR + ZEROTERM + MAGIC
   char *ptext  = pmixed;
   int nlen1   = strlen(ptext);
   char *pattr  = ptext + nlen1 + 1;
   int nlen2   = strlen(pattr);
   char *pmagic = pattr + nlen2 + 1;
   if (*pmagic != (char)0xFF)
      return 9+perr("color string failure, %p \"%.10s\" \"%.10s\" \"%.10s\"", pmixed, pmixed, ptext, pattr);
   *pptext = ptext;
   *ppattr = pattr;
   return 0;
}

int AttribStringMap::put(char *pkey, char *ptext, char *pattr) 
{__
   char *pmix = mixdup(ptext, pattr);
   // mtklog(("asmap::put \"%s\" \"%s\" \"%s\"",pkey,ptext,pattr));
   // the string is dup'ed already,
   // place ptr straight into the keymap:
   return KeyMap::put(pkey, pmix);
}

int AttribStringMap::put(num nkey, char *ptext, char *pattr) 
{__
   char *pmix = mixdup(ptext, pattr);
   // mtklog(("asmap::put %d \"%s\" \"%s\"",(int)nkey,ptext,pattr));
   // the string is dup'ed already,
   // place ptr straight into the keymap:
   return KeyMap::put(nkey, pmix);
}

char *AttribStringMap::get(char *pkey, char **ppattr) 
{
   char *pmix = StringMap::get(pkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   *ppattr = pattr;
   return ptext;
}

char *AttribStringMap::iget(int nindex, char **ppkey, char **ppattr) 
{
   char *pkey = 0;
   char *pmix = StringMap::iget(nindex, &pkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   if (ppkey) *ppkey = pkey;
   *ppattr = pattr;
   return ptext;
}

char *AttribStringMap::get(num nkey, char **ppattr) 
{
   char *pmix = StringMap::get(nkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   *ppattr = pattr;
   return ptext;
}

char *AttribStringMap::iget(int nindex, num *pkey, char **ppattr) 
{
   num nkey = 0;
   char *pmix = StringMap::iget(nindex, &nkey);
   if (!pmix) return 0;

   char *ptext=0,*pattr=0;
   if (demix(pmix, &ptext, &pattr)) return 0;

   if (pkey) *pkey = nkey;
   *ppattr = pattr;
   return ptext;
}

int parseVersion(char *psz, int nmaxlen, StringMap &rmap)
{
   // expect input from a binary block:
   char szBuf[300];
   if (nmaxlen > (int)sizeof(szBuf)-10)
       nmaxlen = (int)sizeof(szBuf)-10;
   memcpy(szBuf, psz, nmaxlen);
   szBuf[nmaxlen] = '\0';

   char szVerID[50];
   sprintf(szVerID, "$%s:", "version");

   // $version:num=1.2.3,id=sfk,name=Swiss File Knife,type=base$\0"
   // 0123456789
   psz = szBuf;
   if (!strBegins(psz, szVerID)) return 9;
   psz += 9;

   char *atmp[10];
   memset(&atmp, 0, sizeof(atmp));

   // split comma separated string
   while (psz)
   {
      // nam=val,
      char *pnam = psz;

      while (*psz && *psz != '=' && *psz != '$') psz++;
      if (*psz != '=') break;
      *psz++ = '\0';

      char *pval = psz;

      while (*psz && *psz != ',' && *psz != '$') psz++;
      if (*psz == ',' || *psz == '$') {
         *psz++ = '\0';
         rmap.put(pnam, pval);
      }
      else break;
   }

   return 0;
}

#ifdef VFILENET
char *flatURLName(char *purl, char *pctype, char *pbuf, int nmaxbuf, uint nmode, bool &rdefault)
{__
   bool bpath2name = (nmode & 1) ? 1 : 0;
   bool bpath2path = (nmode & 2) ? 1 : 0;
   bool bwithdom   = (nmode & 4) ? 1 : 0;
   bool bskippath  = (!bpath2name && !bpath2path);
   // nmode & 8 is reserved
   bool bsynext    = (nmode & 16) ? 1 : 0;

   *pbuf = '\0'; // safety

   char *prel    = purl;
   char *purlmax = purl + strlen(purl);
   char *pCacheDir = getDiskCachePath();

   char szNameBuf[SFK_MAX_PATH+10];

   // only normalize net filenames,
   // or net files from the cache dir.
   if (strBegins(prel, "http://")) prel += strlen("http://");
   else
   if (strBegins(prel, "ftp://"))  prel += strlen("ftp://");
   else
   if (strBegins(prel, pCacheDir)) 
   {
      prel += strlen(pCacheDir);
      if (*prel == glblPathChar) prel++;

      // rebuild url from cache name format
      char *psrc = prel;
      char *pdst = szNameBuf;
      char *pdstmax = pdst+sizeof(szNameBuf)-10;
      szNameBuf[0] = '\0';

      if (strBegins(psrc, "http/") || strBegins(psrc, "http\\"))
         { psrc += 5; strcat(pdst, "http://"); pdst += 7; }
      else
      if (strBegins(psrc, "ftp/") || strBegins(psrc, "ftp\\"))
         { psrc += 4; strcat(pdst, "ftp://"); pdst += 6; }

      while (*psrc && (pdst < pdstmax)) 
      {
         if (!strncmp(psrc, "%2F", 3))
            { psrc+=3; *pdst++ = '/'; continue; }
         if (*psrc == '\\')
            { psrc++; *pdst++ = '/'; continue; }
         *pdst++ = *psrc++;
      }
      *pdst = '\0';

      // printf("-> \"%s\"\n", szNameBuf);

      prel = szNameBuf;
   }
   else
      return 0;

   char *pdst = pbuf;
   int  nrem = nmaxbuf - 10;

   if (nrem <= 100) { perr("int. #9529106"); return 0; }

   if (bskippath) {
      // the/sub/doc.zip -> doc.zip
      // http://foo.com/ -> ""
      char *psz2 = strrchr(prel, '/');
      if (psz2) {
         prel = psz2+1;
         if (!*prel) {
            strcpy(pdst, "index.html");
            rdefault = 1;
            return pbuf;
         }
      }
   }
   else
   if (!bwithdom) {
      // foobar.com/path -> path
      char *psz2 = strchr(prel, '/');
      if (psz2) {
         prel = psz2+1;
         if (!*prel) {
            strcpy(pdst, "index.html");
            rdefault = 1;
            return pbuf;
         }
      }
   }

   // convert and add rest of url.
   // http: $-_.+!*'(),
   char *psrc = prel;
   cchar *pext1 = 0;
   char *pext2 = 0;
   char  clast = 0;
   bool  lm    = 0; // last char was minus
   while (*psrc && (nrem > 0))
   {
      char c = *psrc++;
      clast  = c;
      if (isalnum(c)) {
         *pdst++ = c; nrem--; lm=0;
         continue; 
      }
      if (!pext2) pext2 = psrc-1;
      switch (c) {
         case '.':
             pext1 = psrc-1; pext2 = 0;
         case '-': case '+': case '_':
            *pdst++ = c; nrem--; lm=0;
            continue;
         case '/':
            if (bpath2path) {
               *pdst++ = glblPathChar; nrem--; lm=0;
               continue;
            }
         default:
            if (!lm) {
               *pdst++ = '-'; nrem--; lm=1;
            }
            continue;
      }
      /*
      sprintf(szBuf, "%%%02X", (unsigned)c);
      *pdst++ = szBuf[0];
      *pdst++ = szBuf[1];
      *pdst++ = szBuf[2];
      nrem -= 3;
      */
   }

   // fix trailing slash
   if (clast == '/' && (nrem >= 12)) {
      strcpy(pdst, "index.html");
      pdst += strlen(pdst);
      pext1 = ".html";
      nrem -= 10;
      rdefault = 1;
   }

   *pdst = '\0';

   if (bsynext)
   {
      // create default extensions for well-known ctypes
      if (!pext1 && pctype) {
         if (strstr(pctype, "text"))   pext1 = ".txt";
         if (strstr(pctype, "html"))   pext1 = ".html";
      }
   
      if (!pext1) pext1 = ".dat";
   
      // if extension is not at end of name, append it again
      if (pext1)
      {
         int nlen   = strlen(pext1);
         bool binurl = (pext1 >= purl && pext1 <= purlmax);
         if (binurl && pext2 && (pext2 > pext1))
            nlen = pext2 - pext1;
         if (nlen > 7) { pext1 = ".dat"; nlen = 4; }
         char *pcmp = pdst - nlen;
         if (pcmp < pbuf) pcmp = pbuf;
         if (nlen <= 7 && nlen < nrem && strncmp(pcmp, pext1, nlen))
         {
            memcpy(pdst, pext1, nlen);
            pdst[nlen] = '\0';
            nrem -= nlen;
         }
      }
   }

   return pbuf;
}
#endif // VFILENET

// - - - - - Coi(Table) begin - - - - -

bool Coi::bClDebug = 0;

Coi::Coi(char *pszName, char *pszRootDir)
{
   memset(this, 0, sizeof(*this));

   if (!pszName)
      { perr("int. #21161820"); return; }

   if (!strncmp(pszName, glblDotSlash, 2))
      pszName += 2;

   #ifdef VFILEBASE
   bool strEnds(char *pszStr, char *pszPat);

   bool bexpdone = 0;

   if (strBegins(pszName, "http://") || strBegins(pszName, "ftp://"))
   {
      // auto-expand http://thehost to http://thehost/
      char *psz = strstr(pszName, "//");
      if (psz) {
         psz += 2;
         psz = strchr(psz, '/');
         if (!psz) {
            int nlen = strlen(pszName);
            pszClName = new char[nlen+4];
            strcpy(pszClName, pszName);
            strcat(pszClName, "/");
            bexpdone = 1;
         }
      }
   }

   if (!bexpdone)
   #endif // VFILEBASE

   if (!(pszClName = strdup(pszName)))
      perr("out of memory: coi.ctr.1");

   pszClRoot = pszRootDir ? strdup(pszRootDir) : 0;

   mtklog(("coi ctr %p name %s proot %p", this, pszName, pszClRoot));
}

Coi::~Coi( )
{
   mtklog(("coi dtr %p %s\n", this, pszClName));

   if (nClRefs > 0) {
      perr("url has %d refs open, cannot dtr: %s", nClRefs, pszClName);
      return; // avoid instant crash
   }

   if (pdata) {
      // missing cleanup tolerance:
      if (data().pfile) {
         perr("missing close on %s",name());
         fclose(data().pfile);
      }
      // cleanup heavy data:
      delete pdata;
   }

   delstring(pszClName);
   delstring(pszClRoot);
   delstring(pszClRef);
   delstring(pszClExtStr);
   memset(this, 0, sizeof(*this));
}

Coi *Coi::copy( ) 
{
   Coi *pres = new Coi(name(), pszClRoot ? pszClRoot : 0);
   if (pszClRef) pres->setRef(pszClRef);
   if (pszClExtStr) pres->setExtStr(pszClExtStr);

   pres->nClStatus = nClStatus;
   pres->nClHave   = nClHave;
   pres->nClSize   = nClSize;
   pres->nClMTime  = nClMTime;
   pres->nClCTime  = nClCTime;
   pres->bClRead   = bClRead;
   pres->bClWrite  = bClWrite;
   pres->bClDir    = bClDir;
   pres->bClFSDir  = bClFSDir;
   pres->bClHidden = bClHidden;
   pres->bClLink   = bClLink;
   pres->bClBinary = bClBinary;
   pres->bClArc    = bClArc;
   pres->nClUCS    = nClUCS;
   pres->nClAttr   = nClAttr;

   return pres;
}

int Coi::incref(cchar *pTraceFrom)  {
   ++nClRefs;
   mtklog(("inc-ref: cnt=%d from %s on %p %s", nClRefs, pTraceFrom, this, name()));
   return nClRefs; 
}

int Coi::decref( )  {
   nClRefs--;
   mtklog(("dec-ref: cnt=%d on %p %s", nClRefs, this, name()));
   if (nClRefs < 0)
      pwarn("ref.cnt underflow (%d): %s\n", name());
   return nClRefs;
}

int Coi::refcnt( )  { 
   return nClRefs;   
}

bool Coi::debug( ) { return cs.debug || bClDebug; }

void Coi::fillFrom(void *pfdatin) // SFKFindData ptr
{
   SFKFindData *pfdat = (SFKFindData *)pfdatin;

   bClDir    = (pfdat->attrib & 0x10) ? 1 : 0;

   bClHidden = (pfdat->attrib & 0x06) ? 1 : 0;
   #ifndef _WIN32
   bClLink   = pfdat->islink ? 1 : 0;
   #endif
   nClMTime  = pfdat->time_write;
   nClCTime  = pfdat->time_create;
   nClSize   = pfdat->size;

   // 0x01 of windows finddata.attrib is readonly
   bClWrite  = (pfdat->attrib & 0x01) ? 0 : 1;

   #ifndef _WIN32
   // linux specific and informal stuff
   rawmode   = pfdat->rawmode;
   rawtype   = pfdat->rawtype;
   rawnlnk   = pfdat->rawnlnk;
   if (pfdat->bhavenode) {
      nClINode  = pfdat->ninode;
      memcpy(&oClStDev, &pfdat->ostdev, sizeof(__dev_t));
      nClHave  |= COI_HAVE_NODE;
   }
   #endif

   // flag the status fields that have been copied
   nClHave  |= COI_HAVE_DIR;
   nClHave  |= COI_HAVE_HIDDEN;
   nClHave  |= COI_HAVE_LINK;
   nClHave  |= COI_HAVE_TIME;
   nClHave  |= COI_HAVE_SIZE;

   mtklog(("coi::fillfrom done dir=%d %s", bClDir, name()));

   // remember we don't need to readStat():
   nClStatus = 1; // meta infos now available
}

int Coi::status( ) {
   return (int)nClStatus; 
}

#ifndef _WIN32
bool  Coi::haveNode( )   { return (nClHave & COI_HAVE_NODE) ? 1 : 0; }
num   Coi::getNode( )    { return nClINode; }
bool  Coi::haveFileID( ) { return haveNode(); }

const char *pGlblHexChars = "0123456789ABCDEF";

char *Coi::getFileID( )  
{
   if (!haveNode()) return str("");

   // decode binary stdev and inode into a hex string
   uchar *pdst   = (uchar*)szClFileID;
   uchar *pmax   = pdst + sizeof(szClFileID)-4;

   uchar *psrc    = (uchar*)&oClStDev;
   int  nsrcsize = sizeof(oClStDev);
   int  isrc     = 0;

   if (pdst + nsrcsize * 2 >= pmax) return str("");
   for (isrc=0; isrc<nsrcsize; isrc++) {
      *pdst++ = pGlblHexChars[(*psrc >> 4) & 0x0F];
      *pdst++ = pGlblHexChars[(*psrc >> 0) & 0x0F];
      psrc++;
   }

   psrc = (uchar*)&nClINode;
   nsrcsize = sizeof(nClINode);

   if (pdst + nsrcsize * 2 >= pmax) return str("");
   for (isrc=0; isrc<nsrcsize; isrc++) {
      *pdst++ = pGlblHexChars[(*psrc >> 4) & 0x0F];
      *pdst++ = pGlblHexChars[(*psrc >> 0) & 0x0F];
      psrc++;
   }

   *pdst = '\0';

   if (cs.debug) {
      printf("fileid=\"%s\" len=%d for \"%s\"\n",szClFileID,(int)strlen(szClFileID),name());
   }

   return szClFileID;
}
#endif

CoiData::CoiData( ) {
   mtklog(("coidata ctr %p",this));
   memset(this, 0, sizeof(*this));   
   #ifdef _WIN32
   otrav = -1;
   #endif
}

CoiData::~CoiData( ) 
{
   mtklog(("coidata dtr %p", this));

   #ifdef VFILEBASE
   if (pClFtp) {
      mtklog(("coidata dtr autoreleases ftp %p", pClFtp));
      releaseFtp();
      // do NOT delete, is managed by cache.
   }

   if (pClHeaders) {
      mtklog(("coidata dtr autoreleases headers %p", pClHeaders));
      delete pClHeaders;
   }

   if (pClHttp) {
      mtklog(("coidata dtr autoreleases http %p", pClHttp));
      releaseHttp();
      // do NOT delete, is managed by cache.
   }

   if (pelements) delete pelements;

   if (pClOrgName) delete [] pClOrgName;

   #endif // VFILEBASE

   if (src.data) delete [] src.data;

   if (rbuf.data) delete [] rbuf.data;

   if (prelsubname) delete [] prelsubname;

   if (bdiropen) perr("missing closeDir() after dir traversal, %p", this);

   if (pdirpat)  delete [] pdirpat;

   memset(this, 0, sizeof(*this));   
   #ifdef _WIN32
   otrav = -1;
   #endif
}

#ifdef VFILEBASE
// NOTE: whenever the list is changed,
//       adapt zzfind hashing of extensions.
#endif // VFILEBASE

cchar *arcExtList[] = 
{
   ".zip",".jar",".ear",".war",".aar",".xpi",
   #ifdef VFILEBASE
   #ifndef NO_TAR_SUPPORT
   // CONVENTION:
   //   on ambiguous extensions like .tar <-> .tar.gz,
   //   always list the LONGEST FIRST.
   ".tar.gz", ".tar", ".tgz",
   ".tar.bz2", ".tbz2",
   ".gz", ".bz2",
   // NOTE: .tbz not supported, as it is not clearly bzip2
   #endif
   #endif // VFILEBASE
   // up to 30 user defined ZIP archive extensions are supported:
   0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0, 0,0,0,0,0,
   0,0,0,0,0  // EOD and some tolerance
};

class StartupEnvGrabber 
{
public:
   StartupEnvGrabber();

   char szZipExtBuf[200];
};

StartupEnvGrabber glblEnvGrabber;

StartupEnvGrabber::StartupEnvGrabber() 
{
   // set SFK_ZIP_EXT=".foo .bar .myext"
   char *psz1 = getenv("SFK_ZIP_EXT");
   if (psz1) 
   {
      // find insertion index in arcExtList
      int iins = 0;
      int imax = (sizeof(arcExtList) / sizeof(char*)) - 3;
      for (; arcExtList[iins] && (iins<imax); iins++);

      // copy and split user extension list
      strcopy(szZipExtBuf, psz1);
      psz1 = szZipExtBuf;
      char *psz2 = 0;
      bool bterminal = 0;
      while (!bterminal && psz1 && *psz1) 
      {
         psz1 = strchr(psz1, '.');
         if (!psz1) break;
         psz2 = psz1+1;
         while (*psz2 && isalnum(*psz2))
            psz2++;
         bterminal = *psz2 ? 0 : 1;
         *psz2++ = '\0';
         // still space left?
         if (iins >= imax-1) {
            fprintf(stderr, "Error: too many extensions in SFK_ZIP_EXT\n");
            break;
         }
         // add another extension
         arcExtList[iins++] = psz1;
         // step to next, if !bterminal
         psz1 = psz2;
      }
   }
}

bool endsWithExt(char *pname, char *pszextin)
{
   char *psz = strrchr(pname, '.');
   if (!psz)
      return 0;
      
   if (mystricmp(psz, pszextin))
      return 0;

   return 1;
}

bool endsWithArcExt(char *pname) 
{
   // find relevant end of input name:
   // filesys : e.g. .tar.bz2
   // http url: e.g. .tar.bz2?name=val&foo=bar

   // exclusive name end point (on terminator or '?'):
   char *pend = pname + strlen(pname);

   if (strBegins(pname, "http://")) {
      char *psz = strrchr(pname, '?');
      if (psz) pend = psz;
   }

   // netto length until end point
   int nnamlen = pend - pname;

   for (int i=0; arcExtList[i]; i++) 
   {
      cchar *ppatstr = arcExtList[i];
      int  npatlen  = strlen(ppatstr);
      if (nnamlen < npatlen)
         continue;
      if (!mystrnicmp(pname + nnamlen - npatlen, ppatstr, npatlen))
         return 1;
   }

   return 0;
}

// in case of file masks, "!.zip" shall NOT
// implicitely activate archive processing.
bool maskEndsWithArcExt(char *pname)
{
   if (isNotChar(*pname))
      return 0;
      
   return endsWithArcExt(pname);
}

bool Coi::isDirOpen( ) {
   return data().bdiropen;
}

bool Coi::hasSize  ( ) { return (nClHave && COI_HAVE_SIZE) ? 1 : 0; }
bool Coi::hasTime  ( ) { return (nClHave && COI_HAVE_TIME) ? 1 : 0; }

void Coi::setSize  (num nSize) {
   nClSize  = nSize;
   nClHave |= COI_HAVE_SIZE;
}

void Coi::setTime(num nMTime, num nCTime) {
   nClMTime = nMTime;
   nClCTime = nCTime;
   nClHave |= COI_HAVE_TIME;
}

void Coi::setIsDir (bool bYesNo) {
   bClDir   = bYesNo;
   nClHave |= COI_HAVE_DIR;
}

num Coi::getSize( ) 
{
   if (nClHave & COI_HAVE_SIZE) return nClSize;
   if (!status()) readStat();
   return (status() >= 9) ? -1 : nClSize;
}

num Coi::getTime( ) 
{
   if (nClHave & COI_HAVE_TIME) {
      if (cs.usectime) return nClCTime;
      return nClMTime;
   }

   if (!status()) readStat();
   if (status() >= 9) return -1;

   if (cs.usectime) return nClCTime;
   return nClMTime;
}

uint Coi::getAttr( )
{
   if (nClHave & COI_HAVE_ATTR) return nClAttr;
   if (!status()) readStat();
   return (status() >= 9) ? 0 : nClAttr;
}

// RC >= 9: cannot set attributes
int Coi::writeAttr(uint nuxattr, bool bFullPreserve)
{
   int iSubRC = writeAttrRaw(name(), nuxattr, bFullPreserve, 0);

   if (!iSubRC)
      nClAttr = nuxattr;

   return iSubRC;
}

uint lastErrno()
{
   #ifdef _WIN32
   return GetLastError();
   #else
   return errno;
   #endif
}

// internal
int Coi::writeAttrRaw(char *pszFile, uint nuxattr, bool bFullPreserve, bool bVerbose)
{
   // valid attr are marked by this bit
   if (!(nuxattr & (1U << 31)))
      return 9; // invalid input

   #ifdef _WIN32

   uint nwinattr = GetFileAttributes(pszFile);
   
   if (nwinattr == INVALID_FILE_ATTRIBUTES)
      return 10;

   uint noldattr = nwinattr;
   
   // under windows, 'r' and 'x' flags are ignored.
   // only if all 'w' flags are cleared it is set readonly.

   if (   (nuxattr & (1U << 1)) // write.everyone
       || (nuxattr & (1U << 4)) // write.group
       || (nuxattr & (1U << 7)) // write.owner
      )
   {
      // disable readonly if set
      nwinattr &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);
   }
   else
   {
      // set readonly
      nwinattr |= FILE_ATTRIBUTE_READONLY;
   }

   if (noldattr != nwinattr) {
      if (!SetFileAttributes(pszFile, nwinattr)) {
         if (bVerbose)
            pwarn("cannot set file attributes (%d): %s\n", lastErrno(), pszFile);
         return 11;
      }
   }

   return 0;

   #else

   struct stat64 ostat;
   if (stat64(pszFile, &ostat))
      return 10;

   static bool bGotUMask = 0;
   static uint nSysUMask = 0;
   if (!bGotUMask)
   {
      bGotUMask = 1;
      // to read umask, it must be changed temporarily
      nSysUMask = umask(0);
      // change back immediately, as we now have the value
      umask(nSysUMask);
   }

   if (!bFullPreserve)
   {
      // apply umask to input attributes.
      // bits set in umask must be deleted in attributes.
      uint uiReverse = (0xFFFFFFFFUL ^ nSysUMask);
      nuxattr &= uiReverse;
   }

   uint nmode = ostat.st_mode;
   uint noldmode = nmode;

   // allow only changing of the lower 12 bits.
   // also filters out sfk specific bits.
   nmode &= 0xFFFFF000UL;
   nmode |= (nuxattr & 0xFFFUL);

   if (noldmode != nmode)
      if (chmod(pszFile, nmode))
         return 11;

   return 0;

   #endif
}

// RC >= 9: cannot make this writeable
int Coi::forceWriteable(char *pszFile)
{
   #ifdef _WIN32

   uint nwinattr = GetFileAttributes(pszFile);
   
   if (nwinattr == INVALID_FILE_ATTRIBUTES)
      return 1; // nothing to do, does not exist

   if (!(nwinattr & FILE_ATTRIBUTE_READONLY))
      return 2; // nothing to do, is writeable

   nwinattr &= (0xFFFFFFFFUL ^ FILE_ATTRIBUTE_READONLY);

   if (!SetFileAttributes(pszFile, nwinattr))
      return 9; // cannot change

   #else

   struct stat64 ostat;
   if (stat64(pszFile, &ostat))
      return 1; // nothing to do, does not exist

   uint nmode = ostat.st_mode;
   
   if (nmode & (1UL << 7))
      return 2; // nothing to do, is writeable

   nmode |= (1UL << 7);

   if (chmod(pszFile, nmode))
      return 9; // cannot change

   #endif

   return 0; // OK changed
}

int Coi::setExtStr(char *psz) {
   delstring(pszClExtStr);
   if (psz)
      if (!(pszClExtStr = strdup(psz)))
         return 9;
   return 0;
}

char *Coi::getExtStr( ) {
   return pszClExtStr;
}

#ifdef _WIN32
   #ifdef _MSC_VER
      #ifdef SFK_W64
      typedef struct __stat64 sfkstat_t;
      #else
      typedef struct stat sfkstat_t;
      #endif
   #else
      typedef struct stat sfkstat_t;
   #endif
#else
   typedef struct stat64 sfkstat_t;
#endif

int Coi::readStat( )
{__
   // NOTE: readStat cannot fetch "hidden" and "link" file info.
   //       such info seems to be available only via findFirstFile().

   // if filesystem meta infos already read,
   // or any error already occured, do nothing:
   if (nClStatus > 0) return nClStatus;

   #ifdef VFILEBASE
   // virtual files MUST be blocked from native FS access
   if (isNet() || isZipSubEntry())
   {
      // defensive information gathering:
      // if ANY infos exist, assume that the vfile meta info
      // have already been fetched in a different way,
      // so avoid expensive retrieval operations.
      if (nClHave) {
         nClStatus = 1;
         return 0;
      }

      // in case of Http, try an expensive header access:
      if (isHttp()) {
         if (data().getHttp(name())) return 9;
         HTTPClient *phttp = data().pClHttp;
         if (phttp->getFileHead(name(), this, "stat"))
            { nClStatus = 9; return 9; }
         // sets binary, size
         nClStatus = 1;
         return 0;
      }

      // in any case, block nativeFS access on virtuals:
      nClStatus = 1; // "sorry, we know nothing."
      return 0;
   }
   #endif // VFILEBASE

   sfkstat_t ostat;

   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   num aExtTimes[2];
   memset(aExtTimes, 0, sizeof(aExtTimes));
   if (getFileStat(name(), bIsDir, bCanRead, bCanWrite, 
      nFileTime, nFileSize, aExtTimes,
      &ostat, sizeof(ostat)
      ))
   {
      mtklog(("coi.stat failed: %s have=%u", name(), nClHave));
      nClStatus = 9;
      return 9;
   }

   nClStatus = 1; // read metadata successfully

   nClSize  =       nFileSize;   nClHave |= COI_HAVE_SIZE;
   nClMTime =       nFileTime;   nClHave |= COI_HAVE_TIME;
   nClCTime =    aExtTimes[0];
   bClRead  = (bool)bCanRead;    nClHave |= COI_HAVE_READ;
   bClWrite = (bool)bCanWrite;   nClHave |= COI_HAVE_WRITE;
   bClDir   = (bool)bIsDir;      nClHave |= COI_HAVE_DIR;

   nClAttr  = ostat.st_mode;     nClHave |= COI_HAVE_ATTR;

   // add sfk flags
   nClAttr |= (1U << 31);  // attribs are valid
   #ifndef _WIN32
   nClAttr |= (1U << 30);  // source is linux
   #endif
   
   mtklog(("coi.stat r=%d w=%d dir=%d %s", bClRead, bClWrite, bClDir, name()));

   return 0;
}

bool Coi::isWriteable( ) 
{
   #ifdef VFILEBASE
   // any virtual file?
   if (isNet()) return 0;
   if (isZipSubEntry() > 0) return 0;
   if (isTravelZip()) return 0;
   #endif // VFILEBASE

   mtklog(("coi::iswriteable.1 %d %d %s",bClWrite,nClStatus,name()));

   // only physical files are writeable, so far.
   if (!nClStatus) readStat();
   if (bClDir) return 0;

   mtklog(("coi::iswriteable.2 %d %d %s",bClWrite,nClStatus,name()));

   return bClWrite;
}

char *Coi::relName( ) 
{
   char *pszabs = name();

   // native file:
   char *prel = strrchr(pszabs, glblPathChar);
   if (prel) return prel+1;

   #ifdef _WIN32
   // c:thefile.txt
   prel = strrchr(pszabs, ':');
   if (prel) return prel+1;
   #endif

   return pszabs;
}

char *Coi::rootRelName( ) 
{
   char *relName(char *pszRoot, char *pszAbs);
   if (pszClRoot) 
   {
      mtklog(("coi.rootrelname: %s %.10s %.10s", relName(pszClRoot, pszClName), pszClRoot, pszClName));
      if (debug()) printf("coi.rootrelname: %s\n", relName(pszClRoot, pszClName));
      char *prel = relName(pszClRoot, pszClName);
      // special case: theroot.zip\\thesub.txt
      // then now holding: "\thesub.txt"
      if (*prel == glblPathChar) prel++;
      return prel;
   }
   if (debug()) printf("coi.rrname.noroot: %s\n", pszClName);
   return pszClName;
}

bool Coi::isAnyDir( ) 
{
   if (bGlblSyntaxTest) {
      // if just simulating, check how the name looks
      if (!strcmp(name(), ".")) return 1;
      return strstr(name(), "dir") ? 1 : 0;
   }

   int n = 0;

   #ifdef VFILEBASE
   if (isTravelZip()) {
      bClDir = 1;
      mtklog(("%d = isanydir(%s) by trvzip", bClDir, name()));
      nClHave |= COI_HAVE_DIR;
      return bClDir;
   }
   if ((n = isZipSubEntry())) 
   {
      switch (n) {
         case 1: bClDir = 0; break; // file within zip
         case 2: bClDir = 1; break; // dir within zip (but not traversable)
      }
      mtklog(("%d = isanydir(%s) by zipsub (%d)", bClDir, name(), n));
      nClHave |= COI_HAVE_DIR;
      return bClDir;
   }
   #endif // VFILEBASE

   if (nClHave & COI_HAVE_DIR) {
      mtklog(("%d = isanydir(%s) as stored", bClDir, name()));
      return bClDir;
   }

   // dir status not yet determined
   bClDir = 0;

   #ifdef VFILEBASE
   if (isHttp()) {
      bClDir = rawIsHttpDir();
      mtklog(("%d = isanydir(%s) by httpdir", bClDir, name()));
   }
   else
   if (isFtp()) {
      bClDir = rawIsFtpDir();
      mtklog(("%d = isanydir(%s) by ftpdir", bClDir, name()));
   }
   else
   #endif // VFILEBASE
   {
      bClDir = rawIsDir();
      mtklog(("%d = isanydir(%s) by fs", bClDir, name()));
   }

   // avoid redundant high-effort reads of dir info
   nClHave |= COI_HAVE_DIR;

   return bClDir;
}  // Coi::isAnyDir

bool Coi::isTravelDir( ) 
{
   if (bGlblSyntaxTest) {
      // if just simulating, check how the name looks
      if (!strcmp(name(), ".")) return 1;
      return strstr(name(), "dir") ? 1 : 0;
   }

   // make sure raw status is determined
   bool brawdir = isAnyDir();

   #ifdef VFILEBASE
   if (isTravelZip())   brawdir = 1;   // per definitionem
   else
   if (isZipSubEntry()) brawdir = 0;   // travel done otherwise
   #endif // VFILEBASE

   mtklog(("%d = istravdir(%s)", brawdir, name()));

   return brawdir;
}

bool Coi::rawIsDir( ) {
   if (!nClStatus)
      readStat();
   return bClDir;
}

// used so far only for http redirects
int Coi::setName(char *psz, char *pszOptRoot)
{
   #ifdef VFILEBASE
   if (pszClName && hasData() && !data().pClOrgName) 
   {
      // do not delete first name,
      // but refunction it as the org name.
      data().pClOrgName = pszClName;
      pszClName = 0;
   }
   #endif // VFILEBASE

   if (pszClName) delete [] pszClName;

   pszClName = strdup(psz);

   if (pszOptRoot) {
      if (pszClRoot) delete [] pszClRoot;
      pszClRoot = strdup(pszOptRoot);
   }

   return 0;
}

char  *Coi::name( ) { return pszClName ? pszClName : str(""); }

#ifdef VFILEBASE
char  *Coi::orgName( ) 
{
   if (hasData() && data().pClOrgName)
      return data().pClOrgName;
   return name();
}
#endif // VFILEBASE

char  *Coi::root(bool braw) {
   if (braw) return pszClRoot;
   return pszClRoot ? pszClRoot : (char*)""; 
}

char  *Coi::ref (bool braw) { 
   if (braw) return pszClRef;
   return pszClRef ? pszClRef : (char*)""; 
}

int  Coi::setRef(char *pszName) {
   delstring(pszClRef);
   if (pszName) 
      if (!(pszClRef = strdup(pszName)))
         return 9;
   return 0;
}

CoiData &Coi::data( )
{
   if (!pdata)
      pdata = new CoiData();
   return *pdata;
}

bool Coi::hasData( )    { return pdata ? 1 : 0; }

#ifdef VFILEBASE
bool Coi::isCached( )   { return bClInCache; }
bool Coi::hasContent( ) { return (pdata && pdata->src.data) ? 1 : 0; }
#endif // VFILEBASE

bool Coi::isFileOpen( ) {
   // the open flag itself is managed via pdata
   if (!pdata) return 0;
   return data().bfileopen;
}

void Coi::setContent(uchar *pdata, num nsize, num ntime)
{__
   num nOldSize = data().src.size;
   num nNewSize = nsize;

   if (data().src.data) {
      delete [] data().src.data;
      mclear(data().src);
   }

   if (pdata) {
   
      data().src.data = pdata;
      data().src.size = nsize;
      data().src.time = ntime;

      // fix: 173: missing meta data update after setContent
      setSize(nsize);
      setTime(ntime, ntime);
      
   }

   #ifdef VFILEBASE
   // cache checks itself if coi is really cached
   glblVCache.tellByteSizeChange(this, nOldSize, nNewSize);
   #endif // VFILEBASE
}

int Coi::releaseContent( )
{__
   setContent(0,0); // free existing

   if (data().rbuf.data) {
      mtklog(("coi releases rbuf: %s",name()));
      delete [] data().rbuf.data;
      mclear(data().rbuf);
   }

   return 0;
}

int Coi::getContent(uchar **ppdata, num &rnSize)
{__
   if (!ppdata) return 9; // parameter error

   *ppdata = 0; // safety
   rnSize  = 0; // safety

   if (data().src.data) 
   {
      // was already loaded
      *ppdata = data().src.data;
      rnSize  = data().src.size;
      return 0;
   }

   #ifdef VFILEBASE
   // load file of known or unknown size?
   if (isNet())
   {
      // always expect unknown sizes from the net
      mtklog(("loadownraw, expect unknown size: %s", name()));
      uchar *pdata = 0;
      num    nsize = 0;
      int nrc = 0;
      if ((nrc = loadOwnFileRaw(100 * 1000000, &pdata, nsize))) {
         mtklog(("loadownraw failed, %d", nrc));
         return 9;   // failed
      }
  
      mtklog(("loadownraw ok, %d bytes", (int)nsize));

      setContent(pdata, nsize);

      *ppdata = data().src.data;
      rnSize  = data().src.size;

      return 0;
   }
   #endif // VFILEBASE

   char *pszFile = name();

   num nFileSize = getSize();
   if (nFileSize < 0)
      return 9+perr("unable to read: %s", pszFile);

   num nFileTime = getTime();

   // if FileSize == 0, using a dummy buffer.

   num nTolerance = 100;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut)
      return 9+perr("out of memory: %s\n", pszFile);
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      perr("cannot read: %s\n", pszFile);
      delete [] pOut;
      return 9;
   }

   int nRead = myfread((uchar*)pOut, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      perr("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pOut;
      return 9;
   }

   // zero termination is always guaranteed.
   pOut[nFileSize] = '\0';

   setContent((uchar*)pOut, nFileSize, nFileTime);

   *ppdata = data().src.data;
   rnSize  = data().src.size;

   return 0;
}

bool Coi::existsFile(bool bOrDir)
{
   char *pszName = name();

   #ifdef VFILEBASE
   if (isNet())         return 1; // assume it exists
   if (isZipSubEntry()) return 1; // assume it exists
   // .zip file: fall through
   #endif // VFILEBASE

   #ifdef _WIN32

   DWORD nAttrib = GetFileAttributes(pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (!bOrDir && (nAttrib & FILE_ATTRIBUTE_DIRECTORY))
      return 0; // is a dir, not a file

   #else

   // linux
   struct stat64 buf;
   if (stat64(pszName, &buf))
      return 0;
   if (!bOrDir && (buf.st_mode & _S_IFDIR))
      return 0; // is a dir, not a file

   #endif

   // we can get the attribs, and it's not a dir,
   // so expect that it is a file.
   return 1;
}

int Coi::getOpenElapsedTime( )
{
   if (!pdata)
      return 0;
      
   if (!data().nopentime)
      return 0;
      
   return (int)(getCurrentTime() - data().nopentime);
}

int Coi::open(cchar *pmode)
{__
   mtklog(("coi-open %p %s %s %p",this,name(),pmode));

   // reset per-file statistics
   resetIOStatus();

   #ifdef VFILEBASE
   // in case of vfiles, make sure required inputs
   // are loaded, e.g. http://foo.zip//bar.zip//file.txt
   // RECURSION BLOCK: for now, we call provideInput
   // ONLY for zip sub entries. netFiles are expected
   // to be cached otherwise, but not through pinput.
   if (isZipSubEntry())
      if (provideInput(__LINE__))
         return 9;
   #endif // VFILEBASE

   // (re)init in case that readLine is used:
   if (data().rbuf.data) delete data().rbuf.data;
   memset(&data().rbuf, 0, sizeof(data().rbuf));

   // supported modes: "rb","r+b","wb"
   data().bwrite     = 0;
   data().szmode[0]  = '\0';
   data().ntotalread = 0;
   #ifdef VFILEBASE
   data().bstopread  = 0;
   #endif // VFILEBASE
   data().banyread   = 0;
   data().nopentime  = getCurrentTime();

   if (!strcmp(pmode, "rb"))
      { } // pure read is always ok
   else
   if (!strcmp(pmode, "r")) {
      // read of text: open as binary
      pmode = "rb";
      // but stop as soon as binary is detected.
      data().bstoprdbin = 1;
   }
   else
   if (!strcmp(pmode, "r+b") || !strcmp(pmode, "wb")) {
      #ifdef VFILEBASE
      if (isVirtual(1)) // WITH root zips
         return 9+perr("write not supported: %s", name());
      #endif // VFILEBASE
      // TODO: not sure if this protects utf16 files in every case,
      //       so far it requires an isBinary() check before.
      if (nClUCS)
         return 9+perr("write to utf-16 file not supported: %s", name());
      // read+write ok
      data().bwrite = 1;
   }
   else
      return 9+perr("unsupported mode \"%s\": %s", pmode, name());

   // remember I/O mode
   strcopy(data().szmode, pmode);

   // take cached data?
   if (data().src.data) 
   {
      if (data().bwrite) {
         // re-write of a file: reset cache
         mtklog(("coi-open for write: reset cache"));
         setContent(0,0);
      } else {
         // read: simply reset read index
         mtklog(("coi-open uses cached data, %d bytes",data().src.size));
         data().src.index = 0;
         return 0;
      }
   }

   #ifdef VFILEBASE
   // this can be reached in READ mode only
   // http://thehost/thefile.txt
   if (isHttp()) return rawOpenHttpSubFile(pmode);
   if (isFtp())  return rawOpenFtpSubFile(pmode);
   #endif // VFILEBASE

   // native file I/O: thefile.dat
   data().pfile = fopen(name(), pmode);
   if (data().pfile) {
      data().bfileopen = 1;
      return 0;
   }
   return 9;
}

cchar *Coi::lasterr( ) {
   if (!hasData()) return "";
   return data().szlasterr;
}

#define MY_GETBUF_MAX ((MAX_LINE_LEN+10)*5)

void Coi::setBinaryFile(bool bYesNo) {
   bClBinary = bYesNo;
   nClHave  |= COI_HAVE_BINARY;
}

bool isTextChar(uchar uc) {
   if (uc >= 0x1C) return 1;
   switch (uc) {
   // case 0x04: return 1; // EOT
   // case 0x07: return 1; // BEL
      case 0x08: return 1; // BS
      case 0x09: return 1; // TAB
      case 0x0A: return 1; // LF
      case 0x0C: return 1; // FF
      case 0x0D: return 1; // CR
      case 0x1A: return 1; // EOF
      case 0x1B: return 1; // ESC
   }
   return 0;
}

uchar Coi::isUTF16( ) { return nClUCS; }

bool Coi::isSnapFile( ) { return bClSnap; }

int Coi::iBinaryCheckSize = 4096;

bool Coi::isBinaryFile( )
{__ _p("sf.isbin")

   // if binary status was alread set, return it:
   if (nClHave & COI_HAVE_BINARY)
      return bClBinary;

   // TODO: buffer file header data, then reuse on later reads
   if (open("rb")) return 0;

   mtklog(("coi isbinary %p", this));
 
   // assure read buffer on demand
   if (!data().rbuf.data) {
      memset(&data().rbuf, 0, sizeof(data().rbuf));
      data().rbuf.data = new uchar[MY_GETBUF_MAX+100];
   }

   bool brc = 0;
   
   do
   {
      int nCheckLen = MY_GETBUF_MAX - 10;
      
      if (nCheckLen > iBinaryCheckSize) 
         nCheckLen = iBinaryCheckSize;
      
      int nRead = readRaw(data().rbuf.data, nCheckLen);
      
      // no checks on empty files
      if (nRead <= 0)
         break;
      
      // always assure zero-term'ed memory
      if (nRead <= nCheckLen)
         data().rbuf.data[nRead] = '\0'; // safety
   
      // if (cs.wchardec) 
      {
         // ucs-2 heuristic detection
         uint blehead=0,bbehead=0;
         uchar *pdat = data().rbuf.data;
      
         if (nRead>=2 && pdat[0]==0xFF && pdat[1]==0xFE) blehead=1;
         if (nRead>=2 && pdat[0]==0xFE && pdat[1]==0xFF) bbehead=1;
         if (blehead || bbehead) {
            // scan first part of text for double-byte chars.
            // accept only very low code points.
            int nWChars = (nRead - 2) / 2;
            if (nWChars > 10) nWChars = 10;
            int iwc=0;
            for (iwc=0; iwc<nWChars; iwc++) {
               uchar nlo = pdat[2+iwc*2+bbehead];
               uchar nhi = pdat[2+iwc*2+blehead];
               if (!isTextChar(nlo) || isTextChar(nhi))
                  break;
            }
            if (iwc >= nWChars) {
               // count detected ucs-2 files
               gs.utf16found++;
               mtklog(("utf16%s%s, dec=%d: %s\n",blehead?"le":"",bbehead?"be":"",(int)cs.wchardec,name()));
               // but are we allowed to decode?
               if (cs.wchardec) {
                  if (blehead) nClUCS = (uchar)0xFE;
                  if (bbehead) nClUCS = (uchar)0xEF;
                  if (cs.verbose)
                     printf("utf16%s%s: %s\n",blehead?"le":"",bbehead?"be":"",name());
               }
            }
         }
      }
   
   
      if (!brc && !nClUCS) {
         // binary data heuristic detection
         // for (int i=0; i<nRead; i++)
         //    if (data().rbuf.data[i] == 0x00)
         //       { brc=1; break; }
         if (memchr(data().rbuf.data, 0, nRead))
            brc=1;
      }
      
      // sfk snapfile detection
      {
         const char *ppat = ":snapfile sfk,";
         int npatlen = strlen(ppat);
         if ((nRead > npatlen) && strBegins((char*)data().rbuf.data, (char*)ppat))
            bClSnap = 1;

         ppat = ":cluster sfk,";
         npatlen = strlen(ppat);
         if ((nRead > npatlen) && strBegins((char*)data().rbuf.data, (char*)ppat))
            bClSnap = 1;
      }
   }
   while (0);
   
   // currently, this frees the rbuf.data!
   close();

   bClBinary = brc;
   nClHave  |= COI_HAVE_BINARY;

   mtklog(("%d = coi::isbinary %s",brc,name()));

   return brc;
}

// TODO: rework rc handling in case of error
int Coi::readLine(char *pszOutBuf, int nOutBufLen)
{_p("sf.readln")

   if (!data().rbuf.data) {
      memset(&data().rbuf, 0, sizeof(data().rbuf));
      data().rbuf.data = new uchar[MY_GETBUF_MAX+100];
   }

   if (data().rbuf.getsize  < 0 || data().rbuf.getsize  > MY_GETBUF_MAX) return 0+perr("int. #62 %d %d\n",(data().rbuf.getsize < 0),(data().rbuf.getsize > MY_GETBUF_MAX));
   if (data().rbuf.getindex < 0 || data().rbuf.getindex > MY_GETBUF_MAX) return 0+perr("int. #63 %d %d\n",(data().rbuf.getindex < 0),(data().rbuf.getindex > MY_GETBUF_MAX));
   if (data().rbuf.geteod > 1) return 0+perr("int. #65\n");

   // if remaining data is less than halve of buffer, read next block
   if (!data().rbuf.geteod && ( data().rbuf.getsize < (MY_GETBUF_MAX/2)-100 ))
   {_p("sf.readl1")
   
      // move remaining cache data to front of buffer
      int nindex  = data().rbuf.getindex;
      int nremain = data().rbuf.getsize;
      if (nindex + nremain < 0) return 0+perr("int. #60\n");
      if (nindex + nremain > MY_GETBUF_MAX) return 0+perr("int. #61\n");
      if (nremain > (MY_GETBUF_MAX/2)) return 0+perr("int. #62\n");
      if (nremain > 0)
      {
         // FIX: 1722: read from zip with sfk x64 produced wrong data
         //      due to memcpy on overlapping buffer
         memmove(data().rbuf.data, &data().rbuf.data[nindex], nremain);
      }

      // now remaining data starts from front of buffer,
      // filling less than the first halve of the buffer.
      data().rbuf.getindex = 0;

      // re-fill remaining buffer space
      int nBufFree = MY_GETBUF_MAX - data().rbuf.getsize;
      uchar *pRead  = data().rbuf.data + data().rbuf.getsize;

      int nRead = 0;
      if ((nRead = read(pRead, nBufFree)) <= 0)
         data().rbuf.geteod = 1;
      else
         data().rbuf.getsize += nRead;
   }

   // anything remaining?
   if (data().rbuf.getsize == 0) {
      data().rbuf.geteod = 2;
      return 0;
   }

   // copy next line from copy index
   uchar *psrc     = data().rbuf.data + data().rbuf.getindex;
   uchar *psrcmax  = psrc + data().rbuf.getsize;
   if (psrcmax > data().rbuf.data + MY_GETBUF_MAX) return 0+perr("int. #63");

   uchar *pdst     = (uchar*)pszOutBuf;
   uchar *pdstmax  = pdst + nOutBufLen - 10;

   bool bBinary    = 0;
   int  nSrcBytes  = 0;
   int  nDstBytes  = 0;

   {_p("sf.readl2")
   
      for (; psrc < psrcmax && pdst < pdstmax;)
      {
         uchar c1 = *psrc++;
         nSrcBytes++;
   
         if (c1 == 0x00 || c1 == 0x1A) {
            if (!c1)
               bBinary = 1;
            c1 = (uchar)'.';
         }
         else
         if (c1 == (uchar)'\r')
            continue;
   
         *pdst++ = (char)c1;
         nDstBytes++;
   
         if (c1 == (uchar)'\n')
            break;
      }
      *pdst = '\0';
   
   }
 
   data().rbuf.getindex += nSrcBytes; // copy next line from there
   data().rbuf.getsize  -= nSrcBytes; // reduce remaining bytes in buf
   data().rbuf.getpos   += nSrcBytes; // absolute source position in file

   if (bBinary && data().bstoprdbin)
      return 0; // "EOD", force end of reading

   return nDstBytes;
}

size_t Coi::read(void *pbufin, size_t nBufSize)
{__ _p("sf.read")

   if (nClUCS && (nBufSize & 0x1UL)) {
      // force even buffer size on ucs-2
      nBufSize ^= (size_t)0x1UL;
      if (!nBufSize)
         return 0+perr("cannot read ucs-2, buffer too small: %s", name());
   }

   bool bfirst = data().banyread ? 0 : 1;

   size_t nraw = readRaw(pbufin, nBufSize);
   size_t nres = nraw; // resulting size

   data().banyread = 1;

   if (nClUCS) 
   {
      // transparent ucs-2 decoding.
      // this will return less bytes than nBufSize!
      if (nBufSize & 1) // shouldn't happen due to above alignment
         return 0+perr("cannot read ucs-2, uneven buffer size: %s", name());

      uchar *psrc    = (uchar*)pbufin;
      uchar *psrcmax = (uchar*)pbufin + nraw;
      uchar *pdst    = (uchar*)pbufin;
      uchar *pdstbeg = pdst;
      uchar *pdstmax = (uchar*)pbufin + nBufSize;

      // skip byte order mark?
      if (nClUCS == 0xFE && psrc[0] == 0xFF && psrc[1] == 0xFE)
         psrc += 2;
      else
      if (nClUCS == 0xEF && psrc[0] == 0xFE && psrc[1] == 0xFF)
         psrc += 2;

      // copy loop with zero truncation
      uint nreloff = (nClUCS == 0xFE) ? 0 : 1;
      while (psrc < psrcmax && pdst < pdstmax) {
         *pdst++ = psrc[nreloff];
         psrc += 2;
      }

      // calc new netto size
      nres = pdst - pdstbeg;

      mtklog(("filtered %d ucs-2 chars", (int)nres));

      if (bfirst) gs.utf16read++;
   }

   return nres;
}

size_t Coi::readRaw(void *pbufin, size_t nBufSize)
{__
   // take cached data?
   if (data().src.data) 
   {
      int nremain = data().src.size - data().src.index;
      int ntocopy = (int)nBufSize;
      if (ntocopy > nremain) ntocopy = nremain;
      if (ntocopy > 0) {
         memcpy(pbufin, data().src.data + data().src.index, ntocopy);
         data().src.index += ntocopy;
      }
      mtklog(("coi-read copied %d bytes from cache idx %d", ntocopy, (int)data().src.index));
      data().ntotalread += ntocopy;
      return ntocopy;
   }

   #ifdef VFILEBASE
   if (isHttp())  {
      size_t nread = rawReadHttpSubFile(pbufin, nBufSize);
      data().ntotalread += nread;
      return nread;
   }

   if (isFtp())   {
      size_t nread = rawReadFtpSubFile(pbufin, nBufSize);
      data().ntotalread += nread;
      return nread;
   }
   #endif // VFILEBASE

   // native file I/O:
   if (!data().pfile) {
      perr("read on non-open file: %s",name());
      return 0;
   }

   uchar *pBuf = (uchar *)pbufin;

   size_t nOffset = 0;
   size_t nRemain = nBufSize;
   while (nRemain > 0)
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nReadSub = fread(pBuf+nOffset, 1, nBlock, data().pfile);
      if (nReadSub <= 0)
         break;

      nOffset += nReadSub;
      nRemain -= nReadSub;

      // if (nMax > 0)
      //    info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   // if (nOffset > 0 && pmd5 != 0)
   //    pmd5->update(pBuf, nOffset);

   data().ntotalread += nOffset;

   return nOffset;
}

// rc0:ok >=0:failed to seek
int Coi::seek(num nOffset, int nOrigin)
{__
   if (nOrigin != SEEK_SET)
      return 9+perr("internal: seek: supports only SEEK_SET");

   #ifdef VFILEBASE
   if (!data().src.data && isVirtual()) // w/o root zips
   {
      // force caching of virtual files, except root zips
      uchar *pdummy = 0;
      num    ndummy = 0;
      if (getContent(&pdummy, ndummy))
         return 9+perr("seek failed: %s", name());
      // else fall through to cache use
   }   
   #endif // VFILEBASE

   // take cached data?
   if (data().src.data) 
   {
      mtklog(("coi::seek to %d in cache", (int)nOffset));
      if (nOffset < 0 || nOffset > data().src.size)
         return 9+perr("cannot seek to position %s", numtoa(nOffset));
      data().src.index = nOffset;
      return 0;
   }

   #ifdef VFILEBASE
   // virtual file I/O: shouldn't be reached
   if (isHttp())  return 9+perr("cannot seek on http file");
   if (isFtp())   return 9+perr("cannot seek on ftp file");
   if (isZipSubEntry()) return 9+perr("cannot seek on zip entry");
   #endif // VFILEBASE

   // native file I/O:
   if (!data().pfile) {
      perr("seek on non-open file: %s",name());
      return 0;
   }

   FILE *f = data().pfile;

   #ifdef _WIN32
   if (sizeof(num) != sizeof(fpos_t)) return 9+perr("internal: myfseek: wrong fpos_t size, need 64 bits");
   return fsetpos(f, &nOffset);
   #else
   fpos64_t xpos;
   if (fgetpos64(f, &xpos)) // read xpos.__state
      return 9+perr("internal: seek: failed to read position");
    #if defined(MAC_OS_X) || defined(SOLARIS)
     xpos = (fpos_t)nOffset;
    #else
     if (sizeof(xpos.__pos) != sizeof(nOffset)) return 9+perr("internal: myfseek: wrong __pos size, need 64 bits");
     xpos.__pos = nOffset;
    #endif
   return fsetpos64(f, &xpos);
   #endif
}

size_t Coi::write(uchar *pBuf, size_t nBytes)
{__
   if (data().src.data)
      return 9+perr("write: conflict with cached data");

   #ifdef VFILEBASE
   // virtual file I/O:
   if (isHttp())  return 9+perr("cannot write on http file");
   if (isFtp())   return 9+perr("cannot write on ftp file");
   if (isZipSubEntry()) return 9+perr("cannot write on zip entry");
   #endif // VFILEBASE

   // native file I/O:
   if (!data().pfile) {
      perr("write on non-open file: %s",name());
      return 0;
   }

   size_t nOffset = 0;
   size_t nRemain = nBytes;

   while (nRemain > 0)
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nWriteSub = fwrite(pBuf+nOffset, 1, nBlock, data().pfile);
      if (nWriteSub != nBlock)
         return nOffset+nWriteSub; // return no. of bytes actually written

      nOffset += nWriteSub;
      nRemain -= nWriteSub;

      // if (nMax > 0)
      //    info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   // if (nOffset > 0 && pmd5 != 0)
   //    pmd5->update(pBuf, nOffset);

   return nOffset;
}

void Coi::close( )
{__
   mtklog(("coi-close %p %s", this, name()));

   // reset per-file statistics
   resetIOStatus();

   // assuming: close methods below do NOT use rbuf
   if (data().rbuf.data) {
      mtklog(("coi-close deletes rbuf %p size %d", data().rbuf.data, data().rbuf.getsize));
      delete [] data().rbuf.data;
   }
   memset(&data().rbuf, 0, sizeof(data().rbuf));
 
   if (data().src.data) {
      mtklog(("coi-close finished read from cache"));
      data().src.index = 0; // safety
      return;
   }
 
   #ifdef VFILEBASE
   // http://thehost/thefile.txt
   if (isHttp())  { rawCloseHttpSubFile(); return; }
   if (isFtp())   { rawCloseFtpSubFile(); return; }
   #endif // VFILEBASE
 
 
   // in any case, reset the flag:
   data().bfileopen = 0;

   // native file I/O:
   if (!data().pfile) {
      perr("close on non-open file: %s",name());
      return;
   }

   fclose(data().pfile);
   data().pfile = 0;
   
   // keeptime is applied only after data was written.
   // this may also happen later after a second open/close
   // on the same Coi to overwrite the input file.
   if (bClSetWriteCloseTime) 
   {
      if (data().bwrite) {
         if (cs.debug)
            printf("applying -keeptime after write close: %s\n", name());
         int iSubRC = applyWriteCloseTime();
         if (iSubRC)
            pwarn("cannot set file time (rc=%d) for: %s\n",iSubRC,name());
      } else {
         if (cs.debug)
            printf("skipping -keeptime after non write close: %s\n", name());
      }
   }
}

int Coi::setKeepTime(Coi *pSrc)
{__
   // pSrc can also be == this

   // make sure filestat is read on src
   if (pSrc->getTime() <= 0)
      return 5; // does not apply

   // then copy whatever is set
   nClMTime = pSrc->nClMTime;
   nClCTime = pSrc->nClCTime;

   // and remember to apply this on write close
   bClSetWriteCloseTime = 1;

   return 0;
}

#ifdef _WIN32
int makeWinFileTime(num nsrctime, FILETIME &rdsttime, num nSrcNanoSec=0);   
#endif

int Coi::applyWriteCloseTime( )
{__
   bClSetWriteCloseTime = 0;

   if (!data().bwrite)
      return 5; // ignored, file was not written

   #ifdef _WIN32

   HANDLE hDst = CreateFile(
      name(),
      FILE_WRITE_ATTRIBUTES,
      0,    // share
      0,    // security
      OPEN_EXISTING,
      bClDir ? FILE_FLAG_BACKUP_SEMANTICS : FILE_ATTRIBUTE_NORMAL,
      0     // template file
      );
   if (hDst == INVALID_HANDLE_VALUE)
      return 10;

   int nrc = 0;

   FILETIME nDstMTime, nDstCTime;
   FILETIME *pMTime=0, *pCTime=0;

   if (nClMTime > 0) 
   {
      if (!makeWinFileTime(nClMTime, nDstMTime))
         pMTime = &nDstMTime;
      else
         nrc = 11;
   }

   if (nClCTime > 0) 
   {
      if (!makeWinFileTime(nClCTime, nDstCTime))
         pCTime = &nDstCTime;
      else
         nrc = 12;
   }

   #ifdef WINFULL
   if (!nrc && (pMTime || pCTime)) {
      if (!SetFileTime(hDst, pCTime, 0, pMTime)) {
         perr("cannot set file time (rc=%u): %s\n", (uint)GetLastError(), name());
         nrc = 13;
      }
   }
   #endif
   
   CloseHandle(hDst);

   return nrc;

   #else

   // linux generic: set only mtime

   if (nClMTime <= 0)
      return 1; // nothing to set

   struct utimbuf otimes;
   mclear(otimes);

   otimes.modtime = nClMTime;

   int iRC = utime(name(), &otimes);
   if (iRC) return 9+perr("failed to set file times (rc=%d): %s\n",iRC,name());

   return 0;

   #endif
}

int Coi::openDir( )
{__
   #ifdef VFILEBASE
   if (isTravelZip() || isNet()) {
      int nrc = rawLoadDir();
      if (nrc >= 5) return nrc; // failed
      data().bdiropen = 1;
      return 0;
   }
   #endif // VFILEBASE

   if (rawIsDir())
      return rawOpenDir();

   perr("no filesystem directory, cannot open: %s", name());
   return 9;
}

// caller MUST RELEASE COI after use!
Coi *Coi::nextEntry( )
{__
   // additional filter loop: block any kind of endless
   // link looping, i.e. dir links within a dir to itself.
   while (1)
   {
      Coi *psub = nextEntryRaw();
      if (!psub) return 0;
      if (psub == this) {
         mtklog(("coi.nextentry: skip sub == top for %p", psub));
         // psub is OWNED BY US, so release it first.
         if (!psub->decref())
            perr("int. #1310281137"); // should NOT happen
         // do NOT delete! it was a double ref onto THIS.
         continue;
      }
      if (!strcmp(psub->name(), name())) {
         mtklog(("coi.nextentry: skip equal sub %p, top %p for name %s", psub, this, psub->name()));
         // psub is OWNED BY US, so release it first.
         if (!psub->decref())
            delete psub; // no refs remaining, not cached
         continue;
      }
      // is different, return entry.
      return psub;
   }
   return 0; // not reached
}

// caller MUST RELEASE COI after use!
Coi *Coi::nextEntryRaw( )
{__
   #ifdef VFILEBASE
   if (isHttp())  return rawNextHttpEntry();
   if (isFtp())   return rawNextFtpEntry();
   #endif // VFILEBASE

   if (rawIsDir()) return rawNextEntry();

   perr("no directory, cannot read: %s", name());
   return 0;
}

void Coi::closeDir( )
{__
   mtklog(("coi::closedir %p", this));

   #ifdef VFILEBASE
   if (isHttp())  return rawCloseHttpDir();
   if (isFtp())   return rawCloseFtpDir();
   #endif // VFILEBASE

   if (rawIsDir())
      return rawCloseDir();

   perr("no directory, cannot close: %s", name());
}

int Coi::rawOpenDir( ) 
{
   int joinPath(char *pszDst, int nMaxDst, char *pszSrc1, char *pszSrc2);

   // prepare traversal pattern, or simply
   // the directory name stripped from possible slash

   int nsize1 = strlen(name());
   if (data().pdirpat) delete [] data().pdirpat;
   data().pdirpat = new char[nsize1+12];
   #ifdef _WIN32
   joinPath(data().pdirpat, nsize1+8, name(), (char*)"*");
   #else
   joinPath(data().pdirpat, nsize1+8, name(), (char*)"");
   #endif
   
   #ifdef _WIN32

   // delay real actions until first nextEntry()

   #else

   // linux:
   if (!(data().ptrav = opendir(data().pdirpat)))
      return 1; // no such dir

   #endif

   data().bdiropen = 1;

   return 0;
}

bool isAbsolutePath(char *psz1)
{
   #ifdef _WIN32
   if (strlen(psz1) >= 2) {
      // try for C:\thedir
      char c1 = tolower(*psz1);
      if (c1 >= 'a' && c1 <= 'z' && *(psz1+1) == ':') // && *(psz1+2) == '\\')
         return 1;
   }
   #endif
   // e.g. /tmp
   // e.g. \\machine\path
   if (psz1[0] == glblPathChar) return 1;
   return 0;
}

int joinPath(char *pszDst, int nMaxDst, char *pszSrc1, char *pszSrc2)
{
   mystrcopy(pszDst, pszSrc1, nMaxDst-4); // colon, terminator, 2 buffer.
   int nlen = strlen(pszDst);
   if (nlen > 0) {
      char clast = pszDst[nlen-1];
      #ifdef _WIN32
      if (clast != ':') // AND below
      #endif
      if (clast != glblPathChar) {
         strcat(pszDst, glblPathStr);
         nlen++;
      }
   }
   if (nlen < nMaxDst)
      mystrcopy(pszDst+nlen, pszSrc2, nMaxDst-nlen);
   // printf("JOIN \"%s\" \"%s\" => \"%s\"\n",pszSrc1,pszSrc2,pszDst);
   return 0;
}

int joinShadowPath(char *pszDst, int nMaxDst, char *pszSrc1, char *pszSrc2)
{
   mystrcopy(pszDst, pszSrc1, nMaxDst-4); // colon, terminator, 2 buffer.
   int nlen = strlen(pszDst);
   if (nlen > 0) {
      char clast = pszDst[nlen-1];
      #ifdef _WIN32
      if (clast != ':') // AND below
      #endif
      if (clast != glblPathChar) {
         strcat(pszDst, glblPathStr);
         nlen++;
      }
   }
   mystrcopy(pszDst+nlen, "zz-shadow-01", (nMaxDst-2)-nlen);
   strcat(pszDst, glblPathStr);
   nlen = strlen(pszDst);
   mystrcopy(pszDst+nlen, pszSrc2, nMaxDst-nlen);
   // printf("JOIN \"%s\" \"%s\" => \"%s\"\n",pszSrc1,pszSrc2,pszDst);
   return 0;
}

// caller MUST RELEASE COI after use!
Coi *Coi::rawNextEntry( ) 
{
   if (!data().bdiropen) {
      perr("nextEntry() called without openDir()");
      return 0;
   }

   SFKFindData myfdat;

   char *pabsname = 0; // full combined filename

   // loop to skip ".", ".." and invalid files:
   while (1)
   {
      memset(&myfdat, 0, sizeof(myfdat));
   
      #ifdef _WIN32
   
      // windows:
      if (!data().bdir1stdone) {
         data().bdir1stdone = 1;
         // first call:
         #ifdef SFK_W64
         data().otrav = _findfirst64(data().pdirpat, &myfdat);
         #else
          #ifndef _INTPTR_T_DEFINED
           typedef int intptr_t;
          #endif
         data().otrav = _findfirst(data().pdirpat, &myfdat);
         #endif
         if (data().otrav == -1)
            return 0; // probably empty dir
      } else {
         // subsequent calls
         #ifdef SFK_W64
         int nrc = _findnext64(data().otrav, &myfdat);
         #else
         int nrc = _findnext(data().otrav, &myfdat);
         #endif
         if (nrc) return 0; // no further entries
      }

      mtklog(("rawnextentry attr %lxh %s", (uint)myfdat.attrib, myfdat.name));
   
      #else
   
      // linux:
      struct dirent *e = readdir(data().ptrav);
      if (e == NULL)
         return 0; // no further entries
   
      myfdat.name    = e->d_name;
      myfdat.attrib  = 0;

      #ifdef SOLARIS
      myfdat.rawtype = 0;
      #else
      myfdat.rawtype = (uint)e->d_type;
      #endif

      // dirent symbolic links have their own inode,
      // and are of no use to detect repeated content listings.
      //   myfdat.ninode  = (num)e->d_ino;
      //   myfdat.bhavenode = 1;
      // the actual inode is fetched below through stat64.
   
      #endif

      // always skip "." and ".."
      if (   !strcmp(myfdat.name, ".")
          || !strcmp(myfdat.name, ".."))
         continue;

      // construct absolute name of entry now,
      // although we may decide to skip the file.
      int nRootLen = strlen(name());
      int nSubLen  = strlen(myfdat.name);
   
      // create tmp absname, taking care of ":" and slash
      int nMixLen  = nRootLen+nSubLen;
      pabsname = new char[nMixLen+20];
      joinPath(pabsname, nMixLen+10, name(), myfdat.name);

      // identify further file attributes:
      // symbolic link directory under linux?
   
      #ifndef _WIN32

      // get further dir/file statistics. no 32 bit compat here -
      // getting the latest g++ for linux shouldn't be too difficult.
      struct stat64 hStat1;
      if (stat64(pabsname, &hStat1)) {
         if (cs.verbose) printf("nostat: %s (non-regular file)\n", pabsname);
         cs.noFiles++;
         delete [] pabsname;
         continue;
      }
   
      myfdat.rawmode = (uint)hStat1.st_mode;
      myfdat.rawnlnk = (uint)hStat1.st_nlink;
   
      // get the "true" (dereferenced) inode,
      // allowing dup content listing detection:
      myfdat.ninode  = (num)hStat1.st_ino;
      memcpy(&myfdat.ostdev, &hStat1.st_dev, sizeof(__dev_t));
      myfdat.bhavenode = 1;

      #ifdef SOLARIS
      myfdat.islink = 0; // set by hStat1 below
      myfdat.attrib = 0; // set by hStat1 below
      #else
      // DT_LNK: not available on older Linux versions
      if (e->d_type == DT_LNK)
         myfdat.islink = 1; // cannot tell here if dir or file link
      else
      if (e->d_type == DT_DIR)
         myfdat.attrib = 0x10; // dir
      else
      if (e->d_type == DT_REG)
         myfdat.attrib = 0x00; // regular file
      // else probably DT_UNKNOWN
      #endif
   
      // general linux, including older variants
      #ifdef S_IFLNK
      if ((hStat1.st_mode & S_IFLNK) == S_IFLNK)
         myfdat.islink = 1;
      #endif
      // no else here.
      if ((hStat1.st_mode & S_IFDIR) == S_IFDIR)
         myfdat.attrib = 0x10; // dir
      else
      if ((hStat1.st_mode & S_IFREG) == S_IFREG)
         myfdat.attrib = 0x00; // regular file
      else {
         if (cs.verbose) printf("nofile: %s (non-regular file)\n", myfdat.name);
         cs.noFiles++;
         delete [] pabsname;
         continue;
      }
   
      /*
         NOTE: these are OCTAL VALUES, NOT hexadecimal.
         __S_IFDIR   0040000  // Directory.
         __S_IFCHR   0020000  // Character device.
         __S_IFBLK   0060000  // Block device.
         __S_IFREG   0100000  // Regular file.
         __S_IFIFO   0010000  // FIFO.
         __S_IFLNK   0120000  // Symbolic link.
         __S_IFSOCK  0140000  // Socket.
      */

      // skip of dirlinks should be done by caller
      // if (myfdat.islink && ((hStat1.st_mode & _S_IFDIR) == _S_IFDIR)) {
      //    // symbolic directory link:
      //    bIsDirLink = 1;
      //    if (cs.skipLinks && (nGlblFunc != eFunc_FileStat)) {
      //       delete [] pabsname;
      //       continue;
      //    }
      // }
   
      // may also set 0x02 here for hidden files.
      // may also set 0x04 here for system files.
   
      myfdat.time_write  = hStat1.st_mtime;
      myfdat.time_create = hStat1.st_ctime;
      myfdat.size        = hStat1.st_size;
   
      #endif

      // entry valid, not skipped: take it
      break;

   }  // endwhile (1)

   // expect that we (the parent of psub) have a root
   // copied through from higher levels. if not,
   // set ourselves as the root.
   Coi *psub = new Coi(pabsname, pszClRoot ? pszClRoot : name());
   psub->fillFrom(&myfdat);
   // time, size, hidden, link

   // verified file system directory:
   if (myfdat.attrib & 0x10)
      psub->bClFSDir = 1;

   psub->incref("rne");

   // read metadata successfully:
   psub->nClStatus = 1;

   delete [] pabsname;

   return psub; // managed by caller
}

bool Coi::isHidden( ) {
   // TODO: so far, readStat can NOT determine the hidden status,
   //       therefore the call doesn't help unless this changes.
   if (!nClStatus) readStat();
   mtklog(("%d = coi::ishidden %s",bClHidden,name()));
   return bClHidden; 
}

bool Coi::isLink   ( ) {
   // TODO: so far, readStat can NOT determine the link status,
   //       therefore the call doesn't help unless this changes.
   if (!nClStatus) readStat();
   return bClLink;
}

bool Coi::isDirLink( ) {
   // TODO: so far, readStat can NOT determine the link status,
   //       therefore the call doesn't help unless this changes.
   if (!nClStatus) readStat();
   return bClDir && bClLink;
}

void Coi::rawCloseDir( ) 
{
   if (!data().bdiropen)
      pwarn("closeDir() called on non-open dir");

   #ifdef _WIN32

   if (data().otrav != -1) {
      _findclose(data().otrav);
      data().otrav = -1;
   }

   #else

   if (data().ptrav) {
      closedir(data().ptrav);
      data().ptrav = 0;
   }

   #endif

   if (data().pdirpat) {
      delete [] data().pdirpat;
      data().pdirpat = 0;
   }

   data().bdiropen = 0;
}

CoiTable::CoiTable() {
   mtklog(("coitab ctr %p",this));
   nClArraySize = 0;
   nClArrayUsed = 0;
   apClArray    = 0;
}

CoiTable::~CoiTable() {
   mtklog(("coitab dtr %p",this));
   resetEntries();
}

void CoiTable::resetEntries() {
   for (int i=0; i<nClArrayUsed; i++) {
      if (apClArray[i]) delete apClArray[i];
      apClArray[i] = 0;
   }
   nClArrayUsed = 0;
   if (apClArray)
      delete [] apClArray;
   apClArray = 0;
   nClArraySize = 0;
}

int CoiTable::numberOfEntries() { return nClArrayUsed; }

bool CoiTable::isSet(int iIndex) {
   if (iIndex < 0) { pwarn("illegal index: %d\n", iIndex); return 0; }
   return (iIndex < nClArrayUsed) ? 1 : 0;
}

int CoiTable::expand(int nSoMuch) {
   Coi **apTmp = new Coi*[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (apClArray) {
      memcpy(apTmp, apClArray, nClArraySize*sizeof(Coi*));
      delete [] apClArray;
   }
   apClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

// add a COPY of the supplied coi
int CoiTable::addEntry(Coi &ocoi, int nAtPos) {
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (int i=nClArrayUsed; i>nAtPos; i--)
         apClArray[i] = apClArray[i-1];
      apClArray[nAtPos] = ocoi.copy();
      nClArrayUsed++;
   } else {
      apClArray[nClArrayUsed++] = ocoi.copy();
   }
   return 0;
}

int CoiTable::addSorted(Coi &ocoi, char cSortedBy, bool bUseCase) 
{
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }

   Coi *padd = &ocoi;

   int nInsPos = -1;

   int nCnt = numberOfEntries();
   int i=0; bool bbail=0;
   for (i=0; i<nCnt; i++) 
   {
      Coi *pown = apClArray[i];
      switch (cSortedBy) {
         case 'T': bbail = (pown->getTime() > padd->getTime()); break;
         case 't': bbail = (pown->getTime() < padd->getTime()); break;
         case 'S': bbail = (pown->getSize() > padd->getSize()); break;
         case 's': bbail = (pown->getSize() < padd->getSize()); break;
         case 'N': {
            int ncmp = bUseCase ?      strcmp(pown->name(), padd->name())
                                   : mystricmp(pown->name(), padd->name());
            bbail = (ncmp > 0);
            break;
         }
         case 'n': {
            int ncmp = bUseCase ?      strcmp(pown->name(), padd->name())
                                   : mystricmp(pown->name(), padd->name());
            bbail = (ncmp < 0);
            break;
         }
         default: return 9+perr("internal #141272256\n");
      }
      if (bbail) break;
   }
   if (i < nCnt) nInsPos = i;

   return addEntry(ocoi, nInsPos);
}

int CoiTable::removeEntry(int nAtPos) {
   if (nAtPos < 0 || nAtPos >= nClArrayUsed)
      return 9;
   if (apClArray[nAtPos]) delete apClArray[nAtPos];
   for (int i=nAtPos; i<nClArrayUsed-1; i++)
      apClArray[i] = apClArray[i+1];
   apClArray[nClArrayUsed-1] = 0; // just in case
   nClArrayUsed--;
   return 0;
}

int CoiTable::setEntry(int nIndex, Coi *pcoi) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("illegal set index: %d\n", nIndex);
   if (apClArray[nIndex])
      delete apClArray[nIndex];
   apClArray[nIndex] = pcoi ? pcoi->copy() : 0;
   return 0;
}

Coi *CoiTable::getEntry(int nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return apClArray[nIndex];
   perr("illegal CoiTable index: %d tline %d\n", nIndex, nTraceLine);
   return 0;
}

// - - - - - CoiTable end - - - - -

ProgressInfo info;

void initConsole()
{
   // manually set or override console width:
   char *psz2 = getenv("SFK_CONFIG");
   if (psz2) {
      psz2 = strstr(psz2, "columns:");
      if (psz2) {
         int ncols = atol(psz2+8);
         if (ncols >= 40) {
            nGlblConsColumns = ncols;
            bGlblConsColumnsSet = true;
            info.setWidth(nGlblConsColumns);
         }
      }
   }

   // need this also for html help
   char *pszColEnv = getenv("SFK_COLORS");
   if (pszColEnv)
      setColorScheme(pszColEnv);

   #ifdef WINFULL

   hGlblConsole = GetStdHandle(STD_OUTPUT_HANDLE);

   // TODO: vc10 with GetConsoleScreenBufferInfoEx
   CONSOLE_SCREEN_BUFFER_INFO oConInf;
   if (!GetConsoleScreenBufferInfo(hGlblConsole, &oConInf)) {
      // not in interactive mode, e.g. output redirected to file:
      bGlblUseColor = bGlblUseHelpColor = 0;
      return;
   }
   bGlblHaveInteractiveConsole = 1;
   if (oConInf.dwCursorPosition.X==0 && oConInf.dwCursorPosition.Y==0)
      bGlblStartedInEmptyConsole = 1;
   nGlblConsAttrib = oConInf.wAttributes;
   
   /*
   printf("CONSATTRIB DEFAULTS %lxh:\n",nGlblConsAttrib);
   printf("   %u  BACKGROUND_BLUE\n" , nGlblConsAttrib & BACKGROUND_BLUE);
   printf("   %u  BACKGROUND_GREEN\n", nGlblConsAttrib & BACKGROUND_GREEN);
   printf("   %u  BACKGROUND_RED\n"  , nGlblConsAttrib & BACKGROUND_RED);
   */
   
   if (!bGlblConsColumnsSet && (oConInf.dwSize.X >= 60)) {
      nGlblConsColumns = oConInf.dwSize.X;
      bGlblConsColumnsSet = true;
      info.setWidth(nGlblConsColumns);
   }

   if (!pszColEnv)
   {
      // if we autodetect a black background shell
      uint nBackMask = BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE;
      if ((nGlblConsAttrib & (nBackMask)) == 0) {
         // auto-select color theme:black
         setColorScheme("theme:black");
      }
      if ((nGlblConsAttrib & (nBackMask)) == nBackMask) {
         // optimize colors for white background
         setColorScheme("theme:white");
      }
   }
   #endif

   #ifdef _WIN32

   #ifdef WINFULL
   if (bGlblUseColor)
      SetConsoleCtrlHandler(ctrlcHandler, 1);
   #endif

   #else

   signal(SIGINT, ctrlcHandler);

   #endif
}

int autoCalcWrapColumns()
{
   int ncols = 80;
   if (bGlblConsColumnsSet) 
   {
      if (cs.verbose >= 2) printf("ConsoleColumns=%d\n",nGlblConsColumns);
      return nGlblConsColumns-2;
   }
   #ifdef _WIN32
   HWND hDeskWin = GetDesktopWindow();
   if (hDeskWin) {
      HDC hdcDesk = GetWindowDC(hDeskWin);
      if (hdcDesk != NULL) {
         int ndeskw = GetDeviceCaps(hdcDesk, HORZRES); // gdi32.lib
         int ncols2 = ndeskw / 10; // default char width: 10 pixels
         if (ncols2 > 80)
            ncols = ncols2;
         if (cs.verbose >= 2) printf("wdesk %d col.calc %d used %d\n",ndeskw,ncols2,ncols);
         ReleaseDC(hDeskWin, hdcDesk);
      }
   }
   #else
   // identify number of linux shell columns
   #endif
   return ncols-2;
}

ProgressInfo::ProgressInfo() 
{
   memset(this, 0, sizeof(ProgressInfo));
   setWidth(80);
   nLastDumpTime = getCurrentTime();
   bAddInfoPrio  = 1;
}

void ProgressInfo::setWidth(int nColumns) {
   nMaxChars      = nColumns  -  3;
   nMaxSubChars   = nMaxChars - 20;
}

void ProgressInfo::setAddInfoWidth(int nAddCols) {
   nAddInfoCols = nAddCols;
   // vrfy  58% [filename]......... addinfo
   // 1234567890                    addcols
   nAddCols += 10; // add left side columns
   if (nMaxChars > nAddCols + 30)
      nMaxSubChars = nMaxChars - nAddCols;
}

void ProgressInfo::fixAddInfoWidth() {
   if ((int)strlen(szAddInfo) > nAddInfoCols) {
      nAddInfoCols = (int)strlen(szAddInfo);
      int nAddCols = nAddInfoCols + 10;
      if (nMaxChars > nAddCols + 30)
         nMaxSubChars = nMaxChars - nAddCols;
   }
}

void ProgressInfo::setAddInfoHalve() {
   int nAddCols = (nMaxChars - 10) / 2;
   nAddInfoCols = nAddCols;
   nAddInfoReserve = nAddCols; // if addinfo is overwritten
   nAddCols += 10; // add left side columns
   nMaxSubChars = nMaxChars - nAddCols;
   bAddInfoPrio = 0;
}

void ProgressInfo::setStatus(cchar *pverb, cchar *psubj, cchar *pszAddInfo, int nKeepFlags) 
{
   strcopy(szVerb, pverb);
   strcopy(szSubject, psubj);
   if (nKeepFlags & eKeepProg)  // keep progress
      szPerc[0] = '\0';
   if (pszAddInfo) {
      if (!strcmp(pszAddInfo, "00")) {
         strcpy(szPerc, "... ");
         strcopy(szAddInfo, pszAddInfo+2);
      } else
         strcopy(szAddInfo, pszAddInfo);
   }
   else
   if (!(nKeepFlags & eKeepAdd)) { // keep addinfo
      szAddInfo[0] = '\0';
   }

   fixAddInfoWidth();

   if (nKeepFlags & eSlowCycle)
      nLastDumpTime = getCurrentTime();

   if (!(nKeepFlags & eNoCycle))
      cycle();
}

void ProgressInfo::setStatProg(cchar *pverb, cchar *psubj, num nMax, num nCur, cchar *pszUnit) {
   strcopy(szVerb, pverb);
   strcopy(szSubject, psubj);
   szAddInfo[0] = '\0';
   setProgress(nMax, nCur, pszUnit);
}

void ProgressInfo::setProgress(num nMax, num nCur, cchar *pszUnit) {
   if (nMax <= 0) nMax = 1; // safe division
   int nPerc = (int)(nCur * 100 / nMax);
   if (nPerc > 0 && nPerc <= 100)
      sprintf(szPerc, "%02d%% ", nPerc);
   else
   if (nPerc > 100) {
      sprintf(szPerc, "100%% ");
      if (cs.debug) printf("[progress: cur=%d max=%d perc=%d]\n", (int)nCur, (int)nMax, (int)nPerc);
   } else {
      sprintf(szPerc, "... ");
      if (cs.debug) printf("[progress: cur=%d max=%d perc=%d]\n", (int)nCur, (int)nMax, (int)nPerc);
   }
   cycle();
}

void ProgressInfo::cycle() {
   #ifdef _WIN32
   // windows: if output is redirected, info display makes no sense.
   if (!bGlblHaveInteractiveConsole)
      return;
   #endif
   if (cs.quiet || cs.noprog)
      return;
   if (getCurrentTime() >= (nLastDumpTime + 500)) { 
      dumpTermStatus();
  }
}

void ProgressInfo::setAction(cchar *pverb, cchar *psubj, cchar *pszAddInfo, int nKeepFlags) {
   setStatus(pverb, psubj, pszAddInfo, nKeepFlags);
   print();
}

void ProgressInfo::print() {
   if (cs.quiet || cs.noprog)
      return;
   dumpTermStatus();
}

void ProgressInfo::printLine(int nFilter) {
   if (cs.quiet || cs.noprog)
      return;
   if (nFilter & (1<<1)) {
      // print only subject, but with unlimited length
      clearTermStatus();
      oprintf("%s\n", szSubject);
   } else {
      if (nFilter & (1<<2))
         strcpy(szPerc, " ");
      dumpTermStatus(); // may clear previous status output
      printf("\n");
   }
   nDumped = 0;
}

int ProgressInfo::print(const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf, sizeof(szPrintBuf)-10, pszFormat, argList);
   szPrintBuf[sizeof(szPrintBuf)-10] = '\0';
   clear();
   printf("%s", szPrintBuf);
   return 0;
}

void ProgressInfo::setAddInfo(const char *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szAddInfo, sizeof(szAddInfo)-10, pszFormat, argList);
   szAddInfo[sizeof(szAddInfo)-10] = '\0';
   fixAddInfoWidth();
}

void ProgressInfo::clear() 
{
   clearTermStatus();
   szVerb[0]      = '\0';
   szSubject[0]   = '\0';
   szAddInfo[0]   = '\0';
   szPerc[0]      = '\0';
   // nLastDumpTime  = getCurrentTime();
}

void ProgressInfo::clearTermStatus() 
{
   if (nDumped > 0 && nDumped < sizeof(szTermBuf)-4)
   {
      mtklog(("info::clearterm"));
      memset(szTermBuf, ' ', nDumped);
      szTermBuf[nDumped] = '\0';
      printf("%s\r",szTermBuf);
      fflush(stdout);
      nDumped = 0;
   }
   // do NOT reset szVerb etc. here
}

void ProgressInfo::dumpTermStatus() 
{__
   if (cs.quiet || cs.noprog)
      return;

   if (!szSubject[0])
   {
      if (nDumped)
         clearTermStatus();
      return;  // nothing to dump
   }      

   int nToClear = nDumped;

   int nMaxMiddle = nMaxSubChars;
   if (!szPerc[0])
      nMaxMiddle += 2; // no percentage: have more chars to use

   // if there is few space, and low addinfo prio
   bool bWithAdd = 1;
   if ((int)strlen(szSubject) > nMaxMiddle) {
      if (!bAddInfoPrio) {
         bWithAdd = 0;
         nMaxMiddle += nAddInfoReserve; // add space to center
      }
   }

   if ((int)strlen(szSubject) > nMaxMiddle) {
      int nlen  = strlen(szSubject);
      int nmax2 = nMaxMiddle - 3;
      if (nmax2 < 0) nmax2 = 0;
      char *psz1 = &szSubject[nlen-nmax2];
      snprintf(szTermBuf, sizeof(szTermBuf)-10, "...%s", psz1);
   } else {
      snprintf(szTermBuf, sizeof(szTermBuf)-10, "%-*.*s", (int)nMaxMiddle, (int)nMaxMiddle, szSubject);
   }

   nDumped = 0;

   char cTurn = (nTurn & 1) ? '.':' ';   
   nTurn++;

   if (szVerb[0]) {
      int nvlen = strlen(szVerb);
      if (nvlen > 5) nvlen = 5;
      while (nvlen > 3 && szVerb[nvlen-1] == ' ')
         nvlen--;
      if (szPerc[0]) {
         cchar *pszPerc2 = szPerc;
         if (!strcmp(szPerc, " "))
            pszPerc2 = ""; // ignore, is just a dummy
         printx("<head>%-*.*s %s<def>", nvlen,nvlen, szVerb, pszPerc2);
         nDumped += 6 + strlen(szPerc);
      } else {
         printx("<head>%-*.*s <time>%c<def> ", nvlen,nvlen, szVerb, cTurn);
         nDumped += 6 + 2;
      }
   }

   mtklog(("info::dump \"%s\"", szTermBuf));
   printf("%s ",szTermBuf);
   nDumped += strlen(szTermBuf) + 1;

   if (bWithAdd && strlen(szAddInfo)) {
      setTextColor(nGlblTimeColor);
      printf("%s", szAddInfo);
      setTextColor(-1);
      nDumped += strlen(szAddInfo);
   }
   
   // need to add a blank area to clear old output?
   int nDelta = nToClear - nDumped;
   if (nDelta > 0 && nDelta < sizeof(szTermBuf)-4)
   {
      memset(szTermBuf, ' ', nDelta);
      szTermBuf[nDelta] = '\0';
      printf("%s",szTermBuf);
   }

   printf("\r");
   fflush(stdout);
   nLastDumpTime = getCurrentTime();
}

// FIX for Windows 60 MB I/O Bug: Windows XP fails to read blocks
// larger than 60 MByte, therefore use myfread instead of fread:

// large block read incl. optional info update and checksum building
size_t myfread(uchar *pBuf, size_t nBufSize, FILE *fin, num nMax, num nCur, SFKMD5 *pmd5)
{
   size_t nOffset = 0;
   size_t nRemain = nBufSize;
   
   while ((nRemain > 0) && !bGlblEscape)
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nReadSub = fread(pBuf+nOffset, 1, nBlock, fin);
      if (nReadSub <= 0)
         break;

      nOffset += nReadSub;
      nRemain -= nReadSub;

      if (nMax > 0)
         info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   if (nOffset > 0 && pmd5 != 0)
      pmd5->update(pBuf, nOffset);
   
   return nOffset;
}

// large block write incl. optional info update and checksum building
size_t myfwrite(uchar *pBuf, size_t nBytes, FILE *fout, num nMax, num nCur, SFKMD5 *pmd5)
{
   size_t nOffset = 0;
   size_t nRemain = nBytes;

   while ((nRemain > 0) && !bGlblEscape) 
   {
      size_t nBlock = SFK_IO_BLOCK_SIZE;
      if (nBlock > nRemain) nBlock = nRemain;

      size_t nWriteSub = fwrite(pBuf+nOffset, 1, nBlock, fout);

      // mtklog(("myfwrite: %d = fwrite(%d)",(int)nWriteSub,(int)nBlock));

      if (nWriteSub != nBlock)
         return nOffset+nWriteSub; // return no. of bytes actually written

      nOffset += nWriteSub;
      nRemain -= nWriteSub;

      if (nMax > 0)
         info.setProgress(nMax, nCur+nOffset, "bytes");
   }

   if (nOffset > 0 && pmd5 != 0)
      pmd5->update(pBuf, nOffset);

   return nOffset;
}

#ifdef _WIN32
void timetToFileTime(num ntimet, FILETIME *pft)
{
   time_t t = (time_t)ntimet;
   LONGLONG ll = Int32x32To64(t, 10000000) + 116444736000000000LL;
   pft->dwLowDateTime  = (DWORD)ll;
   pft->dwHighDateTime = (DWORD)(ll>>32);
}

num fileTimeToTimeT(num nwft)
{
   nwft -= 116444736000000000LL;
   nwft /= 10000000;
   return nwft;
}

num fileTimeToTimeT(FILETIME *pft)
{
   num nwft =     (((num)pft->dwHighDateTime) << 32)
               |  (((num)pft->dwLowDateTime));
   nwft -= 116444736000000000LL;
   nwft /= 10000000;
   return nwft;
}
#endif

size_t safefread(void *pBuf, size_t nBlockSize, size_t nBufSize, FILE *fin)
   { return myfread((uchar*)pBuf, nBufSize, fin); }

size_t safefwrite(void *pBuf, size_t nBlockSize, size_t nBufSize, FILE *fin)
   { return myfwrite((uchar*)pBuf, nBufSize, fin); }

// FROM HERE ON, ALL fread() and fwrite() calls are MAPPED to SAFE versions
// to work around the Windows 60 MB I/O bug.

#define fread  safefread
#define fwrite safefwrite

// optional reroute of error messages
int (*pGlblSFKStatusCallBack)(int nMsgType, char *pmsg) = 0;

int errPauseOrEcho( )
{
   if (cs.echoonerr) {
      if (cs.argc > 0 && cs.argv != 0) {
         fprintf(stderr, "[cmd]: ");
         for (int i=0; i<cs.argc; i++)
            fprintf(stderr, "%s ", cs.argv[i]);
         fprintf(stderr, "\n");
      }
      else {
         printf("cmd  : [none]\n");
      }
   }

   if (bGlblPauseOnError) {
      printf("Press ENTER to continue.\n");
      while (getchar() != '\n');
   }
   
   return 0;
}

int perr(const char *pszFormat, ...)
{
   if (cs.noerr) return 0;

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   szErrBuf[sizeof(szErrBuf)-10] = '\0';

   if (pGlblSFKStatusCallBack) {
      // output to callback
      removeCRLF(szErrBuf);
      pGlblSFKStatusCallBack(1, szErrBuf);
   } else {
      // output to terminal
      if (!strchr(szErrBuf, '\n'))
         strcat(szErrBuf, "\n");
      info.clear();
      setTextColor(nGlblErrColor, 1); // on stderr
      fprintf(stderr, "error: %s", szErrBuf);
      setTextColor(-1, 1);
   }

   mtkerr(("%s", szErrBuf));
   bErrBufSet = 1;
   nGlblErrors++;

   errPauseOrEcho();

   return 0;
}

int pwarn(const char *pszFormat, ...)
{
   if (cs.nowarn) return 0;
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   szErrBuf[sizeof(szErrBuf)-10] = '\0';

   if (pGlblSFKStatusCallBack) {
      // output to callback
      removeCRLF(szErrBuf);
      char *pbuf = szErrBuf;
      if (!strncmp(pbuf, "[nopre] ", 8))
         pbuf += 8;
      pGlblSFKStatusCallBack(2, pbuf);
   } else {
      // output to terminal
      if (!strchr(szErrBuf, '\n'))
         strcat(szErrBuf, "\n");
      info.clear();
      setTextColor(nGlblWarnColor, 1);
      char *psz = szErrBuf;
      if (!strncmp(psz, "[nopre] ", 8))
         fprintf(stderr, "%s", psz+8);
      else
         fprintf(stderr, "warn : %s", psz);
      setTextColor(-1, 1);
   }

   mtkwarn(("%s", szErrBuf));
   nGlblWarnings++;

   return 0;
}

int pinf(const char *pszFormat, ...)
{
   if (cs.nonotes) return 0;

   // does NOT use szErrBuf to allow access to last
   // error message through sfkLastError().

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   if (pGlblSFKStatusCallBack) {
      // output to callback
      removeCRLF(szPrintBuf1);
      pGlblSFKStatusCallBack(3, szPrintBuf1);
   } else {
      // output to terminal
      info.clear();
      setTextColor(nGlblTimeColor, 1);
      char *psz = szPrintBuf1;
      if (!strncmp(psz, "[nopre] ", 8))
         fprintf(stderr, "%s", psz+8);
      else
         fprintf(stderr, "note : %s", psz);
      setTextColor(-1, 1);
   }

   mtklog(("note: %s", szPrintBuf1));

   return 0;
}

char *mystrerr(int iOptCode=-1)
{
   static char szBuf[100];
   
   szBuf[0] = '\0';

   #ifdef _WIN32

   DWORD nerr = (iOptCode >= 0) ? iOptCode : GetLastError();

   LPVOID lpMsgBuf = 0;

   FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, nerr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        // MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        (LPTSTR)&lpMsgBuf,
        0, NULL );

   if (lpMsgBuf) {
      removeCRLF((char*)lpMsgBuf);
      snprintf(szBuf, sizeof(szBuf)-10, "%d,%s", nerr, (char*)lpMsgBuf);
   }

   LocalFree(lpMsgBuf);

   #else

   int nerr = (iOptCode >= 0) ? iOptCode : errno;

   char *psz = strerror(nerr);
   snprintf(szBuf, sizeof(szBuf)-10, "%d,%s", nerr, psz);

   #endif
   
   return szBuf;
}

void perrinfo(const char *pszContext)
{
   // general reasons first
   if (!strcmp(pszContext, "fwrite")) {
      pinf("the target volume may have no space left on the device.\n");
      pinf("if the target is a network drive, a file size limit may apply.\n");
   }

   // then dump system infos, if any
   #ifdef _WIN32

   #ifdef WINFULL
   #ifdef USE_SFK_BASE
   int  nerr1 = 0;
   #else
   int  nerr1 = errno;
   #endif
   DWORD nerr2 = GetLastError();
   LPVOID lpMsgBuf = 0;
   FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, nerr2,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &lpMsgBuf,
        0, NULL );
   if (lpMsgBuf) removeCRLF((char*)lpMsgBuf);
   info.clear(); // in case no perr was done
   setTextColor(nGlblWarnColor);
   printf("cerno: %d,%s\n", nerr1, strerror(nerr1));
   printf("werno: %u,%s\n", nerr2, lpMsgBuf ? lpMsgBuf : "");
   setTextColor(-1);
   LocalFree(lpMsgBuf);
   #endif

   #else

   int  nerr1 = errno;
   info.clear(); // in case no perr was done
   setTextColor(nGlblWarnColor);
   printf("cerno: %d,%s\n", nerr1, strerror(nerr1));
   setTextColor(-1);

   #endif
}

bool bGlblSysErrOccured = 0;

static int esys(const char *pszContext, const char *pszFormat, ...)
{
   bGlblSysErrOccured = 1;

   // just like perr:
   if (cs.noerr) return 0;
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   szErrBuf[sizeof(szErrBuf)-10] = '\0';
   if (!strchr(szErrBuf, '\n'))
      strcat(szErrBuf, "\n");
   info.clear();
   setTextColor(nGlblErrColor, 1); // on stderr
   fprintf(stderr, "error: %s", szErrBuf);
   setTextColor(-1, 1);
   mtkerr(("%s", szErrBuf));
   bErrBufSet = 1;
   nGlblErrors++;

   // optionally extend output by runtime info:
   if (bGlblSysErrDetail)
      perrinfo(pszContext);

   errPauseOrEcho();

   return 0;
}

bool cmpchr(char c1, char cmsk, bool bcase, bool besc) {
   if (!besc && cmsk == '?') return 1;
   if (!bcase) c1   = tolower(c1);
   if (!bcase) cmsk = tolower(cmsk);
   if (c1 == cmsk) return 1;
   return 0;
}

enum eMatchStr {
   eMatchCase     = 1,
   eMatchLiteral  = 2,
   eMatchHead     = 4,
   eMatchTail     = 8
};

char peekpatchr(char *p, int &rEscaped)
{
   rEscaped = 0;
   char c  = *p++;
   if (!cs.spat || c != '\\') // spat.3 peek 2
      return c;
   char c2 = *p;
   switch (c2) {
      case 't' : rEscaped=1; c='\t'; break;
      case 'q' : rEscaped=1; c='"'; break;
      case '\\': 
      case '*' :
      case '?' : rEscaped=1; c=c2;   break;
      case 'x' :
         if (p[1] && p[2]) {
            rEscaped=3;
            c = (char)getTwoDigitHex(p+1);
         }
         break;
   }
   return c;
}

bool mystrhit(char *pszStr, char *pszPat, bool bCase, int *pOutHitIndex)
{
   if (bCase) {
      char *psz = strstr(pszStr, pszPat);
      if (psz) {
         if (pOutHitIndex) *pOutHitIndex = (int)(psz-pszStr);
         return true;
      } else {
         if (pOutHitIndex) *pOutHitIndex = -1;
         return false;
      }
   } else {
      if (mystrstrip(pszStr, pszPat, pOutHitIndex))
         return true;
      else
         return false;
   }
}

bool matchstr(char *pszHay, char *pszPat, int nFlags, int &rfirsthit, int &rhitlen)
{
   if (cs.debug)
      printf("match: enter matchstr \"%s\" \"%s\" flags %u\n",pszHay,pszPat,nFlags);

   bool bCase = ( nFlags & 1) ? 1 : 0;
   bool bHead = ( nFlags & 4) ? 1 : 0;
   bool bTail = ( nFlags & 8) ? 1 : 0;

   int nhaylen = strlen(pszHay);
   int ibase   = 0;
   int ifirst  = -1;     // pos'n of first matching char
   int ilast   = -1;     // pos'n of last matching char
   bool bmatch  = 0;
   int nesc    = 0;      // escapes not (0), or 1 or 3 chars

   if (!cs.wpat) {
      // no wildcard interpretation
      int npatlen = strlen(pszPat);
      if (bTail) {
         // check for end-of-line match
         if (nhaylen < npatlen) return 0;
         char *pend = pszHay+nhaylen-npatlen;
         if (!mystrncmp(pend,pszPat,npatlen,bCase)) {
            if (cs.debug)
               printf("match:  direct at %d len %d\n",nhaylen-npatlen,npatlen);
            rfirsthit = nhaylen-npatlen;
            rhitlen   = npatlen;
            return 1;
         }
         return 0;
      } else {
         // check for anywhere or start-of-line match
         int ihit = 0;
         bool brc = mystrhit(pszHay, pszPat, bCase, &ihit);
         if (!brc) return 0;
         if (bHead && ihit != 0) return 0;
         rfirsthit = ihit;
         rhitlen   = npatlen;
         if (cs.debug)
            printf("match:  direct at %d len %d\n",ihit,npatlen);
         rfirsthit = ihit;
         rhitlen   = npatlen;
         return 1;
      }
   }

   do
   {
      char *ppat = pszPat;       // pattern read cursor
      char *phay = pszHay+ibase; // haystack read cursor
   
      bool biskip = !bHead; // initial skip, add * at start
      ifirst = -1;     // pos'n of first matching char
      ilast  = -1;     // pos'n of last matching char
   
      bmatch=0;
      while (true)
      {
         if (!*ppat) {
            bmatch = 1;
            break;
         }

         char cpat  = 0;
         char cpat2 = 0;
         bool bdowc = cs.wpat; // do the wild char, or not
    
         if (biskip) {
            biskip = 0;
            cpat   = '*';
            if (cs.debug)
               printf("match:  process %c index %d \"%s\"\n", cpat, ppat-pszPat, ppat);
         } else {
            cpat  = *ppat++;
            cpat2 = *ppat;
            if (cs.debug)
               printf("match:  process %c index %d \"%s\"\n", cpat, ppat-pszPat-1, ppat-1);
         }
      
         // remapping of \\ \n \t \* \?
         if (cs.spat && cpat == '\\')  // spat.4 matchstr 22
         {
            switch (cpat2) {
               case '\\': ppat++; break;
               case 't' : ppat++; cpat = '\t'; break;
               case 'q' : ppat++; cpat = '"';  break;
               case '*' : ppat++; cpat = '*'; bdowc = 0; break;
               case '?' : ppat++; cpat = '?'; bdowc = 0; break;
               case 'x' :
                  if (ppat[1] && ppat[2]) {
                     cpat = (char)getTwoDigitHex(ppat+1);
                     ppat += 3;
                     bdowc = 0;
                  }
                  break;
            }
         }
    
         if (bdowc && cpat == '*') 
         {
            // seek forward over *
            char cnext = peekpatchr(ppat, nesc);
            bool enext = (nesc > 0) ? 1 : 0;
            if (!cnext) { bmatch=1; break; }
            // **?
            if (!nesc && cnext == '*') continue;
            // isolate next non-* part
            int isrc=0,idst=0;
            while (idst<MAX_MATCH_BUF) {
               char csub = peekpatchr(ppat+isrc, nesc);
               if (nesc)
                  isrc += 1+nesc; // fetched \* or \xnn
               else {
                  if (!csub || csub == '*') break; // NO isrc increment on *
                  isrc++;
               }
               szMatchBuf[idst  ] = csub;
               szMatchEsc[idst++] = (bool)nesc;
            }
            szMatchBuf[idst] = '\0';
            szMatchEsc[idst] = '\0';
            ppat += isrc;
            if (cs.debug)
               printf("match:   check part \"%s\" cnext \"%c\" with hay at \"%.10s\"\n",szMatchBuf,cnext,phay);
            // find next occurrence of non-* part
            bool bsubmatch=0;
            while (*phay) {
               while (*phay && !cmpchr(*phay,cnext,bCase,enext)) phay++;
               if (!*phay) break;
               if (cs.debug)
                  printf("match:   from %.10s\n",phay);
               // matched first char, compare rest
               int isub=0;
               char *ppat2=szMatchBuf;
               bool *epat2=szMatchEsc;
               for (; phay[isub] && ppat2[isub]; isub++)
                  if (!cmpchr(phay[isub], ppat2[isub], bCase, epat2[isub]))
                     break;
               if (!ppat2[isub]) {
                  // rest matched: adapt hit positions
                  bsubmatch=1;
                  if (ifirst < 0)
                     ifirst = phay - pszHay;
                  ilast = phay - pszHay + isub - 1;
                  // jump past non-* part
                  if (cs.debug)
                     printf("match:   submatched \"%s\"\n",szMatchBuf);
                  phay += isub;
                  break;
               }
               // else retry from next position
               if (cs.debug)
                  printf("match:   submiss\n");
               phay++;
            }
            // synced past *
            if (!*ppat){
               if (bsubmatch) {
                  if (cs.debug)
                     printf("match:   full inner match, %d %d\n",ifirst,ilast);
                  bmatch=1;
               } else {
                  if (cs.debug)
                     printf("match:   full inner miss\n");
               }
               break; // match or miss
            }
            if (!*phay) break; // miss
            if (cs.debug)
               printf("match:   cont hay \"%.10s\" pat \"%.10s\"\n",phay,ppat);
            continue;
         }
         else 
         {
            // compare single char, adapt match positions
            if (!cmpchr(*phay, cpat, bCase, 0)) {
               if (cs.debug)
                  printf("match:   miss at haychr \"%c\" msk %c position %d\n",*phay,cpat,phay-pszHay);
               break; // miss
            }
            if (ifirst < 0)
               ifirst = phay - pszHay;
            ilast  = phay - pszHay;
            phay++;
            // and continue
         }
      }  // end inner search loop
 
      if (cs.debug)
         printf("match:  1) ifirst %d ilast %d bmatch %d\n",ifirst,ilast,bmatch);

      if (bmatch) {
         // full hit somewhere, do we accept?
         if (!bTail) break;
         if (nhaylen > 0 && ilast == nhaylen-1) break;
         if (cs.debug)
            printf("match:  c) no line-end hit, %d != %d\n",ilast,nhaylen-1);
         // tail, and no hit at end: continue searching
      }
 
      if (ifirst < 0) break; // full miss
 
      ibase = ifirst+1; // try again
   }
   while (ibase < nhaylen);
 
   if (cs.debug)
      printf("match:  2) ifirst %d ilast %d bmatch %d for hay \"%s\" pat \"%s\"\n",ifirst,ilast,bmatch,pszHay,pszPat);

   if (bmatch && ifirst >= 0) {
      rfirsthit  = ifirst;
      if (ilast >= ifirst)
         rhitlen = (ilast-ifirst)+1;
      return 1;
   }

   return 0;
}

int indent(char *pszin) {
   char *psz = pszin;
   bool bempty = 1;
   for (; *psz; psz++)
      if (*psz != ' ' && *psz != '\t')
         { bempty = 0; break; }
   if (bempty) return -1;
   return psz-pszin;
}

// uses szLineBuf:
num getOldDirTime(char *pszName) 
{
   // printf("gdt %s\n",pszName);
   if (!pszGlblDirTimes)
      return 0;
   // direct search of entry in text file
   sprintf(szLineBuf, " %s\r", pszName);
   char *psz1 = strstr(pszGlblDirTimes, szLineBuf);
   if (!psz1)
      return 0;
   // step back to start of line, with timestamp
   while ((psz1 > pszGlblDirTimes) && (*psz1 != '\n'))
      psz1--;
   // skip LF, if not in very first line
   if (psz1 > pszGlblDirTimes)
      psz1++;
   num nTime = atonum(psz1);
   // printf("-> TIME %u\n",nTime);
   return nTime;
}

bool equalFileName(char *psz1, char *psz2) {
   #ifdef _WIN32
   // Windows: expect case-insensitive filenames
   return (!_stricmp(psz1, psz2)) ? 1 : 0;
   #else
   // Unix: expect case-sensitive filenames
   return (!strcmp(psz1, psz2)) ? 1 : 0;
   #endif
}

bool strBegins(char *pszStr, cchar *pszPat) {
   if (!strncmp(pszStr, pszPat, strlen(pszPat)))
      return 1;
   return 0;
}

bool strbeg(char *pszStr, cchar *pszPat) {
   if (!strncmp(pszStr, pszPat, strlen(pszPat)))
      return 1;
   return 0;
}

bool striBegins(char *pszStr, cchar *pszPat) {
   if (!mystrnicmp(pszStr, pszPat, strlen(pszPat)))
      return 1;
   return 0;
}

bool strcase(char *pszStr, cchar *pszPat) {
   return strcmp(pszStr, pszPat) ? 0 : 1;
}

bool strEnds(char *pszStr, cchar *pszPat) {
   int nlenhay = strlen(pszStr);
   int nlenpat = strlen(pszPat);
   if (nlenhay < nlenpat) return 0;
   return !strcmp(pszStr+nlenhay-nlenpat, pszPat) ? 1 : 0;
}

bool startsLikeSnapFile(char *psz) {
   return strBegins(psz, ":snapfile sfk,") || strBegins(psz, ":cluster sfk,");
}

bool startsLikeActFile(char *psz) {
   return strBegins(psz, "<interleaved-attributes-text version=\"1.0\" prefix=\"\">");
}

class InfoCounter {
public:
   InfoCounter    ( );
   uint count    ( );  // RC > 0 says print the counter now
   bool  checkTime( );  // RC > 0 says print the counter now
   bool  countSkip(char *pszFile);
   uint value    ( );
   uint skipped  ( );
   char  *skipInfo( );
   void  reset    ( );
private:
   void  copyAll  ( );

   uint nClUnits;
   uint nClSkipped;
   num   nClTime;

   uint nClTellSteps;
   uint nClLastTold;
   uint nClTellSteps2;
   uint nClLastTold2;
   num   nClLastTimeTold;
   int  nClTimeInertia; // to avoid calling getCurrentTime() too often

   char  aClSkipInfo[100];
   int  nClSkipIdx;
};

InfoCounter::InfoCounter() { reset(); }

void InfoCounter::reset() 
{
   nClUnits      = 0;
   nClSkipped    = 0;
   nClTime       = 0;

   nClLastTold   = 0;
   nClTellSteps  = 1;
   nClLastTold2  = 0;
   nClTellSteps2 = 1;
   nClLastTimeTold = 0;
   nClTimeInertia = 10;

   memset(aClSkipInfo, 0, sizeof(aClSkipInfo));
   // memset(aClSkipInfo, ' ', 5 * 3);
   nClSkipIdx = 2; // force switch to 0 on first add
}

void InfoCounter::copyAll() {
   nClLastTimeTold = nClTime;
   nClLastTold     = nClUnits;
   nClLastTold2    = nClSkipped;
   nClTimeInertia  = 10;
}

uint InfoCounter::value()    { return nClUnits; }
uint InfoCounter::skipped()  { return nClSkipped; }
char *InfoCounter::skipInfo() { return aClSkipInfo; }

uint InfoCounter::count() {
   nClUnits++;
   if (nClUnits >= (nClLastTold+nClTellSteps)) {
      nClTellSteps++;
      copyAll();
      return 1;
   }
   return checkTime();
}

bool InfoCounter::countSkip(char *pszFile)
{
   nClSkipped++;

   // mtklog(("countskip %s", pszFile));

   // update list of skipped file extensions
   char *pszInfo = pszFile;
   char *pszExt  = strrchr(pszInfo, '.');
   if (pszExt) pszInfo = pszExt;
   int nInfoLen = strlen(pszInfo);
   if (nInfoLen > 4) pszInfo = pszInfo + nInfoLen - 4;
   char *pszCur = &aClSkipInfo[5*nClSkipIdx];
   nInfoLen = strlen(pszInfo);
   if (   strncmp(&aClSkipInfo[ 0], pszInfo, nInfoLen)
       && strncmp(&aClSkipInfo[ 5], pszInfo, nInfoLen)
       && strncmp(&aClSkipInfo[10], pszInfo, nInfoLen)
      )
   {
      // there is a change, so step and write
      nClSkipIdx = (nClSkipIdx + 1) % 3;
      pszCur = &aClSkipInfo[5*nClSkipIdx];
      memset(pszCur, ' ', 5);
      strncpy(pszCur, pszInfo, nInfoLen);
      if (nClSkipIdx == 2)
         pszCur[4] = '\0';
   }

   // mtklog(("countskip info %s", aClSkipInfo));

   if (nClSkipped >= (nClLastTold2+nClTellSteps2)) {
      nClTellSteps2++;
      copyAll();
      return 1;
   }
   return checkTime();
}

bool InfoCounter::checkTime() {
   if (nClTimeInertia-- > 0)
      return 0;
   nClTimeInertia = 10;
   nClTime = getCurrentTime();
   if (nClTime > nClLastTimeTold + 1000) {
      copyAll();
      return 1;
   }
   return 0;
}

InfoCounter glblFileCount;

void resetFileCounter()   { glblFileCount.reset(); cs.lines = 0; }
bool fileCountCheckTime() { return glblFileCount.checkTime(); }

class NoCaseText
{
public:
   NoCaseText    ( );
   void reinit (bool bISO);

   inline  char lowerChar ( char c) { return aClLowerTab[(uchar)c]; }
   inline uchar lowerUChar(uchar c) { return (uchar)aClLowerTab[(uchar)c]; }
   inline  char upperChar ( char c) { return aClUpperTab[(uchar)c]; }
   inline uchar upperUChar(uchar c) { return (uchar)aClUpperTab[(uchar)c]; }

   inline uchar mapChar   (uchar c, uchar bCase) { return bCase ? c : (uchar)aClLowerTab[(uchar)c]; }
   void  setStringToLower(char *psz);

   char aClLowerTab[256+10];
   char aClUpperTab[256+10];
};

NoCaseText glblNoCase;

uchar sfkToLowerCase(uchar uc) { return glblNoCase.lowerUChar(uc); }
uchar sfkToUpperCase(uchar uc) { return glblNoCase.upperUChar(uc); }

NoCaseText::NoCaseText()
{
   reinit(1); // default
}

void NoCaseText::reinit(bool bISO)
{
   memset(aClLowerTab, 0, sizeof(aClLowerTab));

   for (uint u1=0; u1<256; u1++)
      aClUpperTab[u1] = u1;

   for (uint u1=0; u1<256; u1++)
   {
      uchar u2 = (uchar)u1;

      if (u1 >= 0x41 && u1 <= 0x5A)    // A-Z
         u2 += 0x20U;    // -> a-z

      if (bISO)
      {
         // ISO 8859-1 special character lowercase mapping
         if (u1 >= 0xC0 && u1 <= 0xDE)    // special characters
            if (u1 != 0xD7 && u1 != 0xDF) // NOT these two
               u2 += 0x20U; // e.g.  -> 
      }

      aClLowerTab[u1] = (char)u2;
      if (u1 != u2)
         aClUpperTab[u2] = (char)u1;
   }
}

void NoCaseText::setStringToLower(char *psz)
{
   for (int i=0; psz[i]; i++)
   {
      psz[i] = aClLowerTab[(uchar)psz[i]];
   }
}

#ifdef WITH_CASE_XNN
// RC : 0 == match, <> 0 == no match.
// Not suitable for sorting algorithms.
int sfkmemcmp2(uchar *psrc1, uchar *psrc2, num nlen, bool bGlobalCase, uchar *pFlags)
{
   if (bGlobalCase)
      return memcmp(psrc1, psrc2, nlen);

   int idiff=0;

   // optim: compare last character first.
   // requires at least a 2-char phrase.
   if (nlen > 1)
   {
      uchar bCase = pFlags ? sfkGetBit(pFlags,nlen-1) : 0;
      idiff =     glblNoCase.mapChar(psrc1[nlen-1],bCase)
               -  glblNoCase.mapChar(psrc2[nlen-1],bCase);
      if (idiff)
         return idiff;
   }

   uchar bCase;

   for (int i=0; i<nlen; i++)
   {
      bCase = pFlags ? sfkGetBit(pFlags,i) : 0;
      idiff =     glblNoCase.mapChar(psrc1[i],bCase)
               -  glblNoCase.mapChar(psrc2[i],bCase);
      if (idiff)
         break;
   }

   return idiff;
}
#endif

// RC : 0 == match, <> 0 == no match.
// Not suitable for sorting algorithms.
int sfkmemcmp(uchar *psrc1, uchar *psrc2, num nlen, bool bcase)
{
   if (bcase)
      return memcmp(psrc1, psrc2, nlen);

   num i=0, idiff=0;

   // optim: compare last character first.
   // requires at least a 2-char phrase.
   if (nlen > 1)
   {
      idiff =     glblNoCase.lowerUChar(psrc1[nlen-1])
               -  glblNoCase.lowerUChar(psrc2[nlen-1]);
      if (idiff)
         return idiff;
   }

   for (; i<nlen; i++)
   {
      idiff =     glblNoCase.lowerUChar(psrc1[i])
               -  glblNoCase.lowerUChar(psrc2[i]);

      if (idiff)
         break;
   }

   return idiff;
}

#ifdef WITH_CASE_XNN
uchar *memIFind(uchar *pNeedle, num nNeedleSize, uchar *pHayStack, num nHaySize, uchar *pFlags)
{
   uchar *pCur = pHayStack;
   uchar *pMax = pHayStack + nHaySize - nNeedleSize; // inclusive
   uchar bCase = pFlags ? sfkGetBit(pFlags,0) : 0;
   uchar c1    = glblNoCase.mapChar(*pNeedle,bCase);
   while (pCur <= pMax)
   {
      uchar *p1 = pCur;
      // seek to next potential start
      while ((p1 <= pMax) && (glblNoCase.mapChar(*p1,bCase) != c1))
         p1++;
      if (!p1 || (p1 > pMax))
         return 0;
      // compare from p1, case-insensitive
      // pMax assures that from p1, there are at least nNeedleSize
      // bytes available for actual compare, so we don't check
      // p1 against pMax again here.
      num i=0;
      for (; i<nNeedleSize; i++) {
         bCase = pFlags ? sfkGetBit(pFlags,i) : 0;
         if (glblNoCase.mapChar(pNeedle[i],bCase) != glblNoCase.mapChar(p1[i],bCase))
            break;
      }
      if (i >= nNeedleSize)
         return p1;  // hit
      // no hit, proceed
      pCur = p1+1;
   }
   return 0;
}
#else
uchar *memIFind(uchar *pNeedle, num nNeedleSize, uchar *pHayStack, num nHaySize)
{
   uchar *pCur = pHayStack;
   uchar *pMax = pHayStack + nHaySize - nNeedleSize; // inclusive
   uchar c1    = glblNoCase.lowerUChar(*pNeedle);
   while (pCur <= pMax)
   {
      uchar *p1 = pCur;
      // seek to next potential start
      while ((p1 <= pMax) && (glblNoCase.lowerUChar(*p1) != c1))
         p1++;
      if (!p1 || (p1 > pMax))
         return 0;
      // compare from p1, case-insensitive
      // pMax assures that from p1, there are at least nNeedleSize
      // bytes available for actual compare, so we don't check
      // p1 against pMax again here.
      num i=0;
      for (; i<nNeedleSize; i++)
         if (glblNoCase.lowerUChar(pNeedle[i]) != glblNoCase.lowerUChar(p1[i]))
            break;
      if (i >= nNeedleSize)
         return p1;  // hit
      // no hit, proceed
      pCur = p1+1;
   }
   return 0;
}
#endif

char *dataAsHex(void *pAnyData, int iDataSize, char *pszBuf, int iMaxBuf)
{
   static char szBuf[300];

   if (!pszBuf)
   {
      pszBuf = szBuf;
      iMaxBuf = sizeof(szBuf);
   }
 
   uchar *pSrcCur = (uchar *)pAnyData;
   uchar *pSrcMax = pSrcCur + iDataSize;
 
   char *pszDstCur = pszBuf;
   char *pszDstMax = pszBuf + iMaxBuf - 20;
 
   while (pSrcCur < pSrcMax && pszDstCur < pszDstMax)
   {
      uchar uc = *pSrcCur++;
      sprintf(pszDstCur, "%02X", uc);
      pszDstCur += 2;
   }
 
   *pszDstCur = '\0';
 
   return pszBuf;
}

char *dataAsTrace(void *pAnyData, int iDataSize, char *pszBuf, int iMaxBuf)
{
   static char szBuf[300];

   if (iDataSize == -1)
       iDataSize = strlen((char*)pAnyData);

   if (!pszBuf) 
   {
      pszBuf = szBuf;
      iMaxBuf = sizeof(szBuf);
   }
   
   uchar *pSrcCur = (uchar *)pAnyData;
   uchar *pSrcMax = pSrcCur + iDataSize;
 
   char *pszDstCur = pszBuf;
   char *pszDstMax = pszBuf + iMaxBuf - 20;
 
   while (pSrcCur < pSrcMax && pszDstCur < pszDstMax)
   {
      uchar uc = *pSrcCur++;
 
      if (isprint((char)uc))
      {
         *pszDstCur++ = (char)uc;
         continue;
      }

      // convert binary to {hex}
      sprintf(pszDstCur, "{%02X}", uc);
      pszDstCur += 4;
   }
 
   *pszDstCur = '\0';
 
   return pszBuf;
}

class FileInfo 
{
public:
      FileInfo    (bool bWriteOnly=false);
     ~FileInfo    ( );
int   init        (char *pszFileName, int nShortNameLen=60, num nFileSize=0);
bool  fileValid   ( );
bool  timeToTell  ( );
int   percentage  (num nPosition);
cchar *prefix     ( );
cchar *shortName  ( );
num   fileSize    ( ) { return nClFileSize; }
void  printBlankLine (int nChars);
private:
bool  bClWriteOnly;
char  *pszClName;
int   nClNameLen;
int   nClShortNameLen;
num   nClStartTime;
num   nClNextTell;
num   nClFileSize;
};

FileInfo::FileInfo(bool bWriteOnly) {
   bClWriteOnly   = bWriteOnly;
   pszClName      = 0;
   nClNameLen     = 0;
   nClStartTime   = 0;
   nClNextTell    = 0;
   nClFileSize    = 0;
}

int FileInfo::init(char *pszName, int nShortNameLen, num nFileSize) 
{
   pszClName = strdup(pszName);
   if (!pszClName) return 9+perr("out of memory: finfo\n");
   nClNameLen = strlen(pszClName);
   nClShortNameLen = nShortNameLen;
   nClStartTime = getCurrentTime();
   nClNextTell = nClStartTime + 1000;
   nClFileSize = nFileSize;
   return 0;
}

bool FileInfo::fileValid() {
   return (nClFileSize >= 0);
}

FileInfo::~FileInfo() {
   if (pszClName) delete [] pszClName;
}

bool FileInfo::timeToTell() {
   if (getCurrentTime() >= nClNextTell) {
      nClNextTell = getCurrentTime() + 1000;
      return true;
   }
   return false;
}

int FileInfo::percentage(num nPosition) {
   if (!nClFileSize) return 100;
   return (int)(nPosition * 100 / nClFileSize);
}

cchar *FileInfo::prefix() {
   int nLimit = nClShortNameLen;
   if (nClNameLen > nLimit)
      return "...";
   return "";
}

cchar *FileInfo::shortName() {
   int nLimit = nClShortNameLen;
   if (!pszClName) return "";
   int noff = 0;
   if (nClNameLen > nLimit)
        noff = nClNameLen - nLimit;
   return pszClName+noff;
}

void FileInfo::printBlankLine(int nChars) {
   for (int i=0; i<nChars; i++)
      putchar(' ');
   printf("\r");
}

FileSet  glblFileSet;   // int format -dir and -file set
CoiTable glblSFL;       // short format specific file list

int glblSFLNumberOfEntries() { return glblSFL.numberOfEntries(); }

int StringPipe::setEntry(int iIndex, char *psz, char *pAttr)
{
   if (clAttr.setEntry(iIndex, pAttr)) return 9;
   return clText.setEntry(iIndex, psz);
}

int StringPipe::addEntry(char *psz, char *pAttr)
{
   if (clAttr.addEntry(pAttr)) return 9;
   return clText.addEntry(psz);
}

void StringPipe::resetEntries()
{
   clText.resetEntries();
   clAttr.resetEntries();
}

char *StringPipe::getEntry(int nIndex, int nLine, char **ppAttr)
{
   char *ptext = clText.getEntry(nIndex, nLine);
   char *pattr = clAttr.getEntry(nIndex, nLine);
   if (ppAttr) *ppAttr = pattr;
   return ptext;
}

void StringPipe::resetPipe()
{
   resetEntries();
   nReadIndex = 0;
}

void StringPipe::dump(cchar *pszTitle)
{
   printf("[pipe %s contents (%d lines):]\n",pszTitle,numberOfEntries());
   for (int i=0; i<numberOfEntries(); i++)
      printf("[   \"%s\"]\n",getEntry(i,__LINE__));
}

void oprintf(cchar *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';

   #ifdef _WIN32
   char *psz = szPrintBufMap;
   // windows only: if output is NOT directed to file, map it to DOS charset,
   // to have filenames listed with correct umlauts etc.
   if (bGlblEnableOPrintf && (bGlblForceCConv || bGlblHaveInteractiveConsole)) {
      while (*psz)
         *psz++ = ansiCharToOEM(*psz);
   }
   #endif

   printf("%s", szPrintBufMap);
   fflush(stdout);
}

void oprintf(StringPipe *pOutData, cchar *pszFormat, ...)
{
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBufMap, sizeof(szPrintBufMap)-10, pszFormat, argList);
   szPrintBufMap[sizeof(szPrintBufMap)-10] = '\0';

   char *psz = szPrintBufMap;

   if (pOutData) {
      // auto-strip LF if given. oprintf adds full records only.
      // do NOT convert text, as it is passed to further chain commands.
      int nlen = strlen(psz);
      if (nlen > 0 && psz[nlen-1] == '\n')
         psz[nlen-1] = '\0';
      pOutData->addEntry(psz, str(""));
   } else {
      #ifdef _WIN32
      // windows only: if output is NOT directed to file, map it to DOS charset,
      // to have filenames listed with correct umlauts etc.
      if (bGlblEnableOPrintf && (bGlblForceCConv || bGlblHaveInteractiveConsole)) {
         while (*psz)
            *psz++ = ansiCharToOEM(*psz);
      }
      #endif
      printf("%s", szPrintBufMap);
      fflush(stdout);
   }
}

class CommandChaining
{
public:
   CommandChaining ( );

   bool  colfiles;   // collect filenames
   bool  usefiles;   // use collected filenames
   bool  coldata;    // collect data
   bool  usedata;    // use collected data
   bool  colbinary;  // with coldata: next command accepts binary

   CoiTable *infiles;   // while using filenames
   CoiTable *outfiles;  // while collecting filenames

   StringPipe *indata;  // text and attributes
   StringPipe *outdata; // text and attributes
   StringPipe *storedata;

   bool  text2files;
   bool  files2text;

   int  init();
   void  reset();    // per loop
   void  shutdown();
   bool  colany() { return colfiles || coldata; }
   bool  useany() { return usefiles || usedata; }
   int  moveOutToIn(char *pszCmd);
   int  convInDataToInFiles ( );

   int  addLine(char *pszText, char *pszAttr, bool bSplitByLF=0);
   int  addToCurLine(char *pszWords, char *pszAttr, bool bNewLine=0);

   int  addFile(Coi &ocoi); // is COPIED
   int  numberOfInFiles() { return infiles->numberOfEntries(); }
   Coi  *getFile(int nIndex); // returns null on wrong index

   int  print(char cattrib, int nflags, cchar *pszFormat, ...);
   int  print(cchar *pszFormat, ...); // multi-line support

   int  printFile(cchar *pszOutFile, bool bWriteFile, cchar *pszFormat, ...);

   void  dumpContents();   // to terminal

   int   addBinary(uchar *pData, int iSize);
   uchar *loadBinary(num &rSize); // owned by caller

   num   nClOutBinarySize;  // for binary write
   num   nClInBinarySize;   // for binary read
   uint  nClOutCheckSum;
   uint  nClInCheckSum;

private:
   char  szClPreBuf[MAX_LINE_LEN+10];
   char  szClPreAttr[MAX_LINE_LEN+10];
   char  szClBuf[MAX_LINE_LEN+10];
   char  szClAttr[MAX_LINE_LEN+10];
   char  szClBinBuf[32768+100];
   int   iClBinBufUsed;
   bool  btold1;
}
chain;

// sfk cmd support
#define MAX_HELPCMD_TEXT 1000
char szGlblHelpCmdPat[50]; // e.g. [1234]
char szGlblHelpCmdText[MAX_HELPCMD_TEXT+100];
int  iGlblHelpCmd = 0;
int  iGlblHelpCmdCollectState = 0;
int  iGlblHelpCmdIndent = 0;

void addHelpCmdLine(char *pszRawIn, char *pszForm)
{
   /*
      raw
         "      #sfk xex in.csv "_[lstart]*\t*\t*_<row>\n <artist>[part2]{LF}"
         ...
         "         then reformat this to xml data. [123] \n"

      form
         sfk xex in.csv "_[lstart]*\t*\t*_<row>\n <artist>[part2]
         ...
         then reformat this to xml data. [123]{CR/LF}
   */

   // is it the searched reference?
   char *psz = pszForm + strlen(pszForm);
   while (psz > pszForm && (psz[-1]=='\r' || psz[-1]=='\n'))
      psz--;
   if (psz > pszForm && psz[-1] == ']' && strstr(pszForm, szGlblHelpCmdPat))
   {
      // yes, stop further collection
      iGlblCollectCmd = 2;
      return;
   }

   // collect example text
   bool bexamp=0;
   char *pszRaw = pszRawIn;
   while (*pszRaw == ' ')
      pszRaw++;
   if (*pszRaw == '#') {
      int iCurIndent = (int)(pszRaw - pszRawIn);
      if (!strncmp(pszRaw, "#sfk", 4)) {
         iGlblHelpCmdIndent = iCurIndent;
         bexamp = 1;
      } else {
         if (iCurIndent==iGlblHelpCmdIndent || iCurIndent==iGlblHelpCmdIndent+1)
            bexamp = 1;
      }
   }

   switch (iGlblHelpCmdCollectState)
   {
      case 0:  // seeking for next example start
         if (bexamp) {
            iGlblHelpCmdCollectState=1;
            break;
         }
         // any text
         iGlblHelpCmdCollectState=2;
         return;
 
      case 1:  // within example text lines
         if (bexamp)
            break;
         // any text
         iGlblHelpCmdCollectState=2;
         return;

      case 2:  // seeking for reference, or next example start
         if (bexamp) {
            szGlblHelpCmdText[0] = '\0';
            iGlblHelpCmdCollectState=1;
            break;
         }
         // any text
         return;
   } 

   // append another example line

   int iquotes = 0;
   for (char *psz2 = szGlblHelpCmdText; *psz2; psz2++)
      if (*psz2 == '\"')
         iquotes++;
   if (szGlblHelpCmdText[0] != 0 && (iquotes & 1) == 0)
      strcat(szGlblHelpCmdText, " ");

   char *pSrcCur = pszForm;
   char *pSrcMax = pszForm + strlen(pszForm);
   while (*pSrcCur == ' ')
      pSrcCur++;
   while (pSrcMax > pszForm && (pSrcMax[-1]=='\r' || pSrcMax[-1]=='\n'))
      pSrcMax--;

   int iDstLen = strlen(szGlblHelpCmdText);
   int iDstRem = MAX_HELPCMD_TEXT - iDstLen;
   int iSrcLen = pSrcMax - pSrcCur;
   if (iSrcLen < 1 || iSrcLen+10 > iDstRem) {
      printf("example overflow: %s\n", pszForm);
      return;
   }

   memcpy(szGlblHelpCmdText+iDstLen, pSrcCur, iSrcLen);
   szGlblHelpCmdText[iDstLen+iSrcLen] = '\0';   
}

void addHelpCmdLines(char *pszRaw, char *pszForm)
{
   char szBuf1[1100],szBuf2[1100];

   while (*pszRaw && *pszForm)
   {
      char *pszRaw2 = strchr(pszRaw, '\n');
      if (!pszRaw2)
            pszRaw2 = pszRaw + strlen(pszRaw);
      int iLenRaw = pszRaw2 - pszRaw;
      if (iLenRaw > 1000) {
         printf("help.overflow.1 %s\n", pszRaw);
         return;
      }

      char *pszForm2 = strchr(pszForm, '\n');
      if (!pszForm2)
            pszForm2 = pszForm + strlen(pszForm);
      int iLenForm = pszForm2 - pszForm;
      if (iLenForm > 1000) {
         printf("help.overflow.2 %s\n", pszForm);
         return;
      }

      memcpy(szBuf1, pszRaw, iLenRaw);
      szBuf1[iLenRaw] = '\0';

      memcpy(szBuf2, pszForm, iLenForm);
      szBuf2[iLenForm] = '\0';

      addHelpCmdLine(szBuf1, szBuf2);

      if (iGlblCollectCmd == 2)
         break;

      pszRaw = pszRaw2;
      if (*pszRaw)
         pszRaw++;

      pszForm = pszForm2;
      if (*pszForm)
         pszForm++;
   }
}

int chainAddLine(char *pszText, char *pszAttr, bool bSplitByLF) 
{
   // mtklog(("chain-add: \"%.50s\"", pszText));
   return chain.addLine(pszText, pszAttr, bSplitByLF);
}

int CommandChaining::addFile(Coi &ocoi) {
   return outfiles->addEntry(ocoi);
}

Coi *CommandChaining::getFile(int nIndex) {
   return infiles->getEntry(nIndex, __LINE__);
}

void CommandChaining::dumpContents() 
{__
   if (usedata) {
      printf("[indata]\n");
      for (int i=0; i<chain.indata->numberOfEntries(); i++) {
         char *pattr = str("");
         char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
         if (ptext)
            printColorText(ptext, pattr, 1); // with lf
      }         
   }

   if (usefiles) {
      printf("[infiles]\n");
      for (int i=0; i<chain.numberOfInFiles(); i++) {
         Coi *pcoi = chain.getFile(i);
         if (pcoi) {
            oprintf("%s\n", pcoi->name());
         }
      }
   }
}

// uses print buffers from printx
int CommandChaining::print(char cattrib, int nflags, cchar *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);

   bool bWithPostLF = (nflags & 1) ? 1 : 0;
   bool bWithPreLF  = (nflags & 2) ? 1 : 0;
   bool bMultiLine  = (nflags & 4) ? 1 : 0;

   // prepare text
   ::vsnprintf(szClPreBuf, sizeof(szClPreBuf)-10, pszFormat, argList);
   szClPreBuf[sizeof(szClPreBuf)-10] = '\0';

   if (bMultiLine)
   {
      // full flexible line split
      if (!coldata && !cs.outfile)
         info.clear();
   
      char *psz1 = szClPreBuf;
      while (psz1 && *psz1)
      {
         char *psz2 = strchr(psz1, '\n');
         if (psz2) {
            // intermediate record
            int n = psz2-psz1;
            if (n > MAX_LINE_LEN) n = MAX_LINE_LEN;
            memcpy(szPrintBuf2, psz1, n);
            szPrintBuf2[n] = '\0';
            trimCR(szPrintBuf2);
            psz2++;
         } else {
            // last record
            strcopy(szPrintBuf2, psz1);
         }
   
         int nlen = strlen(szPrintBuf2);
         memset(szClPreAttr, cattrib, nlen);
         szClPreAttr[nlen] = '\0';
   
         if (coldata)
            addLine(szPrintBuf2, szClPreAttr);
         else
         if (cs.outfile)
            fprintf(cs.outfile, "%s\n", szPrintBuf2);
         else
            printColorText(szPrintBuf2, szClPreAttr, 1);
   
         psz1 = psz2;
      }
   }
   else
   {
      // single line print

      // prepare mono color
      int nlen = strlen(szClPreBuf);
      memset(szClPreAttr, cattrib, nlen);
      szClPreAttr[nlen] = '\0';
   
      if (coldata) {
         if (bWithPreLF)
            addLine(str(""), str(""));
         if (bWithPostLF) {
            return addLine(szClPreBuf, szClPreAttr);
         } else {
            return addToCurLine(szClPreBuf, szClPreAttr, bWithPreLF);
         }
      } else {
         info.clear();
         if (bWithPreLF)
            printf("\n");
         printColorText(szClPreBuf, szClPreAttr, bWithPostLF);
      }
   }

   return 0;
}

// uses print buffers from printx
int CommandChaining::printFile(cchar *pszOutFile, bool bWriteFile, cchar *pszFormat, ...)
{__
   int nrc = 0;

   // there should be no redirect file open
   if (cs.outfile) return 9+perr("redirect file already open");

   if (bWriteFile) {
      // isolate path, create all directories
      int createSubDirTree(char *pszDstRoot, char *pszDirTree, char *pszRefRoot);
      strcopy(szPrintBuf2, pszOutFile);
      char *psz1 = strrchr(szPrintBuf2, glblPathChar);
      if (psz1) {
         *psz1 = '\0'; 
         if ((nrc = createSubDirTree(szPrintBuf2, str(""), 0)))
            return nrc+perr("cannot create dir: %s\n", szPrintBuf2);
      }
   
      // init redirect outfile
      if (!(cs.outfile = fopen(pszOutFile, "w")))
         return 9+perr("cannot write: %s\n", pszOutFile);
   } else {
      // just simulate the file writing:
      printf("\n:file:\n%s\n", pszOutFile);
   }

   // NO RETURN WITHOUT CONDITIONAL FILE CLOSE BEGIN

   va_list argList;
   va_start(argList, pszFormat);

   // prepare text
   ::vsnprintf(szClPreBuf, sizeof(szClPreBuf)-10, pszFormat, argList);
   szClPreBuf[sizeof(szClPreBuf)-10] = '\0';

   if (!coldata && !cs.outfile)
      info.clear();

   char *psz1 = szClPreBuf;
   while (psz1 && *psz1)
   {
      char *psz2 = strchr(psz1, '\n');
      if (psz2) {
         // intermediate record
         int n = psz2-psz1;
         if (n > MAX_LINE_LEN) n = MAX_LINE_LEN;
         memcpy(szPrintBuf2, psz1, n);
         szPrintBuf2[n] = '\0';
         psz2++;
      } else {
         // last record
         strcopy(szPrintBuf2, psz1);
      }

      int nlen = strlen(szPrintBuf2);
      memset(szClPreAttr, ' ', nlen);
      szClPreAttr[nlen] = '\0';

      if (coldata)
         addLine(szPrintBuf2, szClPreAttr);
      else
      if (cs.outfile)
         fprintf(cs.outfile, "%s\n", szPrintBuf2);
      else
         printColorText(szPrintBuf2, szClPreAttr, 1);

      psz1 = psz2;
   }

   // NO RETURN WITHOUT FILE CLOSE END

   if (bWriteFile && cs.outfile) {
      fclose(cs.outfile);
      cs.outfile = 0;
      printf("written: %s\n", pszOutFile);
   }

   return nrc;
}

// raw printf like method. no colors, no special options,
// but it splits multiline text into many records.
// one-line text SHOULD be terminated with LF.
int CommandChaining::print(cchar *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);

   // prepare text
   ::vsnprintf(szClPreBuf, sizeof(szClPreBuf)-10, pszFormat, argList);
   szClPreBuf[sizeof(szClPreBuf)-10] = '\0';

   if (!coldata && !cs.outfile)
      info.clear();

   char *psz1 = szClPreBuf;
   while (psz1 && *psz1)
   {
      char *psz2 = strchr(psz1, '\n');
      if (psz2) {
         // intermediate record
         int n = psz2-psz1;
         if (n > MAX_LINE_LEN) n = MAX_LINE_LEN;
         memcpy(szPrintBuf2, psz1, n);
         szPrintBuf2[n] = '\0';
         psz2++;
      } else {
         // last record
         strcopy(szPrintBuf2, psz1);
      }

      int nlen = strlen(szPrintBuf2);
      memset(szClPreAttr, ' ', nlen);
      szClPreAttr[nlen] = '\0';

      if (coldata)
         addLine(szPrintBuf2, szClPreAttr);
      else
      if (cs.outfile)
         fprintf(cs.outfile, "%s\n", szPrintBuf2);
      else
         printColorText(szPrintBuf2, szClPreAttr, 1);

      psz1 = psz2;
   }

   return 0;
}

int CommandChaining::convInDataToInFiles()
{__
   // user wants to convert text to filename list
   for (int i=0; i<indata->numberOfEntries(); i++) {
      char *psz1 = indata->getEntry(i, __LINE__);
      // strip LFs (if any) from indata. we will drop
      // all indata records below, therefore edit directly:
      int nlen = strlen(psz1);
      if (nlen > 0 && psz1[nlen-1] == '\n')
          psz1[nlen-1] = '\0';
      Coi ocoi(psz1, 0);
      infiles->addEntry(ocoi); // is copied
   }
   indata->resetEntries();
   if (cs.verbose)
      printf("[chain converts text data to filename list]\n");
   usefiles = 1;
   usedata  = 0;
   return 0;
}

int CommandChaining::addBinary(uchar *pData, int iSize)
{
   int iRemain   = iSize;
   int iRecChars = (sizeof(szClBinBuf)-100);
   int iRecBytes = iRecChars/2;
   
   const char *ptohex = "0123456789ABCDEF";

   int iSrcOff = 0;
   int iDstOff = iClBinBufUsed;

   while (iRemain > 0)
   {
      int iPart = mymin(iRemain, iRecBytes);

      for (int iByte=0; iByte<iPart; iByte++)
      {
         if (iDstOff+2 >= iRecChars)
         {
            szClBinBuf[iDstOff] = '\0';
            iDstOff = iClBinBufUsed = 0;
            if (outdata->addEntry(szClBinBuf, str("")))
               return 9;
         }

         uchar u = pData[iSrcOff+iByte];
         szClBinBuf[iDstOff+0] = ptohex[(u>>4)&0xF];
         szClBinBuf[iDstOff+1] = ptohex[(u   )&0xF];
         nClOutCheckSum = ((nClOutCheckSum << 1) ^ (nClOutCheckSum >> 31)) ^ u;

         iDstOff += 2;
      }

      iSrcOff += iPart;
      iRemain -= iPart;
      nClOutBinarySize += iPart;
   }

   iClBinBufUsed = iDstOff;
   
   return 0;
}

uchar twoHexToUChar(char *psz, bool &rError)
{
   uchar u = 0;
   switch (psz[0]) 
   {
      case '0': u=0x00; break; case '1': u=0x10; break; case '2': u=0x20; break;
      case '3': u=0x30; break; case '4': u=0x40; break; case '5': u=0x50; break;
      case '6': u=0x60; break; case '7': u=0x70; break; case '8': u=0x80; break;
      case '9': u=0x90; break; case 'A': u=0xA0; break; case 'B': u=0xB0; break;
      case 'C': u=0xC0; break; case 'D': u=0xD0; break; case 'E': u=0xE0; break;
      case 'F': u=0xF0; break;
      default:
         rError=1;
         return 0;
   }
   switch (psz[1]) 
   {
      case '0': u|=0x00; break; case '1': u|=0x01; break; case '2': u|=0x02; break;
      case '3': u|=0x03; break; case '4': u|=0x04; break; case '5': u|=0x05; break;
      case '6': u|=0x06; break; case '7': u|=0x07; break; case '8': u|=0x08; break;
      case '9': u|=0x09; break; case 'A': u|=0x0A; break; case 'B': u|=0x0B; break;
      case 'C': u|=0x0C; break; case 'D': u|=0x0D; break; case 'E': u|=0x0E; break;
      case 'F': u|=0x0F; break;
      default:
         rError=1;
         return 0;
   }
   return u;
}

// guarantees zero termination with 100 bytes tolerance
uchar *CommandChaining::loadBinary(num &rSize)
{
   if (nClInBinarySize < 1)
      return 0;

   uchar *pData = new uchar[nClInBinarySize+100];
   if (!pData)
      { perr("out of memory while collecting binary chain data (%s)", numtoa(nClInBinarySize)); return 0; }
   memset(pData, 0, nClInBinarySize+100);

   uchar *pDstCur = pData;
   uchar *pDstMax = pData + nClInBinarySize;

   bool bError = 0;

   num nBytes = 0;
   
   uint nTmpSum = 0;

   for (int i=0; i<chain.indata->numberOfEntries(); i++) 
   {
      char *pattr = str("");
      char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
      if (!ptext)
         break;

      while (ptext[0] && ptext[1])
      {
         uchar u = twoHexToUChar(ptext, bError);
         if (bError) {
            delete [] pData;
            perr("invalid chain binary data format: %s", ptext);
            return 0;
         }
         if (pDstCur >= pDstMax) {
            // should not occur
            delete [] pData;
            perr("output overflow while collecting chain binary data");
            return 0;
         }
         nTmpSum = ((nTmpSum << 1) ^ (nTmpSum >> 31)) ^ u;
         *pDstCur++ = u;
         nBytes++;
         ptext += 2;
      }
   }         

   if (nBytes != nClInBinarySize) {
      delete [] pData;
      perr("data size mismatch while collecting chain binary data (%d/%d)",(int)nBytes,(int)nClInBinarySize);
      return 0;
   }
   if (nTmpSum != nClInCheckSum) {
      delete [] pData;
      perr("checksum mismatch while collecting chain binary data (%X/%X)",nTmpSum,nClInCheckSum);
      return 0;
   }

   rSize = nBytes;

   return pData;
}

int CommandChaining::addLine(char *pszText, char *pszAttr, bool bSplitByLF)
{
   mtklog(("addl.text: %d %04d \"%s\"", bSplitByLF, strlen(pszText), pszText));
   mtklog(("addl.attr: %d %04d \"%s\"", bSplitByLF, strlen(pszAttr), pszAttr));

   if (pszText[0] && bSplitByLF) 
   {
      // detect if the line contains multiple linefeeds. 
      // if so, create multiple records.
      bool btermlf = 0;
      char *psz  = pszText;
      int nalen = strlen(pszAttr);
      while (*psz) 
      {
         char *psz2 = psz;
         while (*psz2 && *psz2 != '\n')
            psz2++;
         int nlen = psz2-psz;
         if (nlen > MAX_LINE_LEN) nlen = MAX_LINE_LEN;

         // isolate text part
         memcpy(szClBuf, psz, nlen);
         szClBuf[nlen] = '\0';
         removeCRLF(szClBuf); // just in case

         // isolate attribute part
         int noff = psz-pszText;
         if (noff < nalen) {
            strncpy(szClAttr, pszAttr+noff, nlen);
            szClAttr[nlen] = '\0';
         } else {
            szClAttr[0] = '\0';
         }

         // then store both parts
         outdata->addEntry(szClBuf, szClAttr);

         if (*psz2) {
            psz2++; // skip lf
            if (!*psz2) btermlf = 1;
         }
         psz = psz2;
      }
      if (btermlf && (bSplitByLF > 1)) {
         // the text was ended by a LF. this should produce
         // an empty line only if SplitByLF == 2.
         outdata->addEntry(str(""), str(""));
      }
   } else {
      // used also for empty strings, to add empty line
      outdata->addEntry(pszText, pszAttr);
   }
   return 0;
}

int CommandChaining::addToCurLine(char *pszWords, char *pszAttr, bool bNewLine)
{
   mtklog(("addc.text: %d %04d \"%s\"", bNewLine, strlen(pszWords), pszWords));
   mtklog(("addc.attr: %d %04d \"%s\"", bNewLine, strlen(pszAttr ), pszAttr ));

   if (!outdata->numberOfEntries() || bNewLine)
       if (outdata->addEntry(str(""), str("")))
         return 9;

   // append actual text
   {
      int nidx = outdata->numberOfEntries()-1;
      if (nidx < 0) return 9+perr("internal 200706102039");

      char *pAttr  = 0;   
      char *pszCur = outdata->getEntry(nidx, __LINE__, &pAttr);
      strcopy(szClBuf, pszCur);
      if (pAttr) strcopy(szClAttr, pAttr);
      else szClAttr[0] = '\0';

      int icurlen = strlen(szClBuf);   
      int nremain = MAX_LINE_LEN - icurlen - 1;

      // append text
      int naddlen = strlen(pszWords);
      if (naddlen > nremain) {
         if (!btold1) {
            btold1 = 1;
            perr("line buffer overflow: cannot join \"%s\" and following\n", pszWords);
            pinf("buffered lines may have %d characters max.\n", MAX_LINE_LEN-10);
         }
         return 1;
      }

      // and attributes as well, length limited by text
      int nattlen = strlen(pszAttr);
      if (nattlen > naddlen) nattlen = naddlen;

      strncpy(szClBuf+icurlen, pszWords, naddlen);
      szClBuf[icurlen+naddlen] = '\0';

      strncpy(szClAttr+icurlen, pszAttr, nattlen);
      szClAttr[icurlen+nattlen] = '\0';

      outdata->setEntry(nidx, szClBuf, szClAttr);
   }

   return 0;
}

int CommandChaining::moveOutToIn(char *pszCmd)
{__
   // flush final part of binary add
   if (chain.coldata && iClBinBufUsed)
   {
      if (cs.verbose)
         printf("[chain flushes %d binary data]\n", iClBinBufUsed/2);
      szClBinBuf[iClBinBufUsed] = '\0';
      iClBinBufUsed = 0;
      if (outdata->addEntry(szClBinBuf, str("")))
         return 9;
   }

   CoiTable *p1 = infiles;
   infiles      = outfiles;
   outfiles     = p1;
   outfiles->resetEntries();

   usefiles = colfiles;

   StringPipe *p3 = indata;
   indata   = outdata;
   outdata  = p3;
   outdata->resetPipe();

   usedata  = coldata;

   colfiles = 0;
   coldata  = 0;
   colbinary= 0;

   if (usefiles && usedata) 
   {
      // chain command with ANY input:
      // can work only if one stream has data AND other is empty
      if (numberOfInFiles() && indata->numberOfEntries()) {
         perr("command chaining: cannot use text data AND filename list in parallel.\n");
         exit(9); 
      }

      // reduce mode selection, following given data
      if (indata->numberOfEntries()) usefiles = 0;
      if (numberOfInFiles()) usedata = 0;
   }

   if (cs.verbose)
      printf("[chain swaps out and in, text2files=%d files2text=%d]\n",text2files,files2text);

   bool bt2f = text2files;
   bool bf2t = files2text;

   text2files = 0;
   files2text = 0;

   if (bt2f && bf2t)
      return 9+perr("command chaining stopped: cannot execute text2files AND files2text\n");

   if (usedata && !usefiles && !indata->numberOfEntries()) {
      if (cs.verbose)
         printf("[chain autoselects ftt from %d filenames.]\n",numberOfInFiles());
      bf2t = 1;
   }

   if (usefiles && !usedata && !numberOfInFiles()) {
      if (cs.verbose)
         printf("[chain autoselects ttf from %d text lines.]\n",indata->numberOfEntries());
      bt2f = 1;
   }

   if (bf2t)
   {
      // autoconvert filename list to text, even on empty list.
      int nrec = numberOfInFiles();
      for (int i=0; i<nrec; i++) {
         Coi *pcoi = getFile(i);
         if (pcoi) indata->addEntry(pcoi->name(), str(""));
      }
      infiles->resetEntries();
      if (cs.verbose)
         printf("[chain converts filename list to text data, %d records]\n", nrec);
      usefiles = 0;
      usedata  = 1;
   }
   else
   if (bt2f)
   {
      if (indata->numberOfEntries()) {
         // user wants to convert text to filename list
         convInDataToInFiles();
      } else {
         // out of chain filenames
         if (!cs.quiet) {
            pinf("chaining stops before %s: no more filenames\n",pszCmd);
         }
         return 1;
      }
   }

   if (cs.verbose) {
      if (usefiles)
         printf("[chain passes %d files to %s]\n",numberOfInFiles(),pszCmd);
      if (usedata)
         printf("[chain passes %d %s to %s]\n",
            indata->numberOfEntries(),
            nClOutBinarySize ? "records":"text lines",
            pszCmd);
   }

   nClInCheckSum = nClOutCheckSum;
   nClOutCheckSum = 0;

   if ((nClInBinarySize = nClOutBinarySize)) {
      nClOutBinarySize = 0;
      if (cs.verbose)
         printf("[chain passes %s bytes of binary]\n", numtoa(nClInBinarySize));
   }

   return 0;
}

CommandChaining::CommandChaining()
{
   colfiles   = 0;
   usefiles   = 0;
   coldata    = 0;
   usedata    = 0;
   colbinary  = 0;

   infiles    = 0;
   outfiles   = 0;

   indata     = 0;
   outdata    = 0;
   storedata  = 0;

   text2files = 0;
   files2text = 0;
   btold1     = 0;

   nClOutBinarySize = 0;
   nClInBinarySize = 0;
   nClOutCheckSum = 0;
   nClInCheckSum = 0;
   iClBinBufUsed = 0;
}

int CommandChaining::init()
{
   infiles  = new CoiTable();
   outfiles = new CoiTable();

   indata   = new StringPipe();
   outdata  = new StringPipe();
   storedata= new StringPipe();

   memset(szClPreBuf, 0, sizeof(szClPreBuf));
   memset(szClPreAttr, 0, sizeof(szClPreAttr));
   memset(szClBuf, 0, sizeof(szClBuf));
   memset(szClAttr, 0, sizeof(szClAttr));
   memset(szClBinBuf, 0, sizeof(szClBinBuf));

   nClOutBinarySize = 0;
   nClInBinarySize = 0;
   nClOutCheckSum = 0;
   nClInCheckSum = 0;
   iClBinBufUsed = 0;
   
   return 0;
}

void CommandChaining::reset()
{
   colfiles   = 0;
   usefiles   = 0;
   coldata    = 0;
   usedata    = 0;
   text2files = 0;
   files2text = 0;
   btold1     = 0;
   colbinary  = 0;

   infiles->resetEntries();
   outfiles->resetEntries();

   indata->resetEntries();
   outdata->resetEntries();
   
   nClOutBinarySize = 0;
   nClInBinarySize = 0;
   nClOutCheckSum = 0;
   nClInCheckSum = 0;
   iClBinBufUsed = 0;
}

void CommandChaining::shutdown()
{
   if (infiles) {
      infiles->resetEntries();
      delete infiles;
   }
   if (outfiles) {
      outfiles->resetEntries();
      delete outfiles;
   }

   if (indata) {
      indata->resetEntries();
      delete indata;
   }
   if (outdata) {
      outdata->resetEntries();
      delete outdata;
   }

   if (storedata) {
      storedata->resetEntries();
      delete storedata;
   }
}

int printEcho(bool bAddToCurLine, const char *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';
   char *pszSrc = szPrintBuf1;
   int iDst = 0;
   char nAttr = ' ';
   bool bResetOnLF = 0;
   while (*pszSrc && (iDst < (int)sizeof(szPrintBuf2)-10)) 
   {
      /*
      if (pszSrc[0] == '\\' && pszSrc[1] == glblWildChar) {
         pszSrc += 2;
         szPrintBuf2[iDst] = glblWildChar;
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else
      */

      if (!strncmp(pszSrc, "[["    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = '[';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      if (!strncmp(pszSrc, "]]"    , 2)) {
         pszSrc += 2;
         szPrintBuf2[iDst] = ']';
         szPrintAttr[iDst] = nAttr;
         iDst++;
      }
      else

      // base colors are bright or dark depending on their first name char
      if (!mystrncmp(pszSrc, "[red]"    , 5)) { nAttr = pszSrc[1]; pszSrc += 5; } else
      if (!mystrncmp(pszSrc, "[green]"  , 7)) { nAttr = pszSrc[1]; pszSrc += 7; } else
      if (!mystrncmp(pszSrc, "[blue]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[yellow]" , 8)) { nAttr = pszSrc[1]; pszSrc += 8; } else
      if (!mystrncmp(pszSrc, "[cyan]"   , 6)) { nAttr = pszSrc[1]; pszSrc += 6; } else
      if (!mystrncmp(pszSrc, "[magenta]", 9)) { nAttr = pszSrc[1]; pszSrc += 9; } else
      // inofficial: does not work with a white background under Windows
      if (!mystrncmp(pszSrc, "[white]"  , 7)) { nAttr = 'v';       pszSrc += 7; } else

      if (!strncmp(pszSrc, "[def]"    , 5)) { pszSrc += 5; nAttr = ' '; }

      else 
      {
         szPrintBuf2[iDst] = *pszSrc;
         szPrintAttr[iDst] = nAttr;
         if (*pszSrc == '\n' && bResetOnLF) {
            nAttr = ' ';
            szPrintAttr[iDst] = nAttr;
            bResetOnLF = 0;
         }
         pszSrc++;
         iDst++;
      }
   }
   szPrintBuf2[iDst] = '\0';
   if (chain.coldata) {
      if (bAddToCurLine) {
         chain.addToCurLine(szPrintBuf2, szPrintAttr, 0);
      } else {
         // mode 2: if echo text ends with "\n", add an empty line.
         chain.addLine(szPrintBuf2, szPrintAttr, 2);
      }
   } else {
      printColorText(szPrintBuf2, szPrintAttr, 0);
      if (!bAddToCurLine) printf("\n");
      fflush(stdout);
   }
   return 0;
}

bool bGlblInSpecificProcessing = 0;

Array glblGrepPat("grep");
Array glblIncBin("incbin");

StringTable::StringTable() {
   nClArraySize = 0;
   nClArrayUsed = 0;
   apClArray    = 0;
}

StringTable::~StringTable() {
   resetEntries();
}

void StringTable::dump(int nIndent) {
   printf("] %.*sstringtable %p, %d entries:\n",nIndent,pszGlblBlank,this,nClArrayUsed);
   for (int i=0; i<nClArrayUsed; i++) {
      printf("]   %.*s%s\n", nIndent,pszGlblBlank,apClArray[i] ? apClArray[i] : "<null>");
   }
}

void StringTable::resetEntries() {
   for (int i=0; i<nClArrayUsed; i++) {
      if (apClArray[i]) delete [] apClArray[i];
      apClArray[i] = 0;
   }
   nClArrayUsed = 0;
   if (apClArray)
      delete [] apClArray;
   apClArray = 0;
   nClArraySize = 0;
}

int StringTable::numberOfEntries() {
   return nClArrayUsed;
}

bool StringTable::isSet(int iIndex) {
   if (iIndex < 0)
      { pwarn("illegal index: %d\n", iIndex); return 0; }
   return (iIndex < nClArrayUsed) ? 1 : 0;
}

int StringTable::expand(int nSoMuch) {
   char **apTmp = new char*[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (apClArray) {
      memcpy(apTmp, apClArray, nClArraySize*sizeof(char*));
      delete [] apClArray;
   }
   apClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

int StringTable::addEntry(char *psz, int nAtPos, char **ppCopy) 
{
   char *pCopy = 0;
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (int i=nClArrayUsed; i>nAtPos; i--)
         apClArray[i] = apClArray[i-1];
      pCopy = psz ? strdup(psz) : 0;
      apClArray[nAtPos] = pCopy;
      nClArrayUsed++;
   } else {
      pCopy = psz ? strdup(psz) : 0;
      apClArray[nClArrayUsed++] = pCopy;
   }
   if (ppCopy) *ppCopy = pCopy;
   return 0;
}

int StringTable::removeEntry(int nAtPos) {
   if (nAtPos < 0 || nAtPos >= nClArrayUsed)
      return 9;
   if (apClArray[nAtPos]) delete [] apClArray[nAtPos];
   for (int i=nAtPos; i<nClArrayUsed-1; i++)
      apClArray[i] = apClArray[i+1];
   apClArray[nClArrayUsed-1] = 0; // just in case
   nClArrayUsed--;
   return 0;
}

int StringTable::addEntryPrefixed(char *psz, char cPrefix) {
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   // create extended copy with prefix at beginning
   int nLen = strlen(psz);
   char *pszCopy = new char[nLen+2];
   pszCopy[0] = cPrefix;
   strcpy(pszCopy+1, psz);
   // add this copy
   apClArray[nClArrayUsed++] = pszCopy;
   if (cs.debug) printf("]  stringtable %p added %s, have %d\n",this,pszCopy,nClArrayUsed);
   return 0;
}

int StringTable::setEntry(int nIndex, char *psz) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("illegal set index: %d\n", nIndex);
   if (apClArray[nIndex])
      delete [] apClArray[nIndex];
   apClArray[nIndex] = strdup(psz);
   return 0;
}

int StringTable::setEntryPrefixed(int nIndex, char *psz, char cPrefix) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("illegal set index: %d\n", nIndex);
   // create extended copy with prefix at beginning
   int nLen = strlen(psz);
   char *pszCopy = new char[nLen+2];
   pszCopy[0] = cPrefix;
   strcpy(pszCopy+1, psz);
   // delete old entry, if any
   if (apClArray[nIndex])
      delete [] apClArray[nIndex];
   // set new copy
   apClArray[nIndex] = pszCopy;
   if (cs.debug) printf("]  stringtable %p set %s, have %d\n",this,pszCopy,nClArrayUsed);
   return 0;
}

char *StringTable::getEntry(int nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return apClArray[nIndex];
   perr("illegal StringTable index: %d tline %d\n", nIndex, nTraceLine);
   return 0;
}

int StringTable::find(char *psz) {
   for (int i=0; i<nClArrayUsed; i++)
      if (apClArray[i] && !strcmp(apClArray[i], psz))
         return i;
   return -1;
}

StringTable glblErrorLog;
StringTable glblStaleLog;

StringPipe::StringPipe()
{
   nReadIndex = 0;
}

bool StringPipe::eod()
{
   return (nReadIndex >= numberOfEntries());
}

char *StringPipe::read(char **ppAttr)
{
   if (nReadIndex < numberOfEntries()) {
      char *psz   = clText.getEntry(nReadIndex, __LINE__);
      char *pattr = clAttr.getEntry(nReadIndex, __LINE__);
      // printf("PIPE.READ %d = %s\n",nReadIndex,psz);
      nReadIndex++;
      if (ppAttr)
         *ppAttr = pattr;
      return psz;
   }
   return 0; // EOD
}

void logError(const char *format, ...)
{
   va_list arg_ptr;
   va_start(arg_ptr, format);

   char szTmpBuf[4096];
   vsprintf(szTmpBuf, format, arg_ptr);

   glblErrorLog.addEntry(szTmpBuf);
   printf("%s\n", szTmpBuf);
}

char *skipDotSlash(char *psz) {
   if (!strncmp(psz, glblDotSlash, 2))
      psz += 2;
   return psz;
}

void trackStaleZip(char *pszFileName)
{
   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   int nEntries = glblStaleLog.numberOfEntries();
   for (int i=0; i<nEntries; i++)
   {
      char *psz = glblStaleLog.getEntry(i, __LINE__);
      if (!strcmp(psz, pszFileName))
         return; // is already registered
   }

   // add zip containing stale files to stale list
   glblStaleLog.addEntry(pszFileName);
}

bool endsWithPathChar(char *pszPath, bool bAcceptFWSlash=0) {
   int nLen = strlen(pszPath);
   if (nLen>0) {
      if (pszPath[nLen-1] == glblPathChar)
         return 1;
      if (bAcceptFWSlash && pszPath[nLen-1] == '/')
         return 1;
   }
   return 0;
}

bool endsWithColon(char *pszPath) {
   #ifdef _WIN32
   int nLen = strlen(pszPath);
   if (nLen>0 && pszPath[nLen-1] == ':')
      return 1;
   #endif
   return 0;
}

// ============================================================

Array::Array(const char *pszID) {
   nClRowsSize = 0;
   nClRowsUsed = 0;
   apClRows    = 0;
   nClCurRow   = 0;
   pszClID     = pszID;
}

Array::~Array() {
   reset();
}

void Array::dump() {
   printf("] array %s dump:\n",pszClID);
   for (int iRow=0; iRow<nClRowsUsed; iRow++) {
      StringTable *pRow = apClRows[iRow];
      printf("]   row %p:\n",pRow);
      pRow->dump(5);
   }
}

// internal: expand row array
int Array::expand(int nSoMuch) {
   StringTable **apTmp = new StringTable*[nClRowsSize+nSoMuch];
   if (!apTmp) return 9;
   if (apClRows) {
      memcpy(apTmp, apClRows, nClRowsSize*sizeof(StringTable*));
      delete [] apClRows;
   }
   apClRows = apTmp;
   nClRowsSize += nSoMuch;
   return 0;
}

// internal: make sure at least one row exists
int Array::ensureBase( ) {
   if (!nClRowsSize) {
      // if (cs.debug) printf("] array %p crt initial\n",this);
      // create initial row, for one-dimensional mode
      if (expand(1)) return 9;
      StringTable *pFirst = new StringTable();
      if (!pFirst) return 9;
      apClRows[nClRowsUsed++] = pFirst;
   }
   return 0;
}

// public: remove everything
void Array::reset() {
   // if (cs.debug) printf("] array %p RESET\n",this);
   for (int i=0; i<nClRowsUsed; i++) {
      delete apClRows[i];
      apClRows[i] = 0;
   }
   nClRowsUsed = 0;
   if (apClRows) {
      delete [] apClRows;
      apClRows = 0;
   }
   nClRowsSize = 0;
}

// public: return number of columns in current row
int Array::numberOfEntries() {
   if (ensureBase()) return 0;
   return apClRows[nClCurRow]->numberOfEntries();
}

int Array::numberOfEntries(int lRow) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   return apClRows[lRow]->numberOfEntries();
}

// public: add string object to current row
int Array::addString(char *psz) {
   if (ensureBase()) return 0;
   if (cs.debug) printf("] array %s: add to row %d entry %s. [%d rows total]\n",pszClID,nClCurRow,psz,nClRowsUsed);
   int lRC = apClRows[nClCurRow]->addEntryPrefixed(psz, 's');
   return lRC;
}

int Array::addString(int lRow, char *psz) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   if (cs.debug) printf("] array %s: add to row %d entry %s. [%d rows total]\n",pszClID,lRow,psz,nClRowsUsed);
   int lRC = apClRows[lRow]->addEntryPrefixed(psz, 's');
   return lRC;
}

int Array::addNull(int lRow) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   if (cs.debug) printf("] array %s: add NULL to row %d. [%d rows total]\n",pszClID,lRow,nClRowsUsed);
   int lRC = apClRows[lRow]->addEntry(0);
   return lRC;
}

int Array::setString(int lRow, int nIndex, char *psz) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow > nClRowsUsed)
      return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   if (cs.debug) printf("] array %s: set row %d:%d entry %s. [%d rows total]\n",pszClID,lRow,nIndex,psz,nClRowsUsed);
   int lRC = apClRows[lRow]->setEntryPrefixed(nIndex, psz, 's');
   return lRC;
}

// public: get string object from current row
char *Array::getString(int nIndex) {
   if (ensureBase()) return 0;
   char *pszRaw = apClRows[nClCurRow]->getEntry(nIndex, __LINE__);
   if (!pszRaw)
      return 0; // NULL entry
   if (pszRaw[0] != 's') { perr("%s: no string entry type at %u %u\n", pszClID, nClCurRow, nIndex); return 0; }
   return pszRaw+1;
}

char *Array::getString(int lRow, int nIndex) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   char *pszRaw = apClRows[lRow]->getEntry(nIndex, __LINE__);
   if (!pszRaw)
      return 0; // NULL entry
   if (pszRaw[0] != 's') { perr("%s: no string entry type at %u %u\n", pszClID, lRow, nIndex); return 0; }
   return pszRaw+1;
}

// public: add integer to current row, internally encoded as string
int Array::addLong(int nValue, int nTraceLine) {
   if (ensureBase()) return 0;
   if (cs.debug) printf("] array %s: add to row %d entry %d [tline %d]\n",pszClID,nClCurRow,nValue,nTraceLine);
   char szBuf[100];
   uint uValue = (uint)nValue;
   // char *_ultoa( unsigned int value, char *string, int radix );
   #ifdef _WIN32
   _ultoa(uValue, szBuf, 16);
   #else
   sprintf(szBuf, "%x", uValue);
   #endif
   return apClRows[nClCurRow]->addEntryPrefixed(szBuf, 'i');
}

int Array::addLong(int lRow, int nValue, int nTraceLine) {
   if (ensureBase()) return 0;
   if (cs.debug) printf("] array %s: add to row %d entry %d [tline %d]\n",pszClID,lRow,nValue,nTraceLine);
   if (lRow < 0 || lRow > nClRowsUsed) return 9+perr("%s: illegal row %d\n",pszClID,lRow);
   char szBuf[100];
   uint uValue = (uint)nValue;
   #ifdef _WIN32
   _ultoa(uValue, szBuf, 16);
   #else
   sprintf(szBuf, "%x", uValue);
   #endif
   return apClRows[lRow]->addEntryPrefixed(szBuf, 'i');
}

int Array::getLong(int nIndex) {
   if (ensureBase()) return 0;
   char *pszRaw = apClRows[nClCurRow]->getEntry(nIndex, __LINE__);
   if (!pszRaw)
      return 0;
   if (pszRaw[0] != 'i') { perr("no long entry type at row %u col %u\n", nClCurRow, nIndex); return 0; } 
   // unsigned int strtoul( const char *nptr, char **endptr, int base );
   uint uValue = strtoul(pszRaw+1, 0, 16);
   return (int)uValue;
}

int Array::getLong(int lRow, int nIndex, int nTraceLine) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   char *pszRaw = apClRows[lRow]->getEntry(nIndex, nTraceLine);
   if (!pszRaw)
      return 0;
   if (pszRaw[0] != 'i') { perr("no long entry type at row %u col %u\n", lRow, nIndex); return 0; } 
   // unsigned int strtoul( const char *nptr, char **endptr, int base );
   uint uValue = strtoul(pszRaw+1, 0, 16);
   return (int)uValue;
}

int Array::setLong(int lRow, int nIndex, int nValue, int nTraceLine) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   char szBuf[100];
   uint uValue = (uint)nValue;
   // char *_ultoa( unsigned int value, char *string, int radix );
   #ifdef _WIN32
   _ultoa(uValue, szBuf, 16);
   #else
   sprintf(szBuf, "%x", uValue);
   #endif
   return apClRows[lRow]->setEntryPrefixed(nIndex, szBuf, 'i');
}

// public: create new row. shouldn't be called for first row.
int Array::addRow(int nTraceLine) {
   int nOldRows = nClRowsSize;
   if (ensureBase()) return 0;
   // if anyone calls this before adding first data, accept it.
   if (!nOldRows)
      return 0;
   // for all further rows, check if row table is full.
   // if so, expand in exponential steps.
   if (nClRowsUsed == nClRowsSize) {
      if (expand(nClRowsSize)) return 9;
   }
   // finally, add new row object
   StringTable *pFirst = new StringTable();
   if (!pFirst) return 9;
   apClRows[nClRowsUsed++] = pFirst;
   nClCurRow = nClRowsUsed-1;
   if (cs.debug) printf("array %s extended to %d rows [tln %d]\n",pszClID,nClRowsUsed,nTraceLine);
   return 0;
}

// public: select current row
int Array::setRow(int iCurRow, int nTraceLine) {
   if (ensureBase()) return 9;
   if (iCurRow < 0 || iCurRow >= nClRowsUsed)
      return 9+perr("%s: illegal row index: %d on setRow, tline %d\n",pszClID,iCurRow,nTraceLine);
   nClCurRow = iCurRow;
   if (cs.debug) printf("array %s setrow %d\n",pszClID,nClCurRow);
   return 0;
}

// public: tell if index in current row is set, used for loops
bool Array::isSet(int iIndex) {
   if (ensureBase()) return 0;
   return apClRows[nClCurRow]->isSet(iIndex);
}

// public: tell if index in current row is set with a string
bool Array::isStringSet(int iIndex) {
   if (ensureBase()) return 0;
   if (!apClRows[nClCurRow]->isSet(iIndex)) {
      // if (cs.debug) printf("] %s: no string set at %d:%d\n",pszClID,nClCurRow,iIndex);
      return 0;
   }
   char *pszRaw = apClRows[nClCurRow]->getEntry(iIndex, __LINE__);
   // printf("xxx %s:%d:%d %s\n",pszClID,nClCurRow,iIndex,pszRaw);
   if (!pszRaw) {
      if (cs.debug) {
         printf("error: no entry at index %d, table %p, within array %p\n",iIndex,apClRows[nClCurRow],this);
         apClRows[nClCurRow]->dump();
      }
      return 0;
   }
   if (pszRaw[0] != 's') {
      perr("no string type at %s:%d:%d\n",pszClID,nClCurRow,iIndex);
      return 0;
   }
   return 1;
}

bool Array::isStringSet(int lRow, int iIndex) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   if (!apClRows[lRow]->isSet(iIndex))
      return 0;
   char *pszRaw = apClRows[lRow]->getEntry(iIndex, __LINE__);
   if (!pszRaw) {
      if (cs.debug) {
         printf("error: no entry at index %d, table %p, within array %p\n",iIndex,apClRows[lRow],this);
         apClRows[lRow]->dump();
      }
      return 0;
   }
   return (pszRaw[0] == 's') ? 1 : 0;
}

// public: tell if index in current row is set with a int
bool Array::isLongSet(int lRow, int iIndex) {
   if (ensureBase()) return 0;
   if (lRow < 0 || lRow >= nClRowsUsed) { perr("%s: illegal row %d\n",pszClID,lRow); return 0; }
   if (!apClRows[lRow]->isSet(iIndex))
      return 0;
   char *pszRaw = apClRows[lRow]->getEntry(iIndex, __LINE__);
   if (!pszRaw)
      return 0;
   return (pszRaw[0] == 'i') ? 1 : 0;
}

// public: tell if row exists
bool Array::hasRow(int iRow) {
   if (ensureBase()) return 0;
   if (iRow < 0) {  perr("%s: illegal row index: %d on hasRow\n",pszClID,iRow); return 0; }
   return (iRow < nClRowsUsed) ? 1 : 0;
}

// ============================================================

LongTable::LongTable() {
   nClArraySize = 0;
   nClArrayUsed = 0;
   pClArray     = 0;
}

LongTable::~LongTable() {
   resetEntries();
}

void LongTable::resetEntries() {
   nClArrayUsed = 0;
   if (pClArray)
      delete [] pClArray;
   pClArray = 0;
   nClArraySize = 0;
}

int LongTable::numberOfEntries() {
   return nClArrayUsed;
}

int LongTable::expand(int nSoMuch) {
   int *apTmp = new int[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (pClArray) {
      memcpy(apTmp, pClArray, nClArraySize*sizeof(int));
      delete [] pClArray;
   }
   pClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

int LongTable::addEntry(int nValue, int nAtPos)
{
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (int i=nClArrayUsed; i>nAtPos; i--)
         pClArray[i] = pClArray[i-1];
      pClArray[nAtPos] = nValue;
      nClArrayUsed++;
   } else {
      pClArray[nClArrayUsed++] = nValue;
   }
   return 0;
}

int LongTable::updateEntry(int nValue, int nIndex) {
   if (nIndex >= nClArrayUsed)
      return 9+perr("wrong index for updateEntry: %d\n", nIndex);
   pClArray[nIndex] = nValue;
   return 0;
}

int LongTable::getEntry(int nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return pClArray[nIndex];
   perr("illegal LongTable index: %d %d tline %d\n", nIndex, nClArrayUsed, nTraceLine);
   return -1;
}

// ======================================================

NumTable::NumTable() {
   nClArraySize = 0;
   nClArrayUsed = 0;
   pClArray     = 0;
}

NumTable::~NumTable() {
   resetEntries();
}

void NumTable::resetEntries() {
   nClArrayUsed = 0;
   if (pClArray)
      delete [] pClArray;
   pClArray = 0;
   nClArraySize = 0;
}

int NumTable::numberOfEntries() {
   return nClArrayUsed;
}

int NumTable::expand(int nSoMuch) {
   num *apTmp = new num[nClArraySize+nSoMuch];
   if (!apTmp) return 9;
   if (pClArray) {
      memcpy(apTmp, pClArray, nClArraySize*sizeof(num));
      delete [] pClArray;
   }
   pClArray = apTmp;
   nClArraySize += nSoMuch;
   return 0;
}

int NumTable::addEntry(num nValue, int nAtPos) {
   if (nClArrayUsed == nClArraySize) {
      if (nClArraySize == 0) {
         if (expand(10)) return 9;
      } else {
         if (expand(nClArraySize)) return 9;
      }
   }
   if (nAtPos != -1) {
      for (int i=nClArrayUsed; i>nAtPos; i--)
         pClArray[i] = pClArray[i-1];
      pClArray[nAtPos] = nValue;
      nClArrayUsed++;
   } else {
      pClArray[nClArrayUsed++] = nValue;
   }
   return 0;
}

int NumTable::updateEntry(num nValue, int nAtPos) {
   if (nAtPos >= nClArrayUsed)
      return 9+perr("illegal index for updateEntry: %d\n", nAtPos);
   pClArray[nAtPos] = nValue;
   return 0;
}

num NumTable::getEntry(int nIndex, int nTraceLine) {
   if (nIndex >= 0 && nIndex < nClArrayUsed)
      return pClArray[nIndex];
   perr("illegal NumTable index: %d %d tline %d\n", nIndex, nClArrayUsed, nTraceLine);
   return -1;
}

// ==========================================================

SFKMD5::SFKMD5()
{
   bClDigDone  = 0;

   nClDigLen   = 16;
   nClBufLen   = 64;
   pClBuf      = aClBuf;
   pClDig      = aClDig;

   nClCntHigh  = nClCntLow = nClBufCnt = 0;

   alClSta[0] = 0x67452301;
   alClSta[1] = 0xefcdab89;
   alClSta[2] = 0x98badcfe;
   alClSta[3] = 0x10325476;
}

SFKMD5::~SFKMD5() { }

void SFKMD5::update(uchar *pData, uint32_t nLen)
{
   if (bGlblOldMD5)
   {
      for (uint32_t i=0; i<nLen; i++)
         update(pData[i]);
   }
   else
   {
      int nCnt = 0;
   
      if (nClBufCnt != 0)
      {
         int nAvail = nClBufLen - nClBufCnt;
         int nMax = nAvail < (int)nLen ? nAvail : (int)nLen;
   
         for (; nCnt < nMax; nCnt++)
            update(pData[nCnt]);
      }
   
      int nBlocks = (nLen - nCnt) / nClBufLen;
   
      unsigned int ulNumChars = nBlocks * nClBufLen;
   
      nClCntLow += ulNumChars;
   
      if (nClCntLow < ulNumChars)
         nClCntHigh++;
   
      for (int i = 0; i < nBlocks; i++)
      {
         memcpy(pClBuf, pData + nCnt, nClBufLen);
         transform();
         nCnt += nClBufLen;
      }
   
      for (; nCnt < (int)nLen; nCnt++)
         update(pData[nCnt]);
   }
}

void SFKMD5::update(uchar c)
{
   pClBuf[nClBufCnt++] = c;
   if (nClBufCnt == nClBufLen)
   {
      transform();
      nClBufCnt = 0;
   }
   if (++nClCntLow == 0)
      nClCntHigh++;
}

void SFKMD5::transform()
{
   #define MD5XOR0(x, y, z) (z ^ (x & (y ^ z)))
   #define MD5XOR1(x, y, z) (y ^ (z & (x ^ y)))
   #define MD5XOR2(x, y, z) (x ^ y ^ z)
   #define MD5XOR3(x, y, z) (y  ^  (x | ~z))
   #define MD5ROT(a, n) a = (a << n) | (a >> (32 - n))
   #define MD5PR0(a, b, c, d, k, s, t) { a += k + t + MD5XOR0(b, c, d); MD5ROT(a, s); a += b; }
   #define MD5PR1(a, b, c, d, k, s, t) { a += k + t + MD5XOR1(b, c, d); MD5ROT(a, s); a += b; }
   #define MD5PR2(a, b, c, d, k, s, t) { a += k + t + MD5XOR2(b, c, d); MD5ROT(a, s); a += b; }
   #define MD5PR3(a, b, c, d, k, s, t) { a += k + t + MD5XOR3(b, c, d); MD5ROT(a, s); a += b; }

   uchar *pBuf = pClBuf;
   for (uint32_t i = 0; i < 16; i++)
   {
      uint32_t ul;
      ul = pBuf[0];
      ul |= pBuf[1] << 8;
      ul |= pBuf[2] << 16;
      ul |= pBuf[3] << 24;
      pBuf += 4;
      alClBuf[i] = ul;
   }

   uint32_t a = alClSta[0];
   uint32_t b = alClSta[1];
   uint32_t c = alClSta[2];
   uint32_t d = alClSta[3];

   MD5PR0(a, b, c, d, alClBuf[ 0],  7, 0xd76aa478);
   MD5PR0(d, a, b, c, alClBuf[ 1], 12, 0xe8c7b756);
   MD5PR0(c, d, a, b, alClBuf[ 2], 17, 0x242070db);
   MD5PR0(b, c, d, a, alClBuf[ 3], 22, 0xc1bdceee);
   MD5PR0(a, b, c, d, alClBuf[ 4],  7, 0xf57c0faf);
   MD5PR0(d, a, b, c, alClBuf[ 5], 12, 0x4787c62a);
   MD5PR0(c, d, a, b, alClBuf[ 6], 17, 0xa8304613);
   MD5PR0(b, c, d, a, alClBuf[ 7], 22, 0xfd469501);
   MD5PR0(a, b, c, d, alClBuf[ 8],  7, 0x698098d8);
   MD5PR0(d, a, b, c, alClBuf[ 9], 12, 0x8b44f7af);
   MD5PR0(c, d, a, b, alClBuf[10], 17, 0xffff5bb1);
   MD5PR0(b, c, d, a, alClBuf[11], 22, 0x895cd7be);
   MD5PR0(a, b, c, d, alClBuf[12],  7, 0x6b901122);
   MD5PR0(d, a, b, c, alClBuf[13], 12, 0xfd987193);
   MD5PR0(c, d, a, b, alClBuf[14], 17, 0xa679438e);
   MD5PR0(b, c, d, a, alClBuf[15], 22, 0x49b40821);

   MD5PR1(a, b, c, d, alClBuf[ 1],  5, 0xf61e2562);
   MD5PR1(d, a, b, c, alClBuf[ 6],  9, 0xc040b340);
   MD5PR1(c, d, a, b, alClBuf[11], 14, 0x265e5a51);
   MD5PR1(b, c, d, a, alClBuf[ 0], 20, 0xe9b6c7aa);
   MD5PR1(a, b, c, d, alClBuf[ 5],  5, 0xd62f105d);
   MD5PR1(d, a, b, c, alClBuf[10],  9, 0x02441453);
   MD5PR1(c, d, a, b, alClBuf[15], 14, 0xd8a1e681);
   MD5PR1(b, c, d, a, alClBuf[ 4], 20, 0xe7d3fbc8);
   MD5PR1(a, b, c, d, alClBuf[ 9],  5, 0x21e1cde6);
   MD5PR1(d, a, b, c, alClBuf[14],  9, 0xc33707d6);
   MD5PR1(c, d, a, b, alClBuf[ 3], 14, 0xf4d50d87);
   MD5PR1(b, c, d, a, alClBuf[ 8], 20, 0x455a14ed);
   MD5PR1(a, b, c, d, alClBuf[13],  5, 0xa9e3e905);
   MD5PR1(d, a, b, c, alClBuf[ 2],  9, 0xfcefa3f8);
   MD5PR1(c, d, a, b, alClBuf[ 7], 14, 0x676f02d9);
   MD5PR1(b, c, d, a, alClBuf[12], 20, 0x8d2a4c8a);

   MD5PR2(a, b, c, d, alClBuf[ 5],  4, 0xfffa3942);
   MD5PR2(d, a, b, c, alClBuf[ 8], 11, 0x8771f681);
   MD5PR2(c, d, a, b, alClBuf[11], 16, 0x6d9d6122);
   MD5PR2(b, c, d, a, alClBuf[14], 23, 0xfde5380c);
   MD5PR2(a, b, c, d, alClBuf[ 1],  4, 0xa4beea44);
   MD5PR2(d, a, b, c, alClBuf[ 4], 11, 0x4bdecfa9);
   MD5PR2(c, d, a, b, alClBuf[ 7], 16, 0xf6bb4b60);
   MD5PR2(b, c, d, a, alClBuf[10], 23, 0xbebfbc70);
   MD5PR2(a, b, c, d, alClBuf[13],  4, 0x289b7ec6);
   MD5PR2(d, a, b, c, alClBuf[ 0], 11, 0xeaa127fa);
   MD5PR2(c, d, a, b, alClBuf[ 3], 16, 0xd4ef3085);
   MD5PR2(b, c, d, a, alClBuf[ 6], 23, 0x04881d05);
   MD5PR2(a, b, c, d, alClBuf[ 9],  4, 0xd9d4d039);
   MD5PR2(d, a, b, c, alClBuf[12], 11, 0xe6db99e5);
   MD5PR2(c, d, a, b, alClBuf[15], 16, 0x1fa27cf8);
   MD5PR2(b, c, d, a, alClBuf[ 2], 23, 0xc4ac5665);

   MD5PR3(a, b, c, d, alClBuf[ 0],  6, 0xf4292244);
   MD5PR3(d, a, b, c, alClBuf[ 7], 10, 0x432aff97);
   MD5PR3(c, d, a, b, alClBuf[14], 15, 0xab9423a7);
   MD5PR3(b, c, d, a, alClBuf[ 5], 21, 0xfc93a039);
   MD5PR3(a, b, c, d, alClBuf[12],  6, 0x655b59c3);
   MD5PR3(d, a, b, c, alClBuf[ 3], 10, 0x8f0ccc92);
   MD5PR3(c, d, a, b, alClBuf[10], 15, 0xffeff47d);
   MD5PR3(b, c, d, a, alClBuf[ 1], 21, 0x85845dd1);
   MD5PR3(a, b, c, d, alClBuf[ 8],  6, 0x6fa87e4f);
   MD5PR3(d, a, b, c, alClBuf[15], 10, 0xfe2ce6e0);
   MD5PR3(c, d, a, b, alClBuf[ 6], 15, 0xa3014314);
   MD5PR3(b, c, d, a, alClBuf[13], 21, 0x4e0811a1);
   MD5PR3(a, b, c, d, alClBuf[ 4],  6, 0xf7537e82);
   MD5PR3(d, a, b, c, alClBuf[11], 10, 0xbd3af235);
   MD5PR3(c, d, a, b, alClBuf[ 2], 15, 0x2ad7d2bb);
   MD5PR3(b, c, d, a, alClBuf[ 9], 21, 0xeb86d391);

   alClSta[0] += a;
   alClSta[1] += b;
   alClSta[2] += c;
   alClSta[3] += d;
}

uchar *SFKMD5::digest()
{
   if (bClDigDone)
      return pClDig;

   uint32_t lLow  = nClCntLow << 3;
   uint32_t lHigh = (nClCntLow >> 29) | (nClCntHigh << 3);

   update(128);

   while ((nClCntLow & 63) != 56)
      update(0);

   update((uchar)lLow);
   update((uchar)(lLow >> 8));
   update((uchar)(lLow >> 16));
   update((uchar)(lLow >> 24));

   update((uchar)lHigh);
   update((uchar)(lHigh >> 8));
   update((uchar)(lHigh >> 16));
   update((uchar)(lHigh >> 24));

   // above code should ensure that last update() lead to empty buffer.
   if (nClBufCnt != 0) { fprintf(stderr, "ERROR: SFKMD5 internal #1\n"); }

   uchar *pDigest = pClDig;
   for (uint32_t i = 0; i < 4; i++)
   {
      uint32_t ul = alClSta[i];
      pDigest[0] = (uchar)ul; ul >>= 8;
      pDigest[1] = (uchar)ul; ul >>= 8;
      pDigest[2] = (uchar)ul; ul >>= 8;
      pDigest[3] = (uchar)ul;
      pDigest += 4;
   }

   bClDigDone = 1;
   return pClDig;
}

// ==========================================================

class FileList {
public:
   FileList       ( );
  ~FileList       ( );
   int  addFile        (char *pszAbsName, char *pszRoot, num nTimeStamp, num nSize, char cSortedBy=0);
   int  checkAndMark   (char *pszName, num nSize);
   void  reset          ( );
   StringTable clNames;
   StringTable clRoots;
   NumTable    clTimes;
   NumTable    clSizes;
};

FileList::FileList()  { }
FileList::~FileList() { }

void FileList::reset()
{
   clNames.resetEntries();
   clRoots.resetEntries();
   clTimes.resetEntries();
   clSizes.resetEntries();
}

int FileList::addFile(char *pszAbsName, char *pszRoot, num nTimeStamp, num nSize, char cSortedBy)
{__ _p("sf.addfile")

   // IF filename starts with ".\\", skip this part
   if (!strncmp(pszAbsName, glblDotSlash, strlen(glblDotSlash)))
      pszAbsName += strlen(glblDotSlash);

   // insert sorted by (1)name, (2)time, (3)size?
   int nInsPos = -1;

   if (cSortedBy == 'T' || cSortedBy == 't') {
      // find insert by time position
      int nCnt = clTimes.numberOfEntries();
      int i=0;
      for (i=0; i<nCnt; i++)
         if (cSortedBy=='T' && (clTimes.getEntry(i, __LINE__) > nTimeStamp))
            break;
         else
         if (cSortedBy=='t' && (clTimes.getEntry(i, __LINE__) < nTimeStamp))
            break;
      if (i < nCnt)
         nInsPos = i;         
   }

   if (cSortedBy == 'S' || cSortedBy == 's') {
      // find insert by size position
      int nCnt = clSizes.numberOfEntries();
      int i=0;
      for (i=0; i<nCnt; i++)
         if (cSortedBy=='S' && (clSizes.getEntry(i, __LINE__) > nSize))
            break;
         else
         if (cSortedBy=='s' && (clSizes.getEntry(i, __LINE__) < nSize))
            break;
      if (i < nCnt)
         nInsPos = i;         
   }

   if (cSortedBy == 'N' || cSortedBy == 'n') {
      // find insert by name position
      int nCnt = clNames.numberOfEntries();
      int i=0;
      for (i=0; i<nCnt; i++) {
         char *psz1 = clNames.getEntry(i, __LINE__);
         char *psz2 = pszAbsName;
         // both psz1 and psz2 point to a mixed string with a prefix.
         // need to find the actual filename first:
         int npre1 = atol(psz1)+6; if (npre1 < (int)strlen(psz1)) psz1 += npre1;
         int npre2 = atol(psz2)+6; if (npre2 < (int)strlen(psz2)) psz2 += npre2;
         int ncmp  = cs.usecase ? strcmp(psz1,psz2) : mystricmp(psz1, psz2);
         if (cSortedBy=='N' && ncmp > 0)
            break;
         else
         if (cSortedBy=='n' && ncmp < 0)
            break;
      }
      if (i < nCnt)
         nInsPos = i;         
   }

   if (clNames.addEntry(pszAbsName, nInsPos)) return 9;
   if (clRoots.addEntry(pszRoot   , nInsPos)) return 9;
   if (clTimes.addEntry(nTimeStamp, nInsPos)) return 9;
   if (clSizes.addEntry(nSize     , nInsPos)) return 9;

   return 0;
}

// checkAndMark checks the filename and size,
// but NOT the rather complicated timestamps.
int FileList::checkAndMark(char *pszName, num nSize) {
   int nEntries = clNames.numberOfEntries();
   for (int i=0; i<nEntries; i++) {
      char *psz = clNames.getEntry(i, __LINE__);
      if ((psz[0] != 0) && !strcmp(psz, pszName)) {
         num nSize2 = clSizes.getEntry(i, __LINE__);
         if (nSize != nSize2)
            return 2; // on size mismatch, do NOT mark as done.
         psz[0] = '\0';
         return 0;
      }
   }
   return 1;
}

// ====================================================

#ifndef USE_SFK_BASE

class DupScanner 
{
public:
   DupScanner     ( );
   int  addFile   (Coi *pcoi);      // copies just name, size
   int  analyze   (bool blistorg);
   void reset     ( );

public:
   int   analyzeBlock   (int ilo, int ihi, bool blistorg);
   int   bfind          (num nKeySize, int &rindex);

   NumTable    clSizes;
   StringTable clNames; // if name==null, was already processed
   StringTable clRoots;
   NumTable    clSumHi;
   NumTable    clSumLo;
   int   clNumOrgs;
   int   clNumDups;
   num   clOrgBytes;
   num   clDupBytes;
   bool  clDiffDirs;    // list only dups from different dirs
};

DupScanner::DupScanner() { reset(); }

void DupScanner::reset() 
{
   clSizes.resetEntries();
   clNames.resetEntries();
   clRoots.resetEntries();
   clSumHi.resetEntries();
   clSumLo.resetEntries();
   clNumOrgs  = 0;
   clNumDups  = 0;
   clOrgBytes = 0;
   clDupBytes = 0;
   clDiffDirs = 0;
}

// rc =0:found_and_index_set
// rc <0:insert_before_index
// rc >0:insert_after_index
int DupScanner::bfind(num nKeySize, int &rindex)
{
   // binary search for insert index by keysize
   uint nbot=0,ndist=0,nhalf=0,imid=0;
   uint ntop=clSizes.numberOfEntries(); // exclusive
   num  ntmp=0;
   int  ncmp=-1;   // if empty, insert before index 0

   while (1)
   {
      if (nbot > ntop) // shouldn't happen
         { perr(0, "int. 187281850"); ncmp=-1; break; }

      ndist = ntop - nbot;
      if (ndist == 0) break; // nothing left
      
      nhalf = ndist >> 1;
      imid  = nbot + nhalf;
      ntmp  = clSizes.getEntry(imid, __LINE__);
      ncmp  = nKeySize - ntmp;

      if (ncmp < 0) {
         // select lower half, if any
         // mtklog((" take lower %lxh %lxh %d",nval,ntmp,imid));
         if (ntop == imid) break; // safety
         ntop = imid;
      }
      else
      if (ncmp > 0) {
         // select upper half, if any
         // mtklog((" take upper %lxh %lxh %d",nval,ntmp,imid));
         if (nbot == imid+1) break; // required
         nbot = imid+1;
      } else {
         // straight match
         // mtklog(("%d = indexof(%.20s) used=%u",imid,pkey,clSizes.numberOfEntries()));
         break; // found
      }
   }

   rindex = imid;
   return ncmp;
}

int DupScanner::addFile(Coi *pcoi) 
{__
   char *pszFile = pcoi->name();

   num nSize = pcoi->getSize();
   if (nSize <= 0) 
      return 1;
   
   // filter by size selection
   if (cs.selMinSize > 0 && nSize < cs.selMinSize)
      return 0;

   // find insert position
   int ipos = 0;
   if (cs.fast) // experimental
   {
      int isubrc = bfind(nSize, ipos);
      // continue with linear stepping
      for (; ipos<clSizes.numberOfEntries(); ipos++)
         if (nSize < clSizes.getEntry(ipos, __LINE__))
            break;
      if (ipos >= clSizes.numberOfEntries())
         ipos = -1;
   }
   else
   {
      for (; ipos<clSizes.numberOfEntries(); ipos++)
         if (nSize < clSizes.getEntry(ipos, __LINE__))
            break;
      if (ipos >= clSizes.numberOfEntries())
         ipos = -1;
   }
   
   int irc = 0;
   do
   {
      if (irc = clSizes.addEntry(nSize  , ipos))   break;
      if (irc = clNames.addEntry(pszFile, ipos))   break;
      if (irc = clRoots.addEntry(glblFileSet.root(), ipos)) break;
      num nDummy = 0;
      if (irc = clSumHi.addEntry(nDummy , ipos))   break;
      if (irc = clSumLo.addEntry(nDummy , ipos))   break;
   }
   while (0);
   
   if (irc) 
   {
      perr("Out of memory. Please select smaller folders to scan.\n");
      return 99; // enforce stop of file tree processing
   }

   return 0;
}

int DupScanner::analyze(bool blistorg) 
{__
   char szAddInfo[200];

   int nTotal = clSizes.numberOfEntries();
   
   if (cs.fast != 0 && nTotal > 0)
   {
      // verify that all sizes are ascending or equal
      num nLastSize = clSizes.getEntry(0, __LINE__);
      num nCurSize  = nLastSize;
      for (int i=0; i<nTotal; i++) {
         nCurSize = clSizes.getEntry(i, __LINE__);
         if (nCurSize < nLastSize) {
            perr("data integrity error, disable -fast option");
            return 99;
         }
         nLastSize = nCurSize;
      }
   }

   #ifdef WITH_TRACING
   mtklog(("] scanned file sizes:"));
   for (int idump=0; idump<nTotal; idump++)
   {
      num nref  = clSizes.getEntry(idump, __LINE__);
      char *psz = clNames.getEntry(idump, __LINE__);
      mtklog(("%s %s",numtoa(nref),psz));
   }
   #endif

   num  nCurSize = -1;
   for (int iouter=0; iouter<nTotal && !userInterrupt();)
   {
      num nref = clSizes.getEntry(iouter, __LINE__);
      if (nref == nCurSize)
         return 9+perr("internal 279122205");

      // found start of new size block.
      nCurSize = nref;
      int iblocklo = iouter + 0;
      int iblockhi = iouter + 1;
      for (; iblockhi<nTotal && clSizes.getEntry(iblockhi, __LINE__) == nCurSize;)
         iblockhi++;

      // size block ranges from iblocklo to iblockhi-1
      if (iblockhi-iblocklo < 2) 
      {
         // this block has just one entry.
         // if "list just orgs" mode selected
         if (blistorg) {
            char *pszOrg     = clNames.getEntry(iouter, __LINE__);
            char *pszOrgRoot = clRoots.getEntry(iouter, __LINE__);
            if (!pszOrg[0]) return 9+perr("internal 279122206");
            if (chain.colfiles) {
               // collect ORG names for next cmd
               Coi ocoi(pszOrg, pszOrgRoot);
               if (chain.addFile(ocoi)) // is copied
                  return 99+perr("out of memory: dsa.1");
            } else {
               chain.print(' ', 1, "%s", pszOrg);
            }
            clNumOrgs++;
            clOrgBytes += nCurSize;
         }
         iouter = iblockhi;
         continue;
      }

      // have at least two entries in this block.
      // build content md5sums.
      int nBlockFiles  = iblockhi-iblocklo;
      num  nCurFileSize = clSizes.getEntry(iblocklo, __LINE__);
      for (int icur=iblocklo; icur<iblockhi; icur++) 
      {__
         char *pszFile = clNames.getEntry(icur, __LINE__);

         info.setProgress(nBlockFiles, icur-iblocklo, "files");
         sprintf(szAddInfo, "%d files of size %s", nBlockFiles, numtoa(nCurFileSize));
         info.setStatus("scan", pszFile, szAddInfo, (icur==iblocklo) ? eSlowCycle : 0);

         SFKMD5 md5;
         uchar abDummy[16];
         unsigned char *pmd5 = abDummy;
         if (!getFileMD5(pszFile, md5, 0, 1))
            pmd5 = md5.digest();
         else 
         {
            // cannot read file: create random digest,
            // to make sure no wrong duplicates are listed.
            for (int i=0; i<sizeof(abDummy); i++)
               abDummy[i] = (uchar)rand();
            // furthermore remove filename to block any post processing.
            clNames.setEntry(icur, str(""));
         }
         num nsumlo=0, nsumhi=0;
         for (int i=0,b=64-8; i<8; i++) {
            nsumhi = nsumhi | (((num)pmd5[0+i]&0xFF) << b);
            nsumlo = nsumlo | (((num)pmd5[8+i]&0xFF) << b);
            b -= 8;
         }
         clSumHi.updateEntry(nsumhi, icur);
         clSumLo.updateEntry(nsumlo, icur);
         /*
         mtklog("md5raw: %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X"
            ,pmd5[0],pmd5[1],pmd5[2],pmd5[3],pmd5[4],pmd5[5],pmd5[6],pmd5[7]
            ,pmd5[8],pmd5[9],pmd5[10],pmd5[11],pmd5[12],pmd5[13],pmd5[14],pmd5[15]);
         szAddInfo[0] = '\0';
         strcat(szAddInfo, numtohex(nsumhi));
         strcat(szAddInfo, " ");
         strcat(szAddInfo, numtohex(nsumlo));
         mtklog(("md5num: %s", szAddInfo));
         */
      }
      
      // all prepared for this block, list results:
      if (analyzeBlock(iblocklo, iblockhi, blistorg) >= 99)
         return 99; // out of memory, or internal error

      // proceed to next size block
      iouter = iblockhi;
   }

   return 0;
}

#define checkPtr(ptr,id) do { if (!ptr) return 99+perr("int. #211618" #id); } while (0)

int DupScanner::analyzeBlock(int ilo, int ihi, bool blistorg)
{__
   for (int iorg=ilo; iorg<ihi; iorg++)
   {__
      char *pszOrg     = clNames.getEntry(iorg, __LINE__);  checkPtr(pszOrg, 1);
      if (!pszOrg[0]) continue; // already processed
      char *pszOrgRoot = clRoots.getEntry(iorg, __LINE__);  checkPtr(pszOrgRoot, 2);

      // get current potential org data
      num nsumhi = clSumHi.getEntry(iorg, __LINE__);
      num nsumlo = clSumLo.getEntry(iorg, __LINE__);

      // see if any dups are present for this
      bool btoldorg=0;
      for (int idup=iorg+1; idup<ihi; idup++)
      {__
         char *pszDup     = clNames.getEntry(idup, __LINE__);  checkPtr(pszDup, 3);
         if (!pszDup[0]) continue; // already processed
         char *pszDupRoot = clRoots.getEntry(idup, __LINE__);  checkPtr(pszDupRoot, 4);

         if (clDiffDirs && !strcmp(pszOrgRoot, pszDupRoot))
            continue; // skip, both files have same root dir

         num nduphi = clSumHi.getEntry(idup, __LINE__);
         num nduplo = clSumLo.getEntry(idup, __LINE__);
         if (nduphi == nsumhi && nduplo == nsumlo)
         {__
            // found a dup for iorg.
            if (!blistorg) {
               if (chain.colfiles) {
                  // collect dup names for next cmd
                  Coi ocoi(pszDup, pszDupRoot);
                  if (chain.addFile(ocoi)) // is copied
                     return 99+perr("out of memory: dsab.1");
               } else {
                  if (!btoldorg) {
                     btoldorg = 1;
                     chain.print('f', 1, "%s", pszOrg);
                  }
                  chain.print(' ', 1, "   %s", pszDup);
               }
            }

            clNumDups++;
            clDupBytes += clSizes.getEntry(idup, __LINE__);

            // mark dup as processed
            clNames.setEntry(idup, str(""));
         }
      }  // endfor potential dups

      // if "list just orgs" mode selected
      if (blistorg) 
      {__
         if (chain.colfiles) {
            // collect ORG names for next cmd
            Coi ocoi(pszOrg, pszOrgRoot);
            if (chain.addFile(ocoi)) // is copied
               return 99+perr("out of memory: dsab.2");
         } else {
            chain.print(' ', 1, "%s", pszOrg);
         }
         clNumOrgs++;
         clOrgBytes += clSizes.getEntry(iorg, __LINE__);
      }

      // mark org as processed
      clNames.setEntry(iorg, str(""));

   }  // endfor orgs
   
   return 0;
}

DupScanner glblDupScan;

#endif // USE_SFK_BASE

enum eDirCommands {
   eCmd_CopyDir      = 1,
   eCmd_FreezeDir    = 2,
   eCmd_Undefined    = 0xFF
};

FileSet::FileSet() 
 : clRootDirs("RootDirs"),
   clDirMasks("DirMasks"),
   clFileMasks("FileMasks")
{
   nClCurDir   =  0;
   nClCurLayer = -1;
   pClLineBuf  = new char[MAX_LINE_LEN+10];
   resetAddFlags();
}

FileSet::~FileSet() {
   shutdown();
}

void FileSet::resetAddFlags() {
   bClGotAllMask = 0;
   bClGotPosFile = 0;
   bClGotNegFile = 0;
}

void FileSet::reset() 
{
   nClCurDir   =  0;
   nClCurLayer = -1;
   resetAddFlags();
   clRootDirs.reset();
   clDirMasks.reset();
   clFileMasks.reset();
}

void FileSet::shutdown() {
   reset();
   delete [] pClLineBuf;
   pClLineBuf = 0;
}

char* FileSet::firstFileMask() {
   Array &rMasks = fileMasks();
   if (!rMasks.isStringSet(0)) return str("*");
   return rMasks.getString(0);
}

int FileSet::getDirCommand() {
   return clRootDirs.getLong(1, nClCurDir, __LINE__);
}

/*
   A "layer" is a set of dir and file masks, which may be
   referenced by one or many root directories.
*/

void FileSet::dump() 
{__
   printf("=== fileset begin ===\n");

   for (int i1=0; clRootDirs.isStringSet(0,i1); i1++)
   {
      int nLayer = clRootDirs.getLong(2,i1, __LINE__);
      int nCmd   = 0;
      if (clRootDirs.isLongSet(1,i1))
           nCmd   = clRootDirs.getLong(1,i1, __LINE__);
      printf("] ROOT \"%s\" -> layer %d, cmd %d\n",
         clRootDirs.getString(0,i1),
         nLayer,
         nCmd
         );
   }

   for (int iLayer=0; clDirMasks.hasRow(iLayer); iLayer++) 
   {
      printf("] layer %d:\n", iLayer);

      printf("]  dmsk:\n");
      for (int i5=0; clDirMasks.isStringSet(iLayer, i5); i5++)
         printf("]   %s\n",clDirMasks.getString(iLayer, i5));

      printf("]  fmsk:\n]   ");
      for (int i6=0; clFileMasks.isStringSet(iLayer, i6); i6++)
         printf("%s, ",clFileMasks.getString(iLayer, i6));
      printf("\n");
   }

   printf("=== fileset end ===\n");
}

char *FileSet::currentInfoLine(int iLine)
{
   pClLineBuf[0] = '\0';
   
   // required:
   //  nClCurDir   is set
   //  nClCurLayer is set
   if (!hasRoot(nClCurDir))
      return str("");
   if (nClCurLayer < 0)
      return str("");

   int iLayer = nClCurLayer;
   char *pszUnit = 0;

   switch (iLine)
   {
      case 1: // current root dir
         return getCurrentRoot();
         
      case 2: // current layer's dir mask set
      {
         for (int i=0; clDirMasks.isStringSet(iLayer, i); i++) {
            pszUnit = clDirMasks.getString(iLayer, i);
            if (!strcmp(pszUnit, "*"))
               continue;
            if (strlen(pClLineBuf) > MAX_LINE_LEN-100)
               break;
            mystrcatf(pClLineBuf, MAX_LINE_LEN-100, "%s ", pszUnit);
         }
         break;
      }

      case 3: // current layer's file mask set
      {
         for (int i=0; clFileMasks.isStringSet(iLayer, i); i++) {
            pszUnit = clFileMasks.getString(iLayer, i);
            if (!strcmp(pszUnit, "*"))
               continue;
            if (strlen(pClLineBuf) > MAX_LINE_LEN-100)
               break;
            mystrcatf(pClLineBuf, MAX_LINE_LEN-100, "%s ", pszUnit);
         }
         break;
      }
   }
   
   return pClLineBuf;
}

// like dump, but easier representation, using pinf
void FileSet::info(void (*pout)(int nrectype, char *pline))
{
   char *psml = szLineBuf;
   char *pbig = (char*)abBuf;

   for (int i1=0; clRootDirs.isStringSet(0,i1); i1++)
   {
      int nLayer = clRootDirs.getLong(2,i1, __LINE__);
      int nCmd   = 0;
      if (clRootDirs.isLongSet(1,i1))
           nCmd   = clRootDirs.getLong(1,i1, __LINE__);

      sprintf(pbig, "directory tree %d:", i1+1);
      pout(1, pbig);

      pout(2, clRootDirs.getString(0,i1));

      // list masks used by that tree, possibly redundant
      int iLayer = nLayer;

      pbig[0] = '\0';
      int i5=0;
      for (; clDirMasks.isStringSet(iLayer, i5); i5++) {
         strcat(pbig, clDirMasks.getString(iLayer, i5));
         strcat(pbig, " ");
      }
      if (i5) {
         sprintf(psml, "... uses %d dir masks:", i5);
         pout(3, psml);
         pout(4, pbig);
      } else {
         pout(3, str("... uses no dir masks."));
      }

      pbig[0] = '\0';
      int i6=0;
      for (; clFileMasks.isStringSet(iLayer, i6); i6++) {
         strcat(pbig, clFileMasks.getString(iLayer, i6));
         strcat(pbig, " ");
      }
      if (i6) {
         sprintf(psml, "... uses %d file masks:", i6);
         pout(5, psml);
         pout(6, pbig);
      } else {
         pout(5, str("... uses no file masks."));
      }
   }
}

int FileSet::checkConsistency()
{__
   int nLayers = 0;
   for (int i0=0; clDirMasks.hasRow(i0); i0++) 
      nLayers++;

   mtklog(("check consistency of %d layers", nLayers));

   int lRC = 0;

   int *pRefCnt = new int[nLayers+10];
   memset(pRefCnt, 0, (nLayers+10)*sizeof(int));
   // NO RETURN FROM HERE

   // count for each layer how often it's referenced
   for (int i1=0; clRootDirs.isStringSet(0,i1); i1++)
   {
      int iLayer = clRootDirs.getLong(2,i1, __LINE__);
      if (iLayer < 0 || iLayer >= nLayers) {
         perr("internal #60 %d\n", iLayer);
         lRC = 9;
         break;
      }
      mtklog(("root %d references layer %d", i1, iLayer));
      pRefCnt[iLayer]++;
   }

   // find unreferenced layers
   for (int i2=0; i2<nLayers; i2++) {
      if (!pRefCnt[i2]) {
         // if -any is specified, the first layer is used implicitely
         // to list important file extensions.
         if ((i2 == 0) && bGlblAnyUsed)
            continue;
         perr("wrong -dir and -file sequence (%d)\n", i2);
         pinf("specify -dir ... before -file\n");
         lRC = 9;
      }
   }

   // NO RETURN UNTIL HERE
   delete [] pRefCnt;

   return lRC;
}

bool FileSet::anyRootAdded() {
   return (clRootDirs.numberOfEntries() > 0) ? 1 : 0;
}

// does the current root have any non-"*" file masks set?
bool FileSet::anyFileMasks()
{
   if (clFileMasks.numberOfEntries() <= 0)
      return false;

   // check if there is any non-"*" file mask
   for (int i=0; clFileMasks.isStringSet(i); i++)
   {
      char *pszMask = clFileMasks.getString(i);
      if (strcmp(pszMask, "*"))
         return true;
   }

   // if not, say no mask is set.
   return false;
}

bool FileSet::hasRoot(int iIndex) {
   bool bRC = clRootDirs.isStringSet(iIndex);
   // if (cs.debug) printf("] %d = hasRoot(%d)\n", bRC, iIndex);
   return bRC;
}

char* FileSet::setCurrentRoot(int iIndex) 
{
   if (cs.debug) printf("] select root %d\n",iIndex);
   mtklog(("FileSet::setCurrentRoot(%d)", iIndex));
   nClCurDir = iIndex;
   // the root dir no. iIndex selects a specific layer.
   nClCurLayer = clRootDirs.getLong(2, iIndex, __LINE__);
   clRootDirs.setRow(0, __LINE__);
   // fully switch to current layer
   if (cs.debug) printf("]  select layer %d\n",nClCurLayer);
   mtklog(("   select layer %d",nClCurLayer));
   clDirMasks.setRow(nClCurLayer, __LINE__);
   clFileMasks.setRow(nClCurLayer, __LINE__);
   return getCurrentRoot();
}

// return current root or simply "" if none:
char *FileSet::root(bool braw) {
   if (!hasRoot(nClCurDir)) return braw ? 0 : (char*)"";
   return getCurrentRoot();
}

char* FileSet::getCurrentRoot()
{
   char *pszDirName = clRootDirs.getString(0, nClCurDir);
   // prefix by preroot, if any
   if (pszGlblPreRoot) {
      // printf("PRE %s ADD %s\n",pszGlblPreRoot,pszDirName);
      strcopy(szGlblMixRoot, pszGlblPreRoot);
      // avoid to append "./" as dir name
      if (!strncmp(pszDirName, glblDotSlash, 2))
         pszDirName += 2;
      // avoid to append "." as dir name
      if (!strcmp(pszDirName, "."))
         pszDirName++;
      // any local dir remaining to append?
      if (strlen(pszDirName)) {
         if (!endsWithPathChar(szGlblMixRoot) && !endsWithColon(szGlblMixRoot))
            strcat(szGlblMixRoot, glblPathStr);
         strcat(szGlblMixRoot, pszDirName);
      }
      pszDirName = szGlblMixRoot;
   }
   return pszDirName;
}

int FileSet::numberOfRootDirs() {
   return clRootDirs.numberOfEntries(0);
}

int FileSet::ensureBase(int nTraceLine) {
   mtklog(("fs: ensureBase %d", nTraceLine));
   // clRootDirs must have 3 rows
   while (!clRootDirs.hasRow(2)) {
      mtklog(("fs: ... add another row"));
      if (clRootDirs.addRow(nTraceLine))
         return 9;
   }
   return 0;
}

// a layer is one set of dir masks and file masks.
// - dir masks is a row in clDirMasks.
// - file masks is a row in clFileMasks.
// - command is 1:1 per directory root,
//   therefore cmd is stored in clRootDirs.
// - clRootDirs row 0 is the directory name.
// - clRootDirs row 1 is the directory command (zip, copy).
// - a directory tree references a layer.

int FileSet::beginLayer(bool bWithEmptyCommand, int nTraceLine)
{
   mtklog(("fs: beginlayer %d", nTraceLine));

   // reset state of add sequence controlling
   resetAddFlags();

   // ensure clRootDirs has two columns
   if (ensureBase(__LINE__)) return 9;
   // make space for new layer
   clDirMasks.addRow(__LINE__);
   clFileMasks.addRow(__LINE__);
   // count new layer
   nClCurLayer++;
   // printf("] BEGINLAYER: new current=%d [\n",nClCurLayer);

   // a "command" is "-copy" or "-zip", used only with freezeto.
   // all other commands will just fill the command column with dummys.
   if (bWithEmptyCommand) {
      // set dummy command "0" in row 1 of clRootDirs
      clRootDirs.addLong(1, 0, __LINE__);
   }
   return 0;
}

int FileSet::addRootDir(char *pszRoot, int nTraceLine, bool bNoCmdFillup) 
{
   mtklog(("fs: addRootDir %s", pszRoot));

   if (cs.debug) printf("] add root dir: %s, referencing layer: %d [tline %d]\n", pszRoot, nClCurLayer, nTraceLine);

   // purify root: no patch char appended
   strncpy(pClLineBuf, pszRoot, MAX_LINE_LEN);
   pClLineBuf[MAX_LINE_LEN] = '\0';
   pszRoot = pClLineBuf;
   if (endsWithPathChar(pszRoot)) {
      #ifdef _WIN32
      if (strlen(pszRoot) == 3 && pszRoot[1] == ':')
         { } // do not strip / from c:/
      else
      #endif
      if (strlen(pszRoot) > 1)
         pszRoot[strlen(pszRoot)-1] = '\0';
   }

   if (ensureBase(__LINE__)) return 9;
   if (nClCurLayer == -1) {
      if (cs.debug) printf("] impl. create first fileset layer\n");
      beginLayer(true, __LINE__);
   }
   // complete the current column
   int nMax = clRootDirs.numberOfEntries(0);
   if (!bNoCmdFillup)
      if (clRootDirs.numberOfEntries(1) < nMax)
          clRootDirs.addLong(1, 0, __LINE__); // add empty command
   if (clRootDirs.numberOfEntries(2) < nMax)
      return 9+perr("internal #20\n");

   // add another root dir, forward-referencing
   // the current layer in which masks will follow.
   clRootDirs.addString(0,pszRoot);
   clRootDirs.addLong(2,nClCurLayer, __LINE__);

   #ifdef VFILEBASE
   // implicite activation of zip travel by root dir:
   if (endsWithArcExt(pszRoot)) {
      cs.xelike     = 1;
      cs.travelzips = 1;
   }
   #endif // VFILEBASE

   return 0;
}  // FileSet::addRootDir

int FileSet::addDirCommand(int lCmd)
{
   if (ensureBase(__LINE__)) return 9;
   // one single -cmd may map to several root dirs.
   // example: -dir a1 a2 a3 -copy
   // therefore fill up until root dir names number reached.
   int nMax = clRootDirs.numberOfEntries(0);  
   while (clRootDirs.numberOfEntries(1) < nMax)
      clRootDirs.addLong(1, lCmd, __LINE__);
   return 0;
}

int FileSet::addDirMask(char *pszMask) 
{
   if (ensureBase(__LINE__)) return 9;
   
   // per definitionem,  ".ext" means ".ext/"
   // per definitionem, "!.ext" means "!.ext/"
   // per definitionem, "*.ext" means "*.ext/"
   
   int iMaskLen = strlen(pszMask);
   if (pszMask[0] == '.' && pszMask[iMaskLen-1] != glblPathChar) 
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }
   else
   if (   isNotChar(pszMask[0]) != 0
       && pszMask[1] == '.'
       && pszMask[iMaskLen-1] != glblPathChar) 
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }
   else
   if (   pszMask[0] == glblWildChar
       && pszMask[1] == '.'
       && pszMask[iMaskLen-1] != glblPathChar)
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }
   
   clDirMasks.addString(pszMask);
   
   return 0;
}

int FileSet::addFileMask(char *pszMask)
{
   // if (cs.debug) printf("] addFileMask %s\n", pszMask);
   if (ensureBase(__LINE__)) return 9;

   // per definitionem,  ".ext" means ".ext/"
   // per definitionem, "!.ext" means "!.ext/"
   
   int iMaskLen = strlen(pszMask);
   if (pszMask[0] == '.' && pszMask[iMaskLen-1] != glblPathChar)
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }
   else
   if (   isNotChar(pszMask[0]) != 0
       && pszMask[1] == '.'
       && pszMask[iMaskLen-1] != glblPathChar)
   {
      snprintf(pClLineBuf, MAX_LINE_LEN-10, "%s%c", pszMask, glblPathChar);
      pszMask = pClLineBuf;
   }

   #ifdef VFILEBASE
   if (!cs.shallowzips && cs.xelike && cs.travelzips && maskEndsWithArcExt(pszMask)) 
   {
      pinf("file mask \"%s\" may produce no results, because\n",pszMask);
      char *pext = strrchr(pszMask, '.');
      if (!pext) pext = pszMask;
      pinf("option -arc is set, treating %s files as directories.\n",pext);
      pinf("say -dir ... %c%s -file ... instead to use %s as a path mask.\n",glblWildChar,pext,pszMask);
   }
   #endif // VFILEBASE

   if (!strcmp(pszMask, "-all") || isWildStr(pszMask)) {
      if (bClGotAllMask)
         return 9+perr("-all or %s supplied multiple times.\n", glblWildInfoStr);
      if (bClGotPosFile) {
         if (bGlblAllowAllPlusPosFile)
            pwarn("wrong sequence: positive file pattern already given, specify \"%s\" before this.\n", pszMask);
         else
            pwarn("positive file pattern already given, \"%s\" is unexpected.\n", pszMask);
      }
      if (bClGotNegFile)
         return 9+perr("wrong sequence: negative file pattern already given, specify \"%s\" before this.\n", pszMask);
      // map to * internally:
      pszMask = str("*");    // no wildstr, using real * internally
      bClGotAllMask = 1;
   }
   else
   if (isNotChar(pszMask[0])) {
      // negative file pattern: if it is the very first pattern
      if (!bClGotAllMask && !bClGotPosFile && !bClGotNegFile)
         clFileMasks.addString(str("*")); // IMPLICITELY. no wildstr.
      bClGotNegFile = 1;
   }
   else {
      // positive file pattern:
      // if (isWildChar(pszMask[0]))
      //    pwarn("%s at start of %s is ignored, say %c%s to force word start search.\n",
      //       glblWildInfoStr, pszMask, glblPathChar, pszMask+1);
      if (bClGotAllMask && !bGlblAllowAllPlusPosFile)
         pwarn("-all or * already given, \"%s\" has no effect.\n", pszMask);
      if (bClGotNegFile)
         return 9+perr("wrong sequence: negative file pattern already given, specify \"%s\" before this.\n", pszMask);
      bClGotPosFile = 1;
   }

   clFileMasks.addString(pszMask);
   return 0;
}

int FileSet::autoCompleteFileMasks(int nWhat) 
{
   if (cs.debug) printf("] autocomplete %d:\n", nWhat);

   if (nWhat & 1)
   for (int irow=0; clFileMasks.hasRow(irow); irow++) {
      if (clFileMasks.setRow(irow, __LINE__)) return 9;
      if (clFileMasks.numberOfEntries() == 0) {
         if (cs.debug) printf("]  yes, at layer %d\n",irow);
         if (clFileMasks.addString(str("*"))) return 9;   // no wildstr
      }
   }

   if (nWhat & 2)
   if (clRootDirs.numberOfEntries() == 0) {
      if (cs.debug) printf("] adding dir .\n");
      addRootDir(str("."), __LINE__, false);
   }

   return 0;
}

void FileSet::setBaseLayer() 
{
   clRootDirs.setRow(0, __LINE__);
   clDirMasks.setRow(0, __LINE__);
   clFileMasks.setRow(0, __LINE__);
}

// find: BinTexter remembers so many chars from previous line
//       to detect AND patterns spawning across soft-wraps.
#define BINTEXT_RECSIZE 3000
// 600 * 2 = 1200, 1200 * 2 = 2400

class BinTexter
{
public:
   BinTexter         (Coi *pcoi);
  ~BinTexter         ( );

   enum eDoWhat {
      eBT_Print   = 1,  // floating output, LFs blanked
      eBT_Grep    = 2,  // LFs lead to hard line break
      eBT_JamFile = 3   // floating output, LFs blanked
   };

   // uses szLineBuf, szLineBuf2.
   int  process     (int nDoWhat);
   int  processLine (char *pszBuf, int nDoWhat, int nLine, bool bHardWrap);

private:
   Coi  *pClCoi;
   char  szClPreBuf[80];   // just a short per line prefix
   char  szClOutBuf[BINTEXT_RECSIZE+100]; // fix: 1703: buffer too small.
   char  szClAttBuf[BINTEXT_RECSIZE+100]; // fix: 1703: buffer too small
   char  szClLastLine[BINTEXT_RECSIZE+100];
   bool  bClDumpedFileName;
};

BinTexter::BinTexter(Coi *pcoi)
{
   memset(this, 0, sizeof(*this));
   pClCoi = pcoi;
}

BinTexter::~BinTexter()
{
   memset(this, 0, sizeof(*this));
}

bool sfkisalpha(uchar uc) {
   if (isalpha((char)uc))
      return 1;
   if (uc > nGlblBinTextBinRange && uc < 0xFF)
      return 1;
   return 0;
}

bool sfkisalnum(uchar uc) {
   if (isalnum((char)uc))
      return 1;
   if (uc > nGlblBinTextBinRange && uc < 0xFF)
      return 1;
   return 0;
}

bool sfkisprint(uchar uc) {
   if (isprint((char)uc))
      return 1;
   if (uc > nGlblBinTextBinRange && uc < 0xFF)
      return 1;
   return 0;
}

// uses szLineBuf. Result in szLineBuf2.
int BinTexter::process(int nDoWhat)
{
   int icol   = 0;
   int istate = 0;
   int iword  = 0;  // index in short word target buffer
   int nword  = 0;  // to count non-binary word length
   int ihi    = 0;
   bool bflush = 0;
   bool bisws  = 0;
   bool bwasws = 0;
   bool bisbin = 0;
   bool bishi  = 0;
   bool bispunct = 0;
   bool bhardwrap = 0;
   bool babineol = 0; // helper flag, add blank if not at end of line
   char c = 0;
   unsigned char uc = 0;
   int nLine = 0;
   int nMinWord = 1; // min word length adapted dynamically below
   int lRC = 0;

   szClOutBuf[0] = '\0';

   num  nTellTime  = getCurrentTime();
   int nTellLines = 0;

   bool bbail = 0;
   while (!bbail)
   {
      int nRead = pClCoi->read(szLineBuf, sizeof(szLineBuf)-10);

      if (nRead <= 0) {
         bbail = 1;
         nRead = 1;
      }
      
      if (nTellLines++ > 1000) {
         nTellLines = 0;
         if (getCurrentTime() > nTellTime + 1000) {
            // working on the same file for 1000 msec: show status
            nTellTime = getCurrentTime();
            if (!cs.quiet && pClCoi->name()) {
               info.setAddInfo("%u files, %u dirs", cs.filesScanned, cs.dirsScanned);
               info.setStatus("scan", pClCoi->name(), 0, eKeepAdd);
            }
         }
      }

      for (int i=0; i<nRead; i++)
      {
         if (bbail) {
            c  = 0x00;
            uc = (unsigned char)c;
            bflush = 1;
         } else {
            c  = szLineBuf[i];
            uc = (unsigned char)c;
            bflush = 0;
         }

         if (c=='\n') {
            nLine++;
            bflush = 1;
            bhardwrap = 1;
         }

         if (cs.rewrap) {
            // reformatting plain text
            bisbin = (uc == 0) ? 1 : 0; // just in case
         } else {
            // reformatting binary
            bisbin = ((uc >= 0x80) && (uc < nGlblBinTextBinRange)) || (uc < 0x20);
            if (nGlblBinTextBinRange == 0xFF)
               bishi = (uc >= 0xC0);
         }

         if (!bisbin && !bishi)
            nword++;

         if (sfkisprint(c) && !bisbin) 
         {
            // printable char
            if (istate == 1) {
               // start collecting next word
               istate = 0;
               iword = 0;
               ihi   = 0;
            }
            // continue collecting current word,
            // reduce multi-whitespace sequences.
            bisws    = (c==' ' || c=='\t');
            bispunct = 0;
            if (cs.delim && strchr(cs.delim, c)) // CHG: 1703: instead of (c=='.' || c==',' || c==';');
               bispunct = 1;
            if (!(bisws && bwasws)) {
               szLineBuf2[iword++] = c;
               if (bishi)
                  ihi++;
            }
            // hard or soft word break?
            if (iword >= cs.wrapbincol)
               bflush = 1;
            else
            if ((iword >= 20) && (bisws || bispunct))
               bflush = 1;
         } else {
            // non-printable (binary) char
            if (istate == 0)  // if collecting a word
               bflush = 1;    // then flush the word
            // start skipping non-word data (binary etc.)
            istate = 1;
            bwasws = 0;
            bisws  = 0;
            bispunct = 0;
            // increment min word length needed to add to buffer.
            nMinWord = 3;
         }

         // dump current word?
         if (bflush) 
         {
            bflush = 0;
            if ((iword >= nMinWord || nword >= nMinWord) || c == '\n' || bbail)
            {
               // reset "add blank if not at end of line"
               babineol = 0;

               szLineBuf2[iword] = '\0';

               // do not add blank after whitespace, punct, or End Of Data.
               // add blank after a linefeed, if not in grep mode.
               if (bisws || bispunct || bbail || c == '\n') {
                  if (nDoWhat != eBT_Grep && c == '\n')
                     if (iword > 0 || nword > 0)
                        babineol = 1;
               } else {
                  // all other cases including '\r':
                  // add blank between isolated expressions
                  babineol = 1; // if not at end of line
               }

               if (strlen(szClOutBuf) + strlen(szLineBuf2) < sizeof(szClOutBuf)-10)
                  strcat(szClOutBuf, szLineBuf2);
               // else
               //    pwarn("buffer overflow (%d/%d/%d)\n",
               //       (int)strlen(szClOutBuf), (int)strlen(szLineBuf2), (int)sizeof(szClOutBuf)-10);

               icol += (iword+1);

               // strings and jamfile: create floating text.
               // in case of grep, keep hard line breaks.
               if (nDoWhat != eBT_Grep && c == '\n')
                  c = ' '; // binary to text: wrap floating text

               if (icol >= cs.wrapbincol || c == '\n' || bbail)
               {
                  // line flush.
                  if ((lRC = processLine(szClOutBuf, nDoWhat, nLine, bhardwrap)))
                     return lRC;
                  bhardwrap = 0;
                  icol = 0;
                  szClOutBuf[0] = '\0';
                  nword = 0;
                  nMinWord = 1;
               }
               else
               if (babineol)
               {
                  // no line flush, further stuff will be added,
                  // and remembered to insert a blank before that.
                  strcat(szClOutBuf, " ");
               }
            }
            iword  = 0;
            ihi    = 0;
            bwasws = 0;
         }
         else
            bwasws = bisws;

         // "sane" word count reset on any binary or non-printable
         if (bisbin || bishi || (c < 0x20))
            nword  = 0;
      }
   }

   return 0;
}

// snapto optional callback functions
int (*pGlblJamCheckCallBack)(char *pszFilename) = 0;
int (*pGlblJamFileCallBack)(char *pszFilename, num &rLines, num &rBytes) = 0;
int (*pGlblJamLineCallBack)(char *pszLine, int nLineLen, bool bAddLF) = 0;
int (*pGlblJamStatCallBack)(Coi *pCoiOrNull, uint nFiles, uint nLines, uint nMBytes, uint nSkipped, char *pszSkipInfo) = 0;

int BinTexter::processLine(char *pszBuf, int nDoWhat, int nLine, bool bHardWrap)
{
   int iRC = 0;

   info.cycle();

   if (nDoWhat == eBT_Print) {
      if (chain.coldata) {
         setattr(szAttrBuf3, 'f', strlen(szClOutBuf)+2, MAX_LINE_LEN);
         chain.addLine(szClOutBuf, szAttrBuf3);
      } else {
         info.print("%s\n", szClOutBuf);
      }
   }
   else
   if (nDoWhat == eBT_JamFile) 
   {
      int dumpJamLine(char *pszLine, int nLineLen, bool bAddLF); // len 0: zero-terminated

      // strip empty lines from binary text:
      if (!strlen(szClOutBuf) || szClOutBuf[0] == '\n')
         return 0;

      int lRC = dumpJamLine(szClOutBuf, 0, 1);

      nGlblBytes += strlen(szClOutBuf);
      cs.lines++;

      // only for callback: check per line if stat update is required.
      // it doesn't matter that nLines is actually counted past call to dumpJamLine.
      if (pGlblJamStatCallBack && glblFileCount.checkTime())
      {
         lRC |= pGlblJamStatCallBack(pClCoi, glblFileCount.value(), cs.lines, (uint)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
         // NO printf output here! BinTexter is also used by grep, strings.
      }

      return lRC;
   }
   else
   if (nDoWhat == eBT_Grep)
   {
      // 1. count no. of hits across current AND last line
      int nMatchCur = 0;
      int nMatchPre = 0;
      int nGrepPat  = glblGrepPat.numberOfEntries();
      int iHitOff   = 0;
      for (int i=0; ((nMatchCur+nMatchPre) < nGrepPat) && (i<nGrepPat); i++) 
      {
         if (mystrhit((char*)pszBuf, glblGrepPat.getString(i), cs.usecase, &iHitOff)) {
            // FIX: 1703: accept hit in current line only if in front halve,
            // otherwise truncation costs are too high. hits in rear halve
            // are moved to previous record.
            if (cs.joinlines == 0 || iHitOff < cs.wrapbincol/2) {
               nMatchCur++;
               continue;
            }
            // else fall through and check previous record
         }
         if (szClLastLine[0] && mystrhit(szClLastLine, glblGrepPat.getString(i), cs.usecase, 0))
            nMatchPre++;
      }

      // 2. if ALL pattern parts have a match somewhere, list both lines
      if ((nMatchCur+nMatchPre) == nGrepPat) 
      {
         // found a matching file
         cs.anymatches = 1;

         if (chain.colfiles) {
            // filenames only, as filename chain
            // TODO: set root as glblFileSet.root()?
            chain.addFile(*pClCoi); // is copied
            return 1; // end read loop above
         }

         if (cs.useJustNames) {
            // filenames only, as text data, NOT prefixing
            // further text data, therefore NOT including ":file "
            if (chain.coldata) {
               sprintf(szLineBuf3, "%s", pClCoi->name());
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf3, 'f', strlen(szLineBuf3)+2, MAX_LINE_LEN);
               chain.addLine(szLineBuf3, szAttrBuf3);
            } else {
               info.print("%s\n", pClCoi->name());
            }
            return 1; // end read loop above
         }

         // actually dump the content:

         // list filename first
         if (!bClDumpedFileName && !cs.nonames && !cs.pure) {
            bClDumpedFileName = 1;
            if (chain.coldata) {
               sprintf(szLineBuf3, ":file %s", pClCoi->name());
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf3, 'f', strlen(szLineBuf3)+2, MAX_LINE_LEN);
               chain.addLine(szLineBuf3, szAttrBuf3);
            } else {
               setTextColor(nGlblFileColor);
               info.print("%s :\n", pClCoi->name());
               setTextColor(-1);
            }
         }

         // create coloured display of hits of PREVIOUS line
         bool bskipcur = 0;
         if (!cs.justrc && nMatchPre)
         {
            // 1703: auto join of split result
            if (cs.joinlines)
            {
               int icur = strlen(szClLastLine);
               int irem = ((int)sizeof(szClLastLine)) - icur;
               int iadd = strlen(pszBuf);
               if (iadd < irem) 
               {
                  memcpy(szClLastLine+icur, pszBuf, iadd);
                  szClLastLine[icur+iadd] = '\0';
                  bskipcur = 1;
               }
            }

            char *pszTmp = szClLastLine;
            bool bPrefixed = 0;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            char csla = cs.joinlines ? ' ' : '/';
            char asla = cs.joinlines ? ' ' : 'p';
            if (bGlblGrepLineNum)
               sprintf(szClPreBuf, " %c %04u ", csla, (nLine > 0) ? (nLine-1) : nLine);
            else
               sprintf(szClPreBuf, " %c ", csla);
            szClAttBuf[1] = asla;
            
            int iMargin = 1;
            if (!cs.pure && !cs.noind) {
               if (chain.coldata) {
                  // FIX: 163: create new record here
                  chain.addLine(szClPreBuf, szClAttBuf);
                  bPrefixed = 1;
               } else {
                  printColorText(szClPreBuf, szClAttBuf, 0); // w/o LF
               }
               iMargin += strlen(szClPreBuf);
            }

            int iMinHitOff = -1;
            int iMaxHitOff = -1;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            for (int k=0; k<nGrepPat; k++) 
            {
               char *pszPat = glblGrepPat.getString(k);
               int nPatLen = strlen(pszPat);
               int nTmpLen = strlen(pszTmp);
               int nCur = 0, nRel = 0;
               while (mystrhit(pszTmp+nCur, pszPat, cs.usecase, &nRel))
               {
                  if (iMinHitOff < 0 || nRel < iMinHitOff)
                     iMinHitOff = nRel;
                  int iMaxOff = nRel+nPatLen;
                  if (iMaxHitOff < 0 || iMaxOff > iMaxHitOff)
                     iMaxHitOff = iMaxOff;
                  if (nCur+nRel+nPatLen < (int)sizeof(szClAttBuf)-10)
                     memset(&szClAttBuf[nCur+nRel], 'i', nPatLen);
                  nCur += nRel+nPatLen;
                  if (nCur >= nTmpLen-1)
                     break;
               }
            }
            if (iMinHitOff < 0 || cs.joinlines == 0)
               iMinHitOff = 0;
            if (cs.rtrim) {
               // trim line to result range
               int itrim = cs.rtrim-1;
               if (iMaxHitOff + itrim > BINTEXT_RECSIZE)
                   itrim = 0;
               pszTmp[iMaxHitOff+itrim] = '\0';
               szClAttBuf[iMaxHitOff+itrim] = '\0';
            } else {
               // trim joined line to normal wrap width
               int iMaxHitLen = iMaxHitOff - iMinHitOff;
               int iPrintLen  = strlen(pszTmp) - iMinHitOff;
               int iBestLen   = cs.wrapbincol/2-iMargin;
               if (   iPrintLen > 0
                   && iMinHitOff+iPrintLen < BINTEXT_RECSIZE
                   && iPrintLen > iBestLen
                   && iMaxHitLen < iBestLen
                   )
               {
                  iPrintLen = iBestLen;
                  pszTmp[iMinHitOff+iPrintLen] = '\0';
                  szClAttBuf[iMinHitOff+iPrintLen] = '\0';
               }
            }
            if (chain.coldata) {
               // FIX: 163: if prefix, append after that
               if (bPrefixed)
                  chain.addToCurLine(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff, 0);
               else
                  chain.addLine(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff);
            } else {
               printColorText(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff);
            }
         }
 
         // create coloured display of hits of CURRENT line
         if (!cs.justrc && !bskipcur && nMatchCur)
         {
            char *pszTmp = pszBuf;
            bool bPrefixed = 0;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            if (bGlblGrepLineNum)
               sprintf(szClPreBuf, "   %04u ", nLine);
            else
               sprintf(szClPreBuf, "   ");
            if (nMatchPre) {
               szClPreBuf[1] = '\\';
               szClAttBuf[1] = 'p';
            }

            int iMargin = 1;
            if (!cs.pure && !cs.noind) {
               if (chain.coldata) {
                  // FIX: 163: create new record here
                  chain.addLine(szClPreBuf, szClAttBuf, 0);
                  bPrefixed = 1;
               } else {
                   printColorText(szClPreBuf, szClAttBuf, 0); // w/o LF
               }
               iMargin += strlen(szClPreBuf);
            }

            int iMinHitOff = -1;
            int iMaxHitOff = -1;

            memset(szClAttBuf, ' ', sizeof(szClAttBuf));
            szClAttBuf[sizeof(szClAttBuf)-1] = '\0';
            for (int k=0; k<nGrepPat; k++) 
            {
               char *pszPat = glblGrepPat.getString(k);
               int nPatLen = strlen(pszPat);
               int nTmpLen = strlen(pszTmp);
               int nCur = 0, nRel = 0;
               while (mystrhit(pszTmp+nCur, pszPat, cs.usecase, &nRel)) 
               {
                  if (iMinHitOff < 0 || nRel < iMinHitOff)
                     iMinHitOff = nRel;
                  int iMaxOff = nRel+nPatLen;
                  if (iMaxHitOff < 0 || iMaxOff > iMaxHitOff)
                     iMaxHitOff = iMaxOff;
                  if (nCur+nRel+nPatLen < (int)sizeof(szClAttBuf)-10)
                     memset(&szClAttBuf[nCur+nRel], 'i', nPatLen);
                  nCur += nRel+nPatLen;
                  if (nCur >= nTmpLen-1)
                     break;
               }
            }
            if (iMinHitOff < 0 || cs.joinlines == 0)
               iMinHitOff = 0;
            if (cs.rtrim) {
               // trim line to result range
               int itrim = cs.rtrim-1;
               if (iMaxHitOff + itrim > BINTEXT_RECSIZE)
                   itrim = 0;
               pszTmp[iMaxHitOff+itrim] = '\0';
               szClAttBuf[iMaxHitOff+itrim] = '\0';
            } else {
               // trim current line to normal wrap width
               int iMaxHitLen = iMaxHitOff - iMinHitOff;
               int iPrintLen  = strlen(pszTmp) - iMinHitOff;
               int iBestLen   = cs.wrapbincol/2-iMargin;
               if (   iPrintLen > 0
                   && iMinHitOff+iPrintLen < BINTEXT_RECSIZE
                   && iPrintLen > iBestLen
                   && iMaxHitLen < iBestLen
                   )
               {
                  iPrintLen = iBestLen;
                  pszTmp[iMinHitOff+iPrintLen] = '\0';
                  szClAttBuf[iMinHitOff+iPrintLen] = '\0';
               }
            }
            if (chain.coldata) {
               // FIX: 163: if prefix, append after that
               if (bPrefixed)
                  chain.addToCurLine(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff, 0);
               else
                  chain.addLine(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff);
            } else {
               printColorText(pszTmp+iMinHitOff, szClAttBuf+iMinHitOff);
            }
         }

         // line was listed, do NOT remember
         szClLastLine[0] = '\0';
         
         if (cs.useFirstHitOnly)
            iRC = 1;
      }
      else
      {
         // line was NOT listed
         szClLastLine[0] = '\0';
         // FIX: 1703: ALWAYS take over current line to lastline no matter if hardwrap
         // if (!bHardWrap) 
         {
            int nCurLen = strlen(pszBuf);
            int nCopyIndex = 0;
            if (nCurLen > BINTEXT_RECSIZE) {
               nCopyIndex = nCurLen - BINTEXT_RECSIZE;
               nCurLen    = BINTEXT_RECSIZE;
            }
            // mystrcopy guarantees a zero terminator if nCurLen > 0.
            mystrcopy(szClLastLine, pszBuf+nCopyIndex, nCurLen+1);
         }
      }
   }

   return iRC;
}

// only for processDirParms and walkAllTrees:
int nGlblError = 0; // flag from walkAllTrees
StringTable *pGlblFileParms = 0;
char **apGlblFileParms = 0;
int  nGlblFileParms    = 0;
bool bGlblHaveMixedDirFileList = 0;

void skipSpaceRem(char **pszInOut)
{
   char *psz1 = *pszInOut;

   // skip all whitespaces and remark lines
   while (*psz1) 
   {
      if (*psz1==' ' || *psz1=='\t' || *psz1=='\r' || *psz1=='\n')
         { psz1++; continue; }

      if (*psz1=='#' || *psz1==';') {
         while (*psz1 && *psz1!='\n')
            psz1++;
         if (*psz1)
            psz1++; // skip LF
      }
      else
         break;
   }

   *pszInOut = psz1;
}

uint currentProcessID()
{
   #ifdef _WIN32
   return (uint)GetCurrentProcessId();
   #else
   return (uint)getpid();
   #endif
}

// SFK home dir creation and filename building
class SFKHome
{
public:
      SFKHome  ( );

bool
      noHomeDir   ( );
char
      *makePath   (char *pszRelPath, bool bReadOnly=0),
       // also creates required folders.
       // returns NULL on any error.
      *getPath    (char *pszRelPath);
       // for readonly access.
       // returns NULL on any error.

bool  bClTold;
char  szClDir     [SFK_MAX_PATH+10];
char  szClPathBuf [SFK_MAX_PATH+10];
};

SFKHome sfkhome;

SFKHome::SFKHome( )
{
   mclear(szClDir);
   bClTold = 0;

   #ifdef _WIN32

   char *psz = getenv("SFK_HOME");
   if (psz) {
      strcopy(szClDir, psz);
      return;
   }
   psz = getenv("LOCALAPPDATA");
   if (psz) {
      snprintf(szClDir, sizeof(szClDir)-10, "%s\\.sfkhome", psz);
      return;
   }

   #else

   sprintf(szClDir, "~/.sfkhome");

   #endif
}

bool SFKHome::noHomeDir()
{
   if (szClDir[0])
      return 0;

   if (!bClTold)
   {
      bClTold = 1;

      pwarn("no SFK Home Dir exists to store or read data.");
   
      #ifdef _WIN32
      pinf("you may SET \"SFK_HOME=anyfolder\" to define it directly.\n");
      pinf("you may SET \"LOCALAPPDATA=anyfolder\" to define it's parent folder.\n");
      #endif
   }

   return 1;
}

char *SFKHome::makePath(char *pszRelPath, bool bReadOnly)
{
   if (noHomeDir())
      return 0;

   snprintf(szClPathBuf, sizeof(szClPathBuf)-10,
      "%s%c%s", szClDir, glblPathChar, pszRelPath);

   if (!bReadOnly && createOutDirTree(szClPathBuf))
      return 0;

   return szClPathBuf;
}

char *SFKHome::getPath(char *pszRelPath)
{
   return makePath(pszRelPath, 1);
}

// temporary file class, REMOVING THE FILE IN DESTRUCTOR.
class SFTmpFile
{
public:
   SFTmpFile   (const char *pszExt, bool bNoAutoDelete, uint nTmpFileNum = 0);
  ~SFTmpFile   ( );
   char *name  ( );
   static void setTmpDir(char *pszDir);
   static bool tmpDirWasSet( );
private:
   bool  bClAutoDel;
   uint nClNum;
   char szClExt[100];
   char *pszClName;
   static int ncnt;
   static char *pszTmpDir;
};

int SFTmpFile::ncnt = 1;
char *SFTmpFile::pszTmpDir = 0;

SFTmpFile::SFTmpFile(const char *pszExt, bool bNoAutoDelete, uint nTmpFileNum) 
{
   strcopy(szClExt, pszExt);
   bClAutoDel = !bNoAutoDelete;
   nClNum     = nTmpFileNum;
   pszClName  = 0;
}

SFTmpFile::~SFTmpFile() 
{
   if (pszClName != 0) {
      if (bClAutoDel && fileExists(pszClName))
         remove(pszClName);
      delete [] pszClName;
      pszClName = 0;
   }
}

void SFTmpFile::setTmpDir(char *pszDir)
{
   pszTmpDir = pszDir;
}

bool SFTmpFile::tmpDirWasSet( )
{
   return pszTmpDir ? 1 : 0;
}

// uses szLineBuf
char *SFTmpFile::name() 
{
   if (!pszClName) {
      char *psz = pszTmpDir;
      if (!psz) psz = getenv("TEMP");
      if (!psz) psz = getenv("TMP");
      #ifndef _WIN32
      if (!psz) psz = str("/tmp");
      #endif
      if (!psz) 
         { perr("cannot create temporary file: no TEMP or TMP environment variable found.\n"); return 0; }
      pszClName = new char[MAX_LINE_LEN+10];
      if (joinPath(pszClName, MAX_LINE_LEN-20, psz, str("zz-tmp-sfk-")))
         { perr("cannot create temporary file.\n"); return 0; }
      int nlen = strlen(pszClName);
      uint uprocid = currentProcessID();
      if (nClNum > 0)
         sprintf(pszClName+nlen, "%03u%s", nClNum, szClExt);
      else
         sprintf(pszClName+nlen, "%03u%s", uprocid, szClExt);
      ncnt = (ncnt+1) % 3;
   }
   if (cperm.showtmp) {
       info.clear();
       setTextColor(nGlblTimeColor);
       oprintf("using temporary file: %s\n", pszClName);
       setTextColor(-1);
   }
   return pszClName;
}

bool isDirParm(char *psz)
{
   if (!strcmp(psz, "-dir"))        return true;
   if (!strcmp(psz, "-file"))       return true;
   if (!strncmp(psz, "-from=", 6))  return true;
   if (!strcmp(psz, "-fileset"))    return true;
   if (!strcmp(psz, "-view"))       return true;   // deprecated
   return false;
}

#ifdef SFK_LINUX_FULL
// experimental: change thread priority
void setPriority(int nprio) 
{
   // supported values are -2 to +2
   #ifdef _WIN32
   SetThreadPriority(GetCurrentThread(), nprio);
   #else
   sched_param oschedparm;
   int nNativePrio = 0;
   switch (nprio) {
      case -2 : nNativePrio =   1; break;
      case -1 : nNativePrio =  25; break;
      case  0 : nNativePrio =  50; break;
      case  1 : nNativePrio =  75; break;
      case  2 : nNativePrio = 100; break;
   }
   if (nprio < -2) nNativePrio =   1;
   if (nprio >  2) nNativePrio = 100;
   oschedparm.sched_priority = nNativePrio;
   pthread_setschedparam(pthread_self(), SCHED_OTHER, &oschedparm);
   #endif
}
#endif

#ifdef VFILEBASE
extern "C" void setUzpMemLimit(num nlimit);
#endif // VFILEBASE

void setMemoryLimit(int nMBytes) 
{
   num nbytes = nMBytes * 1048576;
   // no not accept limits below 10 MB:
   if (nbytes < 10 * 1000000) {
      perr("ignoring memlimit, illegal value: %d", nMBytes);
   } else {
      nGlblMemLimit = nbytes;
      bGlblMemLimitWasSet = 1;
   }
}

bool setGeneralOption(char *argv[], int argc, int &iOpt, bool bGlobal=0)
{
   struct CommandStats *pcs = (bGlobal ? &gs : &cs);

   char *psz1 = argv[iOpt];
   
   if (!strcmp(psz1, "-stest"))     { bGlblSyntaxTest = 1; return true; }
   if (!strcmp(psz1, "-debug"))     { pcs->debug = 1; pcs->memcheck = 1; return true; }
   if (!strncmp(psz1, "-coi", 4))   { Coi::bClDebug = 1; return true; }
   if (!strcmp(psz1, "-noop"))      { return true; }
   if (!strcmp(psz1, "-quiet"))     { pcs->quiet = 1; return true; }
   if (!strcmp(psz1, "-quiet=2"))   { pcs->quiet = 2; return true; }
   if (!strcmp(psz1, "-nohead"))    { pcs->nohead = 1; return true; }
   if (!strcmp(psz1, "-nocheck"))   { pcs->nocheck = 1; return true; }
   if (!strncmp(psz1, "-noinf", 6)) { pcs->noinfo = 1; return true; }
   if (!strncmp(psz1, "-nofile", 7)){ pcs->nonames = 1; return true; }
   if (!strncmp(psz1, "-noname", 7)){ pcs->nonames = 1; return true; }
   if (!strncmp(psz1, "-noind", 6)) { pcs->noind = 1; return true; }
   if (!strcmp(psz1, "-sim"))       { pcs->sim = 1; return true; }
   if (!strcmp(psz1, "-norec"))     { pcs->subdirs = 0; return true; }
   if (!strncmp(psz1, "-nosub", 6)) { pcs->subdirs = 0; return true; }
   if (!strcmp(psz1, "-withsub"))   { pcs->subdirs = 1; return true; }
   if (!strcmp(psz1, "-i"))         { bGlblStdInAny = 1; return true; }
   if (!strcmp(psz1, "-verbose"))   { pcs->verbose = 1; return true; }
   if (!strcmp(psz1, "-verbose=0")) { pcs->verbose = 0; return true; }
   if (!strcmp(psz1, "-verbose=2")) { pcs->verbose = 2; return true; }
   if (!strcmp(psz1, "-verbose=3")) { pcs->verbose = 3; return true; }
   if (!strcmp(psz1, "-verbose=4")) { pcs->verbose = 4; return true; }
   if (!strcmp(psz1, "-showip"))    { pcs->showip = 1; return true; }
   if (!strcmp(psz1, "-justrc"))    { pcs->justrc = 1; return true; }
   if (strBegins(psz1, "-hid"))     { pcs->hidden = 1; return true; }
   if (strBegins(psz1, "-nohid"))   { pcs->hidden = 0; return true; }
   if (!strcmp(psz1, "-yes"))       { pcs->yes = 1; return true; }
   if (!strcmp(psz1, "-umlauts"))   { nGlblBinTextBinRange = 0xC0; return true; }
   if (!strcmp(psz1, "-noumlauts") || strBegins(psz1, "-noacc")) {
      nGlblBinTextBinRange = 0xFF;
      glblNoCase.reinit(0); // -noacc
      return true;
   }
   if (strBegins(psz1, "-utf"))     { pcs->wchardec = 1; return true; } // deprecated
   if (strBegins(psz1, "-noutf"))   { pcs->wchardec = 0; return true; } // deprecated
   if (strBegins(psz1, "-wchar"))   { pcs->wchardec = 1; return true; }
   if (strBegins(psz1, "-nowchar")) { pcs->wchardec = 0; return true; }
   if (!strcmp(psz1, "-nocol"))     { bGlblUseColor = bGlblUseHelpColor = 0; return true; }
   if (!strcmp(psz1, "-col"))       { bGlblUseColor = 1; return true; }
   if (!strcmp(psz1, "-case"))      { pcs->usecase = 1; return true; }
   if (!strcmp(psz1, "-nocase"))    { pcs->usecase = 0; pcs->nocase = 1; return true; }
   if (!strcmp(psz1, "-withdirs"))  { pcs->withdirs = 1; return true; }
   if (!strncmp(psz1, "-wdir", 5))  { pcs->withdirs = 1; return true; }
   if (!strcmp(psz1, "-justdirs"))  { pcs->justdirs = 1; return true; }
   if (!strcmp(psz1, "-names"))     { pcs->useJustNames = 1; return true; }
   if (!strncmp(psz1, "-rel", 4))   { pcs->rootrelname = 1; return true; }
   if (!strncmp(psz1, "-absname", 8)) { pcs->rootabsname = 1; return true; }
   if (!strncmp(psz1, "-quot", 5))  { bGlblQuoted = 1; return true; }
   if (!strcmp(psz1, "-nocconv"))   { bGlblEnableOPrintf = 0; return true; }
   if (!strcmp(psz1, "-cconv"))     { bGlblForceCConv = 1; return true; }
   if (!strcmp(psz1, "-incref"))    { bGlblSinceDirIncRef = 1; return true; }
   if (!strcmp(psz1, "-force"))     { pcs->force = 1; return true; }
   if (!strncmp(psz1, "-lit", 4))   { pcs->spat = 0; pcs->wpat = 0; return true; }
   if (!strcmp(psz1, "-spats"))     { pcs->spat = 2; return true; }
   if (!strncmp(psz1, "-spat", 5))  { pcs->spat = 1; return true; }
   if (!strncmp(psz1, "-nospat", 7)){ pcs->spat = 0; return true; }
   if (!strcmp(psz1, "-bright"))    { nGlblDarkColBase = 1; return true; }
   if (!strcmp(psz1, "-dark"))      { nGlblDarkColBase = 0; return true; }
   if (!strcmp(psz1, "-nochain"))   { pcs->nochain = 1; return true; }
   if (!strcmp(psz1, "-showrc"))    { gs.showrc = 1; return true; }
   if (!strcmp(psz1, "-exectime"))  { gs.tellExecTime = 1; return true; }
   if (!strncmp(psz1, "-nowarn", 7)) { pcs->nowarn = 1; return true; }
   if (!strncmp(psz1, "-noerr",  6)) { pcs->noerr = 1; return true; }
   if (!strncmp(psz1, "-nonote", 7)) { pcs->nonotes = 1; return true; }
   if (!strncmp(psz1, "-nofo", 5))   { pcs->skipLinks = 1; return true; }
   if (!strncmp(psz1, "-rawflags", 5)) { pcs->traceFileFlags = 1; return true; }
   if (!strncmp(psz1, "-ltarg", 6))  { pcs->listTargets = 1; return true; }
   if (!strncmp(psz1, "-stoponerr", 10))  { pcs->treeStopRC = 9; return true; }
   if (!strncmp(psz1, "-echoonerr", 11)) { pcs->echoonerr = 1; return true; }
   if (!strncmp(psz1, "-rcfromerr", 10))  { pcs->rcFromError = 9; return true; }
   if (!strncmp(psz1, "-waitonerr", 10))  { bGlblPauseOnError = 1; return true; }
   else
   if (!strncmp(psz1, "-wait", 5))  { bGlblPauseOnEnd = 1; return true; }
   if (!strncmp(psz1, "-exterr", 7)){ bGlblSysErrDetail = 1; return true; }
   if (!strncmp(psz1, "-detail", 7)){ bGlblSysErrDetail = 1; return true; }
   if (!strcmp(psz1, "-showskip"))  { pcs->showdupdirs = 1; return true; }
   if (strBegins(psz1, "-allowdup")) { pcs->usecirclemap = 0; return true; }
   if (!strcmp(psz1, "-fast"))      { pcs->fast = 1; return true; }
   if (strBegins(psz1, "-nover"))   { pcs->verify = 0; return true; }
   if (strBegins(psz1, "-verify"))  { pcs->verify = 1; return true; }
   if (!strcmp(psz1, "-noprog"))    { pcs->noprog = 1; return true; }
   if (!strcmp(psz1, "-notext"))    { pcs->notext = 1; return true; }
   if (!strcmp(psz1, "-test"))      { pcs->test = 1; return true; }
   if (!strcmp(psz1, "-oldmd5"))    { bGlblOldMD5 = 1; return true; }
   if (strBegins(psz1, "-withbin"))    { pcs->textfiles = 0; pcs->binaryfiles = 0; return true; }
   if (strBegins(psz1, "-textandbin")) { pcs->textfiles = 0; pcs->binaryfiles = 0; return true; }
   if (strBegins(psz1, "-text"))       { pcs->textfiles = 1; return true; }
   if (strBegins(psz1, "-textfile"))   { pcs->textfiles = 1; return true; }
   if (strBegins(psz1, "-nobin"))      { pcs->textfiles = 1; return true; }
   if (strBegins(psz1, "-bin"))        { pcs->binaryfiles = 1; return true; }
   if (strBegins(psz1, "-binfile"))    { pcs->binaryfiles = 1; return true; }
   if (strBegins(psz1, "-binaryfile")) { pcs->binaryfiles = 1; return true; }
   if (!strcmp(psz1, "-keepdate"))  { pcs->keeptime = 1; return true; }
   if (!strcmp(psz1, "-keeptime"))  { pcs->keeptime = 1; return true; }
   if (!strcmp(psz1, "-snap"))      { pcs->usesnap = 1; return true; }
   if (!strncmp(psz1, "-snapw", 6)) { // snapwithnames
      pcs->usesnap = 1;
      pcs->usesnapfiltname = 1;
      return true; 
   }
   if (!strcmp(psz1, "-upat")) {
      // enable unix or unified pattern syntax,
      // esp. for sfk filter under windows.
      setLinuxSyntax();
      return true;
   }
   #ifdef VFILEBASE
   if (!strcmp(psz1, "-qarc")) {
      pcs->travelzips  = 1;
      pcs->xelike      = 1;
      pcs->shallowzips = 1;  // toplevel only
      return true;
   }
   #endif // VFILEBASE
   if (!strcmp(psz1, "-zip") || !strcmp(psz1, "-arc")) {
      pcs->travelzips = 1;
      #ifdef VFILEBASE
      pcs->xelike     = 1;  // process zips as deep as possible
       #ifdef USE_SFK_BASE
       pcs->precachezip = 1; // dv load: always force precache
       #endif // USE_SFK_BASE
      #endif // VFILEBASE
      return true; 
   }
   if (!strcmp(psz1, "-nozip") || !strcmp(psz1, "-noarc"))
      { pcs->travelzips = 0; return true; }

   #ifdef VFILEBASE
   if (!strcmp(psz1, "-extdom"))    { pcs->extdomref = 1; return true; }
   if (!strcmp(psz1, "-xd"))        { pcs->xelike    = 1; return true; }
   if (!strcmp(psz1, "-cacheall"))  { pcs->cacheall  = 1; return true; }
   if (!strcmp(psz1, "-cachestat")) { gs.cachestat   = 1; return true; }
   if (!strcmp(psz1, "-nocache"))   { setDiskCacheActive(0); return true; }
   #endif // VFILEBASE

   if (strBegins(psz1, "-noipex"))  { pcs->noipexpand = 1; return true; }
   if (strBegins(psz1, "-crashtest"))  { pcs->crashtest = 1; return true; }

   // -pure is often a local option, but some commands allow general use:
   if (bGlblAllowGeneralPure && !strcmp(psz1, "-pure"))
      { pcs->pure = 1; return true; }

   if (!strcmp(psz1, "-allbin") || !strcmp(psz1, "-include-all-binaries"))
      { pcs->incbin = 1; return true; }

   if (!strcmp(psz1,"-wrap") || !strcmp(psz1,"-rewrap"))
   {
      if (!strcmp(psz1,"-rewrap")) pcs->rewrap = 1;
      // wrap with auto-calculated number of columns
      int nCols = autoCalcWrapColumns();
      if (nCols) {
         pcs->wrapcol = nCols;
         if (pcs->wrapbincol == 80) // if on default
            pcs->wrapbincol = nCols;
      }
      mtklog(("opt: done %s, wrapcol=%d, wrapbincol=%d",psz1,pcs->wrapcol,pcs->wrapbincol));
      return true;
   }
   if (strBegins(psz1,"-wrap=") || strBegins(psz1,"-rewrap="))
   {
      int nCols = 0;
      if (strBegins(psz1,"-rewrap=")) {
         pcs->rewrap = 1;
         nCols = atol(psz1+8);
      } else {
         nCols = atol(psz1+6);
      }
      // wrap with fixed (user-defined) number of columns
      if (nCols) {
         pcs->wrapcol = nCols;
         if (pcs->wrapbincol == 80) // if on default
            pcs->wrapbincol = nCols;
      }
      mtklog(("opt: done %s, wrapcol=%d, wrapbincol=%d",psz1,pcs->wrapcol,pcs->wrapbincol));
      return true;
   }
   if (!strncmp(psz1,"-wrapbin",8)) {
      // wrap for text extracted from binary files
      int nCols = 0;
      if (!strncmp(psz1,"-wrapbin=",9))
         nCols = atol(psz1+9);
      else
         nCols = autoCalcWrapColumns();
      if (nCols) {
         pcs->wrapbincol = nCols;
      }
      return true;
   }
   if (!strcmp(psz1, "-memcheck"))  { pcs->memcheck = 1; return true; }
   #ifdef SFK_MEMTRACE
   if (!strcmp(psz1, "-nomemcheck")) {
      bGlblNoMemCheck = 1;
      sfkmem_nocheck();
      return true;
   }
   #endif // SFK_MEMTRACE
   if (!strncmp(psz1,"-memlimit=",strlen("-memlimit="))) {
      int nMBytes = atol(psz1+strlen("-memlimit="));
      setMemoryLimit(nMBytes);
      return true;
   }
   if (!strncmp(psz1,"-keepstale=",strlen("-keepstale="))) {
      nGlblActiveFileAgeLimit = atol(psz1+strlen("-keepstale="));
      return true;
   }
   if (!strncmp(psz1, "-html", 5)) {
      bGlblHtml = 1;
      if (!getenv("SFK_COLORS"))
         setColorScheme("file:1,head:4,examp:8");
      if (!strcmp(psz1, "-htmlpage"))
         printf("<font face=\"courier\" size=\"2\"><pre>\n");
      return true; 
   }
   if (   !strcmp(psz1, "-sincedir") || !strcmp(psz1, "-sd")
       || !strcmp(psz1, "-sinceadd") || !strncmp(psz1, "-sincedif", 9)
       || !strncmp(psz1, "-sincech", 8) || !strcmp(psz1, "-sc")
      )
   {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *psz2 = argv[iOpt];
      if (*psz2 == '-') { perr("need directory name, no option allowed after %s\n", psz1); exit(9); }
      pszGlblSinceDir = strdup(psz2);
      if (!bGlblSyntaxTest && !isDir(pszGlblSinceDir))
         { perr("no such directory: %s\n", pszGlblSinceDir); exit(9); }
      if (!strcmp(psz1, "-sinceadd"))
         nGlblSinceMode |= 1;
      else
      if (!strncmp(psz1, "-sincedif", 9))
         nGlblSinceMode |= 2;
      else
      if (!strncmp(psz1, "-sincech", 8) || !strcmp(psz1, "-sc"))
         nGlblSinceMode |= 1+2;  // only add and dif, no time diff
      else
         nGlblSinceMode = 1+2+4; // default: list all differences
      return true;
   }
   if (!strncmp(psz1, "-ignoretime", 11)) {
      // if (!(nGlblSinceMode & 2)) {
      //    perr("-ignoretime can be used only after -sincedir/dif/ch.\n");
      //    exit(9);
      // }
      bGlblIgnoreTime = 1;
      return true;
   }
   if (!strcmp(psz1, "-ignore3600")) {
      bGlblIgnore3600 = 1;
      return true;
   }
   if (!strcmp(psz1, "-noignore3600")) {
      bGlblIgnore3600 = 0;
      return true;
   }
   if (!strncmp(psz1, "-tracesel", 9)) {
      nGlblTraceSel |= 3;
      return true;
   }
   if (!strncmp(psz1, "-tracedir", 9)) {
      nGlblTraceSel |= 1;
      return true;
   }
   if (!strncmp(psz1, "-tracefile", 10)) {
      nGlblTraceSel |= 2;
      return true;
   }
   if (!strcmp(psz1, "-usectime")) {
      pcs->usectime = 1;
      return true;
   }
   if (!strcmp(psz1, "-utc") || !strcmp(psz1, "-gmt")) {
      pcs->useutc = 1;
      return true;
   }
   #ifdef VFILENET
   if (!strcmp(psz1, "-proxy")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char szBuf[200];
      char *pproxy = argv[iOpt];
      strcopy(szBuf, pproxy);
      char *psz1 = szBuf;
      while (*psz1 && *psz1 != ':') psz1++;
      if (*psz1) *psz1++ = '\0';
      int nport = atol(psz1);
      TCPCore::setProxy(szBuf, nport);
      return true;
   }
   #endif // VFILENET
   if (strBegins(psz1, "-minsize=")) {
      pcs->minsize = numFromSizeStr(psz1+9, psz1);
      if (pcs->minsize < 0) exit(9);
      return true;
   }
   if (strBegins(psz1, "-maxsize=")) {
      pcs->maxsize = numFromSizeStr(psz1+9, psz1);
      if (pcs->maxsize < 0) exit(9);
      return true;
   }
   if (!strcmp(psz1, "-since")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *psz2 = argv[iOpt];
      if (tryGetRelTime(psz2, pcs->sincetime))
      { }
      else
      if (timeFromString(psz2, pcs->sincetime))
         exit(9);
      if (pcs->untiltime && pcs->untiltime <= pcs->sincetime)
         {  perr("-before lower or equal than -since was specified.\n"); exit(9); }
      return true;
   }
   if (!strcmp(psz1, "-before")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *psz2 = argv[iOpt];
      if (tryGetRelTime(psz2, pcs->untiltime))
      { }
      else
      if (timeFromString(psz2, pcs->untiltime))
         exit(9);
      if (pcs->sincetime && pcs->sincetime >= pcs->untiltime)
         {  perr("-since greater or equal than -before was specified.\n"); exit(9); }
      return true;
   }
   if (!strcmp(psz1, "-to")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      cs.tomask = argv[iOpt];
      cs.tomaskfile = 0;
      return true;
   }
   if (!strcmp(psz1, "-tofile")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      cs.tomask = argv[iOpt];
      cs.tomaskfile = 1;
      return true;
   }
   if (!strcmp(psz1, "-tmpdir")) {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      SFTmpFile::setTmpDir(argv[iOpt]);
      return true;
   }
   if (!strcmp(psz1, "-keeptmp")) {
      cperm.keeptmp = 1;
      return true;
   }
   if (!strcmp(psz1, "-showtmp")) {
      cperm.showtmp = 1;
      return true;
   }
   if (!strcmp(psz1, "-today")) {
      tryGetRelTime("today", pcs->sincetime);
      return true;
   }
   if (!strcmp(psz1, "-flist") || !strcmp(psz1, "-fl"))
   {
      // this option takes another parameter!
      ++iOpt;  // new iOpt IS WRITTEN BACK.
      if (iOpt >= argc) { perr("missing parameter after %s\n", psz1); exit(9); }
      char *pszFile = argv[iOpt];

      // read list of filenames from a file.
      Coi ocoi(pszFile, 0);
      if (ocoi.open("rb"))
         { perr("cannot read filename list file: %s\n", pszFile); exit(9); }
      while (ocoi.readLine(szLineBuf, sizeof(szLineBuf)-10) > 0)
      {
         szLineBuf[sizeof(szLineBuf)-10] = '\0';
         removeCRLF(szLineBuf);
         if (cs.debug) printf("] add2flist.1: %s\n", szLineBuf);
         Coi ocoisub(szLineBuf, 0);
         glblSFL.addEntry(ocoisub); // is copied
      }
      ocoi.close();

      // if no further dir parms follow, do not autocomplete.
      cs.blockAutoComplete = 1;

      return true;
   }
   #ifdef SFK_LINUX_FULL
   if (!strncmp(psz1,"-prio=", 6)) {
      setPriority(atol(psz1+6));
      return true;
   }
   #endif
   if (!strncmp(psz1,"-dirdelay=",strlen("-dirdelay="))) {
      pcs->walkDirDelay = atol(psz1+strlen("-dirdelay="));
      return true;
   }
   if (!strncmp(psz1,"-filedelay=",strlen("-filedelay="))) {
      pcs->walkFileDelay = atol(psz1+strlen("-filedelay="));
      return true;
   }
   if (!strcmp(psz1,"-slow=3"))   {
      pcs->walkDirDelay  = 10;
      pcs->walkFileDelay = 10;
      return true;
   }
   if (!strcmp(psz1,"-slow=2"))   {
      pcs->walkDirDelay  = 100;
      return true;
   }
   #ifdef SFK_LINUX_FULL
   if (!strncmp(psz1,"-slow", 5)) {
      setPriority(-1);
      return true;
   }
   #endif
   if (!strcmp(psz1,"-broad"))      {  cs.incFNameInPath = 1; return true; }
   if (!strcmp(psz1,"-firsthit"))   {  cs.useFirstHitOnly = 1; return true; }
   if (!strcmp(psz1,"-xchars"))     {  pcs->xchars = 1; return true; }
   if (!strcmp(psz1,"-perf"))       {  pcs->perf = 1; return true; }
   if (!strcmp(psz1,"-crlf"))       {  strcpy(pcs->szeol, "\r\n"); return true; }
   if (!strcmp(psz1,"-lf"))         {  strcpy(pcs->szeol, "\n"); return true; }
   if (strBegins(psz1,"-toiso="))   {  pcs->toiso = 1; pcs->toisodef = psz1[strlen("-toiso=")]; return true; }
   if (!strcmp(psz1,"-toiso"))      {  pcs->toiso = 1; return true; }
   if (!strcmp(psz1,"-iso"))        {  pcs->toiso = 1; return true; }
   if (!strcmp(psz1,"-toutf"))      {  pcs->toutf = 1; return true; }
   if (!strcmp(psz1,"-toutfsafe"))  {  pcs->toutf = 2; return true; }
   // TODO: -utf name conflict with experimental utf16 decode
   #ifdef VFILEBASE
   if (strBegins(psz1,"-useragent="))
   {
      setHTTPUserAgent(psz1+strlen("-useragent="));
      return true;
   }
   #endif // VFILEBASE
   return false;
}

int processDirParms(char *pszCmd, int argc, char *argv[], int iDir, int nAutoComplete, int *iDirNext=0, bool *pAnyDone=0);

// uses szLineBuf. PreCmd is optional prefix, usually "-any" or NULL.
int processFlatDirParms(char *pszPreCmd, char *pszCmdLine, int nAutoComplete)
{
   if (cs.debug) printf("processFlatDirParms\n");

   // make copy of input to allow overwriting.
   strncpy(szLineBuf, pszCmdLine, sizeof(szLineBuf)-10);
   szLineBuf[sizeof(szLineBuf)-10] = '\0';
   pszCmdLine = szLineBuf;
 
   pGlblFileParms = new StringTable();

   if (pszPreCmd)
      pGlblFileParms->addEntry(pszPreCmd);

   int nAbsPathParms = 0;

   char *psz1 = pszCmdLine;
   while (*psz1) 
   {
      // find next token.
      skipSpaceRem(&psz1);
 
      // find end of token. support "parm with blanks".
      char *psz2 = psz1+1;
      if (*psz1 == '"')
         while (*psz2 && *psz2!='"')
            psz2++;
      while (*psz2 && *psz2!=' ' && *psz2!='\t' && *psz2!='\r' && *psz2!='\n')
         psz2++;

      // isolate token
      if (*psz2)
         *psz2++ = '\0';

      // line-end may lead to empty entry, therefore
      if (strlen(psz1)) // only if not line-end
      {
         // strip "", if any
         if (*psz1 == '"' && strlen(psz1) >= 2) {
            psz1++;
            int nLen = strlen(psz1);
            if (psz1[nLen-1] == '"')
                psz1[nLen-1] = '\0';
         }
         if (cs.debug) printf("token: <<%s>>\n", psz1);
         pGlblFileParms->addEntry(psz1);

         // count number of parms starting absolute
         if (isAbsolutePath(psz1))
            nAbsPathParms++;

         #ifdef VFILEBASE
         Coi ocoi(psz1, str(""));
         if (maskEndsWithArcExt(psz1) || ocoi.isZipSubEntry())
            setArcTravel(1, 1);
         #endif // VFILEBASE
      }

      // continue with next token, if any
      psz1 = psz2;
   }

   // pGlblFileParms now holds all parms
   int nParms = pGlblFileParms->numberOfEntries();
   mtklog(("pfdp nparms %d", nParms));
   apGlblFileParms = new char*[nParms];
   for (int i=0; i<nParms; i++) {
      char *pszParm = pGlblFileParms->getEntry(i, __LINE__);
      apGlblFileParms[i] = pszParm;
      mtklog(("   copied %s", pszParm ? pszParm : "<null>"));
   }
   nGlblFileParms = nParms;

   // if user drops a bunch of stuff onto the .exe
   if ((nGlblFileParms > 0) && (nGlblFileParms == nAbsPathParms)) {
      // then we don't process "dir .ext1 .ext2" but a mixed list
      bGlblHaveMixedDirFileList = 1;
   }

   return processDirParms(str(""), nParms, apGlblFileParms, 0, nAutoComplete);
}

enum ePDPStates 
{
   eST_Idle       = 0,
   eST_RootDirs   = 1,
   eST_FileMasks  = 2,
   eST_GrepPat    = 3,
   eST_IncBin     = 4,
   eST_DirFile    = 5,
   eST_SubDirs    = 6,

   eST_MAXStates
};

int containsWildCards(char *pszName)
{
   if (strchr(pszName, glblWildChar)) return 1;
   if (strchr(pszName, '*')) return 1;
   if (strchr(pszName, '?')) return 1;
   return 0;
}

int lastCharIsBackSlash(char *pszName)
{
   uint nlen = strlen(pszName);
   if (!nlen) return 0;
   return (pszName[nlen-1] == glblPathChar) ? 1 : 0;
}

void stripTrailingBackSlashes(char *psz)
{
   int nidx = (int)strlen(psz);
   while (nidx > 0 && psz[nidx-1] == glblPathChar) {
      psz[nidx-1] = '\0';
      nidx--;
   }
}

cchar *aGlblChainCmds[] = 
{
   // list of all chainable commands and their name variations
   // (first unambigious chars). every command is prefixed
   // by the default input data type (1:filenames 2:text)

   "2filt",         // receive+send files and TEXT
   "1ffilt",        // receive+send FILES and text
   "1filefilt",     // receive+send FILES and text
   "1list",         // receive+send FILES and text
   "0sel",          // use nothing, pass-thru

   "1md5gento",     // receive+pass files
   "1snapto",       // receive+pass files
   "1scantab",      // receive+send files
   "2detab",        // receive+send files and TEXT
   "1entab",        // receive+send FILES [and text]
   "1lf-to-crlf","1crlf-to-lf","1addcr","1remcr",
   "1find","1grep", // receive+send FILES and text
   "1ftext",        // receive+send FILES and text
   "1run",          // receive+send FILES and text
   "1inst",         // receive files
   "1deblank",      // receive+send files
   "0noop", 
   "1rep",          // receive+send files
   "1xhex",         // receive+send files
   "1hexfind",      // receive+send files
   "2view",         // receive files and TEXT
   "1fv",           // receive FILES and text (fview)
   "2vc",           // receive files and TEXT
   "1del",          // receive FILES and text
   "1rmtree",       // receive FILES and text
   "0sleep",        // pass-thru text
   "0label",        // pass-thru text
   "3tail",         // receive ANY
   "3head",         // receive ANY
   "2ttail",        // receive TEXT
   "2thead",        // receive TEXT
   "2toclip",       // receive text
   "2tolog",        // receive text
   "2tonetlog",     // receive text
   "0beep",         // pass-thru
   "0loop",         // restart chain
   "2hextobin",     // receive text
   "0echo",         // pass-thru
   "1hexdump",      // receive filenames
   "1dup",          // receive filenames
   "1copy",         // receive filenames
   "2script",       // receive TEXT
   "1fscript",      // receive TEXT
   "0end",          // pass-thru
   "1ftee",         // receive filenames
   "2tee",          // receive TEXT
   "2toterm",       // receive TEXT
   "2tofile",       // receive TEXT
   "2append",       // receive TEXT
   "2appendto",     // receive TEXT
   "0sfk",          // flushes chain
   "0then",         // flushes chain
   "1stat",         // receive filenames
   "0fromclip",     // receive nothing
   "0pause",        // receive nothing
   "2dec",          // receive TEXT
   "2hex",          // receive TEXT
   "2sort",         // receive TEXT
   "2count",        // receive TEXT
   "1ftp",          // receive filenames
   "1sft",          // receive filenames
   "0mkdir", "0cd", "0getcwd", "0cwd", // pass-thru
   "0ver",
   "1md5",          // receive files
   "2wget",         // receive files and text
   "2strlen",       // receive TEXT
   "2linelen",      // receive TEXT
   "2webreq",       // receive TEXT
   "1call",         // receive FILES and text
   "1if",           // receive FILES and text
   "2require",      // receive TEXT
   "2difflines",    // receive TEXT
   "1media",        // receive filenames
   "1filetime",     // receive filenames
   "1touch",        // receive filenames
   "2xml",          // receive TEXT
   "2storetext",    // receive TEXT
   "0gettext",      // receive nothing
   "2csvtotab",     // receive TEXT
   "2csvtab",       // receive TEXT
   "2tabtocsv",     // receive TEXT
   "2tabcsv",       // receive TEXT
   0
};

// when passing stuff from one command to another,
// what is most probably used: text or filenames?
cchar *aGlblDefChnModes[] =
{// from    to      use default mode (1==files, 2==text)
   "sel",  "detab", "1",
   "list", "detab", "1",
   "fromclip", "dv", "2",
   0, 0, 0
};

enum eChainCodes {
   ccftt    = -1,
   ccfile   = -2,
   ccttf    = -3,
   cctext   = -4,
   ccthen   = -5,
};

// rc:  0 if NO chain command
//     <0 if +text, +file etc.
//     >0 if one of aGlblChainCmds
int getChainCode(char *pszin, int &rtype, int &rbinary)
{
   if (   !strcmp(pszin, "+ftt")
       || !strcmp(pszin, "+filenamestotext")
      )
   {
      rtype = 1; // files
      return ccftt;
   }

   if (!strcmp(pszin, "+files"))
   {
      rtype = 1; // files
      return ccfile;
   }

   if (   !strcmp(pszin, "+ttf")
       || !strcmp(pszin, "+texttofilenames")
      )
   {
      rtype = 2; // text
      return ccttf;
   }

   if (!strcmp(pszin, "+text"))
   {
      rtype = 2; // text
      return cctext;
   }

   if (!strcmp(pszin, "+then"))
   {
      rtype = 0; // none
      return ccthen;
   }

   if (pszin[0] == '+')
   {
      pszin++;
      for (int i=0; aGlblChainCmds[i]; i++)
      {
         cchar *psz = aGlblChainCmds[i];
         int aflags = *psz - '0';
         int bbinary = (aflags & 4) ? 1 : 0;
             aflags &= 3;
         psz++;
         if (!strncmp(psz, pszin, strlen(psz)))
         {
            rtype = aflags;
            rbinary = bbinary;
            return i;
         }
      }
   }

   rtype = 0;
   return 0;   
}

// find next chain command clearly defining a type like FILES or TEXT
// rc: 1==files, 2==text, 0==none
// rforce: type is defined by +text etc. and MUST be used,
//         otherwise caller may use defaults
int findNextChainType(int iDir, char *argv[], int argc, char **pszNext, bool &rforce, int &rbinary)
{
   if (cs.nochain) return 0;

   for (; iDir < argc; iDir++) 
   {
      char *psz  = argv[iDir];
      int ntype = 0, bbinary = 0;
      int ncode = getChainCode(psz, ntype, bbinary);
      mtklog(("chain: gcc: %d = getChainCode(%s)",ncode,psz));
      if (ntype != 0) {
         if (psz[0] == '+') psz++;
         *pszNext = psz;
         // is it a forced type like +text?
         if (ncode < 0)
            rforce = 1;
         rbinary = bbinary;
         return ntype;
      }
   }
   return 0;
}

bool isChainStart(char *pszCmd, char *argv[], int argc, int iDir, int *iDirNext, bool bAllowVerbose=0)
{
   if (cs.nochain) return 0;

   // prefix mode switchers:
   int nplus1=0, nplus2=0;
   int ntype = 0, bbin1 = 0;
   int ncode = getChainCode(argv[iDir], ntype, bbin1);
   mtklog(("chain: ics: %d = getChainCode(%s)",ncode,argv[iDir]));

   switch (ncode) 
   {
      case ccftt:
         chain.colfiles   = 1;
         chain.files2text = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccfile:
         chain.colfiles = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccttf:
         chain.coldata    = 1;
         chain.text2files = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case cctext:
         chain.coldata = 1;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         iDir++;
         nplus1 = 1;
         break;

      case ccthen:
         chain.coldata    = 0;
         chain.colfiles   = 0;
         if (iDir >= argc-1)
            { perr("missing +command after %s\n", argv[iDir]); exit(9); }
         // use "then" as next chain command
         break;

      default:
         break;   // fall trough
   }
 
   // if +file or +text is specified, following command
   // is not required to start with "+".
 
   char *pszParm = argv[iDir];
   if (!strncmp(pszParm, "+", 1)) {
      nplus2 = 1;
      pszParm++;
   }

   if (ncode == ccthen) {
      // +then stops any further chain detections:
      if (iDirNext) *iDirNext = iDir;
      if (cs.verbose)
         printf("[chain from %s to %s. collect f=%d t=%d, idir %d %p]\n",pszCmd,pszParm,chain.colfiles,chain.coldata,iDir,iDirNext);
      return true;
   }
 
   if (nplus1 || nplus2)
   {
      if (nplus2)
         nplus1 = 0;
      for (int i=0; aGlblChainCmds[i]; i++) 
      {
         cchar *psz = aGlblChainCmds[i];
         int aflags = *psz - '0';
         int bbin2  = (aflags & 4) ? 1 : 0;
             aflags &= 3;
         psz++;
         if (!strncmp(psz, pszParm, strlen(psz)))
         {
            // standing on the first following chain command.
            if (!chain.coldata && !chain.colfiles)
            {
               // find out what the next typed chain element is,
               // e.g. +noop +sleep 1000 +text +filter -+foo
               // requires to find +text.
               bool bForce    = 0;
               char *pszNext  = 0;
               int  bbin3     = 0;
               int nNextType = findNextChainType(iDir, argv, argc, &pszNext, bForce, bbin3);
               mtklog(("chain: ics: found chain type %d at %s\n", nNextType, pszNext));
 
               if (cs.verbose && pszNext)
                  printf("[found chain type %d at %s]\n", nNextType, pszNext);

               // if next type is not a forced one like +text,
               if (!bForce && pszNext)
               {
                  // check if there is a default mapping
                  for (int k=0; aGlblDefChnModes[k]; k += 3) 
                  {
                     // look into defaults table
                     cchar *pszFrom = aGlblDefChnModes[k+0];
                     cchar *pszTo   = aGlblDefChnModes[k+1];
                     cchar *pszMode = aGlblDefChnModes[k+2];
                     if (   !strncmp(pszCmd , pszFrom, strlen(pszFrom))
                         && !strncmp(pszNext, pszTo  , strlen(pszTo  ))
                        )
                     {
                        // found a default:
                        nNextType = pszMode[0] - '0';
                        if (cs.verbose)
                           printf("[but using default type mapping %d]\n", nNextType);
                        break;
                     }
                  }
               }
 
               if (nNextType & 1) {
                  chain.colfiles = 1;
                  chain.colbinary = bbin3;
               }

               if (nNextType & 2) {
                  chain.coldata = 1;
                  chain.colbinary = bbin3;
               }
            }
 
            // if no mode yet set, use command default, if any
            if (!chain.coldata && !chain.colfiles) {
               if (aflags==1)
                  chain.colfiles = 1;
               else
               if (aflags==2)
                  chain.coldata  = 1;
               chain.colbinary = bbin2;
            }
 
            if (iDirNext) *iDirNext = iDir;
            if (cs.verbose) // && bAllowVerbose)
               printf("[chain from %s to %s. collect f=%d t=%d, idir %d %p]\n",pszCmd,pszParm,chain.colfiles,chain.coldata,iDir,iDirNext);
 
            return true;
         }
      }
   }
 
   if (nplus2) {
      // no chain start although "+" parm
      // find/grep have a very loose syntax, therefore
      if (!strcmp(pszCmd, "find") || !strcmp(pszCmd, "grep"))
         return false; // command handler will issue error
      // check also filter parms
      if (!strncmp(argv[iDir], "++", 2) || !strncmp(argv[iDir], "+ls", 3))
         return false; // accept non-chain start
      char *psz = argv[iDir];
      perr("unknown chain command: %s\n", psz);
      exit(9);
   }
  
   return false;
}

int processDirParms(char *pszCmd, int argc, char *argv[], int iDir, int nModeFlags, int *iDirNext, bool *pAnyDone)
{__
   mtklog(("processDirParms with argc=%d",argc));

   int  nAutoComplete = (nModeFlags & 3);
   bool bstrict = (nModeFlags & 4) ? 1 : 0;
   // strict: accept only -dir ... -file ... but not -copy, -pat etc.
   // except for high prio options: -yes

   bool bAnyDone = 0; // any user-supplied dir/file parm used
   bool bPreFileFlank = 0;
   int lRC = 0;

   bool aStateTouched[eST_MAXStates+10];
   memset(aStateTouched, 0, sizeof(aStateTouched));

   // fetch prefixed general options
   while (iDir < argc) {
      if (setGeneralOption(argv, argc, iDir))
         iDir++;
      else
         break;
   }

   if (iDir < argc)
   {
      if (   !strncmp(argv[iDir], "-from=", 6)
          || !strcmp(argv[iDir], "-fileset")
          || !strcmp(argv[iDir], "-view") // deprecated
         ) 
      {
         // re-create parameter array from input file
         char *pszOpt = argv[iDir];
         char *pszListFile = 0;
         if (!strncmp(argv[iDir], "-from=", 6))
            pszListFile = argv[iDir]+6;
         else {
            iDir++;
            if (iDir >= argc) return 9+perr("missing filename after %s\n", pszOpt);
            pszListFile = argv[iDir];
         }
         char *pszParmFile = loadFile(pszListFile);
         if (!pszParmFile) return 9;

         pGlblFileParms = new StringTable();
         char *psz1 = pszParmFile;
         while (*psz1) 
         {
            // find next token.
            skipSpaceRem(&psz1);

            // find end of token. support "parm with blanks".
            char *psz2 = psz1+1;
            if (*psz1 == '"')
               while (*psz2 && *psz2!='"')
                  psz2++;
            while (*psz2 && *psz2!=' ' && *psz2!='\t' && *psz2!='\r' && *psz2!='\n')
               psz2++;

            // isolate token
            if (*psz2)
               *psz2++ = '\0';

            // line-end may lead to empty entry, therefore
            if (strlen(psz1)) // only if not line-end
            {
               // strip "", if any
               if (*psz1 == '"' && strlen(psz1) >= 2) {
                  psz1++;
                  int nLen = strlen(psz1);
                  if (psz1[nLen-1] == '"')
                      psz1[nLen-1] = '\0';
               }
               if (cs.debug) printf("token: <<%s>>\n", psz1);
               pGlblFileParms->addEntry(psz1);
            }

            // continue with next token, if any
            psz1 = psz2;
         }
         delete [] pszParmFile;

         // pGlblFileParms now holds all parms
         int nParms = pGlblFileParms->numberOfEntries();
         apGlblFileParms = new char*[nParms];
         for (int i=0; i<nParms; i++)
            apGlblFileParms[i] = pGlblFileParms->getEntry(i, __LINE__);
         nGlblFileParms = nParms;

         // restart through recursion
         // printf("[%d parms from file]\n", nParms);
         return processDirParms(pszCmd, nParms, apGlblFileParms, 0, nAutoComplete);
      }
  
      // init fileset
      if (glblFileSet.beginLayer(false, __LINE__))
         return 9;

      // fetch further prefix options, if any
      char *pszFirstParm = argv[iDir];
      while (!strncmp(pszFirstParm, "-", 1)) {
         if (!setGeneralOption(argv, argc, iDir))
            break; // unknown option, fall through to further processing
         pszFirstParm = (iDir < argc-1) ? argv[++iDir] : (char*)"";
      }

      if (*pszFirstParm == '-') 
      {
         if (cs.debug) printf("process long format\n"); 

         // process int format, allowing multiple dirs:
         // sfk cmd -dir dir1 dir2 !dir3 !dir4 -copy -file .hpp .cpp

         // we now have:
         //   clRootDirs , two rows, DirName(empty) and Cmd(empty)
         // one layer:
         //   clDirMasks , one row , empty
         //   clFileMasks, one row , empty

         int lState = eST_Idle;
         for (;iDir < argc; iDir++)
         {
            // prefix -dir -file combi end marker
            if (!strcmp(argv[iDir], "-enddir")) {
               // continue locally with command parms
               if (iDir+1 >= argc)
                  return 9+perr("-enddir is not allowed as last option");
               if (iDirNext)
                  *iDirNext = iDir+1;
               // fall through to autocomplete
               break;
            }

            if (isChainStart(pszCmd, argv, argc, iDir, iDirNext, 1))
               break;

            // on every state switch, we're first landing here
            if (lState >= 0 && lState < (int)(sizeof(aStateTouched)/sizeof(bool)))
               aStateTouched[lState] = 1;

            char *psz1 = argv[iDir];
   
            if (cs.debug) printf("] \"%s\" [\n",psz1);

            if (!strcmp(psz1, "-debug")) {
               cs.debug = 1;
               continue;
            }
   
            if (!strcmp(psz1, "-dir"))
            {
               aStateTouched[eST_RootDirs] = 1;
               // creation of new dir/file mask layers:
               // 1. PostFileFlank: on change from non -dir to -dir
               // 2. PreFileFlank: on change from -file to -dir
               if (lState == eST_FileMasks && !bPreFileFlank) {
                  if (cs.debug) printf("] -dir: begin layer\n");
                  // not the very first -dir parm: add another layer
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               else
               if (lState == eST_SubDirs) {
                  if (cs.debug) printf("] -dir: begin layer.3\n");
                  // not the very first -dir parm: add another layer
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               else
               if (lState == eST_RootDirs && !bPreFileFlank) {
                  // -dir tmp1 tmp2 -dir tmp3 -file .txt
                  // add implicite "-file *" to first layer
                  lState = eST_FileMasks;
                  lRC |= glblFileSet.addFileMask(str("*"));
                  aStateTouched[lState] = 1;
                  if (cs.debug) printf("] -dir: begin layer.2\n");
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               else {
                  if (cs.debug) printf("] -dir: no begin layer\n");
               }
               // will collect further root dirs next
               lState = eST_RootDirs;
               aStateTouched[eST_FileMasks] = 0;
               continue;
            }
            
            if (!strcmp(psz1, "-sub") || !strcmp(psz1, "-subdir"))
            {
               aStateTouched[eST_SubDirs] = 1;
               if (lState != eST_RootDirs) {
                  perr("-sub[dir] is allowed only after -dir");
                  return 9;
               }
               lState = eST_SubDirs;
               continue;
            }

            if (!strcmp(psz1, "-any")) {
               // list of file- and directory names follows.
               bGlblAnyUsed = 1;
               lState = eST_DirFile;
               continue;
            }

            if (   isNotChar(psz1[0]) != 0
                && lState != eST_SubDirs
               )
            {
               if (lState == eST_RootDirs)
                  lRC |= glblFileSet.addDirMask(psz1);
               else
                  lRC |= glblFileSet.addFileMask(psz1);
               bAnyDone = 1;
               continue;
            }

            // collection of directory / file path masks:
            if (lState == eST_RootDirs)
            {
               if (psz1[0] == '+') {
                  if (!glblFileSet.rootDirs().numberOfEntries()) {
                     // +dirmask supplied without any previous root dir.
                     // imply that user wants dirs within the current dir "."
                     glblFileSet.addRootDir(str("."), __LINE__, false);
                     // imply that user does NOT want to process files from "."
                  }
                  bGlblNoRootDirFiles = 1;
                  lRC |= glblFileSet.addDirMask(psz1);
                  bGlblHavePlusDirMasks = 1;
                  bAnyDone = 1;
                  continue;
               }
               else
               if (containsWildCards(psz1)) {
                  if (!glblFileSet.rootDirs().numberOfEntries())
                     glblFileSet.addRootDir(str("."), __LINE__, false);
                  lRC |= glblFileSet.addDirMask(psz1);
                  bAnyDone = 1;
                  continue;
               }
            }

            if (!bstrict && !strcmp(psz1, "-copy")) {
               glblFileSet.addDirCommand(1);
               continue;
            }
            if (!bstrict && !strcmp(psz1, "-zip")) {
               glblFileSet.addDirCommand(2);
               continue;
            }

            if (!strcmp(psz1, "-file"))
            {
               aStateTouched[eST_FileMasks] = 1;
               if (!strncmp(pszCmd, "freezeto=", strlen("freezeto=")))
                  return 9+perr("no -file masks supported with freezeto command.\n");
               if (bGlblShortSyntax)
                  return 9+perr("you specified a dir name in short syntax. -file is not allowed then.\n");
               if (lState != eST_RootDirs)
                  bPreFileFlank = 1; // -file coming before -dir
               else
               if (bPreFileFlank) {
                  // not the very first -file parm: add another layer
                  if (glblFileSet.beginLayer(false, __LINE__))
                     return 9;
               }
               lState = eST_FileMasks;
               continue;
            }

            // used only with grep:
            if (!bstrict && !strcmp(psz1, "-pat")) {
               lState = eST_GrepPat;
               continue;
            }

            // force inclusion of binary files
            if (!bstrict && !strcmp(psz1, "-addbin") || !strcmp(psz1, "-include-binary-files"))
            {
               lState = eST_IncBin;
               continue;
            }

            // general option specified inbetween:
            if (bstrict) {
               // unmaskable high prio general options only:
               // FIX 1652: always handle -yes even with strict -dir ... parsing.
               if (!strcmp(psz1, "-yes"))    { cs.yes = 1; continue; }
               // FIX 1660: allow -justrc being written rightmost.
               if (!strcmp(psz1, "-justrc")) { cs.justrc = 1; continue; }
            } else {
               if (setGeneralOption(argv, argc, iDir))
                  continue;
            }

            // workaround for "*" under unix. see also short syntax.
            if (!strcmp(psz1, "-all")) {
               if (lState != eST_FileMasks)
                  return 9+perr("wrong context for -all. use within -file.\n");
               // else fall through to add.
            }
            else
            if (*psz1 == '-') {
               // CHG: 1.69: continue locally with command parms
               if (iDirNext) {
                  *iDirNext = iDir;
                  // fall through to autocomplete
                  break;
               }
               perr("unknown dir or file parameter: %s\n", psz1);
               pinf("try to specify %s before -dir ... -file\n", psz1);
               return 9;
            }

            // handle all non-command parameters
            switch (lState) 
            {
               case eST_RootDirs : {
                  // add another root dir, referencing the current layer.
                  if (glblFileSet.addRootDir(psz1, __LINE__, true))
                     return 9; 
                  bAnyDone = 1;
                  break;
               }
               case eST_SubDirs : {
                  // add another dir mask, referencing the current layer.
                  if (glblFileSet.addDirMask(psz1))
                     return 9;
                  bAnyDone = 1;
                  break;
               }
               case eST_FileMasks: lRC |= glblFileSet.addFileMask(psz1); break;
               case eST_GrepPat  : {
                  if (!strncmp(psz1, "\\\\", 2) || !strncmp(psz1, "\\+", 2) || !strncmp(psz1, "\\-", 2))
                     psz1++;
                  glblGrepPat.addString(psz1);
                  break;
               }
               case eST_IncBin   : glblIncBin.addString(psz1); break;
               case eST_DirFile  : {
                  // used only in case of explorer drag+drop.
                  Coi ocoi(psz1, 0);
                  if (ocoi.isTravelDir()) {
                     // coi name may have been redirected
                     if (glblFileSet.addRootDir(ocoi.name(), __LINE__, true))
                        return 9;
                  } else {
                     if (cs.debug) printf("add2flist.2: %s\n", psz1);
                     glblSFL.addEntry(ocoi); // is copied
                  }
                  bAnyDone = 1;
                  break;
               }
            }  // endswitch
         }  // endfor

         // FIX: 169: [2131217] missing write back
         if (iDirNext!=0 && iDir>=argc)
            *iDirNext = 0;
      }
      else 
      if (isChainStart(pszFirstParm, argv, argc, iDir, iDirNext))
      {
         // no actual dir parms at all, instead "+end" etc.:
         mtklog(("pdp: no parms, first is chain: %s", pszFirstParm));
         // fall through to autocomplete, if any
      }
      else 
      if (strlen(pszFirstParm))
      {
         // process short format, either with single dir and fpatterns
         //    . .cpp .hpp !.hppx
         // or with a list of specified file names
         //    test1.txt test2.txt
         // OR, if simple drag+drop from explorer, mixed list.
         mtklog(("pdp: short: first=%s havemdfl=%d", pszFirstParm,bGlblHaveMixedDirFileList));

         Coi *pcoi = 0;
         #ifdef VFILEBASE
         pcoi = glblVCache.get(pszFirstParm);
         #endif // VFILEBASE
         if (!pcoi) { 
            pcoi = new Coi(pszFirstParm, 0);
            pcoi->incref("pdp");
         }
         CoiAutoDelete odel(pcoi, 1); // with decref

         if ((!bGlblHaveMixedDirFileList) && pcoi->isTravelDir())
         {
            // fetch dir. coi name may have been redirected.
            glblFileSet.addRootDir(pcoi->name(), __LINE__, false);
            bAnyDone = 1;
            iDir++;

            // fetch masks
            for (; iDir < argc; iDir++)
            {
               if (isChainStart(pszCmd, argv, argc, iDir, iDirNext))
                  break;

               // also care about postfix/inbetween options
               char *psz1 = argv[iDir];
               if (setGeneralOption(argv, argc, iDir))
                  continue;
               if (!strcmp(psz1, "-file"))
                  return 9+perr("mixing of short and long syntax not allowed. you may try -dir %s -file ...\n", pszFirstParm); 
               if (!strcmp(psz1, "-dir"))
                  return 9+perr("mixing of short and long syntax not allowed. you may try -dir %s ...\n", pszFirstParm); 

               // workaround for "*" under unix. see also int syntax.
               if (!strcmp(psz1, "-all")) {
                  // fall through to add
               }
               else
               if (psz1[0] == '-') {
                  perr("unexpected option in short filename list: %s\n", psz1);
                  pinf("try specifying %s directly after %s\n", psz1, pszCmd);
                  return 9;
               }

               #ifdef VFILEBASE
               // convenience: is user trying to specify .zip file mask
               // although .zip's are directories?
               if (!cs.shallowzips && cs.xelike && cs.travelzips && endsWithArcExt(psz1))
               {
                  // then turn file mask into a path mask
                  static char szMaskBuf[100];
                  if (containsWildCards(psz1))
                     strcopy(szMaskBuf, psz1);
                  else
                  if (isNotChar(*psz1))
                     snprintf(szMaskBuf, sizeof(szMaskBuf)-10, "%c*%s", glblNotChar, psz1+1);
                  else
                     snprintf(szMaskBuf, sizeof(szMaskBuf)-10, "*%s", psz1);
                  if (cs.verbose > 1)
                     pinf("auto-converting %s to path mask %s\n", psz1, szMaskBuf);
                  if (lRC |= glblFileSet.addDirMask(szMaskBuf)) // is copied
                     return 9;
               }
               else
               #endif // VFILEBASE
               if (lRC |= glblFileSet.addFileMask(psz1))
                  return 9;
               bAnyDone = 1;
            }
         }
         else
         {
            // todo: split this in 2 paths. there can be no options
            //       in case of drag+drop on .exe.

            // fetch file and/or dir list. this path is called
            // - either from command prompt
            // - or from drag+drop on .exe (no preconfigured icon)
            for (; iDir < argc; iDir++)
            {
               if (isChainStart(pszCmd, argv, argc, iDir, iDirNext))
                  break;

               char *psz1 = argv[iDir];
               if (*psz1 == '-') {
                  if (!setGeneralOption(argv, argc, iDir))
                     return 9+perr("wrong context or unknown option: %s\n", psz1);
               } else {
                  Coi ocoi(psz1, 0);
                  if (bGlblHaveMixedDirFileList && ocoi.isAnyDir()) {
                     glblFileSet.addRootDir(psz1, __LINE__, false);
                     bAnyDone = 1;
                  } else {
                     if (cs.debug) printf("add2flist.3: %s\n", psz1);
                     glblSFL.addEntry(ocoi); // is copied
                     bAnyDone = 1;
                  }
               }
            }
            if (!bGlblHaveMixedDirFileList)
               nAutoComplete = 0;
         }
      }
   }
   else
   {
      // no parms at all supplied:
      if (!cs.blockAutoComplete && (nAutoComplete & 2))
         glblFileSet.addRootDir(str("."), __LINE__, false);
      // possibly redundant, see autocomplete below
   }

   bool bFail = (lRC != 0);

   // plausibility checks
   if (aStateTouched[eST_IncBin] && !glblIncBin.numberOfEntries())
      { bFail=1; perr("please supply a list of file extensions after -addbin or -include-binary-files.\n"); }
   if (aStateTouched[eST_GrepPat] && !glblGrepPat.numberOfEntries())
      { bFail=1; perr("please supply some pattern words after option -pat.\n"); }
   if (aStateTouched[eST_FileMasks] && !glblFileSet.fileMasks().numberOfEntries())
      { bFail=1; perr("please supply some file extensions after option -file.\n"); }
   if (aStateTouched[eST_RootDirs] && !glblFileSet.rootDirs().numberOfEntries())
      { bFail=1; perr("please supply some directory names after option -dir.\n"); }

   if (!cs.blockAutoComplete && (nAutoComplete != 0))
      glblFileSet.autoCompleteFileMasks(nAutoComplete);

   if (aStateTouched[1] || aStateTouched[2]) // if any -dir or -file
      if (glblFileSet.checkConsistency()) // then no empty layers allowed
         bFail=1;

   if (cs.debug) glblFileSet.dump();

   glblFileSet.setBaseLayer();

   // -sincedir requires root dir parameters
   if (pszGlblSinceDir && !glblFileSet.hasRoot(0)) {
      // Array &aroots = glblFileSet.rootDirs();
      // int nroots = aroots.numberOfEntries(0);
      // if (nroots <= 0) 
      return 9+perr("-sincedir/add/diff requires two directories.\n");
   }

   // tell caller if any real dir parms were used
   if (pAnyDone) *pAnyDone = bAnyDone;

   return bFail ? 9 : 0;
}

int setProcessSingleDir(char *pszDirName)
{__
   #ifdef VFILEBASE
   if (   !strBegins(pszDirName, "http://")
       && !strBegins(pszDirName, "ftp://")
      )
   #endif // VFILEBASE
   {
      Coi ocoi(pszDirName, 0);
      if (!ocoi.isTravelDir())
         return 9+perr("directory not found: %s\n", pszDirName);
   }

   // init fileset
   if (glblFileSet.beginLayer(true, __LINE__))
      return 9;

   glblFileSet.addRootDir(pszDirName, __LINE__, false);
   glblFileSet.autoCompleteFileMasks(3);

   if (cs.debug) glblFileSet.dump();

   glblFileSet.setBaseLayer();

   return 0;
}

void trimCR(char *pszBuf) {
   int ilen = strlen(pszBuf);
   if (ilen > 0 && pszBuf[ilen-1] == '\r')
      pszBuf[ilen-1] = '\0';
}

void removeCRLF(char *pszBuf) {
   char *pszLF = strchr(pszBuf, '\n');
   if (pszLF) *pszLF = '\0';
   char *pszCR = strchr(pszBuf, '\r');
   if (pszCR) *pszCR = '\0';
}

void fixPathChars(char *pszBuf) {
   // if path contains foreign path chars, change to local
   char *psz = pszBuf;
   for (; *psz; psz++)
      if (*psz == glblWrongPChar)
          *psz = glblPathChar;
}

int myfseek(FILE *f, num nOffset, int nOrigin)
{
   if (nOrigin != SEEK_SET)
      return 9+perr("internal: myfseek: supports only SEEK_SET");

   #ifdef _WIN32
   if (sizeof(num) != sizeof(fpos_t)) return 9+perr("internal: myfseek: wrong fpos_t size, need 64 bits");
   return fsetpos(f, &nOffset);
   #else
   fpos64_t xpos;
   if (fgetpos64(f, &xpos)) // read xpos.__state
      return 9+perr("internal: myfseek: failed to read position");
    #if defined(MAC_OS_X) || defined(SOLARIS)
     xpos = (fpos_t)nOffset;
    #else
     if (sizeof(xpos.__pos) != sizeof(nOffset)) return 9+perr("internal: myfseek: wrong __pos size, need 64 bits");
     xpos.__pos = nOffset;
    #endif
   return fsetpos64(f, &xpos);
   #endif
}

uchar   aGlblGetBuf[MY_GETBUF_MAX+100];
int    nGlblGetSize  = 0;
int    nGlblGetIndex = 0;
int    nGlblGetEOD   = 0;
num     nGlblGetFPos  = 0;

void myfgets_init()
{
   nGlblGetSize  = 0;
   nGlblGetIndex = 0;
   nGlblGetEOD   = 0;
   nGlblGetFPos  = 0;
}

// replacement for fgets, which cannot cope with 0x00 (and 0x1A under windows)
int myfgets(char *pszOutBuf, int nOutBufLen, FILE *fin, bool *rpIsBinary, char *pAttrBuf)
{
   if (!fin) return 9+perr("int. #66 missing file handle\n");
   if (nGlblGetSize  < 0 || nGlblGetSize  > MY_GETBUF_MAX) return 9+perr("int. #62 %d %d\n",(nGlblGetSize < 0),(nGlblGetSize > MY_GETBUF_MAX));
   if (nGlblGetIndex < 0 || nGlblGetIndex > MY_GETBUF_MAX) return 9+perr("int. #63 %d %d\n",(nGlblGetIndex < 0),(nGlblGetIndex > MY_GETBUF_MAX));
   if (nGlblGetIndex > nGlblGetSize) return 9+perr("int. #64\n");
   if (nGlblGetEOD > 1) return 9+perr("int. #65\n");

   int nBufFree = MY_GETBUF_MAX - nGlblGetSize;
   uchar *pRead  = &aGlblGetBuf[nGlblGetSize];

   // refill read buffer
   int nRead = 0;
   if (!nGlblGetEOD && (nGlblGetSize < MY_GETBUF_MAX/2)) {
      if ((nRead = fread(pRead, 1, nBufFree, fin)) <= 0)
         nGlblGetEOD = 1;
      else
         nGlblGetSize += nRead;
   }

   if (cs.debug) printf("] pre size %d index %d free %d nread %d\n", nGlblGetSize, nGlblGetIndex, nBufFree, nRead);

   // anything remaining?
   if (nGlblGetIndex >= nGlblGetSize) {
      nGlblGetEOD = 2;
      return 0;
   }

   // copy next line from front
   int nIndex     = nGlblGetIndex;
   int nOutIndex  = 0;
   int nOutSecLen = nOutBufLen-10;
   bool bBinary    = 0;
   for (; (nIndex < nGlblGetSize) && (nOutIndex < nOutSecLen);)
   {
      uchar c1 = aGlblGetBuf[nIndex++];
      nGlblGetFPos++; // count source position in file

      if (c1 == 0x00 || c1 == 0x1A) {
         if (!c1)
            bBinary = 1;
         c1 = (uchar)'.';
      }
      else
      if (c1 == (uchar)'\r')
         continue;

      pszOutBuf[nOutIndex++] = (char)c1;

      if (c1 == (uchar)'\n')
         break;
   }
   pszOutBuf[nOutIndex] = '\0';

   // promote binary flag
   if (bBinary && rpIsBinary)
      *rpIsBinary = 1;

   // move remaining cache data
   int nCacheRemain = nGlblGetSize-nIndex;
   if (nIndex + nCacheRemain < 0) return 9+perr("int. #60\n");
   if (nIndex + nCacheRemain > MY_GETBUF_MAX) return 9+perr("int. #61\n");
   if (nCacheRemain > 0)
      memmove(aGlblGetBuf, &aGlblGetBuf[nIndex], nCacheRemain);

   nGlblGetSize -= nIndex;
   nGlblGetIndex = 0;

   // if (cs.debug) printf("] pos size %d index %d out %d\n", nGlblGetSize, nGlblGetIndex, nOutIndex);

   return nOutIndex;
}

// just for sfk run: process text list with file- OR dirnames
int walkStdInListFlat(int nFunc, int &rlFiles, num &rlBytes)
{__
   if (nGlblError)
      return 9;

   nGlblFunc = nFunc;

   int lDirs = 0;
   FileList oLocDirFiles;

   while (fgets(szLineBuf, sizeof(szLineBuf)-10, stdin))
   {
      removeCRLF(szLineBuf);

      if (userInterrupt()) break;

      num nLocalMaxTime = 0, nTreeMaxTime  = 0;

      // skip remark and empty lines
      if (szLineBuf[0] == '#') continue;
      if (!strlen(szLineBuf))  continue;

      if (bGlblStdInFiles)
      {
         Coi ocoi(szLineBuf, 0);

         int lRC = execSingleFile(&ocoi, 0,
                        rlFiles, oLocDirFiles.clNames.numberOfEntries(),
                        lDirs, rlBytes,
                        nLocalMaxTime, nTreeMaxTime);

         if (!lRC) rlFiles++;

         if (cs.stopTree(lRC)) return lRC; else lRC=0;
      }

      if (bGlblStdInDirs)
      {
         rlFiles = 0; // reset tree file count

         Coi ocoi(szLineBuf, 0);

         int rlDirs = 0;
         num  nLocalBytes = 0;
         int lRC = execSingleDir(&ocoi, 0, rlFiles, oLocDirFiles, rlDirs, nLocalBytes,
                                  nLocalMaxTime, nTreeMaxTime);
         nLocalMaxTime = 0; // reset after use in execSingleDir
         rlBytes += nLocalBytes;

         if (cs.stopTree(lRC)) return lRC; else lRC=0;
      }
   }

   return 0;
}

// all commands except sfk run:
// take list with mixed file- and dirnames.
// in case of dirs, process each as root tree.
int walkStdInListDeep(int nFunc, int &rlFiles, num &rlBytes)
{__
   if (nGlblError)
      return 9;

   bool bsilent = 0;

   // select the default mask set.
   glblFileSet.setCurrentRoot(0);

   while (fgets(szLineBuf, sizeof(szLineBuf)-10, stdin))
   {
      removeCRLF(szLineBuf);

      // skip remark and empty lines
      if (szLineBuf[0] == '#') continue;
      if (!strlen(szLineBuf))  continue;

      // now holding a file- OR a dirname.
      int lDirs = 0;
      FileList oLocDirFiles;
      num  nLocalBytes = 0, nLocalMaxTime = 0, ntime2 = 0;

      // szLineBuf may be root itself.
      Coi *pcoi = new Coi(szLineBuf, 0);
      CoiAutoDelete odel(pcoi, 0); // 0: no decref

      if (cs.debug) printf("] siw: %s\n", pcoi->name());
      int lRC = walkFiles(pcoi, 0, rlFiles, oLocDirFiles, lDirs, nLocalBytes, nLocalMaxTime, ntime2);

      if (cs.stopTree(lRC)) return lRC; else lRC=0;

      if (pcoi->isTravelDir())
      {
         lDirs++; // count dir as processed

         rlFiles = 0; // reset tree file count

         // if this succeeded, treat the tree as another dir.
         if (cs.debug) printf("] sid: %s\n", pcoi->name());
         lRC = execSingleDir(pcoi, 0, rlFiles, oLocDirFiles, lDirs, nLocalBytes, nLocalMaxTime, ntime2);
         if (cs.stopTree(lRC, &bsilent)) 
         {
            nLocalMaxTime = 0;
            if (bsilent)
               return 0;
            nGlblError = 1;
            return 9;
         }
         lRC = 0;
         nLocalMaxTime = 0;
      }

      rlBytes += nLocalBytes;

      if (bGlblEscape)
         break;
   }

   return 0;
}

// process files from sfl or chain file list.
// does NOT recurse into directories.
int walkFileListFlat(CoiTable &oList, int nFunc, int &rlFiles, num &rlBytes, int &rlDirs)
{__
   if (nGlblError)
      return 9;

   int lDirs = 0;
   FileList oLocDirFiles;
   int nLocFiles = 0;
   num  nLocBytes = 0;
   num  nLocalMaxTime = 0, nTreeMaxTime = 0;

   int lRC = 0;

   char szCurPath[300];
   memset(szCurPath, 0, sizeof(szCurPath));

   bGlblInSpecificProcessing = 1;

   int nEntries = oList.numberOfEntries();
   for (int i=0; i<nEntries; i++)
   {
      if (userInterrupt()) break;

      Coi *pcoi = oList.getEntry(i, __LINE__);
      if (!pcoi) return 9+perr("int. #50\n");
      char *pszFile = pcoi->name();

      #ifdef VFILEBASE
      // optim: if the cache contains an identical url,
      // take that coi instead, to avoid double reads.
      Coi *ptmp = glblVCache.get(pszFile);
      // caller (we) MUST RELEASE COI after use!
      if (ptmp) {
         mtklog(("wfl: coi replaced by cache entry: %s", pszFile));
         pcoi = ptmp;
      }
      else
      #endif // VFILEBASE
         pcoi->incref("wff");

      // NO RETURN WITHOUT RELEASE!

      // additional fields available only from chain file list:
      char *pszRoot  = pcoi->root(1);  // returns null if none
      char *pszRef   = pcoi->ref(1);   // returns null if none

      if (cs.debug) 
         printf("] wfl: %s   %s   %s   dir=%d\n", pszFile, pszRoot ? pszRoot : "[no root]", pszRef ? pszRef : "[no ref]", pcoi->isTravelDir());

      mtklog(("] wfl: %s   %s   %s   dir=%d", pszFile, pszRoot ? pszRoot : "[no root]", pszRef ? pszRef : "[no ref]", pcoi->isTravelDir()));

      if (cs.withdirs && pcoi->isTravelDir()) {
         // file list mixed with dir names: expect dirname to come last.
         rlFiles  += nLocFiles;
         rlBytes  += nLocBytes;
         // unsolved: exclude previous files that are not part of the dir.
         nLocFiles = -1; // workaround for now: don't list dirs
         nLocBytes = -1; // workaround for now: don't list dirs
         lRC = execSingleDir(pcoi, 0,
                     nLocFiles, oLocDirFiles,
                     lDirs, nLocBytes,
                     nLocalMaxTime, nTreeMaxTime);
         oLocDirFiles.reset();
         nLocFiles = 0;
         nLocBytes = 0;
         rlDirs++;
      } else {
         // process file entry
         lRC = execSingleFile(pcoi, 0,
                     nLocFiles, 1,
                     lDirs, nLocBytes,
                     nLocalMaxTime, nTreeMaxTime);
         if (!lRC) nLocFiles++;
      }

      // RELEASE COI after use:
      pcoi->decref();

      if (cs.stopTree(lRC)) return lRC; else lRC=0;
   }

   // flush yet uncounted values
   rlFiles += nLocFiles;
   rlBytes += nLocBytes;

   bGlblInSpecificProcessing = 0;

   return lRC;
}

void resetFileSet() { glblFileSet.reset(); }

void resetAllFileSets() 
{
   glblFileSet.reset();
   chain.usefiles = 0;
   bGlblStdInAny  = 0;
   glblSFL.resetEntries();
}

int walkAllTreesInt(int nFunc, int &rlFiles, int &rlDirs, num &rlBytes);

int walkAllTrees(int nFunc, int &rlFiles, int &rlDirs, num &rlBytes)
{
   int lRC = walkAllTreesInt(nFunc, rlFiles, rlDirs, rlBytes);

   if (nFunc == eFunc_JamFile && pGlblJamStatCallBack != 0) 
   {
      // final statistics update call
      pGlblJamStatCallBack(0, glblFileCount.value(), cs.lines, (uint)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
      // ignore rc, does not match walkTrees rc
   }
      
   return lRC;
}

int walkAllTreesInt(int nFunc, int &rlFiles, int &rlDirs, num &rlBytes)
{__ _p("sf.walkall")

   mtklog(("wat: walkAllTrees fn %d err %d",nFunc,nGlblError));

   if (nGlblError)
      return 9;

   nGlblFunc = nFunc;

   int lRC = 0;
   bool bsilent = 0;

   if (chain.usefiles) {
      mtklog(("wat: chain.usefiles is set, %d in queue", chain.numberOfInFiles()));
      if (chain.numberOfInFiles())
         return walkFileListFlat(*chain.infiles, nFunc, rlFiles, rlBytes, rlDirs);
      else
         return 9+perr("no filenames to process. command chaining stopped.\n");
   }

   if (bGlblStdInAny) {
      mtklog(("wat: processing stdinlist"));
      return walkStdInListDeep(nFunc, rlFiles, rlBytes);
   }

   if (glblSFL.numberOfEntries()) {
      mtklog(("wat: processing SFL entries, %d in queue", glblSFL.numberOfEntries()));
      lRC = walkFileListFlat(glblSFL, nFunc, rlFiles, rlBytes, rlDirs);
      if (cs.stopTree(lRC)) return lRC; else lRC=0;
   }

   for (int nDir=0; glblFileSet.hasRoot(nDir); nDir++)
   {
      mtklog(("wat: processing root dir %d", nDir));
      
      if (userInterrupt())
         break;

      // local tree statistics:
      int nLocalDirs  = 0;
      int nLocalFiles = 0;
      num  nLocalBytes = 0;

      FileList oDirFiles;

      num nLocalMaxTime = 0, nTreeMaxTime  = 0;

      // process one of the trees given at commandline.
      char *pszTree = glblFileSet.setCurrentRoot(nDir);
      if (cs.debug) printf("] wat: tree %s\n", pszTree);

      char *pszRoot = glblFileSet.root(1); // returns 0 if none

      // The topmost coi gets the top root set.
      // All sub-coi's will copy this root.
      Coi *pcoi = 0;

      #ifdef VFILEBASE
      if ((pcoi = glblVCache.get(pszTree))) {
         mtklog(("wat: ... reusing root from vcache"));
      }
      else
      #endif // VFILEBASE
      {
         pcoi = new Coi(pszTree, pszRoot);
         pcoi->incref("wat");
      }
      CoiAutoDelete odel(pcoi, 1); // with decref

      lRC = walkFiles(pcoi, 0, nLocalFiles, oDirFiles, nLocalDirs, nLocalBytes, nLocalMaxTime, nTreeMaxTime);

      if (cs.stopTree(lRC, &bsilent)) {
         if (bsilent)
            return 0;
         nGlblError = 1;
         return 9;
      }
      lRC = 0;

      if (cs.withrootdirs)
      {
         if (cs.debug) printf("] wat: edir %s\n", pszTree);
         lRC = execSingleDir(pcoi, 0, nLocalFiles, oDirFiles, nLocalDirs, nLocalBytes, nLocalMaxTime, nTreeMaxTime);
      }

      if (cs.flatdirstat) {
         cs.flatdircnt++; // count root dir
         cs.flatdircnt  += nLocalDirs;
         cs.flatfilecnt += nLocalFiles;
         cs.flatbytecnt += nLocalBytes;
      } else {
         rlDirs++; // count root dir
         rlDirs   += nLocalDirs; // add its subdirs
         rlFiles  += nLocalFiles;
         rlBytes  += nLocalBytes;
      }

      if (cs.stopTree(lRC, &bsilent)) {
         nLocalMaxTime = 0;
         if (bsilent)
            return 0;
         nGlblError = 1;
         return 9;
      }
      lRC = 0;

      nLocalMaxTime = 0;

      if (bGlblEscape)
         break;
   }

   return lRC;
}

int isDirByName(char *pszName)
{
   // used for not-yet-existing targets:
   // tell if it should be a dir by looking at the name
   int nlen = strlen(pszName);
   if (nlen <= 0) return 0;
   if (!strcmp(pszName, ".")) return 1;
   if (!strcmp(pszName, "..")) return 1;
   char clast = pszName[nlen-1];
   if (clast == glblPathChar) return 1;
   #ifdef _WIN32
   if (clast == ':') return 1;
   #endif
   // todo: aaa/. and aaa/.. detection
   return 0;
}

int isDir(char *pszName)
{
   if (bGlblSyntaxTest) {
      // if just simulating, check how the name looks
      if (!strcmp(pszName, ".")) return 1;
      return strstr(pszName, "dir") ? 1 : 0;
   }
   if (containsWildCards(pszName))
      return 0;

   #ifdef _WIN32

   DWORD nAttrib = GetFileAttributes(pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (nAttrib & FILE_ATTRIBUTE_DIRECTORY)
      return 1;

   #else

   struct stat64 buf;
   if (stat64(pszName, &buf))
      return 0;
   if (buf.st_mode & _S_IFDIR )
      return 1;

   #endif

   return 0;
}

int fileExists(char *pszName, bool bOrDir)
{
   #ifdef _WIN32

   DWORD nAttrib = GetFileAttributes(pszName);
   if (nAttrib == 0xFFFFFFFF) // "INVALID_FILE_ATTRIBUTES"
      return 0;
   if (!bOrDir && (nAttrib & FILE_ATTRIBUTE_DIRECTORY))
      return 0; // is a dir, not a file

   #else

   struct stat64 buf;
   if (stat64(pszName, &buf))
      return 0;
   if (!bOrDir && (buf.st_mode & _S_IFDIR))
      return 0; // is a dir, not a file

   #endif

   // we can get the attribs, and it's not a dir,
   // so expect that it is a file.
   // TODO: maybe further checks should be added.
   return 1;
}

int coiExists(char *pszName, bool bOrDir)
{
   Coi *pcoi = new Coi(pszName, 0);
   if (!pcoi) return 0;
   pcoi->incref("cex");

   int nrc = pcoi->existsFile(bOrDir);

   if (!pcoi->decref())
      delete pcoi;

   return nrc;   
}

int getFileStat( // RC == 0 if exists anything
   char  *pszName,
   int   &rbIsDirectory,
   int   &rbCanRead,
   int   &rbCanWrite,
   num   &rlFileTime,
   num   &rlFileSize,
   num   *ppcatimes,     // optional: creation and access time
   void  *prawstat,      // optional: create copy of stat structure
   int    nrawstatmax,   // size of above buffer
   uint   nmodeflags     // bit 0: use alternative stat, if available
 )
{
   bool bAltStat = (nmodeflags & 1) ? 1 : 0;

   if (prawstat) memset(prawstat, 0, nrawstatmax);

   #ifdef _WIN32

   #ifdef WINFULL
   // special case: top level of UNC paths
   // \\host\root          fails with stat()
   // \\host\root\subdir   can be used
   if (    bAltStat
       || !strncmp(pszName, "\\\\", 2)
       || !strncmp(pszName, "//", 2)
      )
   do
   {
      if (!bAltStat) 
      {
         // check UNC path format
         char  psep    = pszName[0];
         char *pszHost = pszName+2;
         char *pszRoot = strchr(pszHost, psep);
         if (!pszRoot) return -1; // wrong format
         pszRoot++;
         char *pszSub  = strchr(pszRoot, psep);
         if (pszSub) 
            break; // not top level, fall through
      }
      mtklog(("GetFileAttributesEx %s", pszName));
      WIN32_FILE_ATTRIBUTE_DATA oinf;
      if (!GetFileAttributesEx(pszName, GetFileExInfoStandard, &oinf))
         return -1;
      uint nattrib = oinf.dwFileAttributes;
      rbIsDirectory = (nattrib & FILE_ATTRIBUTE_DIRECTORY) ? 1 : 0;
      rbCanRead     = 1;
      rbCanWrite    = (nattrib & FILE_ATTRIBUTE_READONLY)  ? 0 : 1;
      // on old msvc, this may be 0xFFFF... for timestamps > 2038:
      rlFileSize    =  (((num)oinf.nFileSizeHigh) << 32)
                     | ((num)oinf.nFileSizeLow);
      rlFileTime    =  fileTimeToTimeT(&oinf.ftLastWriteTime);
      if (ppcatimes != 0) {
         ppcatimes[0] = fileTimeToTimeT(&oinf.ftCreationTime);
         ppcatimes[1] = fileTimeToTimeT(&oinf.ftLastAccessTime);
      }
      return 0;
   }
   while (0);
   #else
   uint nattrib = GetFileAttributesA(pszName);
   rbIsDirectory = (nattrib & FILE_ATTRIBUTE_DIRECTORY) ? 1 : 0;
   rbCanRead     = 1;
   rbCanWrite    = (nattrib & FILE_ATTRIBUTE_READONLY)  ? 0 : 1;
   #endif

   // using MSC specific 64-bit filesize and time stamp infos
   #ifdef SFK_W64
   struct __stat64 buf;
   if (_stat64(pszName, &buf))
      return -1;
   #else
   struct stat buf;
   if (stat(pszName, &buf))
      return -1;
   #endif

   rbIsDirectory = (buf.st_mode & _S_IFDIR ) ? 1 : 0;
   rbCanRead     = (buf.st_mode & _S_IREAD ) ? 1 : 0;
   rbCanWrite    = (buf.st_mode & _S_IWRITE) ? 1 : 0;
   // on old msvc, this may be 0xFFFF... for timestamps > 2038:
   rlFileTime    =  buf.st_mtime;
   rlFileSize    =  buf.st_size;
   if (ppcatimes != 0) {
      ppcatimes[0] = buf.st_ctime;
      ppcatimes[1] = buf.st_atime;
   }
   if (prawstat) {
      if (nrawstatmax < sizeof(buf))
         return 9+perr("internal #1090: statbuf too small\n");
      memcpy(prawstat, &buf, sizeof(buf));
   }
   return 0;

   #else

   // generic linux 64-bit stat
   struct stat64 buf;
   if (stat64(pszName, &buf))
      return -1;
   rbIsDirectory = (buf.st_mode & _S_IFDIR ) ? 1 : 0;
   rlFileTime    =  buf.st_mtime;
   rlFileSize    =  buf.st_size;
   rbCanRead     = (buf.st_mode & _S_IREAD ) ? 1 : 0;
   rbCanWrite    = (buf.st_mode & _S_IWRITE) ? 1 : 0;
   if (ppcatimes != 0) {
      ppcatimes[0] = buf.st_ctime;
      ppcatimes[1] = buf.st_atime;
   }
   if (prawstat) {
      if (nrawstatmax < (int)sizeof(buf))
         return 9+perr("internal #1090: statbuf too small\n");
      memcpy(prawstat, &buf, sizeof(buf));
   }
   return 0;

   #endif
}

num getFileSize(char *pszName) 
{
   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize))
      return -1;
   return nFileSize;
}

num getFileSizeSeek(char *pszName)
{
   FILE *fin = fopen(pszName, "rb");
   if (!fin) return -1;

   if (fseek(fin, 0, SEEK_END))
      { fclose(fin); return -1; }

   num npos = (num)ftell(fin);

   fclose(fin);

   return npos;
}

num getFileTime(char *pszName)
{
   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize))
      return 0;
   return nFileTime;
}

// get file age in seconds
num getFileAge(char *pszName)
{
   num nFileTime = getFileTime(pszName);
   // printf("filetime: %s\n",numtoa(nFileTime));
   num nNow = getSystemTime();
   // printf("now is  : %s\n",numtoa(nNow));
   num nAge = nNow - nFileTime;
   return nAge;
}

bool canWriteFile(char *pszName, bool bTryCreate)
{
   int bIsDir    = 0;
   int bCanRead  = 0;
   int bCanWrite = 0;
   num  nFileTime = 0;
   num  nFileSize = 0;
   if (!getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize)) {
      return bCanWrite ? 1 : 0;
   }
   if (bTryCreate) {
      // file does not exist yet: try creation
      FILE *fout = fopen(pszName, "wb");
      if (!fout) return 0;
      fclose(fout);
      remove(pszName);
      return 1;
   }
   return 1;
}

// uses szLineBuf.
int getFileSystemInfoRaw(
   char  *pszPath,          // e.g. "D:\\", "/home/user/"
   num   &nOutTotalBytes,   // total volume size
   num   &nOutFreeBytes,    // free bytes usable for normal users
   char  *pszOutFSName,     // file system name buffer
   int    nOutFSNMaxSize,   // size of this buffer
   char  *pszOutVolID,      // volume name and serial, if any
   int    nOutVolIDMaxSize, // size of this buffer
   uint  &rOutVolID         // numeric volume id
   )
{
   nOutTotalBytes  = -1;
   nOutFreeBytes   = -1;
   pszOutFSName[0] = '\0';
   pszOutVolID[0]  = '\0';
   rOutVolID       =  0;

   #ifdef _WIN32

   #ifdef WINFULL
   char  szVolName[200];
   DWORD nVolSerNum = 0;
   DWORD nMaxFNLen  = 0;
   DWORD nFSFlags   = 0;

   if (!GetVolumeInformation(
      pszPath,
      szVolName, sizeof(szVolName)-10,
      &nVolSerNum, &nMaxFNLen, &nFSFlags,
      pszOutFSName, nOutFSNMaxSize
      ))
      return 9+perr("unable to get volume information for %s\n", pszPath);

   szVolName[sizeof(szVolName)-10] = '\0';
   sprintf(szLineBuf, "%08lX %s", nVolSerNum, szVolName);
   mystrcopy(pszOutVolID, szLineBuf, nOutVolIDMaxSize);

   rOutVolID = nVolSerNum;

   ULARGE_INTEGER nFreeCaller;
   ULARGE_INTEGER nTotalBytes;
   ULARGE_INTEGER nFreeTotal;
   if (!GetDiskFreeSpaceEx(
      pszPath,
      &nFreeCaller, &nTotalBytes, &nFreeTotal
      ))
      return 9+perr("unable to get free space of %s\n", pszPath);

   nOutTotalBytes = nTotalBytes.QuadPart;
   nOutFreeBytes  = nFreeCaller.QuadPart;
   
   // sprintf(szLineBuf, "VOL: %X for %s",nVolSerNum,pszPath);
   // MessageBox(0, szLineBuf, "info", MB_OK);
   #endif

   return 0;

   #else

   // #include <sys/statvfs.h>
   struct statvfs64 oinf;
   if (statvfs64(pszPath, &oinf))
      return 9+perr("unable to get free space of %s\n", pszPath);

   // unsigned int f_bsize   - preferred filesystem blocksize. 
   // unsigned int f_frsize  - fundamental filesystem blocksize (if supported) 
   // fsblkcnt_t f_blocks     - total number of blocks on the filesystem, in units of f_frsize. 
   // fsblkcnt_t f_bfree      - total number of free blocks. 
   // fsblkcnt_t f_bavail     - number of free blocks available to a nonsuperuser. 
   // fsfilcnt_t f_files      - total number of file nodes (inodes). 
   // fsfilcnt_t f_ffree      - total number of free file nodes. 
   // fsfilcnt_t f_favail     - number of inodes available to a nonsuperuser. 
   // unsigned int f_fsid    - filesystem ID (dev for now). 
   // char f_basetype[16]     - type of the target filesystem, as a null-terminated string. 
   // unsigned int f_flag    - bitmask of flags; the function can set these flags: 
   //    ST_RDONLY -- read-only filesystem. 
   //    ST_NOSUID -- the filesystem doesn't support setuid/setgid semantics. 
   // unsigned int f_namemax - maximum filename length.

   // not with linux:
   // mystrcopy(pszOutFSName, oinf.f_basetype, nOutFSNMaxSize);
   pszOutFSName[0] = '\0';

   num nTotalBytes = (num)oinf.f_blocks * (num)oinf.f_frsize;
   num nFreeBytes  = (num)oinf.f_bavail * (num)oinf.f_frsize;

   nOutTotalBytes = nTotalBytes;
   nOutFreeBytes  = nFreeBytes;

   return 0;

   #endif
}

int getFileSystemInfo(
   char  *pszPath,          // e.g. "D:\\", "/home/user/"
   num   &nOutTotalBytes,   // total volume size
   num   &nOutFreeBytes,    // free bytes usable for normal users
   char  *pszOutFSName,     // file system name buffer
   int    nOutFSNMaxSize,   // size of this buffer
   char  *pszOutVolID,      // volume name and serial, if any
   int    nOutVolIDMaxSize, // size of this buffer
   uint  &rOutVolID         // numeric volume id
   )
{
   char szPath[SFK_MAX_PATH+10];
   strcopy(szPath, (char*)pszPath);

   #ifdef _WIN32

   // need a root dir path like "C:"
   if (szPath[1] == ':') {
      // there is a C:, or D:, etc.
      szPath[2] = '\\';
      szPath[3] = '\0';
   } else {
      // a relative path: check for invalids
      if (!strncmp(szPath, "\\\\", 2))
         return -1;
      if (!strncmp(szPath, "//", 2))
         return -1;
      // find out our drive
      getcwd(szPath,SFK_MAX_PATH);
      if (szPath[1] != ':')
         return -1;
      // we're on C:, or D:, etc.
      szPath[2] = '\\';
      szPath[3] = '\0';
   }

   #else

   // reduce /media/small/dummydir/whatever.txt
   // to the first existing directory
   while (1)
   {
      struct stat oinf;
      if (!stat(szPath, &oinf))
         break; // exists

      char *psz = strrchr(szPath, '/');
      if (!psz)
         return -1; // failed to reduce

      *psz = '\0';
      // and retry on next higher level
   }

   #endif

   return getFileSystemInfoRaw(szPath,
      nOutTotalBytes,
      nOutFreeBytes, 
      pszOutFSName,  
      nOutFSNMaxSize,
      pszOutVolID,   
      nOutVolIDMaxSize,
      rOutVolID
      );
}

num getFreeSpace(char *pszPath)
{
   num nTotal=0, nFree=0;
   char szFSName[200];
   char szVolID[200];
   uint nVolID=0;
   
   if (getFileSystemInfo(pszPath, nTotal, nFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10, nVolID))
      return -1;

   return nFree;
}

char *timeAsString(num nTime, int iMode=0)
{
   static char szTimeStrBuf[200];

   // nTime may be 0xFFFF... in case of times > 2038.

   struct tm *pLocTime = 0;
   mytime_t nTime2 = (mytime_t)nTime;

   if (cs.useutc) {
      #ifdef SFK_W64
      pLocTime = _gmtime64(&nTime2);   // may be NULL
      #else
      pLocTime = gmtime(&nTime2);      // may be NULL
      #endif
   } else {
      #ifdef SFK_W64
      pLocTime = _localtime64(&nTime2);   // may be NULL
      #else
      pLocTime = localtime(&nTime2);      // may be NULL
      #endif
   }

   bool bFlat    = (iMode & 1) ? 1 : 0;
   bool bFlatSep = (iMode & 2) ? 1 : 0;
   bool bTabSep  = (iMode & 4) ? 1 : 0;

   // size_t strftime( char *strDest, size_t maxsize, const char *format, const struct tm *timeptr );
   // 20110101 120101
   // 2011-01-01 12:01:01
   // 01234567890
   
   struct tm oNullTime;
   mclear(oNullTime);
   
   if (!pLocTime)
      pLocTime = &oNullTime;
   
   szTimeStrBuf[0] = '\0';
   
   if (bFlat) {
      if (bFlatSep) {
         strftime(szTimeStrBuf, sizeof(szTimeStrBuf)-10, "%Y%m%d %H%M%S", pLocTime);
         szTimeStrBuf[8] = bTabSep ? '\t' : ' ';
      } else {
         strftime(szTimeStrBuf, sizeof(szTimeStrBuf)-10, "%Y%m%d%H%M%S", pLocTime);
      }            
   } else {
      strftime(szTimeStrBuf, sizeof(szTimeStrBuf)-10, "%Y-%m-%d %H:%M:%S", pLocTime);
      szTimeStrBuf[10] = bTabSep ? '\t' : ' ';
   }

   return szTimeStrBuf;
}

static const char *pszGlblMonths[] = {
   "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
};

bool tryGetRelTime(cchar *psz, num &nRetTime)
{
   bool brc = false;

   // get local time (zone)
   time_t now = time(NULL);
   struct tm *tm = 0;
   tm = localtime(&now);
   tm->tm_isdst = -1;

   int nlen = strlen(psz);

   if (!strcmp(psz, "now")) {
      brc = true;
   }
   else
   if (!strcmp(psz, "today")) {
      tm->tm_hour = 0;
      tm->tm_min  = 0;
      tm->tm_sec  = 0;
      brc = true;
   }
   else
   if (!strcmp(psz, "tomonth")) {
      tm->tm_hour = 0;
      tm->tm_min  = 0;
      tm->tm_sec  = 0;
      tm->tm_wday = 0;  // 0..6
      tm->tm_mday = 1;  // 1..31
      brc = true;
   }
   else
   if (!strcmp(psz, "toyear")) {
      tm->tm_hour = 0;
      tm->tm_min  = 0;
      tm->tm_sec  = 0;
      tm->tm_wday = 0;  // 0..6
      tm->tm_mday = 1;  // 1..31
      tm->tm_yday = 0;  // 0..365
      tm->tm_mon  = 0;  // 0..11
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 'd') {
      time_t pre = now - atol(psz) * 3600 * 24;
      tm = localtime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 'h') {
      time_t pre = now - atol(psz) * 3600;
      tm = localtime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 'm') {
      time_t pre = now - atol(psz) * 60;
      tm = localtime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }
   else
   if (nlen >= 2 && nlen <= 4 && psz[nlen-1] == 's') {
      time_t pre = now - atol(psz);
      tm = localtime(&pre);
      tm->tm_isdst = -1;
      brc = true;
   }

   time_t nTime = mktime(tm);
   if (!nTime) { perr("cannot calc time: %s\n", psz); return 0; }
   num nTime2 = (num)nTime;
   if (nTime2 <= 0) { perr("cannot calc time: %s\n", psz); return 0; }

   nRetTime = nTime2;
   return brc;
}

int timeFromString(char *pszin, num &nRetTime)
{
   char *psz = pszin;

   // get local time (zone)
   time_t now = time(NULL);
   struct tm *tm = 0;
   tm = localtime(&now);
   tm->tm_isdst = -1;

   // accept formats:
   // 12345678901234567890123456789012345678901234567890
   // 01 Jan 2008 01:01:25 +0200 GMT - 30 chars
   // 01 Jan 2008 01:01:25 +0100 - 26 chars
   // 01 Jan 2008 01:01:25 GMT   - 24 chars
   // 2006-11-21 12:49:36  - 19 chars
   // 2006-11-21           - 10 chars
   // 20061121124936       - 14 chars
   // 20061121             - 08 chars
   // Sep 28 2006          - 11 chars
   // Sep 28 14:37         - 12 chars
   uint nyear=0,nmon=0,nday=0,nhour=0,nmin=0,nsec=0;
   int nslen = strlen(psz);
   int lrc = 0;
   if (nslen == 24 || nslen == 26 || nslen == 30) {
      // TODO: so far, "GMT" or "+0100" postfixes are ignored.
      nday = atol(psz);
      psz += 3;
      char *pszMon = psz;
      for (nmon=0; nmon<12; nmon++)
         if (!strncmp(pszMon, pszGlblMonths[nmon], 3))
            break;
      if (nmon >= 12) return 9+perr("wrong date/time format.0: %s\n", psz);
      psz += 4;
      lrc = sscanf(psz, "%4u %2u:%2u:%2u", &nyear, &nhour, &nmin, &nsec);
      if (lrc != 4) return 9+perr("wrong date/time format.0: %s\n", psz);
      nmon++; // ONE based months
   }
   else
   if (nslen == 19) {
      lrc = sscanf(psz, "%4u-%2u-%2u %2u:%2u:%2u", &nyear, &nmon, &nday, &nhour, &nmin, &nsec);
      if (lrc != 6) return 9+perr("wrong date/time format.1: %s\n", psz);
   }
   else
   if (nslen == 14) {
      lrc = sscanf(psz, "%4u%2u%2u%2u%2u%2u", &nyear, &nmon, &nday, &nhour, &nmin, &nsec);
      if (lrc != 6) return 9+perr("wrong date/time format.2: %s\n", psz);
   }
   else
   if (nslen == 12) {
      char *pszMon = psz;
      for (nmon=0; nmon<12; nmon++)
         if (!strncmp(pszMon, pszGlblMonths[nmon], 3))
            break;
      if (nmon >= 12) return 9+perr("wrong date/time format.3: %s\n", psz);
      psz += 4;
      lrc = sscanf(psz, "%2u %2u:%2u", &nday, &nhour, &nmin);
      if (lrc == 3) {
         // copy year from current time:
         nyear = tm->tm_year;
         if (nyear < 1970)
            nyear = nyear - 100 + 2000;   // "108" -> "2008"
      } else {
         // retry on "29  2007" with TWO blanks:
         lrc = sscanf(psz, "%2u  %4u", &nday, &nyear);
         if (lrc != 2) return 9+perr("wrong date/time format.4: %s\n", psz);
      }
      nmon++; // ONE based months
   }
   else
   if (nslen == 11) {
      char *pszMon = psz;
      for (nmon=0; nmon<12; nmon++)
         if (!strncmp(pszMon, pszGlblMonths[nmon], 3))
            break;
      if (nmon >= 12) return 9+perr("wrong date/time format.5: %s\n", psz);
      psz += 4;
      lrc = sscanf(psz, "%2u %4u", &nday, &nyear);
      if (lrc != 2) return 9+perr("wrong date/time format.6: %s\n", psz);
      nmon++; // ONE based months
   }
   else
   if (nslen == 10) {
      lrc = sscanf(psz, "%4u-%2u-%2u", &nyear, &nmon, &nday);
      if (lrc != 3) return 9+perr("wrong date format.7: %s\n", psz);
   }
   else
   if (nslen == 8) {
      lrc = sscanf(psz, "%4u%2u%2u", &nyear, &nmon, &nday);
      if (lrc != 3) return 9+perr("wrong date format.8: %s\n", psz);
   }
   else
      return 9+perr("wrong date and/or time format.9: \"%s\"\n", psz);

   if (nyear < 1970) return 9+perr("unexpected year: %u\n", nyear);
   if (nmon < 1 || nmon > 12) return 9+perr("unexpected month: %u in \"%s\" %d\n", nmon, pszin, nslen);
   if (nday < 1 || nday > 31) return 9+perr("unexpected day: %u\n", nday);
   if (nhour > 23) return 9+perr("unexpected hour: %u\n", nhour);
   if (nmin  > 59) return 9+perr("unexpected minute: %u\n", nmin);
   if (nsec  > 59) return 9+perr("unexpected second: %u\n", nsec);

   // adjust values
   nyear -= 1900;
   nmon--; // mktime uses ZERO BASED months

   // printf("] %u-%u-%u %u:%u:%u\n",nyear,nmon,nday,nhour,nmin,nsec);

   tm->tm_year = nyear;
   tm->tm_mon  = nmon;
   tm->tm_mday = nday;
   tm->tm_hour = nhour;
   tm->tm_min  = nmin;
   tm->tm_sec  = nsec;

   bool bNearEpoch = 0;
   if (nyear == 70 && nmon == 0 && nday == 1)
        bNearEpoch = 1;

   time_t nTime = mktime(tm);
   num nTime2 = (num)nTime;
   if (     nTime2 < 0
       || (!bNearEpoch && (nTime2 == 0))
      )
      return 9+perr("invalid date/time: %s (%d %d %d)\n", psz, nyear, nmon, nday);

   // char *psz1 = timeAsString(nTime2);
   // printf("] %s\n", psz1);

   nRetTime = nTime2;
   return 0;
}

char getYNAchar()
{
   while (1) {
      int c1 = getchar();
      if (c1=='\r' || c1=='\n')
         continue;
      return c1;
   }
}

// sizefromstr
num numFromSizeStr(char *psz, cchar *pszLoudInfo, bool bRelaxed)
{
   int nLen = strlen(psz);
   if (nLen >= 1) {
      num lNum = myatonum(psz);
      if (!strncmp(psz, "0x", 2))
         return lNum; // hex: always byte values
      char cPostFix = psz[nLen-1];
      switch (cPostFix) {
         case 'b': return lNum;
         case 'k': return lNum * 1000;
         case 'K': return lNum * 1024;
         case 'm': return lNum * 1000000;
         case 'M': return lNum * 1048576;
         case 'g': return lNum * 1000000000;
         case 'G': return lNum * 1073741824;
         default :
            if (bRelaxed)
               return lNum;
            if (cPostFix >= '0' && cPostFix <= '9')
               return lNum; // no postfix at all: assume bytes
      }
   }
   if (pszLoudInfo) {
      perr("unexpected %s value: %s", pszLoudInfo, psz);
      pinf("supply a value like 1000 500k 100m 5M [k=kbyte,m=mbyte]\n");
   }
   return -1;
}

class FileStat {
public:
   FileStat       ( );
   int  readFrom (char *pszSrcFile, bool bWithFSInfo=0, bool bSilent=0);
   int  writeTo  (char *pszDstFile, int nTraceLine, bool bWriteJustTime=0);
   int  differs  (FileStat &oref, bool bSameIfOlderSrc, bool *pSrcIsOlder=0);
   int  copyFrom (FileStat &src);
   int  setFilename(char *psz);
   char *filename( );
   int  writeStat(int iTraceLine); // using stored filename
   int  dump     ( );
   int  dumpTimeDiff (FileStat &rdst);
   num   getSize  ( )   { return src.nSize; }
   uchar *marshal (int &nRetSize);
   int  setFrom  (uchar *pBuf, int nBufSize);
   char  *attrStr ( );
   const char *diffReason  (int nReason);

   num   getUnixTime ( ) { return src.nMTime; }
   num   getWinTime  ( );

public:
   int   dumpSub  (int nRow, uint nmask, char *pszOut, int iMaxOut);
   void  reset    ( );

   struct FileStatSrcInfo 
   {
      int  bIsDir;
      int  bIsReadable;
      int  bIsWriteable;
   
      // time of MODIFICATION or LAST WRITE is ALWAYS available.
      num   nMTime;
   
      // time of CREATION and LAST ACCESS is only available on
      // SOME file systems, e.g. NTFS. on FAT32, ATime is 0,
      // and CTime == MTime.
      num   nCTime;
      num   nATime;
   
      #ifdef _WIN32
      FILETIME ftMTime;
      FILETIME ftCTime;
      FILETIME ftATime;
      bool  nHaveWFT;   // 1 = have at least windows mod file time
      #endif            // 2 = also have windows C and A time
   
      num   nSize;
      int  bIsUTCTime;
      uint nAttribs;
   }
   src;

   char  szClFileName[SFK_MAX_PATH+10];
   char  szClSrcPath[SFK_MAX_PATH+10];
   char  szClSrcFSName[200];
   char  szClSrcVolID[200];
   char  szClTextBuf1[200];
   char  szClTextBuf2[200];
   char  szClAttrStr[50];
   char  szClDiffReason[100];
};

FileStat::FileStat() 
{
   reset();
}

int FileStat::setFilename(char *psz)
{
   strcopy(szClFileName, psz);
   return 0;
}

char *FileStat::filename( )
{
   return szClFileName;
}

int FileStat::copyFrom(FileStat &osrc)
{
   memcpy(this, &osrc, sizeof(*this));
   return 0;
}

num FileStat::getWinTime() {
   num nval = 0;
   #ifdef _WIN32
   if (sizeof(nval) == sizeof(src.ftMTime))
      memcpy(&nval, &src.ftMTime, sizeof(nval));
   #endif
   return nval;
}

char *FileStat::attrStr() {
   memset(szClAttrStr, 0, sizeof(szClAttrStr));
   //                   01234
   strcpy(szClAttrStr, "---- ");
   if (src.bIsReadable)  szClAttrStr[0] = 'a';
   if (src.bIsWriteable) szClAttrStr[1] = 'w';
   #ifdef _WIN32
   // if (src.nAttribs & FILE_ATTRIBUTE_READONLY)   szClAttrStr[0] = 'R';
   if (src.nAttribs & FILE_ATTRIBUTE_HIDDEN)     szClAttrStr[2] = 'h';
   if (src.nAttribs & FILE_ATTRIBUTE_SYSTEM)     szClAttrStr[3] = 's';
   // if (src.nAttribs & FILE_ATTRIBUTE_ARCHIVE)    szClAttrStr[4] = 'a';
   if (src.nAttribs) szClAttrStr[4] = '-';
   #endif
   return szClAttrStr;
}

uchar *FileStat::marshal(int &nRetSize) {
   nRetSize = sizeof(src);
   return (uchar*)&src;
}

int FileStat::setFrom(uchar *pBuf, int nBufSize) {
   if (nBufSize != sizeof(src))
      return 9+perr("internal 612112005\n");
   memcpy(&src, pBuf, sizeof(src));
   return 0;
}

int FileStat::dumpTimeDiff(FileStat &rdst)
{
   num nsec = src.nMTime - rdst.src.nMTime;
   printf("diff: mtime %s sec ",numtoa(nsec));
   num nhours = nsec / 3600;
   printf("(= %s hours)",numtoa(nhours));

   #ifdef _WIN32
   num nSrcWFT = 0;
   num nDstWFT = 0;
   if (sizeof(nSrcWFT) == sizeof(src.ftMTime)) {
      memcpy(&nSrcWFT, &src.ftMTime, sizeof(nSrcWFT));
      memcpy(&nDstWFT, &rdst.src.ftMTime, sizeof(nDstWFT));
      num nxnano = nSrcWFT - nDstWFT;
      num nmsec  = nxnano / 10;
      num nwsec  = nmsec / 1000000;
      num nwhours = nwsec / 3600;
      printf(", wft mtime %s usec*10 ", numtoa(nxnano));
      printf(" (= %s sec, ", numtoa(nwsec));
      printf("or %s hours)",numtoa(nwhours));
   }
   #endif

   printf("\n");

   nsec = src.nCTime - rdst.src.nCTime;
   printf("      ctime %s sec ",numtoa(nsec));
   nhours = nsec / 3600;
   printf("(= %s hours)",numtoa(nhours));

   #ifdef _WIN32
   if (sizeof(nSrcWFT) == sizeof(src.ftCTime)) {
      memcpy(&nSrcWFT, &src.ftCTime, sizeof(nSrcWFT));
      memcpy(&nDstWFT, &rdst.src.ftCTime, sizeof(nDstWFT));
      num nxnano = nSrcWFT - nDstWFT;
      num nmsec  = nxnano / 10;
      num nwsec  = nmsec / 1000000;
      num nwhours = nwsec / 3600;
      printf(", wft ctime %s usec*10 ", numtoa(nxnano));
      printf(" (= %s sec, ", numtoa(nwsec));
      printf("or %s hours)",numtoa(nwhours));
   }
   #endif

   printf("\n");

   return 0;
}

int FileStat::dump() 
{
   char szBuf1[100],szBuf2[100],szBuf3[100];
   char szHead[300];
   
   uint nutc = (cs.timemask & 1024);

   if (cs.timemask & 512)
   {
      dumpSub(0, 16+512+nutc, szBuf1, sizeof(szBuf1));
      dumpSub(1, 16+512+nutc, szBuf2, sizeof(szBuf2));
      #ifdef _WIN32
      dumpSub(2, 16+512+nutc, szBuf3, sizeof(szBuf3));
      #endif
      
      cchar *pprem = cs.tabform ? "":"mtime ";
      cchar *pprea = cs.tabform ? "\t":", atime ";
      cchar *pprec = cs.tabform ? "\t":", ctime ";
      cchar *ppos  = cs.tabform ? "\t":", ";

      if (!cs.tabform && !(cs.timemask & 8)) {
         pprem = "";
         pprea = "";
         pprec = "";
         ppos  = " ";
      }

      szHead[0] = '\0';

      if (cs.timemask & 1) { strcat(szHead,pprem); strcat(szHead,szBuf1); }
      if (cs.timemask & 2) { strcat(szHead,pprea); strcat(szHead,szBuf2); }
      #ifdef _WIN32
      if (cs.timemask & 4) { strcat(szHead,pprec); strcat(szHead,szBuf3); }
      #endif

      if (cs.timemask & 256)
         chain.print("%s%s%s\n", szHead, ppos, szClFileName);
      else
         chain.print("%s\n", szHead);
   }
   else
   {
      if (cs.timemask & 1) dumpSub(0, cs.timemask, 0, 0);
      if (cs.timemask & 2) dumpSub(1, cs.timemask, 0, 0);
      #ifdef _WIN32
      if (cs.timemask & 4) dumpSub(2, cs.timemask, 0, 0);
      #endif
   }

   return 0;
}

int FileStat::dumpSub(int nRow, uint nmask, char *pszOut, int iMaxOut)
{
   char szLocDate[100]; szLocDate[0] = '\0';
   char szLocTime[100]; szLocTime[0] = '\0';
   char szUTCTime[100]; szUTCTime[0] = '\0';
   char szUXTime [100]; szUXTime[0]  = '\0';
   char szWFTTime[100]; szWFTTime[0] = '\0';
   char szBuf[200]; szBuf[0] = '\0';

   num nTime = 0;
   cchar *pszPrefix = "";

   switch (nRow) 
   {
      case 0: nTime = src.nMTime; pszPrefix = "mtime"; break;
      case 1: nTime = src.nATime; pszPrefix = "atime"; break;
      case 2: nTime = src.nCTime; pszPrefix = "ctime"; break;
   }

   mytime_t tTime = (mytime_t)nTime;

   struct tm *pltime = 0;

   if (nmask & 1024)
      pltime = mygmtime(&tTime);
   else
      pltime = mylocaltime(&tTime);

   if (pltime) {
      if (cs.flatTime) {
         strftime(szLocDate, sizeof(szLocDate)-10, "%Y%m%d", pltime);
         strftime(szLocTime, sizeof(szLocTime)-10, "%H%M%S", pltime);
      } else {
         strftime(szLocDate, sizeof(szLocDate)-10, "%Y-%m-%d", pltime);
         strftime(szLocTime, sizeof(szLocTime)-10, "%H:%M:%S", pltime);
      }
   }

   struct tm *pgtime = mygmtime(&tTime);
   if (pgtime) {
      if (cs.flatTime)
         strftime(szUTCTime, sizeof(szUTCTime)-10, "%H%M%S", pgtime);
      else
         strftime(szUTCTime, sizeof(szUTCTime)-10, "%H:%M:%S", pgtime);
   }

   numtoa(nTime, 10, szUXTime);

   #ifdef _WIN32
   num nWinFileTime = 0;
   bool bCopyDone = 0;
   switch (nRow) {
      case 0:
         if (sizeof(nWinFileTime) == sizeof(src.ftMTime)) {
            memcpy(&nWinFileTime, &src.ftMTime, sizeof(nWinFileTime));
            bCopyDone = 1;
         }
         break;
      case 1:
         if (sizeof(nWinFileTime) == sizeof(src.ftATime)) {
            memcpy(&nWinFileTime, &src.ftATime, sizeof(nWinFileTime));
            bCopyDone = 1;
         }
         break;
      case 2:
         if (sizeof(nWinFileTime) == sizeof(src.ftCTime)) {
            memcpy(&nWinFileTime, &src.ftCTime, sizeof(nWinFileTime));
            bCopyDone = 1;
         }
         break;
   }
   if (bCopyDone)
      numtoa(nWinFileTime, 18, szWFTTime);
   #endif

   cchar *ppre = "";

   int nzones = 0;
   if (nmask &  16) nzones++;
   if (nmask &  32) nzones++;
   if (nmask &  64) nzones++;
   if (nmask & 128) nzones++;

   cchar *pwhite  = cs.tabform ? "\t":" ";
   cchar *pzon    = (nzones > 1) ? ", ":pwhite;
   cchar *pcon    = cs.tabform?"\t":pzon;
   cchar *ptwhite = (cs.flatTime >= 2) ? "":pwhite;

   if (nmask &   8) { mystrcatf(szBuf, sizeof(szBuf), "%s%s"    , pszPrefix, cs.tabform?"":": "); if (cs.tabform) ppre="\t"; }
   if (nmask &  16) { mystrcatf(szBuf, sizeof(szBuf), "%s%s%s%s", ppre, szLocDate, ptwhite, szLocTime); ppre=pcon; }
   if (nmask &  32) { mystrcatf(szBuf, sizeof(szBuf), "%s%s%s"  , ppre, szUTCTime, cs.tabform?"":" utc"  ); ppre=pcon; }
   if (nmask &  64) { mystrcatf(szBuf, sizeof(szBuf), "%s%s%s"  , ppre, szUXTime , cs.tabform?"":" sec"  ); ppre=pcon; }
   #ifdef _WIN32
   if (nmask & 128) { mystrcatf(szBuf, sizeof(szBuf), "%s%s%s"  , ppre, szWFTTime, cs.tabform?"":" wft"  ); ppre=pcon; }
   #endif
   if (nmask & 256) { mystrcatf(szBuf, sizeof(szBuf), "%s%s"    , ppre, szClFileName); ppre=pcon; }

   if (nmask & 512) {
      if (!pszOut)
         return 9;
      snprintf(pszOut, iMaxOut-10, "%s", szBuf);
   } else {
      chain.print("%s\n", szBuf);
   }

   return 0;
}

void FileStat::reset() 
{
   memset(this, 0, sizeof(*this));
}

int FileStat::writeStat(int iTraceLine)
{
   if (!szClFileName[0])
      return 9+perr("missing stat filename, cannot write filetime (%d)", iTraceLine);

   if (src.nMTime <= 0)
      return 10+perr("missing stat data, cannot write filetime (%d)", iTraceLine);

   return writeTo(szClFileName, iTraceLine);
}

const char *FileStat::diffReason(int nReason)
{
   if (szClDiffReason[0])
      return szClDiffReason;

   switch (nReason) {
      case  0: return "none";
      case  8: return "newer, wft";
      case  7: return "time, wft";
      case  9: return "newer, uft";
      case 10: return "time, uft";
      case  1: return "size";
      case  3: return "isreadable";
      case  4: return "iswriteable";
      case  5: return "attributes";
   }
   return "unknown";
}

bool is3600Range(num n) {
   if (n >= 3598 && n <= 3602)
      return true;
   return false;
}

/*
   RC 1 ...  5: difference in attributes
   RC 7 ... 10: difference in time
*/
int FileStat::differs(FileStat &oref, bool bSameIfOlderSrc, bool *pSrcIsOlder)
{
   int nTimeState = 0; // 0: time is no reason to process

   szClDiffReason[0] = '\0';

   #ifdef _WIN32
   if (src.nHaveWFT && oref.src.nHaveWFT) 
   {
      // compare windows filetime, to be safer on DST switches and time zones.
      // NOTE: files from FAT filesystems will also produce a pseudo wft
      // (calculated implicitely by the OS) that will still jump on DST.

      num nSrcMTime = 0;
      num nRefMTime = 0;
      memcpy(&nSrcMTime, &src.ftMTime, sizeof(nSrcMTime));
      memcpy(&nRefMTime, &oref.src.ftMTime, sizeof(nRefMTime));

      num nSrcSec   = fileTimeToTimeT(nSrcMTime);
      num nNowSec   = getSystemTime();
      num nAgeSec   = nNowSec - nSrcSec;
      int nAgeDays = (int)(nAgeSec / (24 * 3600));

      num ndif = (nSrcMTime - nRefMTime) / 10000000; // in seconds
      if (abs((int)ndif) < 3)
         nTimeState = 0; // time is no reason
      else
      if (bGlblIgnore3600 && is3600Range(abs((int)ndif)) && (nAgeDays > nGlblActiveFileAgeLimit))
      {
         nTimeState = 0; // dst jump difference
      }
      else
      if (bSameIfOlderSrc) {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %d [1]\n", ndif);
         if (ndif > 0) {
            sprintf(szClDiffReason, "newer, wft by %s sec", numtoa(ndif));
            nTimeState = 8; // src is newer, must process
         }
         if ((ndif < 0) && pSrcIsOlder) {
            if (is3600Range(abs((int)ndif)))
               *pSrcIsOlder = 2; // notice: probably older due to dst jump
            else
               *pSrcIsOlder = 1; // notice
         }
      } else {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %d [2]\n", ndif);
         if (nRefMTime != nSrcMTime) {
            sprintf(szClDiffReason, "time, wft by %s sec", numtoa(ndif));
            nTimeState = 7; // any time diff, must process
         }
         if ((ndif < 0) && pSrcIsOlder)
            *pSrcIsOlder = 1; // just a notice
      }
      // else fall through, time check passed
   }
   else
   #endif
   if (src.nMTime != oref.src.nMTime) 
   {
      // a time difference: ignore below a threshold
      //   NTFS : 100 nanoseconds resolution
      //   Linux:   1 second resolution
      //   FAT32:   2 seconds resolution
      // therefore all differences below 3 seconds are ignored.

      num nSrcSec   = src.nMTime;
      num nNowSec   = getSystemTime();
      num nAgeSec   = nNowSec - nSrcSec;
      int nAgeDays = (int)(nAgeSec / (24 * 3600));

      num ndif = src.nMTime - oref.src.nMTime;
      if (abs((int)ndif) < 3)
         nTimeState = 0; // time is no reason
      else
      if (bGlblIgnore3600 && is3600Range(abs((int)ndif)) && (nAgeDays > nGlblActiveFileAgeLimit))
      {
         nTimeState = 0; // dst jump difference
      }
      else
      if (bSameIfOlderSrc) {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %d [3]\n", (int)ndif);
         if (ndif > 0) {
            sprintf(szClDiffReason, "newer, uft by %s sec", numtoa(ndif));
            nTimeState = 9; // src is newer, must process
         }
         if ((ndif < 0) && pSrcIsOlder) {
            if (is3600Range(abs((int)ndif)))
               *pSrcIsOlder = 2; // notice: probably older due to dst jump
            else
               *pSrcIsOlder = 1; // notice
         }
      }
      else {
         if (cs.verbose > 1 && (ndif != 0))
            printf("wft diff %d [4]\n", (int)ndif);
         sprintf(szClDiffReason, "time, uft by %s sec", numtoa(ndif));
         nTimeState = 10; // any time diff, must process
         if ((ndif < 0) && pSrcIsOlder)
            *pSrcIsOlder = 1; // just a notice
      }
   }

   // with "sameifolder", processing is based only on timestamp.
   if (bSameIfOlderSrc) 
   {
      // if time is equal, don't process , no matter if size etc. differs!
      // if src  is older, don't process , no matter if size etc. differs!
      // if src  is newer, always process, no matter if size etc. is equal!
      return nTimeState;
   }

   // else process on size or attribute difference.
   if (src.nSize != oref.src.nSize) return 1;

   if (src.bIsReadable  != oref.src.bIsReadable ) return 3;
   if (src.bIsWriteable != oref.src.bIsWriteable) return 4;

   #ifdef _WIN32
   if (   (src.nAttribs      & WINFILE_ATTRIB_MASK)
       != (oref.src.nAttribs & WINFILE_ATTRIB_MASK)
      )
   {
      if (cs.verbose > 1)
         printf("[win_attributes differ, %x %x]\n",src.nAttribs,oref.src.nAttribs);
      return 5;
   } else {
      if (cs.verbose > 2)
         printf("[win_attributes match, %x %x]\n",src.nAttribs,oref.src.nAttribs);
   }
   #endif

   return nTimeState;
}

int FileStat::readFrom(char *pszSrcFile, bool bWithFSInfo, bool bSilent) 
{
   reset();

   sfkstat_t ostat;

   szClFileName[0] = '\0'; // safety

   num aExtTimes[2];
   mclear(aExtTimes);
   if (getFileStat(pszSrcFile, src.bIsDir, src.bIsReadable, src.bIsWriteable, src.nMTime, src.nSize, aExtTimes, &ostat, sizeof(ostat)))
      return 10;

   strcopy(szClFileName, pszSrcFile);

   src.nCTime = aExtTimes[0];
   src.nATime = aExtTimes[1];

   num   nTotalBytes = 0;
   num   nFreeBytes  = 0;

   if (bWithFSInfo)
   {
      // must extract path from pszSrcFile. if there is none, use ".".
      mystrcopy(szClSrcPath, pszSrcFile, sizeof(szClSrcPath)-10);
   
      // turn the/dir into the/dir/
      if (src.bIsDir && strlen(szClSrcPath)>0)
         if (szClSrcPath[strlen(szClSrcPath)-1] != glblPathChar)
            strcat(szClSrcPath,glblPathStr);
   
      #ifdef _WIN32
      // windows only: if path starts with c: ...
      if (strlen(szClSrcPath) >= 2 && szClSrcPath[1] == ':') {
         // then reduce c:\whatever to c:\, extend c: to c:/
         szClSrcPath[2] = glblPathChar;
         szClSrcPath[3] = '\0';
      }
      else
      if (!strncmp(szClSrcPath, "\\\\", 2)) {
         // network path
      }
      else {
         // relative path: reduce to "\\", should be same volume.
         // will probably NOT work with LINKS.
         strcpy(szClSrcPath, "\\");
      }
      #endif
   
      // try for x:\thefile, \thefile, the\path\file
      char *psz1 = strrchr(szClSrcPath, glblPathChar);
      if (psz1 && (psz1 > szClSrcPath)) {
         psz1++;
         *psz1 = '\0';
      } else {
         #ifdef _WIN32
         // try for x:thefile
         psz1 = strchr(szClSrcPath, ':');
         if (psz1 && (psz1 > szClSrcPath)) {
            // change x:thefile to x:/
            psz1++;
            *psz1++ = glblPathChar;
            *psz1   = '\0';
         }
         else
            strcpy(szClSrcPath, "\\");
         #else
         // TODO: use /, ./ or "." with linux?
         strcpy(szClSrcPath, ".");
         #endif
      }

      if (cs.debug)
         printf("filestat: \"%s\" => \"%s\"\n",pszSrcFile,szClSrcPath);

      uint nVolID = 0;
      if (getFileSystemInfo(szClSrcPath, nTotalBytes, nFreeBytes,
         szClSrcFSName, sizeof(szClSrcFSName)-10,
         szClSrcVolID , sizeof(szClSrcVolID)-10,
         nVolID
         ))
         return 11;
   
      #ifdef _WIN32
      if (cs.debug)
         printf("\"%s\" => %s, %s\n",szClSrcPath, szClSrcFSName, szClSrcVolID);
      #endif
   
      src.bIsUTCTime = 0;
      if (!strcmp(szClSrcFSName, "NTFS"))
         src.bIsUTCTime = 1;
   }

   #ifdef _WIN32

   #ifdef WINFULL
   WIN32_FILE_ATTRIBUTE_DATA oinf;
   BOOL bok2 = GetFileAttributesEx(pszSrcFile, GetFileExInfoStandard, &oinf);
   if (!bok2) {
      src.nAttribs = 0;
      if (!bSilent)
         perr("cannot read attributes: %s (rc %u)\n", pszSrcFile, GetLastError());
      return 12;
   }
   src.nAttribs = oinf.dwFileAttributes;
   // => see WINFILE_ATTRIB_MASK
   // ftCreationTime; ftLastAccessTime; ftLastWriteTime
   memcpy(&src.ftMTime, &oinf.ftLastWriteTime , sizeof(src.ftMTime));
   memcpy(&src.ftCTime, &oinf.ftCreationTime  , sizeof(src.ftCTime));
   memcpy(&src.ftATime, &oinf.ftLastAccessTime, sizeof(src.ftATime));
   src.nHaveWFT = 2;
   #else
   src.nAttribs = GetFileAttributes(pszSrcFile);
   #endif

   #else

   // src.bIsReadable, src.bIsWriteable
   src.nAttribs = (uint)ostat.st_mode;

   #endif

   return 0;
}

num calcSumTime(num nRawTime, int nTimeDiff, char *pszInfo)
{
   // does RawTime point into a summertime section?
   time_t ntmod = (time_t)nRawTime;
   tm *ptmod = localtime(&ntmod);
   if (ptmod && ptmod->tm_isdst) {
      // YES: change by one hour
      nRawTime += (num)nTimeDiff; // seconds
      if (pszInfo)
         printf("%s time adapted, %02d.%02d., %d\n",pszInfo,ptmod->tm_mday,ptmod->tm_mon+1,nTimeDiff);
   }
   if (ptmod && !ptmod->tm_isdst) {
      if (pszInfo)
         printf("%s time not adapted, %02d.%02d., %d\n",pszInfo,ptmod->tm_mday,ptmod->tm_mon+1,nTimeDiff);
   }
   return nRawTime;
}

#ifdef _WIN32
int makeWinFileTime(num nsrctime, FILETIME &rdsttime, num nSrcNanoSec)
{
   time_t ftime = (time_t)nsrctime;
   struct tm *loctm;
   SYSTEMTIME st;
   FILETIME locft, modft;

   loctm = localtime(&ftime);
   if (loctm == NULL)
      return 9+perr("cannot convert time %s (%u)\n",numtoa(nsrctime),(uint)GetLastError());

   st.wYear         = (WORD)loctm->tm_year + 1900;
   st.wMonth        = (WORD)loctm->tm_mon + 1;
   st.wDayOfWeek    = (WORD)loctm->tm_wday;
   st.wDay          = (WORD)loctm->tm_mday;
   st.wHour         = (WORD)loctm->tm_hour;
   st.wMinute       = (WORD)loctm->tm_min;
   st.wSecond       = (WORD)loctm->tm_sec;
   st.wMilliseconds = 0;

   if (!SystemTimeToFileTime(&st, &locft) ||
      !LocalFileTimeToFileTime(&locft, &modft))
      return 9+perr("cannot convert time %s (%u)\n",numtoa(nsrctime),(uint)GetLastError());

   if (nSrcNanoSec > 0)
   {
      modft.dwLowDateTime += (nSrcNanoSec / 100);
   }

   rdsttime = modft;

   return 0;
}
#endif

/*
   Factors influencing conversion:
      1. is src on UTC or non-UTC file system
      2. is src time dependent on DST, i.e. is it different
         depending on the fact that we currently have DST or not?
      3. is src's date stamp lying within a DST zone?
      4. all above for dst as well
*/

int FileStat::writeTo(char *pszDstFile, int nTraceLine, bool bWriteJustTime)
{
   if (!pszDstFile || !pszDstFile[0])
   {
      perr("missing stat filename, cannot write file time (%d)\n", nTraceLine);
      return 9;
   }

   // totally experimental and incomplete,
   // esp. on NTFS <-> FAT file transfers.

   #ifdef _WIN32
   HANDLE hDst = CreateFile(
      pszDstFile,
      FILE_WRITE_ATTRIBUTES,
      0,    // share
      0,    // security
      OPEN_EXISTING,
      src.bIsDir ? FILE_FLAG_BACKUP_SEMANTICS : FILE_ATTRIBUTE_NORMAL,
      0     // template file
      );
   if (hDst == INVALID_HANDLE_VALUE) {
      uint nerr = GetLastError();
      perr("cannot set attributes (rc=%u): %s\n",nerr,pszDstFile);
      if (nerr == ERROR_ACCESS_DENIED)
        pinf("make sure you have full access rights. maybe you have to be administrator.\n");
      return 9;
   }

   int nrc = 0;

   // src.nMTime is a value in SECONDS since 1970.

   FILETIME nDstMTime, nDstCTime, nDstATime;

   // native windows file times are copied 1:1
   if (src.nHaveWFT) 
   {
      memcpy(&nDstMTime, &src.ftMTime, sizeof(nDstMTime));
      if (src.nHaveWFT > 1)
         memcpy(&nDstCTime, &src.ftCTime, sizeof(nDstCTime));
      if (src.nHaveWFT > 1)
         memcpy(&nDstATime, &src.ftATime, sizeof(nDstATime));
   }
   else 
   {
      if (!nrc && src.nMTime)
         if (makeWinFileTime(src.nMTime, nDstMTime))
            nrc = 9;
   
      if (!nrc && src.nCTime)
         if (makeWinFileTime(src.nCTime, nDstCTime))
            nrc = 9;
   
      if (!nrc && src.nATime)
         if (makeWinFileTime(src.nATime, nDstATime))
            nrc = 9;
   }

   /*
      // TODO: this works only in SystemInWinterTime. On Windows,
      //       use converted GetFileTime() only.
      int nTimeDiff = 3600;
      num nDstMTime = calcSumTime(src.nMTime, nTimeDiff, 0);
      num nDstCTime = calcSumTime(src.nCTime, nTimeDiff, 0);
      num nDstATime = calcSumTime(src.nATime, nTimeDiff, 0);
   
      // convert times to "1601" format.
      FILETIME oftm, oftc, ofta;
      timetToFileTime(nDstMTime, &oftm);  // modification
      timetToFileTime(nDstCTime, &oftc);  // creation, optional
      timetToFileTime(nDstATime, &ofta);  // access  , optional
   */

   #ifdef WINFULL
   if (!nrc) {
      if (!SetFileTime(hDst, &nDstCTime, &nDstATime, &nDstMTime)) {
         perr("cannot set file time (rc=%u): %s %s\n", (uint)GetLastError(), pszDstFile, numtohex(src.nMTime));
         nrc = 9;
      }
   }
   #endif
   
   CloseHandle(hDst);

   if (!bWriteJustTime)
   {
      // CreateFile() was done ONLY to set filetime.
      // the attributes require another API call:
      if (src.nAttribs == 0) {
         perr("no attributes to set for %s\n",pszDstFile);
         nrc = 9;
      }
      else
      if (!SetFileAttributes(pszDstFile, src.nAttribs)) {
         perr("failed to set attributes (rc=%u): %s %s\n", (uint)GetLastError(), pszDstFile, numtohex(src.nMTime));
         nrc = 9;
      }
   }

   return nrc;

   #else

   // linux generic

   struct utimbuf otimes;
   mclear(otimes); // FIX: 167: missing actime init
   if (src.nATime)
      otimes.actime = src.nATime;
   otimes.modtime = src.nMTime;
   int iRC = utime(pszDstFile, &otimes);
   if (iRC) return 9+perr("failed to set file times (rc=%d): %s\n",iRC,pszDstFile);

   if (!bWriteJustTime)
   {
      mode_t nmode = (mode_t)src.nAttribs;
      if (nmode == 0) return 9+perr("no attributes to set for %s\n",pszDstFile);
      iRC = chmod(pszDstFile, nmode);
      if (iRC) return 9+perr("failed to set file attributes (rc=%d): %s\n",iRC,pszDstFile);
   }

   return 0;

   #endif
}

int cloneAttributes(char *pszSrc, char *pszDst, int nTraceLine)
{
   FileStat ofs;
   if (ofs.readFrom(pszSrc)) return 9;
   if (ofs.writeTo(pszDst, nTraceLine)) return 9;
   return 0;
}

/*
int getFileMD5(Coi *pcoi, SFKMD5 &md5, bool bSilent, bool bInfoCycle)
{
   if (pcoi->open("rb")) {
      if (!bSilent) perr("cannot read: %s\n", pcoi->name());
      return 9;
   }
   size_t nRead = 0;
   while ((nRead = pcoi->read(abBuf,sizeof(abBuf)-10)) > 0) {
      md5.update(abBuf,nRead);
      nGlblBytes += nRead;
      if (bInfoCycle)
         info.cycle();
   }
   pcoi->close();
   return 0;
}
*/

int getFileMD5(char *pszFile, SFKMD5 &md5, bool bSilent, bool bInfoCycle)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      if (!bSilent) perr("cannot read: %s\n", pszFile);
      return 9; 
   }
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      nGlblBytes += nRead;
      if (bInfoCycle)
         info.cycle();
   }
   fclose(fin);
   return 0;
}

int getFileMD5(char *pszFile, uchar *abOut16)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;
   SFKMD5 md5;
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      nGlblBytes += nRead;
   }
   fclose(fin);
   uchar *pmd5 = md5.digest();
   for (uint k=0; k<16; k++)
      abOut16[k] = pmd5[k];
   return 0;
}

#ifdef _WIN32
// size of windows-specific read buffer must be
// a multiple of disk's sector size. the following
// should be sufficient for everything.
int   nGlblMD5NoCacheBufSize = 128000;
LPVOID pGlblMD5NoCacheBuf     = 0;
#endif

int getFileMD5NoCache(char *pszFile, uchar *abOut16, bool bSilent)
{
   #ifdef _WIN32
   int lRC = 0;

   int nBufSize = nGlblMD5NoCacheBufSize;

   // alloc read buffer on demand
   if (pGlblMD5NoCacheBuf == 0) {
      pGlblMD5NoCacheBuf = VirtualAlloc(0, nBufSize, MEM_COMMIT, PAGE_READWRITE);
      if (!pGlblMD5NoCacheBuf) return 11;
   }

   LPVOID pBuf = pGlblMD5NoCacheBuf;

   /*
   DWORD nBytesPerSector = 0;
   DWORD nDummy1, nDummy2, nDummy3;
   // try to get sector size
   if (GetDiskFreeSpace(szRootDir, &nDummy1, &nBytesPerSector, &nDummy2, &nDummy3)) {
      // adjust max. read size to multiples of sector size
      if (nBytesPerSector > 0) {
         int nBufSize2 = (int)(nBufSize / nBytesPerSector) * nBytesPerSector;
         printf("adjusted %d => %d by %d\n",nBufSize,nBufSize2,nBytesPerSector);
         nBufSize = nBufSize;
      }
   } else {
      printf("GetDiskFreeSpace failed\n");
   }
   */

   HANDLE hDst = CreateFile(
      pszFile,
      FILE_READ_DATA,
      0,    // share
      0,    // security
      OPEN_EXISTING,
      FILE_FLAG_NO_BUFFERING,
      0     // template file
      );

   if (hDst == INVALID_HANDLE_VALUE) 
      return 9;

   SFKMD5 md5;
   DWORD nRead = 0;
   while (true) {
      nRead = 0;
      if (!ReadFile(hDst, pBuf, nBufSize, &nRead, 0))
         {  lRC = 10; break;   }
      if (nRead <= 0)
         break;
      // printf("%d bytes,\n\"%.*s\"\n",nRead,(int)nRead,pBuf);
      md5.update((uchar*)pBuf,nRead);
      nGlblBytes += nRead;
      if (userInterrupt(bSilent))
         {  lRC = 8; break;   }
      info.cycle();
   }

   CloseHandle(hDst);

   if (lRC == 10 && GetLastError() == 87) {
      // ReadFile did not accept buffer size. try fallback:
      // pwarn("md5nocache: readfile failed, using fallback\n");
      return getFileMD5(pszFile, abOut16);
   }

   uchar *pdigest = md5.digest();
   memcpy(abOut16, pdigest, 16);

   return lRC;
   #else
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;
   SFKMD5 md5;
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      nGlblBytes += nRead;
      if (userInterrupt(bSilent)) {
         fclose(fin);
         return 8;
      }
      info.cycle();
   }
   fclose(fin);
   uchar *pmd5 = md5.digest();
   for (uint k=0; k<16; k++)
      abOut16[k] = pmd5[k];
   return 0;
   #endif
}

void ab8ToNum(uchar *pin, num &rn1) {
    num n1 =  (num)(*(pin+0)) & 0xFFUL;
    n1 = (n1 << 8) | ((num)(*(pin+1)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+2)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+3)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+4)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+5)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+6)) & 0xFFUL);
    n1 = (n1 << 8) | ((num)(*(pin+7)) & 0xFFUL);
    rn1 = n1;
}

uint ab4toulong(uchar *pin) {
    uint n1 = (uint)(*(pin+0)) & 0xFFUL;
    n1 = (n1 << 8) | ((uint)(*(pin+1)) & 0xFFUL);
    n1 = (n1 << 8) | ((uint)(*(pin+2)) & 0xFFUL);
    n1 = (n1 << 8) | ((uint)(*(pin+3)) & 0xFFUL);
    return n1;
}

void ab16ToNum(uchar *pin, num &rn1, num &rn2) {
    ab8ToNum(pin+0, rn1);
    ab8ToNum(pin+8, rn2);
}

void numToAb8(num n1, uchar *pout) {
   pout[7]  = (uchar)n1;
   n1 = (n1 >> 8); pout[6] = (uchar)n1;
   n1 = (n1 >> 8); pout[5] = (uchar)n1;
   n1 = (n1 >> 8); pout[4] = (uchar)n1;
   n1 = (n1 >> 8); pout[3] = (uchar)n1;
   n1 = (n1 >> 8); pout[2] = (uchar)n1;
   n1 = (n1 >> 8); pout[1] = (uchar)n1;
   n1 = (n1 >> 8); pout[0] = (uchar)n1;
}

void ulongtoab4(uint n1, uchar *pout) {
   pout[3]  = (uchar)n1;
   n1 = (n1 >> 8); pout[2] = (uchar)n1;
   n1 = (n1 >> 8); pout[1] = (uchar)n1;
   n1 = (n1 >> 8); pout[0] = (uchar)n1;
}

void numToAb16(num n1, num n2, uchar *pout) {
   numToAb8(n1, pout+0);
   numToAb8(n2, pout+8);
}

#ifndef USE_SFK_BASE

class FileMetaDB
{
public:
   FileMetaDB  ( );

   bool  canRead     ( ) { return nClMode == 1; }
   bool  canUpdate   ( ) { return nClMode == 2; }

   int  openUpdate  (char *pszFilename);
   int  openRead    (char *pszBaseName, bool bVerbose); // zz-sign w/o .dat
   int  updateFile  (char *pszName, uchar *pmd5cont = 0, bool bJustKeep=false);
   int  removeFile  (char *pszName, bool bPrefixLF = 0);
   int  updateDir   (char *pszName);
   int  save        (int &rnSignsWritten);
   void  reset       ( );
   int  checkFile   (char *pszName);
   int  numberOfFiles  ( ) { return aUnixTime.numberOfEntries(); }

   int  getFileFlags   (int nIndex) { return aFlags.getEntry(nIndex, __LINE__); }

   int  verifyFile  (char *pszFilename, char *pszShFile=0, bool bSilentAttribs=0);
   int  verifyFile  (int nIndex, bool bCleanup);
   // 0:ok 1:notfound 9:file_differs_inconsistently

   int  numberOfVerifies  ( ) { return nClVerified; }
   int  numberOfVerMissing( ) { return nClVerMissing; }
   int  numberOfVerFailed ( ) { return nClVerFailed; }
   bool  anyEvents         ( ) { return nClVerified || nClVerMissing || nClVerFailed; }
   char *filename          ( ) { return pszClDBFile; }
   int  setMetaDir        (char *psz);
   char  *metaDir          ( ) { return pszClMetaDir; }
   bool  isSignatureFile   (char *pszFile);

private:
   int  indexOf     (char *pszFile);
   int  writeRecord (FILE *fout, int nIndex, SFKMD5 *pmd5, bool bIsLastRec);
   int  writeEpilogue     (FILE *fout, SFKMD5 *pmd5);
   int  loadDB      (char *pszBasePath, bool bVerbose);
   int  loadRecord  (FILE *fin, SFKMD5 *pmd5, bool bSim); // uses szLineBuf
   int  loadHeader  (FILE *fin, SFKMD5 *pmd5);
   int  loadCheckEpilogue (FILE *fin, SFKMD5 *pmd5);

   static char *pszClFileDBHead;

   char     *pszClDBPath;
   char     *pszClDBFile;
   char     *pszClLineBuf;
   char     *pszClMetaDir;
   int     nClMode;
   int     nClVerified;
   int     nClVerMissing;
   int     nClVerFailed;
   NumTable  aUnixTime;
   NumTable  aWinTime;
   NumTable  aContSumLo;
   NumTable  aContSumHi;
   LongTable aFlags;
   StringTable aPath;

   uchar     abClRecBuf[1024];
};

char *FileMetaDB::pszClFileDBHead = (char*)"SFKSIG10";

FileMetaDB filedb;

FileMetaDB::FileMetaDB()
{
   pszClDBPath    = 0;
   pszClDBFile    = 0;
   pszClLineBuf   = 0;
   pszClMetaDir   = 0;
   nClMode        = 0;
   nClVerified    = 0;
   nClVerMissing  = 0;
   nClVerFailed   = 0;
}

int FileMetaDB::setMetaDir(char *psz)
{
   if (pszClMetaDir) delete [] pszClMetaDir;
   pszClMetaDir = strdup(psz);
   return 0;
}

bool FileMetaDB::isSignatureFile(char *pszBase)
{
   if (!pszClLineBuf)
      if (!(pszClLineBuf = new char[MAX_LINE_LEN+100]))
         { perr("outofmem.1\n"); return 0; }

   bool bChecked = 0;

   int i=0;
   for (i=1; i<=3 && !bChecked; i++)
   {
      SFKMD5 md5; // re-init per loop

      sprintf(pszClLineBuf, "%s-%02d.dat", pszBase, i);

      FILE *fin = fopen(pszClLineBuf, "rb");
      if (!fin) return 0;
   
      uchar abin[20];
      char *pszHead = pszClFileDBHead;
      int nread = fread(abin, 1, 8, fin);
      if (nread < 8) { fclose(fin); return 1; } // EOD
      abin[8] = '\0';
      if (!strcmp((char*)abin, pszHead))
         bChecked = 1;
   
      fclose(fin);
   }

   return bChecked;
}

int FileMetaDB::indexOf(char *pszInFile)
{
   int nEntries = aUnixTime.numberOfEntries();
   for (int i=0; i<nEntries; i++) 
   {
      char *pszRefFile = aPath.getEntry(i, __LINE__);
      if (!strcmp(pszInFile, pszRefFile))
      {
         return i;
      }
   }
   return -1;
}

int FileMetaDB::loadDB(char *pszBase, bool bVerbose)
{
   if (pszClDBPath) { delete [] pszClDBPath; pszClDBPath=0; }
   pszClDBPath = strdup(pszBase);

   if (pszClDBFile) { delete [] pszClDBFile; pszClDBFile=0; }
   pszClDBFile = new char[strlen(pszClDBPath)+100];

   bool bChecked = 0;
   int nSigRes  = 0;

   // pass 1: check several sign files until a functional one is found
   int i=0;
   for (i=1; i<=3 && !bChecked; i++)
   {
      SFKMD5 md5; // re-init per loop

      sprintf(pszClDBFile, "%s-%02d.dat", pszClDBPath, i);

      // if (i > 1)
      //   pwarn("retrying on signature db: %s\n", pszClDBFile);

      if (fileExists(pszClDBFile)) 
      {
         // printf("load %s\n", pszClDBFile);

         FILE *fin = fopen(pszClDBFile, "rb");
         if (!fin)
            nSigRes = 3;
         else   
         if (!loadHeader(fin, &md5))
         for (int nrec=1; ;nrec++)
         {
            int nrc = loadRecord(fin, &md5, 1); // uses szLineBuf
            // printf("   rec %d loaded, rc %d\n", nrec, nrc);
            if (nrc == 1)
               break; // EOD
            if (bChecked) {
               perr("unexpected record data at end of %s\n", pszClDBFile);
               break;
            }
            if (nrc == 2) {
               if (!(nSigRes = loadCheckEpilogue(fin, &md5)))
                  bChecked = 1;
            }
            if (nrc > 2) {
               perr("error while reading %s: wrong content format (%d)\n", pszClDBFile, nrc);
               break;
            }
         }

         fclose(fin);
      } else {
         nSigRes = 3;
      }

      if (!bChecked) {
         if (nSigRes == 3) {
            if (bVerbose)
               printf("signature db not found: %s\n", pszClDBFile);
         }
         else
         if (i < 3) {
            if (nSigRes == 2)
               pwarn("signature db modified: %s - retrying on copy\n", pszClDBFile);
            else
               pwarn("invalid signature db: %s - retrying on copy\n", pszClDBFile);
         } else {
            perr("all signature databases unreadable or modified.\n", pszClDBFile);
         }
      }
   }

   // pass 2: load the first functional file
   if (!bChecked) {
      return 9; // +perr("cannot find a valid signature database.");
   }
   else
   {
      // pszClDBFile is still the valid name
      FILE *fin = fopen(pszClDBFile, "rb");
      if (!fin) return 9+perr("cannot read: %s\n", pszClDBFile);

      SFKMD5 md5;

      if (!loadHeader(fin, &md5))
      while (1) {
         int nrc = loadRecord(fin, &md5, 0); // uses szLineBuf
         if (nrc == 1)
            break; // EOD
         if (nrc == 2) {
            if (loadCheckEpilogue(fin, &md5))
               { fclose(fin); return 9+perr("internal #11571940"); }
         }
         if (nrc > 2) {
            perr("error while reading %s: wrong content format\n", pszClDBFile);
            break;
         }
      }

      fclose(fin);
   }

   return 0;   
}

int FileMetaDB::openUpdate(char *pszBase)
{__
   loadDB(pszBase, 0);
   // ignore rc

   nClMode = 2;

   return 0;
}

int FileMetaDB::openRead(char *pszBase, bool bVerbose)
{__
   if (loadDB(pszBase, bVerbose))
      return 9;

   nClMode = 1;

   return 0;
}

int FileMetaDB::verifyFile(char *pszName, char *pszShadow, bool bSilentAttribs)
{
   char *relName(char *pszRoot, char *pszAbs);
   char *pszRelName = pszName;

   if (pszGlblCopySrc)
      pszRelName = relName(pszGlblCopySrc, pszName);

   int nind = indexOf(pszRelName);
   if (nind < 0) {
      nClVerMissing++;
      return 8;   // not found
   }

   // get archived metadata
   num nUnixTime2  = aUnixTime.getEntry(nind, __LINE__);
   // num nWinTime2   = aWinTime.getEntry(nind, __LINE__);
   num nContSumLo2 = aContSumLo.getEntry(nind, __LINE__);
   num nContSumHi2 = aContSumHi.getEntry(nind, __LINE__);

   // build current metadata
   FileStat ofs;
   ofs.readFrom(pszName, 0, bSilentAttribs);
   num nUnixTime = ofs.getUnixTime();
   // num nWinTime  = ofs.getWinTime();
   num ncontlo, nconthi;
   uchar abContSum[20];
   if (getFileMD5(pszName, abContSum)) {
      perr("no such file: %s - cannot read checksum\n", pszName);
      return 9;
   }
   ab16ToNum(abContSum, ncontlo, nconthi);

   // let's expect that time is the same, all that matters is
   // if the content was tampered during transport:
   if (ncontlo != nContSumLo2 || nconthi != nContSumHi2)
   {
      nClVerFailed++;

      if (pszShadow && fileExists(pszShadow))
      {
         // try fallback to shadow file
         if (getFileMD5(pszShadow, abContSum)) {
            perr("no such file: %s - cannot read shadow file\n", pszShadow);
            return 9;
         }
         ab16ToNum(abContSum, ncontlo, nconthi);
         if (ncontlo == nContSumLo2 && nconthi == nContSumHi2)
            return 5;   // fallback to shadow is possible
      }

      return 9;
   }

   nClVerified++;

   if (nUnixTime != nUnixTime2)  return 1; // informal

   return 0;
}

int FileMetaDB::verifyFile(int nind, bool bCleanup)
{
   uint currentKBPerSec();

   // if anything fails with this record, skip it on cleanup
   aFlags.updateEntry(0, nind); // no save by default

   // get archived metadata
   char *pszRelName = aPath.getEntry(nind, __LINE__);
   if (!pszRelName) return 9+perr("unexpected filedb entry at record %d\n", nind);

   num nUnixTime2  = aUnixTime.getEntry(nind, __LINE__);
   // num nWinTime2   = aWinTime.getEntry(nind, __LINE__);
   num nContSumLo2 = aContSumLo.getEntry(nind, __LINE__);
   num nContSumHi2 = aContSumHi.getEntry(nind, __LINE__);

   // create absolute filename
   if (!pszGlblCopySrc) return 9+perr("internal #0605071204");
   joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszGlblCopySrc, pszRelName);
   char *pszName = szRefNameBuf;

   joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszGlblCopySrc, pszRelName);
   char *pszShadow = szRefNameBuf2;

   // show detailed info
   char szAddInfo[200];
   int nVerOK     = filedb.numberOfVerifies();
   int nVerFailed = filedb.numberOfVerFailed();
   if (nVerFailed > 0)
      sprintf(szAddInfo, "%u files ok, %d failed, %u mb %u kbs", nVerOK, nVerFailed, (uint)(nGlblBytes/1000000UL), currentKBPerSec());
   else
      sprintf(szAddInfo, "%u files %u mb %u kbs", nVerOK, (uint)(nGlblBytes/1000000UL), currentKBPerSec());
   info.setProgress(numberOfFiles(), nind, "files");
   info.setStatus("verfy", pszName, szAddInfo, eKeepProg);

   // build current metadata
   FileStat ofs;
   if (ofs.readFrom(pszName)) {
      nClVerMissing++;
      return 9+perr("file not found: %s\n", pszName);
   }
   num nUnixTime = ofs.getUnixTime();
   num nWinTime  = ofs.getWinTime();
   num ncontlo, nconthi;
   uchar abContSum[20];
   if (getFileMD5(pszName, abContSum)) {
      perr("no such file: %s - cannot read checksum\n", pszName);
      nClVerMissing++;
      return 9;
   }
   ab16ToNum(abContSum, ncontlo, nconthi);

   // check if the content was tampered during transport:
   if (ncontlo != nContSumLo2 || nconthi != nContSumHi2)
   {
      // primary file content corrupted
      nClVerFailed++;

      if (bCleanup) {
         setTextColor(nGlblErrColor);
         oprintf("DEL: %s - was modified, please resync\n", pszName);
         if (remove(pszName)) {
            if (setWriteEnabled(pszName))
               perr("cannot delete: %s\n", pszName);
            else
            if (remove(pszName))
               perr("cannot delete: %s\n", pszName);
         }
         setTextColor(-1);
         return 9;
      }

      if (pszShadow && fileExists(pszShadow))
      {
         // try fallback to shadow file
         if (getFileMD5(pszShadow, abContSum)) {
            perr("content modified  : %s\n", pszName);
            perr("cannot read shadow: %s\n", pszShadow);
            return 9;
         }

         ab16ToNum(abContSum, ncontlo, nconthi);

         if (ncontlo == nContSumLo2 && nconthi == nContSumHi2)
         {
            cs.shadowFallbacks++;
            pwarn("content modified: %s\n", pszName);
            pwarn("shadow file ok  : %s\n", pszShadow);
            return 5;   // fallback to shadow is possible
         }

         perr("content modified: %s\n", pszName);
         perr("shadow modified : %s\n", pszShadow);

         return 9;
      }

      perr("content modified: %s\n", pszName);

      return 9;
   }

   // produce only notic if time mismatches:
   if (nUnixTime != nUnixTime2) 
   {
      num nTimeDiff = nUnixTime - nUnixTime2;
      if (nTimeDiff < -5 || nTimeDiff > 5) 
      {
         pinf("time difference (%s sec), content ok: %s\n", numtoa(nTimeDiff), pszName);
         // in case cleanup is done: update with current times
         aUnixTime.updateEntry(nUnixTime, nind);
         if (nWinTime != 0)
            aWinTime.updateEntry(nWinTime, nind);
      }
      // else ignore: up to 5 sec time diff happens between file systems
   }

   nClVerified++;

   // record confirmed, keep it in case of cleanup.
   aFlags.updateEntry(1, nind);

   return 0;
}

int FileMetaDB::updateFile(char *pszName, uchar *pmd5cont, bool bJustKeep)
{
   // printf("updateFile %s, %02X%02X%02X%02X\n", pszName, *(pmd5cont+0),*(pmd5cont+1),*(pmd5cont+2),*(pmd5cont+3));

   char *relName(char *pszRoot, char *pszAbs);

   // printf("updatefile: %s\n", pszName);

   FileStat ofs;
   ofs.readFrom(pszName);

   num nUnixTime = ofs.getUnixTime();
   num nWinTime  = ofs.getWinTime();

   // strip x:\the\foo\bar.txt to the\foo\bar.txt
   char *pszRelName = relName(pszGlblCopySrc, pszName);

   int nind = indexOf(pszRelName);
   if (nind >= 0)
   {
      // we have this filename in the db.
      if (bJustKeep) {
         // unconditionally keep the entry of a non-synced file
         // e.g. on copy: target is newer than source (no copy)
         // if (aUnixTime.getEntry(nind, __LINE__) == nUnixTime) {
         aFlags.updateEntry(1, nind); // store file entry again
         return 0;
         // }
      }

      // update metadata:
      aUnixTime.updateEntry(nUnixTime, nind);
      aWinTime.updateEntry(nWinTime, nind);

      // update content checksum
      num ncontlo, nconthi;
      uchar abContSum[20];
      // take supplied content md5, or build now
      if (pmd5cont != 0)
         memcpy(abContSum, pmd5cont, 16);
      else
         if (getFileMD5(pszName, abContSum)) return 9;
      ab16ToNum(abContSum, ncontlo, nconthi);
      aContSumLo.updateEntry(ncontlo, nind);
      aContSumHi.updateEntry(nconthi, nind);

      // mark this record as updated, for save:
      aFlags.updateEntry(2, nind);
   }
   else
   {
      // not yet in the db
      if (aUnixTime.addEntry(nUnixTime))  return 9;
      if (aWinTime.addEntry(nWinTime))    return 9;

      // add content checksum
      num ncontlo, nconthi;
      uchar abContSum[20];
      // take supplied content md5, or build now
      if (pmd5cont != 0)
         memcpy(abContSum, pmd5cont, 16);
      else
         if (getFileMD5(pszName, abContSum)) return 9;
      ab16ToNum(abContSum, ncontlo, nconthi);
      if (aContSumLo.addEntry(ncontlo))   return 9;
      if (aContSumHi.addEntry(nconthi))   return 9;

      if (aFlags.addEntry(2)) return 9;

      // add also path for easier verify syntax
      if (aPath.addEntry(pszRelName)) return 9;
   }

   return 0;
}

int FileMetaDB::removeFile(char *pszName, bool bPrefixLF)
{
   char *relName(char *pszRoot, char *pszAbs);

   // strip x:\the\foo\bar.txt to the\foo\bar.txt
   char *pszRelName = relName(pszGlblCopySrc, pszName);

   int nind = indexOf(pszRelName);
   if (nind >= 0)
   {
      // mark this record as deleted, for save:
      aFlags.updateEntry(0, nind);
   }
   else
   {
      if (bPrefixLF) printf("\n");
      pwarn("cannot remove filename from metadb: %s\n", pszName);
   }

   return 0;
}

int FileMetaDB::checkFile(char *pszName)
{
   FileStat ofs;
   if (ofs.readFrom(pszName)) {
      perr("cannot read file infos: %s\n", pszName);
      return 5;
   }

   cs.files++;

   num nUnixTime = ofs.getUnixTime();
   // num nWinTime  = ofs.getWinTime();

   int nind = indexOf(pszName);
   if (nind >= 0)
   {
      // we have this filename in the db
      num nUnixTime2  = aUnixTime.getEntry(nind, __LINE__);
      // num nWinTime2   = aUnixTime.getEntry(nind, __LINE__);
      num nContSumLo2 = aContSumLo.getEntry(nind, __LINE__);
      num nContSumHi2 = aContSumHi.getEntry(nind, __LINE__);

      if (nUnixTime2 != nUnixTime) {
         printf("time: %s\n", pszName);
         return 0;
      }

      num ncontlo, nconthi;
      uchar abContSum[20];
      if (getFileMD5(pszName, abContSum)) return 9;
      ab16ToNum(abContSum, ncontlo, nconthi);

      if (ncontlo != nContSumLo2 || nconthi != nContSumHi2) {
         printf("cont: %s\n", pszName);
         return 0;
      }
   }  

   return 0;
}

int FileMetaDB::updateDir(char *pszName)
{
    return 0;
}

int FileMetaDB::writeRecord(FILE *fout, int nIndex, SFKMD5 *pmd5, bool bIsLastRec)
{
   uchar about1[20];

   // since SFKSIG10, first field is uint nmetalen.
   uint nmetalen = 16+16+2;
   ulongtoab4(nmetalen, about1);
   if (myfwrite(about1, 4, fout, 0,0,pmd5) != 4) return 9;

   // - - - meta data block: - - -

   // file times
   numToAb16(aUnixTime.getEntry(nIndex, __LINE__),
             aWinTime.getEntry(nIndex, __LINE__) ,
             about1);
   if (myfwrite(about1, 16, fout, 0,0,pmd5) != 16) return 9;

   // content checksum
   numToAb16(aContSumLo.getEntry(nIndex, __LINE__),
             aContSumHi.getEntry(nIndex, __LINE__), 
             about1);
   if (myfwrite(about1, 16, fout, 0,0,pmd5) != 16) return 9;

   // update flags
   uchar abFlags[2];
   uint nflags = aFlags.getEntry(nIndex, __LINE__);
   if (bIsLastRec)
      nflags |= 4;
   abFlags[0] = (uchar)(nflags >> 8);
   abFlags[1] = (uchar)(nflags     );
   if (myfwrite(abFlags, 2, fout, 0,0,pmd5) != 2) return 9;

   // - - - end meta data block - - -

   uchar abPathLen[2];
   memset(abPathLen, 0, sizeof(abPathLen));
   if (aPath.isSet(nIndex)) {
      char *psz  = aPath.getEntry(nIndex, __LINE__);
      // printf("WRITE %d %s\n", nIndex, psz);
      uint nlen = strlen(psz);
      abPathLen[0] = (uchar)(nlen >> 8);
      abPathLen[1] = (uchar)(nlen     );
      if (myfwrite(abPathLen,    2, fout, 0,0,pmd5) !=    2) return 9;
      if (myfwrite((uchar*)psz    , nlen, fout, 0,0,pmd5) != nlen) return 9;
   } else {
      // printf("WRITE %d [noname]\n", nIndex);
      if (myfwrite(abPathLen,    2, fout, 0,0,pmd5) != 2) return 9;
   }

   // printf(" saved record, %d %d\n", nflags, bIsLastRec);

   return 0;
}

int FileMetaDB::loadHeader(FILE *fin, SFKMD5 *pmd5)
{
   uchar abin[20];
   char *pszHead = pszClFileDBHead;
   int nread = myfread(abin, 8, fin, 0,0,pmd5);
   if (nread < 8) { fclose(fin); return 1; } // EOD
   abin[8] = '\0';
   if (strcmp((char*)abin, pszHead))
      return 9+perr("wrong signature db version: \"%s\"\n", abin);

   return 0;
}

int FileMetaDB::loadCheckEpilogue(FILE *fin, SFKMD5 *pmd5)
{
   uchar abin[20];

   int nread = myfread(abin, 16, fin, 0,0,0);
   if (nread < 16) {
      return 1; // EOD
   }

   uchar *pdig = pmd5->digest();
   if (memcmp(abin, pdig, 16)) {
      return 2; // mismatch
   }

   return 0;
}

// uses szLineBuf
int FileMetaDB::loadRecord(FILE *fin, SFKMD5 *pmd5, bool bSim)
{
   memset(abClRecBuf, 0, sizeof(abClRecBuf));
   uchar *abin = abClRecBuf;

   int nread = myfread(abin, 4, fin, 0,0,pmd5);
   if (nread < 4) return 1; // EOD, read after epilogue
   uint nmetalen = ab4toulong(abin);

   if (nmetalen > sizeof(abClRecBuf)-10)
      return 9+perr("metadb: header block too large (%u), cannot load.\n",nmetalen);

   if (nmetalen < 16+16+2)
      return 9+perr("metadb: header block too small (%u), cannot load.\n",nmetalen);

   // - - - meta data block - - -

   nread = myfread(abin, nmetalen, fin, 0,0,pmd5);
   if (nread < (int)nmetalen) return 10; // unexpected

   num n1, n2;
   ab16ToNum(abin+0, n1, n2);
   if (!bSim) {
      if (aUnixTime.addEntry(n1)) return 9;
      if (aWinTime.addEntry(n2))  return 9;
   }

   ab16ToNum(abin+16, n1, n2);
   if (!bSim) {
      if (aContSumLo.addEntry(n1)) return 9;
      if (aContSumHi.addEntry(n2)) return 9;
   }

   // read flag value
   uchar abFlags[2];
   memcpy(abFlags, abin+32, 2);
   uint nflags = (((uint)abFlags[0]) << 8) | ((uint)abFlags[1]);
   if (!bSim) {
      // filter out flag "4" (last record marker):
      if (aFlags.addEntry(nflags & (255UL ^ 4))) return 9;
   }

   // - - - end of meta data block - - -

   // read filename
   uchar abPathLen[2];
   nread = myfread(abPathLen, 2, fin, 0,0,pmd5);
   if (nread < 2) return 12; // unexpected
   uint nlen = (((uint)abPathLen[0]) << 8) | ((uint)abPathLen[1]);
   if (nlen > 0) {
      if (nlen > MAX_LINE_LEN-1) return 13;
      nread = myfread((uchar*)szLineBuf, nlen, fin, 0,0,pmd5);
      if (nread < (int)nlen) return 14;
      szLineBuf[nlen] = '\0';
      if (!bSim) {
         aPath.addEntry(szLineBuf);
      }
      // printf("LOADED NAME %s\n", szLineBuf);
   } else {
      // printf("LOADED NO NAME\n");
   }

   if (nflags & 4) {
      // printf("metadb load: lastrec found\n");
      return 2; // last data record read, md5 follows
   }

   return 0;
}

int FileMetaDB::writeEpilogue(FILE *fout, SFKMD5 *pmd5)
{
   uchar *pdig = pmd5->digest();
   if (myfwrite(pdig, 16, fout, 0,0,0) != 16) return 9;
   return 0;
}

int FileMetaDB::save(int &rnSignsWritten)
{__
   if (!pszClDBPath) return 9+perr("internal #11571945");

   if (pszClDBFile) { delete [] pszClDBFile; pszClDBFile=0; }
   pszClDBFile = new char[strlen(pszClDBPath)+100];

   int nCopies = 3;
   int nCopied = 0;

   // write signature db 3 times
   for (int i=1; i<=nCopies; i++)
   {
      sprintf(pszClDBFile, "%s-%02d.dat", pszClDBPath, i);
   
      SFKMD5 md5;
   
      // printf("saveto %s\n", pszClDBFile);
      FILE *fout = fopen(pszClDBFile, "wb");
      if (!fout) {
         perr("cannot write file meta db: %s\n", pszClDBFile);
         continue; // but retry with next
      }
   
      char *pszHead = pszClFileDBHead;
      if (myfwrite((uchar*)pszHead, 8, fout, 0,0,&md5) != 8)
         {  fclose(fout); continue; }
   
      bool bFailed = 0;
      bool bDoneLastRec = 0;

      int nEntries = aUnixTime.numberOfEntries();

      // identify last valid record to be saved
      int ilastval = 0;
      for (int k=0; k<nEntries; k++) {
         if (aFlags.getEntry(k, __LINE__) >= 1)
            ilastval = k;
      }

      int nWritten = 0;
      for (int i=0; i<nEntries; i++) 
      {
         // write only added or updated records
         if (aFlags.getEntry(i, __LINE__) >= 1) {
            bool bIsLastRec = (i == ilastval);
            // printf("   write rec %d last=%d\n",i,bIsLastRec);
            if (writeRecord(fout, i, &md5, bIsLastRec)) {
               perr("error while writing file meta db: %s\n", pszClDBFile);
               bFailed = 1;
               break;
            } else {
               nWritten++;
               if (bIsLastRec)
                  bDoneLastRec = 1;
            }
         }
      }

      if (!bDoneLastRec)
         perr("internal: no lastrec saved %d %d\n",ilastval,nEntries);
   
      if (!bFailed)
         writeEpilogue(fout, &md5);
   
      fclose(fout);

      if (!bFailed) {
         rnSignsWritten = nWritten;
         nCopied++;
      }
   }

   if (nCopied <= 0)
      return 9+perr("failed to write any metadb copy.\n");

   if (nCopied < nCopies)
      return 5+perr("%d metadb copies written, %d failed.\n", nCopied, (nCopies-nCopied));

   return 0;
}

void FileMetaDB::reset( )
{
   if (pszClDBPath) {
      delete [] pszClDBPath;
      pszClDBPath = 0;
   }
   if (pszClDBFile) {
      delete [] pszClDBFile;
      pszClDBFile = 0;
   }
   if (pszClLineBuf) {
      delete [] pszClLineBuf;
      pszClLineBuf = 0;
   }
   if (pszClMetaDir) {
      delete [] pszClMetaDir;
      pszClMetaDir = 0;
   }
   aUnixTime.resetEntries();
   aWinTime.resetEntries();
   aContSumLo.resetEntries();
   aContSumHi.resetEntries();
   aFlags.resetEntries();
   aPath.resetEntries();
}

class FileVerifier
{
public:
   FileVerifier   ( );
   int  remember (char *pszDstName, num nsumhi, num nsumlo);
   int  verify   ( );
   void  reset    ( );
   int  matchedFiles( ) { return nClMatched; }
   int  failedFiles ( ) { return nClFailed; }
   int  totalFiles  ( ) { return aClDst.numberOfEntries(); }
private:
   NumTable    aClSumHi;
   NumTable    aClSumLo;
   StringTable aClDst;
   int  nClMatched;
   int  nClFailed;
};

FileVerifier glblVerifier;

FileVerifier::FileVerifier() 
{ 
   nClMatched = 0;
   nClFailed  = 0;
}

void FileVerifier::reset() 
{
   aClSumHi.resetEntries();
   aClSumLo.resetEntries();
   aClDst.resetEntries();
}

int FileVerifier::remember(char *pszDst, num nsumhi, num nsumlo)
{
   if (aClSumHi.addEntry(nsumhi)) return 9;
   if (aClSumLo.addEntry(nsumlo)) return 9;
   if (aClDst.addEntry(pszDst))   return 9;
   return 0;
}

int FileVerifier::verify()
{
   char szAddInfo[200];

   int lRC = 0;

   int nFiles = totalFiles();
   for (int i=0; i<nFiles; i++)
   {
      if (userInterrupt(1, 1)) // silent, wait for release
      {
         info.print("verify stopped by user.\n");
         bGlblEscape = 0;
         return 1;
      }

      // get source file sum
      num nsrchi = aClSumHi.getEntry(i, __LINE__);
      num nsrclo = aClSumLo.getEntry(i, __LINE__);

      // build destination sum
      char *pszDst = aClDst.getEntry(i, __LINE__);
      info.setProgress(nFiles, i, "files");
      sprintf(szAddInfo, "file %d/%d", i+1, nFiles);
      info.setStatus("verfy", pszDst, szAddInfo);
      uchar abMD5Dst[20];
      if (getFileMD5NoCache(pszDst, abMD5Dst, 1)) // silent
      {
         if (userInterrupt(1, 1)) {
            pinf("[nopre] verify skipped.\n");
            lRC = 1;
            break;
         }
         perr("unable to read for verify: %s   \n", pszDst);
         lRC = 5;
         nClFailed++;
         continue;
      }
      uchar *pmd5dst = abMD5Dst;
      num ndstlo=0, ndsthi=0;
      for (int i=0,b=64-8; i<8; i++) {
         ndsthi = ndsthi | (((num)pmd5dst[0+i]&0xFF) << b);
         ndstlo = ndstlo | (((num)pmd5dst[8+i]&0xFF) << b);
         b -= 8;
      }

      // compare both
      if (nsrchi!=ndsthi || nsrclo!=ndstlo) {
         perr("verify failed, file differs: %s   \n", pszDst);
         nClFailed++;
         lRC = 6;
      } else {
         // info.setStatus("vryfd", pszDst); // , 0, eNoCycle);
         // info.printLine(1<<2); // w/o progress
         nClMatched++;
      }
   }

   return lRC;
}

void printCopyCompleted(char *pszName, uint nflags)
{
   info.clear();
   if (cs.quiet >= 2)
      return;
   cchar *pszpre = "";
   if (nflags & 8) {
      printx("<warn>##<def>"); pszpre=" "; 
   }
   switch (nflags & 3) {
      case 1 : printx("<prefix>]<def>"); pszpre=" "; break;
      case 3 : printx("<warn>]<def>");   pszpre=" "; break;
   }
   if (nflags & 4) {
      printx("<prefix>><def>"); pszpre=" "; 
   }
   oprintf("%s%s", pszpre, pszName);
   if (nflags & 8)
      printx(" <warn>[sync'ing older file]<def>");
   printf("\n");
}

class CopyCache
{
public:
   CopyCache      ( );
   void setBuf    (uchar *pBuf, num nBufSize);
   int process   (char *pszSrcFile, char *pszDstFile, char *pszShDst, uint nflags);
   int flush     ( );
   void setEmpty  ( );
private:
   int putBlock  (uchar *pData, int nDataSize);
   uchar *pClBuf;
   num   nClBufSize;
   num   nClUsed;
   char  szTmpBuf[MAX_LINE_LEN+10];
};

CopyCache glblCopyCache;

CopyCache::CopyCache()
{
}

void CopyCache::setBuf(uchar *pBuf, num nBufSize)
{
   pClBuf      = pBuf;
   nClBufSize  = nBufSize;
   nClUsed     = 0;
}

int CopyCache::process(char *pszSrcFile, char *pszDstFile, char *pszShDst, uint nflags)
{
   if (!pszShDst) pszShDst = str("");

   // may another source file fit into the cache?
   FileStat ofsrc;
   if (ofsrc.readFrom(pszSrcFile))
      return 9+perr("unable to read: %s\n", pszSrcFile);
   num nSrcSize = ofsrc.getSize();
   num nRemain  = nClBufSize - nClUsed;
   if (nRemain < 0) return 9+perr("internal 612112001\n");

   // if not, write all cache contents
   if (nSrcSize + 1500 > nRemain) {
      int lRes = flush();
      if (lRes >= 9)
         return lRes;
      setEmpty(); // in case flush was interrupted
   }
 
   if (nSrcSize + 1500 > nClBufSize)
      return 1;   // file too large to fit into cache, copy directly
 
   // cache is ready to accept file
   num nUsedSave = nClUsed;

   // 1. filenames
   if (putBlock((uchar*)pszSrcFile, strlen(pszSrcFile)+1)) return 9+perr("internal 612112002\n");
   if (putBlock((uchar*)pszDstFile, strlen(pszDstFile)+1)) return 9+perr("internal 612112009\n");
   if (putBlock((uchar*)pszShDst  , strlen(pszShDst  )+1)) return 9+perr("internal 612112029\n");
 
   // 2. meta data: filestat and flags
   int nMetaSize = 0;
   uchar *pMeta = ofsrc.marshal(nMetaSize);
   if (putBlock(pMeta, nMetaSize)) return 9+perr("internal 612112006\n");

   uchar abflags[10];
   ulongtoab4(nflags, abflags);
   if (putBlock(abflags, 4)) return 9+perr("internal 612112006.2\n");

   // 3. if it's a directory,
   if (ofsrc.src.bIsDir)
   {
      // set zero-sized content, meta data is sufficient
      uchar *pCur = pClBuf+nClUsed;
      int nLongSize = 0;
      memcpy(pCur, &nLongSize, sizeof(int));
      pCur += sizeof(int);
      nClUsed += sizeof(int);
   }
   else
   {
      // else add the file content
      uchar *pCur = pClBuf+nClUsed;
      int nLongSize = (int)nSrcSize;
      memcpy(pCur, &nLongSize, sizeof(int));
      pCur += sizeof(int);
      nClUsed += sizeof(int);
  
      info.setStatProg("cache", pszSrcFile, nClBufSize, nUsedSave, "bytes");

      FILE *fin = fopen(pszSrcFile, "rb");
      if (!fin) {
         nClUsed = nUsedSave;
         return 5+perr("cannot open input file %s   \n", pszSrcFile);
         // non-fatal, proceed copy, but list error count at end.
      }
   
      size_t nRead = 0;
      if (cs.sim)
         nRead = nSrcSize;
      else
         nRead = myfread(pCur, (size_t)nSrcSize, fin, nClBufSize, nUsedSave);

      fclose(fin);
   
      if (nRead != nSrcSize) {
         perr("while reading %s: incomplete data\n", pszSrcFile);
         // fall back, remove metadata from cache
         nClUsed = nUsedSave;
      } else {
         SFKMD5 md5in;
         md5in.update(pCur, nSrcSize);
   
         nClUsed += nSrcSize;
         pCur += nSrcSize;
   
         // 4. md5
         uchar *pmd5in = md5in.digest();

         // remember source sum in case of late verify:
         if (cs.verifyLate) {
            num nsumlo=0, nsumhi=0;
            for (int i=0,b=64-8; i<8; i++) {
               nsumhi = nsumhi | (((num)pmd5in[0+i]&0xFF) << b);
               nsumlo = nsumlo | (((num)pmd5in[8+i]&0xFF) << b);
               b -= 8;
            }
            glblVerifier.remember(pszDstFile, nsumhi, nsumlo);
         }

         memcpy(pCur, pmd5in, 16);

         // printf("1] %02X%02X%02X%02X %s %p %s\n",pmd5in[0],pmd5in[1],pmd5in[2],pmd5in[3], numtoa(nSrcSize), pCur, pszSrcFile);

         pCur += 16;
         nClUsed += 16;

         // and also to filedb, if active
         if (filedb.canUpdate())
            if (filedb.updateFile(pszSrcFile, pmd5in))
               return 9;
      }
   }
 
   return 0;   
}

int CopyCache::putBlock(uchar *pData, int nDataSize) 
{
   uchar *pCur = pClBuf+nClUsed;
   num nRemain = nClBufSize-nClUsed;
   if (nDataSize > nRemain + 100) return 9;
   memcpy(pCur, &nDataSize, sizeof(int));
   memcpy(pCur+sizeof(int), pData, nDataSize);
   nClUsed += sizeof(int)+nDataSize;
   return 0;
}

void CopyCache::setEmpty()
{
   nClUsed = 0;
}

int CopyCache::flush() 
{
   uchar *pCur = pClBuf;
   uchar *pMax = pClBuf+nClUsed;
   while (pCur < pMax) 
   {
      bool bDoneFile = 0;

      // 1. filenames
      int nBlockSize = 0;
      if (pCur >= (pMax - sizeof(int))) return 9+perr("internal #113701\n");
      memcpy(&nBlockSize, pCur, sizeof(int));
      pCur += sizeof(int);
      char *pszSrc = (char*)pCur;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur >= pMax) return 9+perr("internal #113702\n");

      memcpy(&nBlockSize, pCur, sizeof(int));
      pCur += sizeof(int);
      char *pszDst = (char*)pCur;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur >= pMax) return 9+perr("internal #113703\n");

      memcpy(&nBlockSize, pCur, sizeof(int));
      pCur += sizeof(int);
      char *pszShDst = (char*)pCur;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur >= pMax) return 9+perr("internal #113733\n");

      char *pszTell = chain.usefiles ? pszDst : pszSrc;
      if (cs.listTargets) pszTell = pszDst;

      // 2. meta data
      // filestat
      memcpy(&nBlockSize, pCur, sizeof(int));
      pCur += sizeof(int);
      uchar *pMeta = pCur;
      int nMetaSize = nBlockSize;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur >= pMax) return 9+perr("internal #113704\n");

      // flags, also prefixed by blocksize (4)
      memcpy(&nBlockSize, pCur, sizeof(int));
      pCur += sizeof(int);
      if (nBlockSize != 4) return 9+perr("internal #113704.2\n");
      uchar abflags[10];
      memcpy(abflags, pCur, 4);
      pCur += 4;
      uint nflags = ab4toulong(abflags);
      // bit0: verified by checksum. 
      // bit1: is shadow fallback.
      // bit2: 
      // bit3: source is older than target (sync)

      // 3. file content
      memcpy(&nBlockSize, pCur, sizeof(int));
      pCur += sizeof(int);
      uchar *pContent = pCur;
      pCur += nBlockSize;
      if (nBlockSize < 0 || pCur > pMax) return 9+perr("internal #113705\n");

      FileStat ofsdst;
      if (ofsdst.setFrom(pMeta, nMetaSize))
         return 9;
 
      if (ofsdst.src.bIsDir)
      {
         // set target dir meta data
         if (cs.verbose > 2)
            info.print("[%s : about to copy time]\n", pszDst);
         if (!cs.sim)
            if (!ofsdst.writeTo(pszDst, __LINE__)) {
               cs.dirsCloned++;
               if (cs.verbose)
                  info.print("[%s : time copied]\n", pszDst);
            }
         // IGNORE rc. error messages are counted.
         // cs.dirs++;
      }
      else
      if (cs.sim)
      {
         // 4. skip md5
         pCur += 16;

         info.setStatus("", pszTell, "-----", eNoCycle);
         info.printLine(nGlblCopyStyle);
         cs.files++;
      }
      else
      {
         // 4. md5
         uchar *pmd5in = pCur;
         pCur += 16;

         for (int ntry=1; ntry<=3; ntry++)
         {
            // write target file
            info.setStatus("write", pszDst, "00");
   
            FILE *fout = myfopen(pszDst, "wb");
            if (!fout) {
               perr("cannot open output file %s (rc %d)\n", pszDst, (int)errno); 
               break; // PROCEED with next file. errors are counted.
            }
      
            num nSize = ofsdst.src.nSize;
   
            size_t nWrite = myfwrite(pContent, nSize, fout, nSize, 0);
   
            myfclose(fout);
   
            if (bGlblEscape) {
               remove(pszDst);
               return 9+perr("failed to fully write %s, user interrupt\n", pszDst);
            }
            else
            if (nWrite != nSize)
               return 9+esys("fwrite", "failed to fully write %s   \n", pszDst);
               // do NOT proceed, this seems fatal.
      
            // set target meta data
            if (!ofsdst.writeTo(pszDst, __LINE__))
               cs.filesCloned++;
            // IGNORE rc. errors are counted.
         
            if (!cs.sim && cs.verifyEarly)
            {
               // run target verify
               info.setStatus("verfy", pszDst, "00");
               uchar abmd5[20];

               int nrcsub = getFileMD5NoCache(pszDst, abmd5, 1);

               if (userInterrupt(1))
               {
                  info.setAction("stop", pszDst, 0, 4);
                  info.printLine();
                  break;
               }
               else
               if (nrcsub == 0)
               {
                  if (memcmp(pmd5in, abmd5, 16)) {
                     if (ntry < 3) {
                        pwarn("verify failed, file differs: %s - retrying write\n", pszDst);
                        // fall through, next retry
                        remove(pszDst);
                     } else {
                        perr("verify failed, file differs: %s - giving up\n", pszDst);
                        remove(pszDst);
                     }
                  } else {
                     // verify succeeded
                     bDoneFile = 1;
                     cs.files++;
                     break;
                  }
               }
            }
            else
            {
               // no verify selected
               bDoneFile = 1;
               cs.files++;
               break;
            }
         }  // endfor tries

         // pszShDst must be set, but may be empty
         if (   filedb.canUpdate() && nGlblCopyShadows && strlen(pszShDst)
             && (!nGlblShadowSizeLimit || (ofsdst.src.nSize < nGlblShadowSizeLimit))
            )
         {
            // write shadow
            pszDst = pszShDst;

            info.setStatus("write", pszDst, "00");
            FILE *fout = myfopen(pszDst, "wb");
            if (!fout) {
               perr("cannot open output file %s (rc %d)\n", pszDst, (int)errno); 
            } else {
               num nSize = ofsdst.src.nSize;
               size_t nWrite = myfwrite(pContent, nSize, fout, nSize, 0);
               myfclose(fout);
               if (bGlblEscape) {
                  remove(pszDst);
                  return 9+perr("failed to fully write %s, user interrupt\n", pszDst);
               }
               else
               if (nWrite != nSize)
                  return 9+esys("fwrite", "failed to fully write %s   \n", pszDst);
                  // do NOT proceed, this seems fatal.

               // set target meta data
               ofsdst.writeTo(pszDst, __LINE__);
               // IGNORE rc. errors are counted.
               nflags |= 4; // shadow written
               cs.shadowsWritten++;
            }
         }

         // print filename, tell how it was copied
         if (bDoneFile)
            printCopyCompleted(pszTell, nflags);
      }  
   }
   setEmpty();
   return 0;
}

#endif // USE_SFK_BASE

num currentElapsedMSec() {
   return getCurrentTime() - nGlblStartTime;
}

uint currentKBPerSec() {
   num lMSElapsed = currentElapsedMSec();
   if (lMSElapsed == 0) lMSElapsed = 1;
   return (uint)(nGlblBytes / lMSElapsed);
}

uint currentMBPerSec() {
   num lMSElapsed = currentElapsedMSec();
   if (lMSElapsed == 0) lMSElapsed = 1;
   return (uint)((nGlblBytes / lMSElapsed) / 1000);
}

char szCmpBuf1[4096];
char szCmpBuf2[4096];

#if 1

// 1694: new strstri without size limit
char *mystrstri(char *phay, cchar *ppat)
{
   int i=0,j=0,ncmp=0,ndiff=0;

   int llen = (int)strlen(phay);
   int slen = (int)strlen(ppat);

   ncmp = (llen-slen)+1;

   if (ncmp < 0)
      return 0;

   for (j=0; j<ncmp; ++j)
   {
      ndiff = 0;

      for (i=0; (i<slen) && !ndiff; ++i)
         ndiff = tolower(phay[j+i]) - tolower(ppat[i]);

      if (!ndiff)
         return (char *)phay+j;
   }

   return 0;
}

// 1694: replacement for old strstri
int mystrstrip(char *psz1, cchar *psz2, int *lpAtPosition)
{
   char *pHit = mystrstri(psz1, psz2);
   int iPos = pHit ? (int)(pHit - psz1) : -1;
   if (lpAtPosition)
      *lpAtPosition = iPos;
   return pHit ? 1 : 0;
}

#else

// only for strings up to 4k length.
int mystrstrip(char *psz1, cchar *psz2, int *lpAtPosition)
{
   int slen1 = strlen(psz1);
   if (slen1 > (int)sizeof(szCmpBuf1)-10)
       slen1 = (int)sizeof(szCmpBuf1)-10;
   memcpy(szCmpBuf1, psz1, slen1);
   szCmpBuf1[slen1] = '\0';

   int slen2 = strlen(psz2);
   if (slen2 > (int)sizeof(szCmpBuf2)-10)
       slen2 = (int)sizeof(szCmpBuf2)-10;
   memcpy(szCmpBuf2, psz2, slen2);
   szCmpBuf2[slen2] = '\0';

   for (int i1=0; i1<slen1; i1++)
      szCmpBuf1[i1] = tolower(szCmpBuf1[i1]);

   for (int i2=0; i2<slen2; i2++)
      szCmpBuf2[i2] = tolower(szCmpBuf2[i2]);

   char *pszHit = strstr(szCmpBuf1, szCmpBuf2);

   if (lpAtPosition) {
      if (pszHit)
         *lpAtPosition = (int)(pszHit - szCmpBuf1);
      else
         *lpAtPosition = -1;
   }

   return (pszHit != 0) ? 1 : 0;
}

int mystrstri(char *psz1, cchar *psz2)
{
   return mystrstrip(psz1, psz2, 0);
}

#endif

// same as above, but support "?" wildcards.
// only for strings up to 4k length.
int mystrstriq4k(char *psz1, cchar *psz2, int *lpAtPosition=0)
{
   int slen1 = strlen(psz1);
   if (slen1 > (int)sizeof(szCmpBuf1)-10)
       slen1 = (int)sizeof(szCmpBuf1)-10;
   memcpy(szCmpBuf1, psz1, slen1);
   szCmpBuf1[slen1] = '\0';

   int slen2 = strlen(psz2);
   if (slen2 > (int)sizeof(szCmpBuf2)-10)
       slen2 = (int)sizeof(szCmpBuf2)-10;
   memcpy(szCmpBuf2, psz2, slen2);
   szCmpBuf2[slen2] = '\0';

   for (int i1=0; i1<slen1; i1++)
      szCmpBuf1[i1] = tolower(szCmpBuf1[i1]);
   for (int i2=0; i2<slen2; i2++)
      szCmpBuf2[i2] = tolower(szCmpBuf2[i2]);

   char *pszHay = szCmpBuf1;  // HayStack
   char *pszNed = szCmpBuf2;  // Needle
   char *pszHit = 0;
   while (*pszHay) {
      // optim: quick check of current char
      if (*pszNed != '?' && *pszHay != *pszNed)
         { pszHay++; continue; }
      // compare against needle at current hay position
      int i=0;
      for (; pszHay[i] && pszNed[i]; i++) {
         char c = pszNed[i];
         if (c == '?')
            continue;
         if (c != pszHay[i])
            break;
      }
      // comparison stopped: why?
      if (!pszNed[i]) {
         // needle elapsed: success
         pszHit = pszHay;
         break;
      }
      // needle not elapsed: no hit here
      pszHay++;
   }

   if (lpAtPosition) {
      if (pszHit)
         *lpAtPosition = (int)(pszHit - szCmpBuf1);
      else
         *lpAtPosition = -1;
   }

   return (pszHit != 0) ? 1 : 0;
}

// returns 0 if equal.
int mystrncmp(char *psz1, cchar *psz2, int nLen, bool bCase)
{
   if (bCase)
      return strncmp(psz1, psz2, nLen);

   int i=0;
   for (i=0; i<nLen && psz1[i] && psz2[i]; i++)
      if (tolower(psz1[i]) != tolower(psz2[i]))
         return 1;

   return (i==nLen) ? 0 : 1;
}

int mystricmp(char *psz1, cchar *psz2)
{
   while (*psz1 && *psz2 && tolower(*psz1) == tolower(*psz2)) {
      psz1++;
      psz2++;
   }
   return tolower(*psz1) - tolower(*psz2);
}

int mystrnicmp(char *psz1, cchar *psz2, int nLen)
{
   int i=0;
   for (i=0; i<nLen && psz1[i] && psz2[i]; i++)
      if (tolower(psz1[i]) != tolower(psz2[i]))
         return tolower(psz1[i]) - tolower(psz2[i]);

   if (i >= nLen) return 0;

   return tolower(psz1[i]) - tolower(psz2[i]);
}

bool stricase(char *psz, cchar *ppat)
   {  return mystricmp(psz, ppat) ? 0 : 1; }

bool strnicase(char *psz, cchar *pstart, int nlen)
   {  return mystrnicmp(psz, pstart, nlen) ? 0 : 1; }

bool stribeg(char *psz, cchar *pstart)
   {  return mystrnicmp(psz, pstart, strlen(pstart)) ? 0 : 1; }

int iGlblMovTotalTime = 0;
num nGlblMovFileSize  = 0;

int movtimetoms(int i)
{
   int ifrac = i % 100;
       i /= 100;
       
   int isec = i % 60;
       i /= 60;

   int imin = i % 60;
       i /= 60;

   int ihou = i;

   return (ihou * 100 + imin) * 100 + isec;
}

char *movtimetoa(int i, char *szBuf=0)
{
   static char szBuf2[100];
   
   if (!szBuf)
      szBuf = szBuf2;

   int ifrac = i % 100;
       i /= 100;
       
   int isec = i % 60;
       i /= 60;

   int imin = i % 60;
       i /= 60;

   int ihou = i;

   sprintf(szBuf, "%02u:%02u:%02u", ihou, imin, isec);

   return szBuf;
}

// RC 0: error
int atomovtime(char *psz, int ioptlen, bool bUseBytes)
{
   char szBuf[100];

   int ilen = ioptlen ? ioptlen : strlen(psz);

   if (ilen > sizeof(szBuf)-10)
      return 0+perr("buffer overflow");

   if (bUseBytes)
   {
      if (!nGlblMovFileSize)
         return 0+perr("missing filesize. specify as first parameter.");

      if (!iGlblMovTotalTime)
         return 0+perr("missing total time. specify as second parameter.");

      memcpy(szBuf, psz, ilen);
      szBuf[ilen] = '\0';

      num nBytePos = atonum(szBuf);

      int ires = nBytePos * iGlblMovTotalTime / nGlblMovFileSize;
   
      // printf("# time %08u = \"%s\" * %u / %s (inlen=%d)\n",
      //   ires, szBuf, iGlblMovTotalTime, numtoa(nGlblMovFileSize), ilen);   

      if (cs.verbose > 1)
         printf("itime : %s = %s bytes\n", movtimetoa(ires, szBuf), numtoa(nBytePos));
   
      return ires;
   }

   // 3053     -> ((30 * 60) + 53) * 100
   // 305395   -> ((30 * 60) + 53) * 100 + 95

   char szHou[10]; mclear(szHou);
   char szMin[10]; mclear(szMin);
   char szSec[10]; mclear(szSec);
   char szFrc[10]; mclear(szFrc);

   if (strchr(psz, ':'))
   {
      // 30:53 and 01:30:53
      switch (ilen)
      {
         case 5:
            memcpy(szMin, psz, 2);
            memcpy(szSec, psz+3, 2);
            break;
   
         case 8:
            memcpy(szHou, psz, 2);
            memcpy(szMin, psz+3, 2);
            memcpy(szSec, psz+6, 2);
            break;
      }
   }
   else
   {
      // 3053 and 013053
      switch (ilen)
      {
         case 4:
            memcpy(szMin, psz, 2);
            memcpy(szSec, psz+2, 2);
            break;
   
         case 6:
            memcpy(szHou, psz, 2);
            memcpy(szMin, psz+2, 2);
            memcpy(szSec, psz+4, 2);
            break;
      }
   }

   int iTime =
         (atoi(szHou) * 3600) * 100
      +  (atoi(szMin) *   60) * 100
      +  (atoi(szSec)       ) * 100
      ;

   return iTime;
}

// RC 0: OK
int atomovrange(char *psz, num *pstart, num *pend)
{
   char *pszStart = psz;
   char *pszEnd   = strchr(psz, '-');
   if (!pszEnd)
      return 9+perr("wrong time range format: %s", psz);

   *pstart = atonum(pszStart);

   pszEnd++;

   if (!(*pend = atonum(pszEnd)))
      return 10+perr("wrong time range end: %s", psz);

   return 0;
}

// RC 0: OK
int atomovrange(char *psz, int *pstart, int *pend, bool bUseBytes)
{
   char *pszStart = psz;
   char *pszEnd   = strchr(psz, '-');
   if (!pszEnd)
      return 9+perr("wrong time range format: %s", psz);

   *pstart = atomovtime(pszStart, pszEnd-pszStart, bUseBytes);

   pszEnd++;

   if (!(*pend = atomovtime(pszEnd, 0, bUseBytes)))
      return 10+perr("wrong time range end: %s", psz);

   return 0;
}

#ifdef _WIN32
// type: 1==onlyDown 2==onlyUp 0==any
int getKeyPress(int ntype=0)
{
   #ifdef WINFULL
   DWORD dwNumEvents, dwEventsPeeked, dwInputEvents;
   INPUT_RECORD aInputBuffer[1];

   HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);

   if (!GetNumberOfConsoleInputEvents(hStdIn, &dwNumEvents))
      return -1;

   if (dwNumEvents <= 0)
      return -1;

   if (!PeekConsoleInput(hStdIn, aInputBuffer, 1, &dwEventsPeeked))
      return -1;
   
   if (!ReadConsoleInput(hStdIn, &aInputBuffer[0], 1, &dwInputEvents))
      return -1;

   if (dwInputEvents != 1)
      return -1;

   if (aInputBuffer[0].EventType == KEY_EVENT) {
      int ncode = aInputBuffer[0].Event.KeyEvent.wVirtualKeyCode;
      bool bdown = aInputBuffer[0].Event.KeyEvent.bKeyDown;
      // react only on key down or key up?
      if (ntype == 1 && !bdown) return -1; // no type match
      if (ntype == 2 &&  bdown) return -1; // no type match
      return ncode;
   }
   #endif

   return -1;
}

bool userInterrupt(bool bSilent, bool bWaitForRelease) {
   if (bGlblEscape)
      return 1;
   static bool bTold = 0;
   if (getKeyPress() == VK_ESCAPE) {
      if (!bSilent && !bTold) {
         bTold = 1;
         info.clear(); // if any
         printf("[stopped by user]%.50s\n", pszGlblBlank);
      }
      if (bWaitForRelease)
         while (getKeyPress() == VK_ESCAPE)
            doSleep(200);
      bGlblEscape = 1;
      return 1;
   }
   return 0;
}
#else
bool userInterrupt(bool bSilent, bool bWait) 
{ 
   // FIX 1642: always returned 0
   return bGlblEscape;
}
#endif

struct SFKLoadNode 
{
   struct SFKLoadNode *pNext;
   int iSize;
   char abData[1000000];
};

char *loadStdIn(num &rnFileSize)
{
   SFKLoadNode *pFirst=0,*pCur=0,*pPrev=0,*pDel=0;

   int iRC=0,iTotal=0;

   // load packages
   while (1)
   {
      if (!(pCur = new SFKLoadNode())) {
         perr("out of memory");
         iRC = 9;
         break;
      }
      memset(pCur, 0, sizeof(SFKLoadNode));
      if (!pFirst)
         pFirst = pCur;

      int iRead = fread(pCur->abData, 1, sizeof(pCur->abData), stdin);
      if (iRead <= 0) {
         delete pCur;
         break;
      }

      pCur->iSize = iRead;
      iTotal += iRead;

      if (pPrev)
         pPrev->pNext = pCur;

      pPrev = pCur;
   }

   // join packages
   char *pOut = 0;
   
   if (!iRC)
   {
      if (!(pOut = new char[iTotal+100]))
      {
         perr("out of memory");
         iRC = 10;
      }
      else
      {
         int iOff=0;
         for (pCur = pFirst; pCur; pCur=pCur->pNext)
         {
            memcpy(pOut+iOff, pCur->abData, pCur->iSize);
            iOff += pCur->iSize;
         }
         pOut[iOff] = '\0';
      }
   }
   
   // cleanup
   pCur = pFirst;
   while (pCur)
   {
      SFKLoadNode *pTmp = pCur->pNext;
      delete pCur;
      pCur = pTmp;
   }

   if (iRC)
      return 0;
   
   rnFileSize = iTotal;

   return pOut;
}

char *loadFile(char *pszFile, bool bquiet)
{
   num nFileSize = getFileSize(pszFile);
   if (nFileSize < 0) {
      if (!bquiet) perr("file not found: %s", pszFile);
      return 0;
   }

   num nTolerance = 10;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut) {
      perr("out of memory: %s\n", pszFile);
      return 0; 
   }
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      if (!bquiet) perr("cannot read: %s\n", pszFile);
      delete [] pOut;
      return 0; 
   }

   int nRead = fread(pOut, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      if (!bquiet) perr("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pOut;
      return 0;
   }

   // loadFile guarantees zero termination after buffer:
   pOut[nFileSize] = '\0';
   return pOut;
}

uchar *loadBinaryFile(char *pszFile, num &rnFileSize) 
{
   num nFileSize = getFileSize(pszFile);
   if (nFileSize < 0)
      return 0;

   num nTolerance = 10;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut) {
      perr("out of memory: %s\n", pszFile);
      return 0; 
   }
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      perr("cannot read: %s\n", pszFile); 
      delete [] pOut; 
      return 0; 
   }

   int nRead = fread(pOut, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      perr("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pOut;
      return 0;
   }

   // not strictly needed w/binary data, but anyway.
   pOut[nFileSize] = '\0';

   rnFileSize = nFileSize;
   return (uchar*)pOut;
}

uchar *loadBinaryFlex(char *pszFile, num &rnFileSize)
{
   Coi *pcoi = new Coi(pszFile, 0);
   if (!pcoi) return 0;

   CoiAutoDelete odel(pcoi, 0); // no decref

   #ifdef VFILEBASE
   pcoi->provideInput(__LINE__);
   #endif // VFILEBASE

   num nFileSize = pcoi->getSize();
   if (nFileSize < 0)
      return 0;

   num nTolerance = 10;
   char *pOut = new char[nFileSize+nTolerance+4];
   if (!pOut) {
      perr("out of memory: %s\n", pszFile);
      return 0;
   }
   memset(pOut+nFileSize, 0, nTolerance); // added safety

   if (pcoi->open("rb")) {
      perr("cannot read: %s\n", pszFile);
      delete [] pOut;
      return 0;
   }

   int nRead = pcoi->read(pOut, nFileSize);

   pcoi->close();

   if (nRead != nFileSize) {
      perr("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pOut;
      return 0;
   }

   // not strictly needed w/binary data, but anyway.
   pOut[nFileSize] = '\0';

   rnFileSize = nFileSize;
   return (uchar*)pOut;
}

int saveFile(char *pszName, uchar *pData, int iSize)
{
   FILE *fout = fopen(pszName, "wb");
   if (!fout)
      return 9+perr("cannot write: %s\n", pszName);

   if (myfwrite(pData, iSize, fout) != iSize) {
      fclose(fout);
      return 10+perr("cannot fully write (disk full?): %s\n", pszName);
   }

   fclose(fout);
   return 0;
}

// used by matchesNormName only to check .ext dir masks
bool dirExtEndMatch(char *pszHay, char *pszPat)
{
   // hay1: ".svn/"
   // pat1: ".svn"
   // pat2: ".svn/"
   int npatlen = strlen(pszPat);
   if (npatlen < 1) return 0; // shouldn't happen
   // case ".svn/" == ".svn/"
   if (pszPat[npatlen-1] == glblPathChar)
      return mystricmp(pszHay, pszPat) ? 0 : 1;
   // pat differs in length to hay,
   // case ".svn/" == ".svn"
   int nhaylen = strlen(pszHay);
   if (nhaylen != npatlen+1)
      return 0;
   if (mystrnicmp(pszHay, pszPat, npatlen))
      return 0;
   if (pszHay[npatlen] != glblPathChar)
      return 0;
   return 1;
}

int normalizePath(char *pszSrc, char *pszDst, int iMaxDst)
{
   if (iMaxDst < 100)
      return 9+perr("buffer overflow #213461 %d", iMaxDst);

   char *pszMaxDst = pszDst+iMaxDst-10;

   pszDst[0] = '\0';

   int iNameLen = strlen(pszSrc);

   if (iMaxDst < iNameLen+4)
      return 10+perr("buffer overflow #213462 %d %d", iMaxDst, iNameLen);

   if (pszSrc[0] != glblPathChar)
      strcat(pszDst, glblPathStr);

   if (iNameLen > 0) 
   {
      int iAppendPos = strlen(pszDst);

      if (pszDst+iAppendPos+iNameLen > pszMaxDst)
         return 11; // safety

      memcpy(pszDst+iAppendPos, pszSrc, iNameLen);
      pszDst[iAppendPos+iNameLen] = '\0';
   }

   if (iNameLen == 0 || pszSrc[iNameLen-1] != glblPathChar)
      strcat(pszDst, glblPathStr);

   return 0;
}

bool matchesNormName(char *pszStr, char *pszMask,
   bool *rPartMatch = 0, int nFlags = 0,
   int *pHitPos = 0, int *pHitLen = 0
   )
{
    if (cs.verbose >= 4)
       printf("\nmname %s %s\n",pszStr,pszMask);

    // flags, bit 0: DISABLE start of name comparison
    bool bEnableSNC = ((nFlags & 1) == 0);

    // flags, bit 1: PATH matching mode i/o FILE.
    bool bPathMatch =  (nFlags & 2) ? 1 : 0;

    // flags, bit 2: matchesDirMask mode, no ".ext" comparison.
    bool bMDirMask = (nFlags & 4) ? 1 : 0;
    
    //  foo         -> thefoosys.txt
    //  *foo*bar*   -> thefooanybar.txt
    //  .txt        -> only .txt files
    //  !.txt       -> all except .txt files
    //  * anywhere  -> ignore . position

    if (rPartMatch) *rPartMatch = false;

    szMatchBuf[0] = '\0';

    int nMinHitPos = -1;
    int nMaxHitLen =  0;

    char *pstr1  = pszStr;
    char *pmsk1  = pszMask;
    char *pmsk2  = pmsk1;
    bool  bneg   = 0;
    bool  bimt   = true; // inner match
    int  nmpos  = 0;
    int  nlen   = 0;
    bool  bwild2 = 0;

    while (*pmsk1) 
    {
        char c = *pmsk1;
        bool bIsLastChr = (*(pmsk1+1) == '\0');

        // initial negation
        if (!nmpos && isNotChar(c))
            { bneg=1; pmsk1++; pmsk2=pmsk1; nmpos++; continue; }
        nmpos++;

        // identify tokens between *
        bool bwild = isWildChar(c); // checks for *, but not ?
        if (bwild || bIsLastChr) 
        {
            // have mask part from pmsk2 to pmsk1-1
            nlen = pmsk1 - pmsk2;
            if (!bwild) nlen++; // do not exlude * then

            // "*" as first character of mask?
            if (nlen <= 0) { 
               if (bPathMatch) {
                  pmsk1++; pmsk2=pmsk1; bwild2=1; continue;
               } else {
                  pmsk1++; pmsk2=pmsk1; continue;
               }
            }

            // have mask part from pmsk2 with length nlen
            if (nlen > MAX_MATCH_BUF-2) {
               if (cs.verbose >= 3) printf("0 = MATCH (msk %.100s, str %s) r2\n",pmsk2,pszStr);
               return false;
            }
            memcpy(szMatchBuf, pmsk2, nlen);
            szMatchBuf[nlen] = '\0';
            if (cs.verbose >= 4) printf("PART %s neg %d\n", szMatchBuf, bneg);

            // special case ".ext" part at end of mask?
            if (!bwild && !bwild2 && szMatchBuf[0] == '.') 
            {
                // compare mask: szMatchBuf e.g. ".1.txt"
                // against end of: pstr1    e.g. "foo.1.txt"
                int nMaskLen = strlen(szMatchBuf);
                int nNameLen = strlen(pstr1);

                // FIX: R157: no longer use strrchr(pstr1, '.')
                char *psz5 = 0;
                if (endsWithPathChar(szMatchBuf)) {
                   if (nMaskLen <= nNameLen) {
                      psz5 = pstr1 + nNameLen - nMaskLen;
                      if (*psz5 != '.') psz5 = 0;   
                   }
                } else {
                   // FIX 163R3: .txt <-> tmp1.txt/
                   // fix includes strnicmp below i/o stricmp
                   if (nMaskLen+1 <= nNameLen) {
                      psz5 = pstr1 + nNameLen - (nMaskLen+1);
                      if (*psz5 != '.') psz5 = 0;
                   }
                }

                bool bmatch1 = false;
                if (!psz5)
                    bmatch1 = false;
                else
                if (bMDirMask)
                    bmatch1 = dirExtEndMatch(psz5, szMatchBuf);
                else
                    bmatch1 = !mystrnicmp(psz5, szMatchBuf, nMaskLen);
                if (bmatch1 && rPartMatch) *rPartMatch = true;
                // final match decision by extension:
                if (cs.verbose >= 3) printf("%d = MATCH (msk %s, str %s) %d^%d r3 %p\n",bneg^bmatch1,szMatchBuf,pszStr,bneg,bmatch1,psz5);
                return bneg ^ bmatch1;
            }

            int nHitPos = 0;

            // string cursor is pstr1
            bool bmatch2 = false;

            #ifdef SFK_STRICT_MATCH
            // on first mask part, if it's not an extension:
            if (pmsk2 == pszMask && szMatchBuf[0] != '.') {
               // start of name comparison:
               if (mystrstriq4k(pstr1, szMatchBuf, &nHitPos))
                  if (nHitPos == 0) {
                     if (bwild || (strlen(pstr1+nHitPos) == strlen(szMatchBuf)))
                     {
                        bmatch2 = true;
                     }
                  }
            }
            #else
            if (bEnableSNC && (szMatchBuf[0] == glblPathChar) && (szMatchBuf[1] != '\0')) {
               // start of name comparison:
               if (mystrstriq4k(pstr1, &szMatchBuf[1], &nHitPos))
                  if (nHitPos == 0) {
                     bmatch2 = true;
                     if (pHitPos) {
                        nMinHitPos = 0;
                        nMaxHitLen = strlen(&szMatchBuf[1]);
                     }
                  }
            }
            #endif
            else 
            {
               // normal within-name comparison:
               if (mystrstriq4k(pstr1, szMatchBuf, &nHitPos)) {
                   // part matches:
                   #ifdef SFK_STRICT_MATCH
                   if (bwild || (strlen(pstr1+nHitPos) == strlen(szMatchBuf)))
                   {
                   #endif
                   if (rPartMatch) *rPartMatch = true;
                   if (cs.verbose >= 4) printf("CHK0 bneg %d (msk %s,str %s)\n",bneg,szMatchBuf,pszStr);
                   // if (bneg) return false;
                   // else continue, no mismatch yet.
                   if (pHitPos) {
                      int nAbsPos1 = (pstr1-pszStr)+nHitPos;
                      if (nMinHitPos < 0) nMinHitPos = nAbsPos1;
                      int nAbsPos2 = nAbsPos1 + strlen(szMatchBuf);
                      nMaxHitLen = nAbsPos2 - nMinHitPos;
                   }
                   // have to step past hit in string.
                   pstr1 += nHitPos + strlen(szMatchBuf);
                   pmsk1++; pmsk2=pmsk1;
                   continue;
                   #ifdef SFK_STRICT_MATCH
                   }
                   #endif
               }
               // else fall through, bmatch2 hasn't been raised.
            }

            if (!bmatch2)
            {
                // part mismatch:
                bimt = false; // no inner match
                if (!bneg) {
                   if (cs.verbose >= 3) printf("0 = MATCH (msk %s, str %s) r4\n",szMatchBuf,pszStr);
                   return false;
                }
                if (cs.verbose >= 4) printf("CHK2 bneg %d (msk %s,str %s)\n",bneg,szMatchBuf,pszStr);
                // else continue, no negation match yet
                // e.g. "!the*foo" over "bigtest.txt";
                // do not step pstr1 at all.
                if (cs.verbose >= 4) printf("CNT2 bneg %d\n",bneg);
                pmsk1++; pmsk2=pmsk1; continue;
            } else {
                pmsk1++; pmsk2=pmsk1; continue;
            }
        }
        // continue on characters within tokens
        pmsk1++;
    }
    // the string past "!" (if any) matches:
    if (cs.verbose >= 3) printf("%d = MATCH (msk \"%s\", str \"%s\") %d^%d\n",bimt^bneg,szMatchBuf,pszStr,bimt,bneg);
    bool brc = bimt ^ bneg;
    if (brc && pHitPos && (nMinHitPos >= 0) && (nMaxHitLen > 0)) {
       if (pHitPos) *pHitPos = nMinHitPos;
       if (pHitLen) *pHitLen = nMaxHitLen;
    }
    return brc;
}

// RC 0 : no match
// RC 1 : match, but just by wildcard
// RC 2 : match by non wildcard pattern
int matchesFileMask(char *pszFile, char *pszInfoAbsName=0)
{
   int iRC = 1;
   
   // build normalized filename
   //    foo.txt     -> /foo.txt/
   //    foo\bar.txt -> /foo/bar.txt/
   int iNameLen = strlen(pszFile);
   
   char *pszNormSubName = new char[iNameLen + 10];
   CharAutoDel odel(pszNormSubName);

   pszNormSubName[0] = '\0';
   if (pszFile[0] != glblPathChar)
      strcat(pszNormSubName, glblPathStr);
   if (iNameLen > 0) {
      int iAppendPos = strlen(pszNormSubName);
      memcpy(pszNormSubName+iAppendPos, pszFile, iNameLen);
      pszNormSubName[iAppendPos+iNameLen] = '\0';
   }
   if (iNameLen == 0 || pszFile[iNameLen-1] != glblPathChar)
      strcat(pszNormSubName, glblPathStr);

   int iNumberOfWhiteMasks    = 0;
   int iNumberOfWhiteMatches  = 0;
   int iNumberOfBlackMasks    = 0;
   int iNumberOfWildMasks     = 0;

   Array &rMasks = glblFileSet.fileMasks();
   for (int i=0; rMasks.isStringSet(i); i++)
   {
      char *pszMask = rMasks.getString(i);

      if (isNotChar(pszMask[0]))
      {
         iNumberOfBlackMasks++;
         if (matchesNormName(pszNormSubName, pszMask+1, 0, 3)) { // ,3: no start-of-name + cmp-path
            if (nGlblTraceSel & 1) {
               setTextColor(nGlblTraceExcColor);
               info.print("file-exclud: %s due to \"%s\"\n", pszNormSubName, pszMask);
               setTextColor(-1);
            }
            return 0;
         } else {
            if (cs.verbose >= 4)
               printf("1 = msbm (msk %s, str %s)\n", pszMask, pszNormSubName);
         }
      }
      else
      {
         iNumberOfWhiteMasks++;
         if (matchesNormName(pszNormSubName, pszMask, 0, 3)) { // ,3: no start-of-name + cmp-path
            iNumberOfWhiteMatches++;
            if (!containsWildCards(pszMask))
               iRC = 2;
            if (nGlblTraceSel & 1) {
               setTextColor(nGlblTraceExcColor);
               info.print("file-wmatch: %s to \"%s\"\n", pszNormSubName, pszMask);
               setTextColor(-1);
            }
         } else {
            if (cs.verbose >= 4)
               printf("0 = mswm (msk %s, str %s)\n", pszMask, pszNormSubName);
         }
      }
   }

   // if any white masks given, at least one or all must match
   if (cs.fileMaskAndMatch) {
      if (iNumberOfWhiteMasks > 0 && iNumberOfWhiteMatches < iNumberOfWhiteMasks)
         iRC = 0;
   } else {
      if (iNumberOfWhiteMasks > 0 && iNumberOfWhiteMatches < 1)
         iRC = 0;
   }

   if (nGlblTraceSel & 1) {
      if (iRC) {
         setTextColor(nGlblTraceIncColor);
         info.print("file-keep  : %s (wmask=%d/%d bmask=0/%d)\n", pszNormSubName, iNumberOfWhiteMatches, iNumberOfWhiteMasks, iNumberOfBlackMasks);
         // mtklog(("mdm: include %s", pszStr));
      } else {
         setTextColor(nGlblTraceExcColor);
         info.print("file-exclud: %s (wmask=%d/%d bmask=0/%d)\n", pszNormSubName, iNumberOfWhiteMatches, iNumberOfWhiteMasks, iNumberOfBlackMasks);
         // mtklog(("mdm: exclude %s", pszStr));
      }
      setTextColor(-1);
   }

   // mtklog(("mdm: %d for %s", iRC, pszStr));

   return iRC;
}

bool matchesDirMask(char *pszFullPath, bool bTakeFullPath, bool bApplyWhiteMasks)
{_p("sf.mtchdir")

   bool bRC = 1;

   // build normalized path name
   //    include  -> /include/
   //    \foo\bar -> /bar/
   // if input path is an absolute filename
   //    include\foo.hpp -> /include/
   int iPathLen = strlen(pszFullPath);
   if (!bTakeFullPath) {
      char *pszRelName = strrchr(pszFullPath, glblPathChar);
      if (!pszRelName)
         iPathLen = 0;
      else
         iPathLen = pszRelName - pszFullPath;
   }

   char *pszNormSubName = new char[iPathLen + 10];
   CharAutoDel odel(pszNormSubName);

   pszNormSubName[0] = '\0';
   if (pszFullPath[0] != glblPathChar)
      strcat(pszNormSubName, glblPathStr);
   if (iPathLen > 0) {
      int iAppendPos = strlen(pszNormSubName);
      memcpy(pszNormSubName+iAppendPos, pszFullPath, iPathLen);
      pszNormSubName[iAppendPos+iPathLen] = '\0';
   }      
   if (iPathLen == 0 || pszFullPath[iPathLen-1] != glblPathChar)
      strcat(pszNormSubName, glblPathStr);
      
   int iNumberOfWhiteMasks    = 0;
   int iNumberOfWhiteMatches  = 0;
   int iNumberOfBlackMasks    = 0;
   int iNumberOfWildMasks     = 0;
      
   Array &rMasks = glblFileSet.dirMasks();
   for (int i=0; rMasks.isStringSet(i); i++)
   {
      char *pszMask = rMasks.getString(i);

      if (isNotChar(pszMask[0]))
      {
         // black masks are applied asap, both during directory travel
         // and later when checking file paths.
         iNumberOfBlackMasks++;
         if (matchesNormName(pszNormSubName, pszMask+1, 0, 3)) { // ,3: no start-of-name + cmp-path
            if (nGlblTraceSel & 1) {
               setTextColor(nGlblTraceExcColor);
               info.print("dir-exclude: %s due to \"%s\"\n", pszNormSubName, pszMask);
               setTextColor(-1);
            }
            return 0;
         } else {
            if (cs.verbose >= 4) 
               printf("1 = msbm (msk %s, str %s)\n", pszMask, pszNormSubName);
         }
      }
      else
      if (bApplyWhiteMasks)
      {
         // white masks are applied on file path checking,
         // but not on directory travel.
         iNumberOfWhiteMasks++;
         if (matchesNormName(pszNormSubName, pszMask, 0, 3)) { // ,3: no start-of-name + cmp-path
            iNumberOfWhiteMatches++;
            if (nGlblTraceSel & 1) {
               setTextColor(nGlblTraceExcColor);
               info.print("dir-wmatch : %s to \"%s\"\n", pszNormSubName, pszMask);
               setTextColor(-1);
            }
         } else {
            if (cs.verbose >= 4)
               printf("0 = mswm (msk %s, str %s)\n", pszMask, pszNormSubName);
         }
      }
   }
   
   // if any white masks given, at least one or all must match
   if (cs.dirMaskAndMatch) {
      if (iNumberOfWhiteMasks > 0 && iNumberOfWhiteMatches < iNumberOfWhiteMasks)
         bRC = 0;
   } else {
      if (iNumberOfWhiteMasks > 0 && iNumberOfWhiteMatches < 1)
         bRC = 0;
   }
   
   if (nGlblTraceSel & 1) {
      if (bRC) {
         setTextColor(nGlblTraceIncColor);
         info.print("dir-keep   : %s (wmask=%d/%d bmask=0/%d)\n", pszNormSubName, iNumberOfWhiteMatches, iNumberOfWhiteMasks, iNumberOfBlackMasks);
         // mtklog(("mdm: include %s", pszStr));
      } else {
         setTextColor(nGlblTraceExcColor);
         info.print("dir-exclude: %s (wmask=%d/%d bmask=0/%d)\n", pszNormSubName, iNumberOfWhiteMatches, iNumberOfWhiteMasks, iNumberOfBlackMasks);
         // mtklog(("mdm: exclude %s", pszStr));
      }
      setTextColor(-1);
   }

   // mtklog(("mdm: %d for %s", bRC, pszStr));

   return bRC;
}

void padBuffer(char *pszBuf, int nMaxLen, char c, int nTargLen)
{
   int nlen = strlen(pszBuf);
   if (nlen < nTargLen) {
      int ndif = nTargLen-nlen;
      if (nlen+ndif < nMaxLen) {
         memset(pszBuf+nlen, c, ndif);
         pszBuf[nlen+ndif] = '\0';
      }
   }
}

int execFind(Coi *pcoi) 
{__
   bool isBinaryFile(char *pszFile);

   info.setAddInfo("%u files, %u dirs", cs.filesScanned, cs.dirsScanned);
   info.setStatus("scan ", pcoi->name(), 0, eKeepAdd);

   bool bBinGrep = bGlblBinGrep;
 
   if (bGlblBinGrepAutoDetect)
   {
      bBinGrep = pcoi->isBinaryFile();
   }
  
   if (bBinGrep)
   {
      if (pcoi->open("rb"))
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      cs.filesScanned++;
  
      BinTexter bt(pcoi);
      bt.process(BinTexter::eBT_Grep);
  
      pcoi->close();
   }
   else
   {
      // this is only reached with "-text" option specified.
      // we're using TEXT MODE and fgets BY INTENTION.
      // on the first NULL or EOF byte, the scanning will stop.
  
      if (pcoi->open("r")) // TEXT only read mode
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      cs.filesScanned++;

      int nMaxLineLen = sizeof(szLineBuf)-10; // YES, szLineBuf
      memset(abBuf, 0, nMaxLineLen+2); // yes, abBuf is larger by far
   
      int nLocalLines = 0;
      int nMatchLines = 0;
      bool bDumpedFileName = 0;
      bool btold1 = 0;

      while (pcoi->readLine((char*)abBuf, nMaxLineLen) > 0) // yes, exact len
      {
         cs.lines++;
         nLocalLines++;
   
         if (!btold1 && ((int)strlen((char*)abBuf) == nMaxLineLen)) {
            btold1 = 1;
            pwarn("max line length %d reached, splitting input line(s) in file %s\n", nMaxLineLen, pcoi->name());
         }
   
         removeCRLF((char*)abBuf);
   
         int nMatch = 0;
         int nGrepPat = glblGrepPat.numberOfEntries();
         for (int i=0; (nMatch < nGrepPat) && (i<nGrepPat); i++)
            if (mystrhit((char*)abBuf, glblGrepPat.getString(i), cs.usecase, 0))
               nMatch++;
   
         if (nMatch == nGrepPat) 
         {
            // found a matching file
            cs.anymatches = 1;

            if (chain.colfiles) {
               // filenames only, as filename chain
               // TODO: set root here as glblFileSet.root()?
               chain.addFile(*pcoi); // is copied
               break;
            }

            if (cs.useJustNames) {
               nMatchLines++;
               // if counting matches, continue until end of file.
               if (cs.countMatchLines)
                  continue;
               // fall through to printing of filename.
               break;
            }

            // actually dump the content:

            // list filename first
            if (!bDumpedFileName && !cs.nonames && !cs.pure) {
               bDumpedFileName = 1;
               if (chain.coldata) {
                  sprintf(szLineBuf2, ":file %s", pcoi->name());
                  // note: +view scans extended end of attribute line
                  //       to identify 'f'ile header lines, therefore +2:
                  setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
                  chain.addLine(szLineBuf2, szAttrBuf2);
               } else {
                  setTextColor(nGlblFileColor);
                  info.print("%s :\n", pcoi->name());
                  setTextColor(-1);
               }
            }

            // list the line
            bool bPrefixed = 0;
            
            if (bGlblGrepLineNum)
               { sprintf(szLineBuf2, "   %04u ", nLocalLines); bPrefixed=1; }
            else
            if (!cs.pure)
               { sprintf(szLineBuf2, "   "); bPrefixed=1; }

            if (bPrefixed) {
               if (chain.coldata) {
                  szAttrBuf2[0] = '\0';
                  padBuffer(szAttrBuf2, MAX_LINE_LEN, ' ', strlen(szLineBuf2));
                  // FIX: 163: create new record here
                  chain.addLine(szLineBuf2, szAttrBuf2);
               } else {
                  info.print("%s", szLineBuf2);
               }
            }

            char *pszTmp  = (char*)abBuf;
            int nAttrPad = strlen(pszTmp);
            if (nAttrPad > (int)sizeof(szAttrBuf)-10)
                nAttrPad = (int)sizeof(szAttrBuf)-10;

            memset(szAttrBuf, ' ', nAttrPad);
            szAttrBuf[nAttrPad] = '\0';

            for (int k=0; k<nGrepPat; k++) 
            {
               char *pszPat = glblGrepPat.getString(k);
               int nPatLen = strlen(pszPat);
               int nTmpLen = strlen(pszTmp);
               int nCur = 0, nRel = 0;
               while (mystrhit(pszTmp+nCur, pszPat, cs.usecase, &nRel)) 
               {
                  if (nCur+nRel+nPatLen < (int)sizeof(szAttrBuf)-10)
                     memset(&szAttrBuf[nCur+nRel], 'i', nPatLen);
                  nCur += nRel+nPatLen;
                  if (nCur >= nTmpLen-1)
                     break;
               }
            }

            if (!cs.justrc) {
               if (chain.coldata) {
                  // FIX: 163: if prefix, append after that
                  if (bPrefixed)
                     chain.addToCurLine((char*)abBuf, szAttrBuf, 0);
                  else
                     chain.addLine((char*)abBuf, szAttrBuf);
               } else {
                  printColorText((char*)abBuf, szAttrBuf);
               }
            }
            
            if (cs.useFirstHitOnly)
               break;

         }  // endif all patterns match

      }  // endwhile fgets
   
      pcoi->close();

      if (cs.useJustNames && nMatchLines) {
         // filenames only, as text data, NOT prefixing
         // further text data, therefore NOT including ":file "
         if (chain.coldata) {
            if (cs.countMatchLines) {
               // do not pass file headers, but pure text
               sprintf(szLineBuf2, "%05d : %s", nMatchLines, pcoi->name());
               setattr(szAttrBuf2, ' ', strlen(szLineBuf2), MAX_LINE_LEN);
            } else {
               sprintf(szLineBuf2, "%s", pcoi->name());
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
            }
            chain.addLine(szLineBuf2, szAttrBuf2);
         } else {
            if (cs.countMatchLines)
               info.print("%05d : %s\n", nMatchLines, pcoi->name());
            else
               info.print("%s\n", pcoi->name());
         }
      }

   }  // endelse bingrep
 
   return 0;
}

CoiTable glblFileListCache;

int prtFile(char *pszPreInfo, char *pszRelName, Coi *pcoi, char *pszZip, int nFlags, const char *pszFormat, ...)
{__
   char *pszFilename = pszRelName;

   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szPrintBuf1, sizeof(szPrintBuf1)-10, pszFormat, argList);
   szPrintBuf1[sizeof(szPrintBuf1)-10] = '\0';

   char *pq = bGlblQuoted ? (char*)"\"" : (char*)"";

   bool bshowprog = 0;

   if (cs.listByTime || cs.listBySize || cs.listByName) {
      // remember string with metadata length prefix, for easier output formatting
      char cOrder = 0;
      if (cs.listByTime) cOrder = (cs.listByTime < 0) ? 't':'T';
      if (cs.listBySize) cOrder = (cs.listBySize < 0) ? 's':'S';
      if (cs.listByName) cOrder = (cs.listByName < 0) ? 'n':'N';
      int nLen = strlen(pszFilename);
      if (nLen > (int)sizeof(szPrintBuf2)-100)
          nLen = (int)sizeof(szPrintBuf2)-100;
      sprintf(szPrintBuf2, "%05u %s%s%.*s%s", (uint)strlen(szPrintBuf1), szPrintBuf1, pq,nLen,pszFilename,pq);
      pcoi->setExtStr(szPrintBuf2);
      if (glblFileListCache.addSorted(*pcoi, cOrder, cs.usecase))
         return 9;
      bshowprog = 1;
   }
   else
   if (cs.outfile) {
      // direct filename listing to an output file
      chain.print("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
      bshowprog = 1;
   }
   else
   if (chain.colfiles) {
      // chain mode: do not print files, collect them
      // if (pszZip)
      //    sprintf(szPrintBuf2, "%s%c%s", pszZip, glblPathChar, pszFilename);
      // else
      //    strcopy(szPrintBuf2, pszFilename);
      chain.addFile(*pcoi); // is COPIED
      bshowprog = 1;
   }
   else 
   {
      StringPipe *pout = 0;
      if (chain.coldata) {
         nFlags = 0; // no highlighting, just collect text
         pout = chain.outdata;
         bshowprog = 1;
      }

      // no sorted listing: try to highlight files by attribute
      if (nFlags & 128) { // link
         setTextColor(nGlblLinkColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      } 
      else
      if (nFlags & 64) { // hidden
         setTextColor(nGlblFileColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      } 
      else
      if (nFlags & 4) { // added
         setTextColor(nGlblWarnColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      } 
      else
      if (nFlags & 1) { // time
         setTextColor(nGlblTimeColor);
         oprintf("%s%s%s%s%s", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
         setTextColor(-1);
         printf("\n");
      } 
      else {
         oprintf(pout, "%s%s%s%s%s\n", pszPreInfo, szPrintBuf1, pq,pszFilename,pq);
      }
   }

   // show progress info, if filenames are not printed
   // onto terminal, but redirected:
   if (bshowprog) {
      cs.filesScanned++;
      mtklog(("prtfile.bshowprog=%d q=%d nhead=%d",bshowprog,cs.quiet,cs.nohead));
      if (!cs.quiet && !cs.nohead) {
         info.setAddInfo("%u files", cs.filesScanned);
         info.setStatus("scan", pszFilename, 0, eKeepAdd);
      }
   }
   
   if (cs.crashtest)
      crashTest();

   return 0;
}

char *sizeOrDir(num nSize, int nFlags)
{
   static char szInfo[200];
   int ndig = (uint)nGlblListDigits;
   if (ndig < 1) ndig = 1;
   if (ndig > (int)sizeof(szInfo)-10) ndig = sizeof(szInfo)-10;
   if (nFlags & 1) {
      snprintf(szInfo, sizeof(szInfo)-10, "%*.*s",(int)ndig,(int)ndig,"[dir]");
   } else {
      if (ndig >= 4)
      switch (cs.listunit) {
         case 'k': case 'm': case 'g':
            ndig -= 3; // for " kb"
            break;
      }
      switch (cs.listunit)
      {
         case 'k': snprintf(szInfo, sizeof(szInfo)-10, "%*s kb",(int)ndig,numtoa(nSize/1000UL)); break;
         case 'm': snprintf(szInfo, sizeof(szInfo)-10, "%*s mb",(int)ndig,numtoa(nSize/1000000UL)); break;
         case 'g': snprintf(szInfo, sizeof(szInfo)-10, "%*s gb",(int)ndig,numtoa(nSize/1000000000UL)); break;
         case 'K': snprintf(szInfo, sizeof(szInfo)-10, "%*s",(int)ndig,numtoa(nSize/1000UL)); break;
         case 'M': snprintf(szInfo, sizeof(szInfo)-10, "%*s",(int)ndig,numtoa(nSize/1000000UL)); break;
         case 'G': snprintf(szInfo, sizeof(szInfo)-10, "%*s",(int)ndig,numtoa(nSize/1000000000UL)); break;
         default:
            strcpy(szInfo, numtoa_blank(nSize, ndig));
            break;
      }
   }
   return szInfo;
}

int listSingleFile(int lLevel, Coi *pcoi, char *pszParentZip, bool bIsDir, int nSinceReason)
{__
   char *pszFileName = pcoi->name();
   num   nFileTime   = pcoi->getTime();
   num   nFileSize   = pcoi->getSize();

   const char *p1 = "";
   const char *p2 = "";

   char *pz = pszParentZip;

   int nf = 0; // flags
   if (bIsDir)
        nf |= 32;
   if (pcoi->isHidden())
        nf |= 64;
   if (pcoi->isLink())
        nf |= 128;

   char szSinceInfo[50];
   szSinceInfo[0] = '\0';
   if (!cs.pure) {
      if (nSinceReason & 2) { strcpy(szSinceInfo, "[dif] "); nf |= 2; }
      else
      if (nSinceReason & 1) { strcpy(szSinceInfo, "[tim] "); nf |= 1; }
      if (nSinceReason & 4) { strcpy(szSinceInfo, "[add] "); nf |= 4; }
   }
   char *ps = szSinceInfo;

   // RELATIVIZE FILENAME (OPTIONAL)
   char *pf = cs.rootrelname ? pcoi->rootRelName() : pszFileName;
   if (!pf) return 9;
   
   char csep = cs.listTabs ? '\t':' ';
   int  iTimeMode = 0;
   if (cs.flatTime) iTimeMode |= 3; // flat and separated
   if (cs.listTabs) iTimeMode |= 4; // use tabs

   switch (nGlblListMode)
   {
      case 1:
         if (!cs.quiet && (nGlblListMinSize > 0))
         {
            int lMBytes = (int)(nFileSize / 1000000L);
            if (nFileSize >= nGlblListMinSize)
            {
               int nIndent = (int)lLevel;
               if (nIndent > (int)strlen(pszGlblBlank)) nIndent = strlen(pszGlblBlank);
               if (nIndent > 10) nIndent = 10;

               switch (cs.listunit) {
                  case 'b':
                     prtFile(ps,pf,pcoi,pz,nf, "%s,              %.*s%s%s", numtoa_blank(nFileSize, 12), nIndent, pszGlblBlank, p1,p2);
                     break;
                  case 'k':
                     prtFile(ps,pf,pcoi,pz,nf, "%s kb,              %.*s%s%s", numtoa_blank(nFileSize/1000, 10), nIndent, pszGlblBlank, p1,p2);
                     break;
                  default :
                     prtFile(ps,pf,pcoi,pz,nf, "%5d mb,               %.*s%s%s", lMBytes, nIndent, pszGlblBlank, p1,p2);
                     break;
               }
            }
         }
         break;

      case 2:
         #ifndef _WIN32
         if (cs.traceFileFlags) {
            printf("t=%04x m=%04x l=%04x ", pcoi->rawtype, pcoi->rawmode, pcoi->rawnlnk);
         }
         #endif
         switch (cs.listForm)
         {
            // plain filename, nothing else:
            case 0: prtFile(ps,pf,pcoi,pz,nf, "%s%s", p1,p2); break;
            // size and filename:
            case 1: prtFile(ps,pf,pcoi,pz,nf, "%s%c%s%s", sizeOrDir(nFileSize, nf), csep, p1,p2); break;
            // time and filename:
            case 2: prtFile(ps,pf,pcoi,pz,nf, "%s%c%s%s", timeAsString(nFileTime, iTimeMode), csep, p1,p2); break;

            // size time filename:
            case 0x0102: prtFile(ps,pf,pcoi,pz,nf, "%s%c%s%c%s%s", sizeOrDir(nFileSize, nf), csep, timeAsString(nFileTime, iTimeMode), csep, p1,p2); break;
            // time size filename:
            case 0x0201: prtFile(ps,pf,pcoi,pz,nf, "%s%c%s%c%s%s", timeAsString(nFileTime, iTimeMode), csep, sizeOrDir(nFileSize, nf), csep, p1,p2); break;
         }
         break;
   }

   return 0;
}

#ifndef USE_SFK_BASE
int execDupScan(Coi *pcoi)
{
   int irc = 0;

   if (irc = glblDupScan.addFile(pcoi))
      return irc;

   char szAddInfo[200];
   sprintf(szAddInfo, "%d files", glblDupScan.clSizes.numberOfEntries());
   info.setStatus("scan", pcoi->name(), szAddInfo);
   return 0;
}
#endif // USE_SFK_BASE

// uses szLineBuf, szLineBuf2
int execAliasList(char *pszFileName, bool *pbIsAlias = 0)
{__
   FILE *fin = fopen(pszFileName, "r");
   if (!fin) return 1; // ignore

   // read header of potential alias batch
   szLineBuf[0] = '\0';
   if (!fgets(szLineBuf, sizeof(szLineBuf)-10, fin))
      { fclose(fin); return 1; } // ignore

   int lRC = 0;

   if (!strncmp(szLineBuf, pszGlblAliasBatchHead, strlen(pszGlblAliasBatchHead)))
   {
      /* get additional info
      char *psz2 = szLineBuf+strlen(pszGlblAliasBatchHead);
      if (*psz2 == ' ') psz2++;
      int nCmdLines = atol(psz2);
      */

      if (pbIsAlias)
         *pbIsAlias = 1;

      // reduce filename back to alias name
      char *psz1 = strrchr(pszFileName, glblPathChar);
      if (psz1) pszFileName = psz1+1;
      int nLen = strlen(pszFileName);
      char *pszBat = strstr(pszFileName, ".bat");
      if (pszBat) nLen = pszBat-pszFileName;

      sprintf(szLineBuf2, "%.*s\t= ", (int)nLen, pszFileName);
      if (chain.coldata) {
         chain.addToCurLine(szLineBuf2, str(""), 1); // 1: add new line first
      } else {
         printf("%s", szLineBuf2);
      }

      // read the actual command lines
      int nMaxLines = 10;
      bool bFirst = 1;
      while (nMaxLines-- > 0)
      {
         if (!fgets(szLineBuf, sizeof(szLineBuf)-10, fin))
            break;
         int nLen2 = strlen(szLineBuf);
         if (nLen2 > 0) nLen2--; // strip linefeed
         char *pszCmd = szLineBuf;
         #ifdef _WIN32
         if ((*pszCmd == '@') && nLen2) { pszCmd++; nLen2--; } // strip silencer
         #else
         if ((*pszCmd == '#') && nLen2) { pszCmd++; nLen2--; } // strip silencer
         #endif
         sprintf(szLineBuf2, "%s%.*s", bFirst ? "":" , ", (int)nLen2, pszCmd);
         if (chain.coldata)
            chain.addToCurLine(szLineBuf2, str(""));
         else
            printf("%s", szLineBuf2);
         bFirst = 0;
      }

      if (!chain.coldata)
         printf("\n");
   }

   fclose(fin);

   return lRC;
}

// for windows: convert "/" to "\\"
void setSystemSlashes(char *pdst)
{
   #ifdef _WIN32
   for (; *pdst; pdst++)
      if (*pdst == glblWrongPChar)
          *pdst = glblPathChar;
   #endif
}

void setNetSlashes(char *pdst)
{
   for (; *pdst; pdst++)
      if (*pdst == '\\')
          *pdst = '/';
}

int execFileStat(Coi *pcoi, int lLevel, int &lFiles, int &lDirs, num &lBytes, num &nLocalMaxTime, num &nTreeMaxTime, int nSinceReason)
{__
   char *pszFileName = pcoi->name();

   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFileTime = 0;
   num  nFileSize = 0;
   getFileStat(pszFileName, bIsDir, bCanRead, bCanWrite, nFileTime, nFileSize);

   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   listSingleFile(lLevel, pcoi, 0, 0, nSinceReason);
   cs.files++;
   nGlblBytes += nFileSize;

   if (pcoi->isHidden())
      cs.numHiddenFiles++;

   #ifndef VFILEZIP
   if (cs.travelzips) 
   {
      // char *psz1 = strrchr(pszFileName, '.');
      // if (psz1 && 
      //     (   !mystricmp(psz1, ".zip") || !mystricmp(psz1, ".jar") 
      //      || !mystricmp(psz1, ".war") || !mystricmp(psz1, ".aar") || !mystricmp(psz1, ".ear")
      //      || !mystricmp(psz1, ".xpi")
      //     )
      //    )
      bool endsWithArcExt(char *pname);
      if (endsWithArcExt(pszFileName))
      {
         // int getZipMD5(char *pszFile, SFKMD5 &md5, FileList &rFileList, bool bMakeList);
         int getZipList(char *pszFile, FileList &rFileList);
         // SFKMD5 md5;
         FileList oFiles;
         // uses szLineBuf2
         char *pszRootZip = pszFileName;
         if (!getZipList(pszRootZip, oFiles)) 
         {
            int nFiles = oFiles.clNames.numberOfEntries();
            for (int i=0; i<nFiles; i++) 
            {
               char *pRelSubName = oFiles.clNames.getEntry(i, __LINE__);
               num nSize = oFiles.clSizes.getEntry(i, __LINE__);
               num nTime = oFiles.clTimes.getEntry(i, __LINE__);

               // construct absolute, double-slashed name of zip file entry
               int nRootLen  = strlen(pszRootZip);
               int nSubLen   = strlen(pRelSubName);
               char *psubname = new char[nRootLen+nSubLen+10]; // TEMPORARY
               if (!psubname) return 9+perr("out of memory");
               sprintf(psubname, "%s%c%c%s", pszRootZip, glblPathChar, glblPathChar, pRelSubName);
               setSystemSlashes(psubname + nRootLen + 2);

               // create a temporary coi, which may be copied in listSingleFile.
               Coi *psub = new Coi(psubname, pszRootZip);
               psub->incref("efs"); // mark as used

               psub->setSize(nSize);
               psub->setTime(nTime);
               listSingleFile(lLevel+1, psub, pszRootZip, 0, nSinceReason);

               // cleanup temporary data
               delete [] psubname;  // was copied in ctr
               if (!psub->decref())
                  delete psub;      // no longer used

               cs.files++;
               nGlblBytes += nSize;
            }
         }
      }
   }
   #endif

   // update maxtimes
   if (nFileTime > nLocalMaxTime)
       nLocalMaxTime = nFileTime;
   if (nFileTime > nTreeMaxTime)
       nTreeMaxTime = nFileTime;

   lBytes += nFileSize;
   return 0;
}

int execFileTime(char *pszFileName)
{__
   FileStat ofs;

   if (ofs.readFrom(pszFileName))
      return 9+perr("cannot read: %s\n", pszFileName);

   ofs.dump();

   return 0;
}

int execDirTime(char *pszFileName)
{__
   if (cs.withdirs || cs.justdirs)
      return execFileTime(pszFileName);

   return 0;
}

FileStat glblTouchSrc;

struct FileTouchOpts {
   bool bATime;
   bool bMTime;
   bool bCTime;
   bool bUseWFT;
} glblTouchOpt;

int execTouch(char *pszDst, bool bSingleFileMode)
{__
   FileStat ofdst;
   
   if (ofdst.readFrom(pszDst))
      return 9+perr("cannot read: %s\n", pszDst);
      
   if (cs.sim) {
      printx("$totouch:<def> %s\n", pszDst);
      return 0;
   }

   if (glblTouchOpt.bATime) ofdst.src.nATime = glblTouchSrc.src.nATime;
   if (glblTouchOpt.bMTime) ofdst.src.nMTime = glblTouchSrc.src.nMTime;
   if (glblTouchOpt.bCTime) ofdst.src.nCTime = glblTouchSrc.src.nCTime;

   #ifdef _WIN32
   if (glblTouchOpt.bUseWFT)
   {
    if (glblTouchOpt.bATime) memcpy(&ofdst.src.ftATime, &glblTouchSrc.src.ftATime, sizeof(ofdst.src.ftATime));
    if (glblTouchOpt.bMTime) memcpy(&ofdst.src.ftMTime, &glblTouchSrc.src.ftMTime, sizeof(ofdst.src.ftMTime));
    if (glblTouchOpt.bCTime) memcpy(&ofdst.src.ftCTime, &glblTouchSrc.src.ftCTime, sizeof(ofdst.src.ftCTime));
   }
   #endif

   if (ofdst.writeTo(pszDst, __LINE__, 1))
      return 9+perr("cannot change time: %s\n", pszDst);

   if (!cs.quiet && (!bSingleFileMode || cs.verbose))
      printx("$touched:<def> %s\n", pszDst);

   return 0;
}

#ifdef WITH_FN_INST
int execInst(char *pszFileName, int lLevel, int &lFiles, int &lDirs, num &lBytes) 
{__
   extern int sfkInstrument(char *pszFile, cchar *pszInc, cchar *pszMac, bool bRevoke, bool bRedo, bool bTouchOnRevoke, int nmode);

   // source code automatic instrumentation
   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   int nmode = bGlblInstEol ? 1 : 0;

   int nRC = sfkInstrument(pszFileName, pszGlblInstInc, pszGlblInstMac, bGlblInstRevoke, bGlblInstRedo, bGlblTouchOnRevoke, nmode);

   if (nRC < 9)
      return 0;

   return nRC;
}
#endif

enum eRunExpressions 
{
   erun_path      = 0,
   erun_file      = 1,
   erun_file_     = 2,
   erun_relfile   = 3,
   erun_base      = 4,
   erun_ext       = 5,
   erun_since     = 6,
   erun_text      = 7
};

const char *apRunTokens[] =
{
   // new and simple     kept for compatibility     quoted expressions           new ease
   "path"    , ""      , "purepath"    , "ppath"  , "quotpath"     , "qpath"   , "",
   "file"    , ""      , "purefile"    , "pfile"  , "quotfile"     , "qfile"   , "",
   ""        , ""      , "pure_file"   , "p_file" , "quot_file"    , "q_file"  , "",
   "relfile" , "rfile" , "purerelfile" , "prfile" , "quotrelfile"  , "qrfile"  , "qrelfile",
   "base"    , ""      , "purebase"    , "pbase"  , "quotbase"     , "qbase"   , "",
   "ext"     , ""      , "pureext"     , "pext"   , "quotext"      , "qext"    , "",
   "since"   , ""      , "puresince"   , "psince" , "quotsince"    , "qsince"  , "",
   "text"    , ""       , ""            , ""       , "quottext"     , "qtext"   , "",
};

#define RUNTPR 7  // run tokens per row

// tell if a supplied user command references single files.
// if not, it will be applied on directories only.
bool anyFileInRunCmd(char *pszCmd) 
{
   char abToken[100];
   for (uint i=RUNTPR; i<(sizeof(apRunTokens)/sizeof(apRunTokens[0])); i++) 
   {
      strcpy(&abToken[1], apRunTokens[i]);
      if (!abToken[1]) continue;
      abToken[0] = '#';
      if (strstr(pszCmd, abToken))
         return true;
      #ifdef SFK_BOTH_RUNCHARS
      abToken[0] = '$';
      if (strstr(pszCmd, abToken))
         return true;
      #endif
   }
   return false;
}

bool anyTextInRunCmd(char *pszCmd) 
{
   char abToken[100];
   for (uint i=RUNTPR*7; i<(sizeof(apRunTokens)/sizeof(apRunTokens[0])); i++) 
   {
      strcpy(&abToken[1], apRunTokens[i]);
      if (!abToken[1]) continue;
      abToken[0] = '#';
      if (strstr(pszCmd, abToken))
         return true;
      #ifdef SFK_BOTH_RUNCHARS
      abToken[0] = '$';
      if (strstr(pszCmd, abToken))
         return true;
      #endif
   }
   return false;
}

int onRunExpression(char *psz1, int &lExpLength, bool &bquot, bool &btext)
{
   char abToken[100];
   uint nPtrs = (sizeof(apRunTokens)/sizeof(apRunTokens[0]));
   uint nRows = nPtrs / RUNTPR;
   for (uint irow=0; irow<nRows; irow++)
   {
      for (uint icol=0; icol < RUNTPR; icol++)
      {
         strcpy(&abToken[1], apRunTokens[irow * RUNTPR +icol]);
         abToken[0] = '#';
         if (!abToken[1]) continue;
         char *psz2 = abToken;
         if (!strncmp(psz1, psz2, strlen(psz2)))
         {
            lExpLength = strlen(psz2);
            bquot = (icol >= 4) ? true : false;
            if (strstr(psz2, "text")) btext=1;
            if (cs.debug) printf("orp %u %u - %s row %d\n", lExpLength, bquot, psz2, irow);
            return irow;
         }
         #ifdef SFK_BOTH_RUNCHARS
         else {
          abToken[0] = '$';
          if (!strncmp(psz1, psz2, strlen(psz2)))
          {
            lExpLength = strlen(psz2);
            bquot = (icol >= 4) ? true : false;
            if (strstr(psz2, "text")) btext=1;
            if (cs.debug) printf("orp %u %u - %s row %d\n", lExpLength, bquot, psz2, irow);
            return irow;
          }
         }
         #endif
      }
   }
   if (cs.debug) printf("orp none in %s\n", psz1);
   return -1;
}

bool isQuoteChar(char c)
{
   switch ((uchar)c) 
   {
      case '\"': return 1;
      case '\'': return 1;
      case 0x60: return 1;
      case 0x91: return 1;
      case 0x92: return 1;
      case 0x93: return 1;
      case 0x94: return 1;
   }
   return false;
}

int copyFormStr(char *pszDst, int nMaxDst, char *pszSrc, int nSrcLen, uint nflags=0);

// turn \+file into +file
char *unescf(char *pszFile)
{
   if (pszFile[0] == '\\')
      pszFile++;
   return pszFile;
}

// out   : pDstBuf with MAX_LINE_LEN
// uses  : szLineBuf
// rc    : 0 if replacements done, 1 if none found,
//         >= 9 on format error
int renderOutMask(char *pDstBuf, Coi *pcoi, char *pszMask, cchar *pszCmd)
{__
   char *pszInFile   = pcoi->name();
   char *pszFileName = pszInFile;

   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   // relativize filename. todo: used at all?
   if (cs.rootrelname)
      pszFileName = pcoi->rootRelName();

   // copy command template to command buffer
   copyFormStr(pDstBuf, MAX_LINE_LEN, pszMask, strlen(pszMask));

   // preparations
   char *pszRelFilename = relativeFilename(pszFileName);

   bool bDoneAny = 0;
   bool bUsingText = false;

   char *psz1 = strchr(pDstBuf, '#');
   #ifdef SFK_BOTH_RUNCHARS
   if (!psz1) psz1 = strchr(pDstBuf, '$');
   #endif
   while (psz1)
   {
      int lTokenLen = 0;
      bool bQuoted   = false;
      switch (onRunExpression(psz1, lTokenLen, bQuoted, bUsingText))
      {
         case erun_file:
         case erun_text:
         {
            // replace absolute filename
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszFileName);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_file_:
         {
            // absolute filename with blanks replaced by "_".
            // alpha - not yet official.
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            char *psz3 = szLineBuf+strlen(szLineBuf);
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszFileName);
            if (bQuoted) strcat(szLineBuf, "\"");
            // replace blanks, within target buffer
            while (*psz3) {
               if (*psz3 == ' ')
                   *psz3 = '_';
               psz3++;
            }
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_relfile:
         {
            // replace relative filename
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszRelFilename);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_path:
         {
            // replace filename path
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            char *psz3 = strrchr(pszFileName, glblPathChar);
            if (psz3 && (psz3-pszFileName)>0)
               strncat(szLineBuf, pszFileName, psz3-pszFileName);
            else
               strcat(szLineBuf, ".");
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_base:
         {
            // replace file base name, without ".ext"
            // have to use relative filename for this.
            // note: ".afile" has ".afile" as base
            // note: "afile.int.longext" has ".longext" as ext
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            char *psz3 = strrchr(pszRelFilename, '.');
            if (psz3 && (psz3 > pszRelFilename)) {
               // can identify extension
               strncat(szLineBuf, pszRelFilename, psz3-pszRelFilename);
            } else {
               // cannot identify extension
               strcat(szLineBuf, pszRelFilename);
            }
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_ext:
         {
            // replace file extension
            // have to use relative filename for this.
            // note: ".afile" has ".afile" as base
            // note: "afile.int.longext" has ".longext" as ext
            // note: "afile." has "" as extension
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
            char *psz3 = strrchr(pszRelFilename, '.');
            if (psz3 && (psz3 > pszRelFilename)) {
               // can identify extension, zero length accepted
               strcat(szLineBuf, psz3+1);
            } else {
               // cannot identify extension, leave empty
            }
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         case erun_since:
         {
            // replace absolute sincedir filename incl. root
            char *pszSinceFile = pcoi->ref(1); // returns null if none
            if (!pszSinceFile) {
               perr("missing reference name, cannot replace \"since\" token.\n");
               pinf("-sincedir/add/diff may not have been specified before.\n");
               pinf("a previous command may not support passing -since names.\n");
               return 9;
            }
            memset(szLineBuf, 0, sizeof(szLineBuf));
            strncpy(szLineBuf, pDstBuf, psz1-pDstBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf, "\"");
             strcat(szLineBuf, pszSinceFile);
            if (bQuoted) strcat(szLineBuf, "\"");
            // remember position past insert
            psz1 = pDstBuf+strlen(szLineBuf);
            // right
            strcat(szLineBuf, psz2);
            // copy back result
            mystrcopy(pDstBuf, szLineBuf, MAX_LINE_LEN);
            bDoneAny = 1;
            break;
         }

         default:
            psz1++;
            break;

      }  // end switch

      // find next potential token, if any
      #ifdef SFK_BOTH_RUNCHARS
      if (strchr(psz1, '#'))
         psz1 = strchr(psz1, '#');
      else
         psz1 = strchr(psz1, '$');
      #else
      psz1 = strchr(psz1, '#');
      #endif
   }

   // user error detection:
   // if filename contains blanks,
   if (!bUsingText && !cs.quiet && !cs.noinfo) {
      if (strchr(pszInFile, ' ')) {
         cs.blankRunFiles++;
         // then count quotes in produced expression
         int nlen  = strlen(pDstBuf);
         int nquot = 0;
         for (int i=0; i<nlen; i++)
            if (isQuoteChar(pDstBuf[i]))
               nquot++;
         if (nquot == 0) cs.badNameForm |= 1;
      }
      if (strchr(pszInFile, glblWrongPChar)) {
         cs.wrongpcRunFiles++;
         cs.badNameForm |= 2;
      }
   }

   return bDoneAny ? 0 : 1;
}

int submain(int argc, char *argv[], char *penv[], char *pszCmd, int iDir, bool &bFatal);

// run an sfk command, staying in the current process.
// cannot be used right now, as this requires that command
// chaining data is pushed and later popped on a stack.
int runInternal(char *pcmdraw)
{__
   mtklog(("runint: %s", pcmdraw));

   int nrc = 9;

   #ifndef USE_SFK_BASE

   // split whole command string into command and args
   char *pcmd = strdup(pcmdraw);
   CharAutoDel odel(pcmd);

   // e.g.: list mydir .txt
   int nsubargc = 0; 
   char *psubargv[100+10];
   mclear(psubargv);

   char *psz = pcmd;
   while (*psz && (nsubargc < 100))
   {
      skipWhite(&psz);
      psubargv[nsubargc++] = psz;
      char *pcur = psz;
      skipToWhite(&psz);
      if (*psz) *psz++ = '\0';
      printf("[%s] ",pcur);
   }
   printf("\n");

   char *pszSubCmd = psubargv[0];
   int iSubDir = 1;
   // if chain starts like "sfk ...", skip "sfk":
   if (!strcmp(pszSubCmd, "sfk")) {
      pszSubCmd = psubargv[1];
      iSubDir = 2;
   }
   
   bool bFatal = 0;

   // TODO: push command chaining data, provide clean one
   nrc = submain(nsubargc, psubargv, 0, pszSubCmd, iSubDir, bFatal);
   // TODO: pop old command chaining data

   #endif // USE_SFK_BASE

   return nrc;
}

int execRunFile(Coi *pcoi, char *pszOutFile,
   int lLevel, int &lFiles, int &lDirs, num &lBytes
   ) 
{__
   char *pszFileName = pcoi->name();

   mtklog(("execRunFile: %s", pszFileName));

   int nrc = renderOutMask(szRunCmdBuf, pcoi, cs.runCmd, "run"); // execRun
   if (nrc >= 9) return nrc;

   bool bDoneAny = (nrc == 0);

   if (!bDoneAny && !cs.force)
      return 9+perr("no valid token in run command. type \"sfk run\" for help.\n");

   int  iRC = 0;
   bool btoldcmd = 0; // command was fully printed, but w/o rc
   bool btoldrc  = 0; // rc status was printed
   char szAddInfo[200];
   int nclines = 0; // no. of collected lines, if any

   if (cs.sim) 
   {
      // simulation: just dump resulting command to terminal
      printf("%s\n", szRunCmdBuf);
      btoldcmd = 1;
   } 
   else 
   {
      SFTmpFile ftmp(".txt", cperm.keeptmp);
      char *pszTmpFile = 0;

      // if -to outfile specified, OR collecting chain data
      if (pszOutFile || chain.coldata)
      {
         // prepare redirection of command output
         pszTmpFile = pszOutFile ? pszOutFile : ftmp.name();
         if (!pszTmpFile) return 9;
         int nlen = strlen(szRunCmdBuf);
         if (nlen > MAX_LINE_LEN-20)
            return 9+perr("command buffer overflow\n");
         // todo: detect > and print warn if -to used
         // todo: detect > within double quotes
         sprintf(&szRunCmdBuf[nlen], " >\"%s\"", pszTmpFile);
         // todo: detect 2> within double quotes
         if (!strstr(szRunCmdBuf, " 2>")) // AND " 2>>"
            strcat(szRunCmdBuf, " 2>&1");

         // create output directories on demand
         // uses: szLineBuf, abBuf
         int createOutDirTree(char *pszOutFile);
         if (pszOutFile)
            if (createOutDirTree(pszOutFile))
               return 9;

         // print pre-execution info
         if (cs.printcmd) {
            printf("%s\n", szRunCmdBuf);
            btoldcmd = 1;
         }
         else
         if (!cs.quiet) {
            info.setStatus("run", pszFileName); // temporary display
            // cmd is not yet permanently printed
         }
      }
      else
      if (!cs.quiet) {
         // non-chaining: command will dump its output to terminal
         if (cs.printcmd) {
            printf("%s\n", szRunCmdBuf);
            btoldcmd = 1;
         } else {
            info.setStatus("run", pszFileName);
            info.printLine(1<<2);
            btoldcmd = 1;
         }
      }

      if (!cs.nonames && chain.coldata) {
         sprintf(szLineBuf3, ":file %s", pszFileName);
         // note: +view scans extended end of attribute line
         //       to identify 'f'ile header lines, therefore +2:
         setattr(szAttrBuf3, 'f', strlen(szLineBuf3)+2, MAX_LINE_LEN);
         chain.addLine(szLineBuf3, szAttrBuf3);
      }

      if (cs.intrun)
         iRC = runInternal(szRunCmdBuf);
      else
         iRC = system(szRunCmdBuf);

      if (chain.coldata && pszTmpFile) 
      {
         // chaining: collect redirected command output
         FILE *fin = fopen(pszTmpFile, "rb");
         if (!fin) return 9+perr("cannot read command output file: %s\n", pszTmpFile);
         myfgets_init();
         while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin))
         {
            szLineBuf[sizeof(szLineBuf)-10] = '\0';
            removeCRLF(szLineBuf);
            chain.addLine(szLineBuf, str(""));
            nclines++;
         }
         fclose(fin);
      }

      // by default, tmpfile is autodeleted here
   }

   if (!cs.quiet && !btoldcmd) {
      if (pszOutFile) {
         if (chain.coldata)
            sprintf(szAddInfo, "cached %d lines, rc %d", nclines, iRC);
         else
            sprintf(szAddInfo, "rc %d", iRC);
         info.setStatus("wrote", pszOutFile, szAddInfo);
         info.printLine(1<<2);
         btoldrc = 1;
      }
      else
      if (chain.coldata) {
         sprintf(szAddInfo, "%d lines, rc %d", nclines, iRC);
         info.setStatus("run", pszFileName, szAddInfo);
         btoldrc = 1;
      }
   }

   // extra chain support:
   if (chain.colfiles) {
      // next chain step expects filename list
      if (!chain.usefiles || pszOutFile) {
         // there is either nothing to pass thru,
         // or the filenames changed on output, so create new list:
         if (pszOutFile) {
            Coi ocoi(pszOutFile, 0);
            chain.addFile(ocoi); // is copied
         } else {
            chain.addFile(*pcoi); // pass input file
         }
      }
   }

   if (cs.stoprc && iRC >= cs.stoprc) {
      perr("... rc %d - stopping due to return code.\n",iRC);
      return 9;
   }
   else
   if (!cs.quiet && !cs.sim && !btoldrc) {
      if (iRC) {
         printf("... rc %d\n", iRC);
         fflush(stdout);
      }
   }

   return 0;
}

int execRunDir(Coi *pcoi, int lLevel, int &lFiles, int &lDirs, num &lBytes) 
{__
   char *pszFileName = pcoi->name();

   if (!strcmp(pszFileName, "."))
      return 0;

   if (!strncmp(pszFileName, glblDotSlash, 2))
      pszFileName += 2;

   // copy command template to command buffer
   copyFormStr(szLineBuf, MAX_LINE_LEN, cs.runCmd, strlen(cs.runCmd), 0);

   bool bDoneAny = 0;
   char *psz1 = strchr(szLineBuf, '#');
   #ifdef SFK_BOTH_RUNCHARS
   if (!psz1) psz1 = strchr(szLineBuf, '$');
   #endif
   while (psz1)
   {
      int lTokenLen = 0;
      bool bQuoted   = false;
      bool bText     = false;
      switch (onRunExpression(psz1, lTokenLen, bQuoted, bText))
      {
         case erun_path:
         case erun_text:
         {
            // replace filename path
            memset(szLineBuf2, 0, sizeof(szLineBuf2));
            strncpy(szLineBuf2, szLineBuf, psz1-szLineBuf);
            // middle
            char *psz2 = psz1+lTokenLen;
            if (bQuoted) strcat(szLineBuf2, "\"");
             strcat(szLineBuf2, pszFileName);
            if (bQuoted) strcat(szLineBuf2, "\"");
            // remember position past insert
            psz1 = szLineBuf+strlen(szLineBuf2);
            // right
            strcat(szLineBuf2, psz2);
            // copy back result
            strncpy(szLineBuf, szLineBuf2, sizeof(szLineBuf));
            bDoneAny = 1;
            break;
         }

         default:
            psz1++;
            break;
      }

      // find next potential token, if any
      #ifdef SFK_BOTH_RUNCHARS
      if (strchr(psz1, '#'))
         psz1 = strchr(psz1, '#');
      else
         psz1 = strchr(psz1, '$');
      #else
      psz1 = strchr(psz1, '#');
      #endif
   }

   if (!bDoneAny && !cs.force)
      return 9+perr("no valid token in run command. type \"sfk run\" for help.\n");

   if (!cs.quiet && !cs.sim) {
      printf("%s\n", szLineBuf);
      fflush(stdout); 
   }

   int iRC = 0;

   if (cs.sim) {
      // special case: just dump resulting command to terminal
      printf("%s\n", szLineBuf);
   } else {
      if (cs.intrun)
         iRC = runInternal(szLineBuf);
      else
         iRC = system(szLineBuf);
   }

   if (!cs.quiet && !cs.sim) {
      if (iRC) {
         printf("... error, rc %d\n", iRC);
         fflush(stdout);
      }
   }

   // extra chain support:
   if (chain.colfiles) {
      // next chain step expects filename list
      if (!chain.usefiles) {
         // but there is nothing to pass thru, so create
         chain.addFile(*pcoi);
      }
   }

   return 0;
}

int execDirStat(Coi *pcoi, int lLevel, int lFiles, int lDirs, num lBytes, num &nLocalMaxTime, num &ntime2)
{__
   char *pszDir = pcoi->name();

   StringPipe *pout = 0;
   if (chain.coldata)
      pout = chain.outdata;

   if (nGlblListMode == 1)
   {
      int nIndent = (int)lLevel;
      if (nIndent > (int)strlen(pszGlblBlank)) nIndent = strlen(pszGlblBlank);
      if (nIndent > 10) nIndent = 10;
   
      if (!strncmp(pszDir, glblDotSlash, 2))
         pszDir += 2;
   
      int lMBytes = (lBytes / 1000000UL);

      if (cs.statonlysum)
      { }
      else
      if (cs.quiet) {
         if (lLevel == 0)
            oprintf(pout, "%5d mb %s\n", lMBytes, pszDir);
      } else {
         if (lBytes < 0) // for sfk sel -withdirs ... +stat
         { } // print nothing, there are no stats.
         else
         if (lBytes < nGlblListMinSize)
         { } // print nothing, dir content too small to list.
         else
         {
            // dir content size can be listed
            if (lLevel <= cs.stathilitelevel) setTextColor(nGlblFileColor);
            switch (cs.listunit) {
               case 'b':
                  oprintf(pout, "%s, %5d files, %.*s%s\n", numtoa_blank(lBytes, 12), lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
               case 'k':
                  oprintf(pout, "%s kb, %5d files, %.*s%s\n", numtoa_blank(lBytes/1000, 10), lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
               default :
                  oprintf(pout, "%5ld mb, %5d files, %.*s%s\n", lMBytes, lFiles, nIndent, pszGlblBlank, pszDir);
                  break;
            }
            if (lLevel <= cs.stathilitelevel) setTextColor(-1);
         }
      }
   }
   else
   if (nGlblListMode == 2)
   {
      if ((cs.withdirs || cs.justdirs) && strcmp(pszDir, "."))
         listSingleFile(lLevel, pcoi, 0, 1, 0);
   }

   cs.dirs++;
   if (pcoi->isHidden())
      cs.numHiddenDirs++;

   return 0;
}

bool matchesCurrentRoot(char *pszDir)
{
   if (!glblFileSet.hasRoot(0)) return false;
   char *pszRoot = glblFileSet.getCurrentRoot();
   if (!pszRoot) { perr("internal 812064\n"); return false; }
   bool brc = equalFileName(pszDir, pszRoot);
   // printf("%d = mcr(%s)\n", brc, pszDir);
   return brc;
}

bool isEmptyDir(char *pszIn)
{
   bool bRC = 1;

   int lSize1       = strlen(pszIn);
   char *pszPattern  = new char[lSize1+10];
   char *pszBasePath = new char[lSize1+10];

   // pszIn might be
   // -  a directory, with or w/o slash at end
   // -  a pattern expression: dir\a*b??.cpp
   char *pszLastSlash = strrchr(pszIn, glblPathChar);

   if (!pszLastSlash) {
      strcpy(pszBasePath, pszIn);
      joinPath(pszPattern, lSize1+10, pszIn, (char*)glblAddWildCard);
   } else {
      joinPath(pszPattern, lSize1+10, pszIn, (char*)glblAddWildCard);
      strcpy(pszBasePath, pszIn);
   }

   #ifdef _WIN32 // --------- Windows directory walking code ----------

   #ifdef SFK_W64
   SFKFindData myfdat;
   intptr_t myfdh = _findfirst64(pszPattern, &myfdat);
   #else
    #ifndef _INTPTR_T_DEFINED
     typedef int intptr_t;
    #endif
   SFKFindData myfdat;
   intptr_t myfdh = _findfirst(pszPattern, &myfdat);
   #endif

   if (myfdh == -1) {
      delete [] pszPattern;
      delete [] pszBasePath;
      return 1; // yes, seems to be empty
   }

   do
   {

   #else // ----------- unix directory walking code -------------

   SFKFindData myfdat;

   DIR *myfdh = opendir(pszPattern);

   if (!myfdh) {
      delete [] pszPattern;
      delete [] pszBasePath;
      return 1;
   }

   while (1)
   {
      struct dirent *e = readdir(myfdh);
      if (e == NULL)
         break; // while

      memset(&myfdat, 0, sizeof(myfdat));
      myfdat.name   = e->d_name;
      myfdat.attrib = 0;

   #endif // _WIN32
   
      char *pszFile = myfdat.name;

      if (   !strcmp(pszFile, ".")
          || !strcmp(pszFile, ".."))
         continue;

      // first "real" file reached
      bRC = 0;
      break;
   }
   #ifdef _WIN32
    #ifdef SFK_W64
    while (!_findnext64(myfdh, &myfdat));
    #else
    while (!_findnext(myfdh, &myfdat));
    #endif
   _findclose(myfdh);
   #else
   closedir(myfdh);
   #endif

   delete [] pszPattern;
   delete [] pszBasePath;

   if (cs.verbose >= 2)
      printf("%d = isEmptyDir(%s)\n", bRC, pszIn);

   return bRC;
}

class AutoCoiDirClose {
public:
      AutoCoiDirClose (Coi *pcoi) { pClCoi = pcoi; }
     ~AutoCoiDirClose ( ) {
         if (pClCoi->isDirOpen()) {
            mtklog(("auto-close coi %p", pClCoi));
            pClCoi->closeDir();
         }
      }
   Coi *pClCoi;
};

/*
class AutoCoiRelease {
public:
      AutoCoiRelease (Coi *pcoi) { pClCoi = pcoi; } // or NULL
     ~AutoCoiRelease ( ) {
         if (pClCoi)
            pClCoi->decref();
      }
   Coi *pClCoi;
};
*/

// NOTE: walkFiles does NOT accept stack-based AUTOMATIC Coi's!
//       whatever ptop is passed into here must've been created
//       with "new", otherwise the reference counting will fail.
int walkFiles(
   Coi *ptop, int lLevel,
   int &nGlobFiles, FileList &rParentDirFiles,
   int &lDirs, num &lBytes,
   num &nLocalMaxTime, num &nTreeMaxTime
 )
{__ _p("sf.wfiles")

   mtklog(("walkFiles %s", ptop->name()));

   // printf("wfl %s\n", ptop->name());

   if (bGlblEscape)
      return 0;

   int lRC = 0;

   // this function accepts
   // -  directory Cois   like c:\\thedir
   // -  single file Cois like c:\\thefile.txt

   Coi *psub = 0;

   // in case of a return, make sure dirs are closed:
   AutoCoiDirClose odirclose(ptop);

   bool bTravelTop = ptop->isTravelDir();

   #ifndef _WIN32
   // if on top level, reset the circle map, to avoid
   // unwanted blockings on multi-root dir commands:
   if (lLevel <= 0) {
      mtklog((" wfiles1.level0: resetting circle map"));
      glblCircleMap.reset();
   }
   // check for circular (endless) travels:
   if (cs.usecirclemap && bTravelTop && ptop->haveFileID()) {
      if (glblCircleMap.isset(ptop->getFileID())) {
         if (cs.debug)
            pinf("fileid already set: %s\n", ptop->getFileID());
         if (cs.showdupdirs)
            pinf("skipping content, already done: %s\n", ptop->name());
         bTravelTop = 0;
      } else {
         // printf("node %xh is not set: %s\n", (uint)ptop->getNode(),ptop->name());
      }
   }
   #endif

   if (bTravelTop)
   {
      mtklog((" wfiles1.travel %s", ptop->name()));
      // open dir for traversal
      if (ptop->openDir()) {
         if (cs.verbose > 1)
            printf("cannot read dir: %s\n", ptop->name());
         return 0;
      }
      // fetch first entry
      psub = ptop->nextEntry();
      mtklog((" wfiles1.get1st of coi %p sub %p", ptop, psub));
      // caller (we) MUST RELEASE COI after use!
      // if refcnt is zero then, we also DELETE it.
      if (!psub) {
         if (cs.verbose > 1)
            printf("empty dir: %s\n", ptop->name());
         return 0; // empty directory
      }
      #ifdef VFILEBASE
      // if top is virtual, cache it now, as the child members
      // may need the data. do not use ptop->name() to check
      // the cache, as a redirect may have renamed the coi.
      // NOTE: caching is the reason why automatic cois
      //       are strictly not allowed as ptop.
      if (ptop->isVirtual() && !ptop->isCached())
      {
         mtklog(("vpar-register %s", ptop->orgName()));
         glblVCache.put(ptop->orgName(), ptop, "wf");
         // ptop is now MANAGED BY CACHE.
         // cache has incremented the refcnt.
      }
      #endif // VFILEBASE
      #ifndef _WIN32
      // remember that we traveled this directory:
      if (ptop->haveFileID()) {
         // printf("node %xh is stored: %s\n", (uint)ptop->getNode(),ptop->name());
         glblCircleMap.put(ptop->getFileID());
      }
      #endif
   }
   else
   if (ptop->status() >= 9) {
      // non-existing filesystem object:
      if (lLevel < 1 || cs.verbose)
         pwarn("cannot read: %s\n", ptop->name());
      mtklog((" wfiles1.noread %s", ptop->name()));
      return 0;
   } else {
      // process dir or file w/o traveling:
      mtklog((" wfiles1.any %s coi %p", ptop->name(), ptop));
      psub = ptop;
      // NOTE: WE DO NOT OWN psub NOW.
      // must check later if == ptop.
   }

   do
   {
     if (psub->isHidden() && !cs.hidden)
     {
         // hidden or system file or dir,
         // but inclusion of hidden not selected: skip
         if (psub->isAnyDir()) {
            mtklog((" wfiles2.hidden.dir %s", psub->name()));
            cs.numHiddenDirsSkipped++;
         } else {
            mtklog((" wfiles2.hidden.file %s", psub->name()));
            cs.numHiddenFilesSkipped++;
         }
     }
     else
     {
      if (psub->isAnyDir())
      {
         // subdirectory
         mtklog((" wfiles2.isdir %s", psub->name()));

         // allowed to travel?
         bool bTravelSub = 0;

         if (psub == ptop) {
            bTravelSub = bTravelTop;
         } else {
            bTravelSub = psub->isTravelDir();
            #ifdef VFILEBASE
             #ifdef DEEP_FTP
             if (psub->isFtp()) { } else
             #endif
             if (psub->isNet()) {
               bTravelSub = 0;
             }
            #endif // VFILEBASE
         }

         FileList oLocDirFiles;
         int nTreeFileCnt = 0;
         int nDirDirs  = 0;
         num  nDirBytes = 0, nDirLocalMaxTime = 0, nDirTreeMaxTime = 0;

         bool bMatch = 1;

         #ifndef USE_SFK_BASE
         // some commands want to skip own meta dir
         if (cs.skipOwnMetaDir) {
            if (filedb.metaDir() && !mystricmp(filedb.metaDir(), psub->name()))
               bMatch = 0;
         }
         #endif // USE_SFK_BASE
 
         if (bMatch)
         {
            bMatch = matchesDirMask(psub->name(), 1, 0); // on subdir
            // ,1 : take full path as it's a dir name
            // ,0 : check only against negative dir masks
         }

         // general processing: recursion and the like
         if (bMatch)
         {
            // char *pszRoot = glblFileSet.root(1); // returns 0 if none

            if (bTravelSub && cs.subdirs && !(psub->isLink() && cs.skipLinks)) 
            {
               mtklog((" wfiles2.walksub top=%p sub=%p %s", ptop, psub, psub->name()));
               lRC = walkFiles(psub, lLevel+1, nTreeFileCnt, oLocDirFiles, nDirDirs, nDirBytes,
                               nDirLocalMaxTime, nDirTreeMaxTime);
            } else {
               lRC = 0;
            }

            lDirs++; // count directory as processed

            if (!cs.stopTree(lRC))
            {
               if (cs.debug) printf("] esd: %d %s files=%d ts=%d sd=%d\n", lLevel, psub->name(), nTreeFileCnt, bTravelSub, cs.subdirs);
               lRC = execSingleDir(psub, lLevel+1, nTreeFileCnt, oLocDirFiles, nDirDirs, nDirBytes,
                                   nDirLocalMaxTime, nDirTreeMaxTime);
               if (cs.stopTree(lRC))
               {
                  nDirLocalMaxTime = 0;
                  break; // while
               }
               lRC = 0;
            }
            nDirLocalMaxTime = 0;

            // NOTE: local maxtime is NOT promoted, it was used w/in execSingleDir.
            //       we only promote the tree max time:
            if (nDirTreeMaxTime > nTreeMaxTime)
                nTreeMaxTime = nDirTreeMaxTime;

         }  // endif bmatch

         // add subdir stats to next higher level
         if (cs.flatdirstat) {
            cs.flatfilecnt += nTreeFileCnt;
            cs.flatdircnt  += nDirDirs ;
            cs.flatbytecnt += nDirBytes;
         } else {
            nGlobFiles += nTreeFileCnt;
            lDirs      += nDirDirs ;
            lBytes     += nDirBytes;
         }

         if (cs.stopTree(lRC))
            break; // while

         lRC = 0;
      }
      else
      if ((lLevel<1) && bGlblNoRootDirFiles && matchesCurrentRoot(ptop->name())) {
         mtklog((" wfiles2.skip %s", psub->name()));
         // list -dir +simp +test: walk "." but do not process files,
         // we only want to filter the contained directories.
      }
      else
      {
         // normal file: check dir mask also against full file path
         bool bpmmatch = matchesDirMask(psub->name(), cs.incFNameInPath, 1); // on file
         // ,0 : default is not to include filename, extract path first
         // ,1 : check both black and white masks against file path

         // normal file: check mask against file name WITHOUT path
         if (bpmmatch && (matchesFileMask(psub->relName(), psub->name()) > 0))
         {
            mtklog((" wfiles2.match %s", psub->name()));

            // char *pszRoot = glblFileSet.root(1); // returns 0 if none

            // TODO: set psub->root here?
            if (cs.justdirs) {
               // since sfk 1.5.5, -justdirs counts the number of matching files
               // within a folder, but does not process any of those files.
               lRC = 0;
            } else {
               lRC = execSingleFile(psub, lLevel+1,
                           nGlobFiles, rParentDirFiles.clNames.numberOfEntries(),
                           lDirs, lBytes,
                           nLocalMaxTime, nTreeMaxTime);
            }
            
            if (cs.stopTree(lRC))
               break; // while
            else
            if (!lRC)
            {
               // count file as processed.
               nGlobFiles++;
               if (!cs.skipDirFileColl)
                  // TODO: add to a coi list here?
                  if (rParentDirFiles.addFile(psub->name(), glblFileSet.root(), psub->getTime(), psub->getSize()))
                     return 9; // shouldn't happen (outofmem)
            }
            lRC = 0;
         } else {
            mtklog((" wfiles2.miss  %s pmatch=%d", psub->name(), bpmmatch));
         }
      } // endelse dir or file
     } // endelse hidden

      // cleanup current sub entry:
      if (psub != ptop) {
         // decrement refcnt, and optionally delete
         if (!psub->decref())
            delete psub; // no refs remaining, not cached
         psub = 0;
      }

      if (userInterrupt())
         break;

      if (!bTravelTop)
         break;   // single dir or file processed

      psub = ptop->nextEntry();

      mtklog((" sub %p = wfiles2.getnext of coi %p", psub, ptop));
      mtklog((" (%s = wfiles2.getnext of coi %s)", psub ? psub->name():"", ptop ? ptop->name():""));
   }
   while (psub);

   // cleanup sub on loop break:
   if (psub && (psub != ptop)) {
      if (!psub->decref())
         delete psub; // no refs remaining, not cached
      psub = 0;
   }

   if (bTravelTop) {
      mtklog(("top travel done, close coi %p", ptop));
      ptop->closeDir();
   }

   // mtklog(("%d = walkfiles.end", lRC));
   return lRC;
}

int dumpBlock(uchar *pCur, int lSize, int nmode)
{
   FILE *fout = fGlblOut;
   int i=0;
   switch (nmode) 
   {
      case 2:
      {
         bool bAddPad = ((lSize & 1) != 0);
         fprintf(fout, "\t\"");
         uchar u1, u2;
         for (i=0; i<lSize; i += 2) {
            // if input has uneven size, the very last byte
            // is not read from input, but filled with dummy 0xFF.
            u1 = pCur[i+0];
            if (i < lSize-2 || !bAddPad)
               u2 = pCur[i+1];
            else
               u2 = 0xFF;
            fprintf(fout, "\\u%02x%02x", u1, u2);
         }
         fprintf(fout, "\",");
      }
         break;

      case 1:
         for (i=0; i<lSize; i++) {
            if (pCur[i])
               fprintf(fout, "0x%x,", pCur[i]);
            else
               fprintf(fout, "0,");
         }
         break;

      default:
         for (i=0; i<lSize; i++)
            fprintf(fout, "%u,", (unsigned int)pCur[i]);
         break;
   }
   fprintf(fout,"\n");
   return 0;
}

uchar *binPack(uchar *pIn, uint nInSize, ulong &rnOutSize)
{__
   ulong nOutSize = 0;
   uchar *pOut = 0;
   uchar *pMem = 0;
   uchar *pMax = pIn + nInSize;
   uchar *pCur = 0;
   uchar *pOld = 0;
   uchar *pNul = 0;

   for (uchar npass=1; npass <= 2; npass++)
   {
      if (npass == 1)
         pOut = pNul;
      else {
         pMem = new uchar[nOutSize];
         pOut = pMem;
      }

      pCur = pIn;
      pOld = pCur;

      while (pCur < pMax)
      {
         // detect repetition of patterns up to size 3
         uchar nbestsize = 0;
         uchar nbestgain = 0;
         uchar nbestrep  = 0;
         for (uchar isize = 1; isize <= 3; isize++) {
            uchar nrep  = 0;
            uchar bbail = 0;
            for (; (pCur+(nrep+1)*isize < pMax) && (nrep < 60) && !bbail; nrep++)
            {
               for (uchar i1=0; (i1<isize) && !bbail; i1++)
                  if (pCur[nrep*isize+i1] != pCur[i1])
                     bbail = 1;
               if (bbail)
                  break;
            }
            // this always results in nrep >= 1.
            uchar ngain = (nrep-1)*isize;
            if (ngain >= 3) {
               // there is a repetition, saving at least 3 bytes.
               // determine max savings accross all sizes.
               if (ngain > nbestgain) {
                  nbestgain = ngain;
                  nbestsize = isize;
                  nbestrep  = nrep;
               }
            }
         }
         // if (nbestrep > 0)
         //   printf("size %02u rep %02u gain %02u at %x\n", nbestsize, nbestrep, nbestgain, pCur-pIn);

         // if repeat pattern found,
         // OR if non-repeat exceeds maxsize
         if ( (nbestrep > 0) || ((pCur - pOld) >= 60) ) {
            // flush non-packable, if any
            if (pCur > pOld) {
               // printf("[flush non-pack %x]\n", pCur-pOld);
               uchar nDist = pCur-pOld;
               if (npass == 1) {
                  pOut++;
                  pOut += (pCur - pOld);
               } else {
                  *pOut++ = 0x00 | nDist;
                  while (pOld < pCur)
                     *pOut++ = *pOld++;
               }
               pOld  = pCur;
            }
            // flush packable, if any
            if (nbestrep > 0) {
               // printf("[pack %x %x]\n", nbestsize, nbestrep);
               if (npass == 1) {
                  pOut++;
                  pOut += nbestsize;
                  pCur += nbestsize;
               } else {
                  *pOut++ = (nbestsize << 6) | nbestrep;
                  for (uchar i1=0; i1<nbestsize; i1++)
                     *pOut++ = *pCur++;
               }
               pCur += (nbestrep-1)*nbestsize;
               pOld  = pCur;
            }
         } else {
            // count non-packable
            pCur++;
         }
      }

      // flush remainder, if any
      if (pCur > pOld) {
         // printf("[flush trailer %x]\n", pCur-pOld);
         uchar nDist = pCur-pOld;
         if (npass == 1) {
            pOut++;
            pOut += (pCur - pOld);
         } else {
            *pOut++ = 0x00 | nDist;
            while (pOld < pCur)
               *pOut++ = *pOld++;
         }
         pOld  = pCur;
      }

      if (npass == 1) {
         nOutSize = (ulong)(pOut - pNul);
         // printf("packsize %lu\n", nOutSize);
      }
   }

   rnOutSize = nOutSize;
   return pMem;
}

uchar *binUnpack(uchar *pIn, uint nInSize, ulong &rnOutSize)
{__
   ulong nOutSize = 0;
   uchar *pOut = 0;
   uchar *pMem = 0;
   uchar *pMax = pIn + nInSize;
   uchar *pCur = 0;
   uchar *pOld = 0;
   uchar *pNul = 0;

   for (uchar npass=1; npass <= 2; npass++)
   {
      if (npass == 1)
         pOut = pNul;
      else {
         pMem = new uchar[nOutSize];
         pOut = pMem;
      }

      pCur = pIn;
      pOld = pCur;

      while (pCur < pMax)
      {
         uchar ncmd = *pCur++;
         if (ncmd >= 64) {
            // unpack repeat block
            uchar nsiz = ncmd >> 6;
            uchar nrep = ncmd & 0x3F;
            // printf("[upack-rep %x %x (%x)]\n", nsiz, nrep, ncmd);
            // reproduce reference pattern nrep times
            if (npass == 1)
               pOut += nrep * nsiz;
            else
            for (; nrep > 0; nrep--)
               for (uchar i1=0; i1<nsiz; i1++)
                  *pOut++ = *(pCur+i1);
            // skip reference pattern
            pCur += nsiz;
         } else {
            // unpack skip block
            uchar nrep = ncmd;
            // printf("[upack-skip %x]\n", nrep);
            if (npass == 1) {
               pOut += nrep;
               pCur += nrep;
            }
            else
            for (; (nrep > 0) && (pCur < pMax); nrep--)
               *pOut++ = *pCur++;
         }
      }

      if (npass == 1) {
         nOutSize = (ulong)(pOut - pNul);
         // printf("unpacksize %lu\n", nOutSize);
      }
   }

   rnOutSize = nOutSize;
   return pMem;
}

int execBinToJava(uchar *pIn, int lInSize, bool bPack, char *pszNameBase, bool bClass, int nRecSize)
{__
   FILE *fout = fGlblOut;

   if (bClass)
   fprintf(fout,
      "\n"
      "import java.io.*;\n"
      "\n"
      "public class %s {\n"
      "\n"
      "\tpublic static void main(String args[]) throws Throwable {\n"
      "\t\tbyte abData[] = %s_getBlock();\n"
      "\t\tFileOutputStream fout = new FileOutputStream(args[0]);\n"
      "\t\tfout.write(abData, 0, abData.length);\n"
      "\t}\n"
      "\n"
      ,pszNameBase,pszNameBase
      );

   fprintf(fout, 
      "\tpublic static int %s_BlockSize = %d;\n"
      "\tstatic String %s_RawBlock[] = {\n"
      ,pszNameBase,lInSize,pszNameBase);

   int lRemain = lInSize;
   uchar *pCur  = pIn;
   while (lRemain > nRecSize) {
      dumpBlock(pCur, nRecSize, 2);
      lRemain -= nRecSize;
      pCur += nRecSize;
   }
   if (lRemain > 0)
      dumpBlock(pCur, lRemain, 2);

   fprintf(fout, "\t};\n\n");

   char *pname=pszNameBase;
   fprintf(fout,
      "\tpublic static byte[] %s_getBlock() {\n"
      "\t   int iout=0, nblen=%s_BlockSize;\n"
      "\t   char atmp[] = new char[%d];\n"
      "\t   byte aout[] = new byte[nblen];\n"
      "\t   for (int i=0; i<%s_RawBlock.length; i++) {\n"
      "\t      String stmp = %s_RawBlock[i];\n"
      "\t      int nlen = stmp.length();\n"
      "\t      stmp.getChars(0,nlen,atmp,0);\n"
      "\t      for (int k=0; k<nlen; k++) {\n"
      "\t         char c = atmp[k];\n"
      "\t         byte bhi = (byte)(c >> 8);\n"
      "\t         byte blo = (byte)(c >> 0);\n"
      "\t         aout[iout++] = bhi;\n"
      "\t         if (iout < nblen)\n"
      "\t            aout[iout++] = blo;\n"
      "\t      }\n"
      "\t   }\n"
      "\t   return aout;\n"
      "\t}\n\n"
      ,pname,pname,nRecSize,pname,pname
      );

   if (bClass)
   fprintf(fout,
      "}\n\n"
      );

   return 0;
}

int execBinToCpp(uchar *pIn, int lInSize, bool bPack, char *pszNameBase, bool bHex)
{__
   int lOldInSize = lInSize;

   if (bPack) {
      ulong nPackSize = 0;
      // binPack alloc's mem block with packed data
      pIn = binPack(pIn, lInSize, nPackSize);
      lInSize = (int)nPackSize;
   }

   fprintf(fGlblOut,"#define %s_BLOCK_SIZE %u\n\n", pszNameBase, lOldInSize);
   fprintf(fGlblOut,"static unsigned char %s_abRawBlock[%u] = {\n", pszNameBase, lInSize);
   int lRemain = lInSize;
   uchar *pCur  = pIn;
   while (lRemain > 32) {
      dumpBlock(pCur, 32, bHex ? 1 : 0);
      lRemain -= 32;
      pCur += 32;
   }
   if (lRemain > 0)
      dumpBlock(pCur, lRemain, bHex ? 1 : 0);
   fprintf(fGlblOut,"};\n");

   if (bPack) {
fprintf(fGlblOut,
   "\n"
   "// input : target buffer and buffer size.\n"
   "//         must have size >= %s_BLOCK_SIZE.\n"
   "// result: 0 if OK, 9 on buffer overflow.\n"
   "// note  : output data is not null terminated.\n"
   "int %s_getBlock(uchar *pOut, uint nOutSize)\n",
   pszNameBase, pszNameBase
   );
fprintf(fGlblOut,
   "{\n"
   "   uchar *pCur    = %s_abRawBlock;\n"
   "   uint nInSize  = %u;\n"
   "   uchar *pMax    = pCur + nInSize;\n"
   "   uchar *pOutMax = pOut + nOutSize;\n"
   "   while (pCur < pMax)\n"
   "   {\n"
   "      uchar ncmd = *pCur++;\n"
   "      if (ncmd >= 64) {\n"
   "         uchar nsiz = ncmd >> 6;\n"
   "         uchar nrep = ncmd & 0x3F;\n"
   "         for (; nrep > 0; nrep--)\n"
   "            for (uchar i1=0; i1<nsiz; i1++) {\n"
   "               if (pOut >= pOutMax) return 9;\n"
   "               *pOut++ = *(pCur+i1);\n"
   "            }\n"
   "         pCur += nsiz;\n"
   "      } else {\n"
   "         uchar nrep = ncmd;\n"
   "         for (; (nrep > 0) && (pCur < pMax); nrep--) {\n"
   "            if (pOut >= pOutMax) return 9;\n"
   "            *pOut++ = *pCur++;\n"
   "         }\n"
   "      }\n"
   "   }\n"
   "   return 0;\n"
   "}\n",
   pszNameBase, lInSize
      );
      delete [] pIn;
   }

   return 0;
}

bool equalFileContent(char *pszFile1, char *pszFile2, uchar *psrcmd5=0, uchar *pdstmd5=0)
{
   if (psrcmd5) memset(psrcmd5, 0, 16);
   if (pdstmd5) memset(pdstmd5, 0, 16);
   uchar absum1[20];
   uchar absum2[20];
   if (getFileMD5(pszFile1, absum1)) return false;
   if (psrcmd5) memcpy(psrcmd5, absum1, 16);
   if (getFileMD5(pszFile2, absum2)) return false;
   if (pdstmd5) memcpy(pdstmd5, absum2, 16);
   if (!memcmp(absum1, absum2, 16))
      return 1; // equal
   return 0;
}

// uses szLineBuf. pOutBuf must be >= 16 bytes.
int getFuzzyTextSum(char *pszFile, uchar *pOutBuf)
{
   // this function reads a text file line by line, and
   // - strips line endings
   // - turns all \\ slashes into /
   // - ignores the SEQUENCE of lines
   // to make result files of sfk commands comparable
   // both accross platforms, and independent from the sequence
   // in which files happen to be read from the file system.
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+perr("cannot read: %s\n", pszFile);
   uchar abSum[16];
   memset(abSum, 0, sizeof(abSum));
   myfgets_init();
   while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin))
   {
      szLineBuf[sizeof(szLineBuf)-10] = '\0';
      removeCRLF(szLineBuf);
      uint nLen = strlen(szLineBuf);
      // turn all non-/ slashes into /
      for (uint i=0; i<nLen; i++)
         if (szLineBuf[i] == '\\')
             szLineBuf[i] = '/';
      if (cs.verbose) printf("sum: \"%s\"\n", szLineBuf);
      // build local checksum over line
      SFKMD5 md5;
      md5.update((uchar*)szLineBuf, nLen);
      // xor this with overall checksum
      unsigned char *pmd5 = md5.digest();
      for (uint k=0; k<16; k++)
         abSum[k] ^= pmd5[k];
   }
   fclose(fin);
   memcpy(pOutBuf, abSum, 16);
   return 0;
}

int getFuzzyTextSum(char *pszText, int iTextLen, uchar *pOutBuf)
{
   uchar abSum[16];
   memset(abSum, 0, sizeof(abSum));
   
   char *pszCur = pszText;
   char *pszMax = pszText + iTextLen;

   bool bStop=0;
   while (pszCur < pszMax)
   {
      char *pszNext = strchr(pszCur, '\n');
      if (!pszNext) {
         pszNext = pszCur+strlen(pszCur);
         bStop=1;
      }

      int iLen = pszNext-pszCur;
      if (iLen > MAX_LINE_LEN)
         break;
      memcpy(szLineBuf, pszCur, iLen);
      szLineBuf[iLen] = '\0';

      removeCRLF(szLineBuf);
      uint nLen = strlen(szLineBuf);
      // turn all non-/ slashes into /
      for (uint i=0; i<nLen; i++)
         if (szLineBuf[i] == '\\')
             szLineBuf[i] = '/';
      if (cs.verbose) printf("sum: \"%s\"\n", szLineBuf);
      // build local checksum over line
      SFKMD5 md5;
      md5.update((uchar*)szLineBuf, nLen);
      // xor this with overall checksum
      unsigned char *pmd5 = md5.digest();
      for (uint k=0; k<16; k++)
         abSum[k] ^= pmd5[k];

      if (bStop)
         break;

      pszCur = pszNext;
      pszCur++;
   }

   memcpy(pOutBuf, abSum, 16);

   return 0;
}

uint getLong(uchar ab[], uint noffs) {
   return  (((uint)ab[noffs+3])<<24)
          |(((uint)ab[noffs+2])<<16)
          |(((uint)ab[noffs+1])<< 8)
          |(((uint)ab[noffs+0])<< 0);
}

uint getShort(uchar ab[], uint noffs) {
   return  (((uint)ab[noffs+1])<< 8)
          |(((uint)ab[noffs+0])<< 0);
}

time_t zipTimeToMainTime(num nZipTime)
{
   time_t now = time(NULL);
   struct tm *tm = 0;
   tm = localtime(&now);
   tm->tm_isdst = -1;

   tm->tm_year = ((int)(nZipTime >> 25) & 0x7f) + (1980 - 1900);
   tm->tm_mon  = ((int)(nZipTime >> 21) & 0x0f) - 1;
   tm->tm_mday = ((int)(nZipTime >> 16) & 0x1f);

   tm->tm_hour = (int)((unsigned)nZipTime >> 11) & 0x1f;
   tm->tm_min  = (int)((unsigned)nZipTime >>  5) & 0x3f;
   tm->tm_sec  = (int)((unsigned)nZipTime <<  1) & 0x3e;

   // rebuild main time
   time_t nTime = mktime(tm);

   // check for overflows
   #ifndef S_TIME_T_MAX
    #define S_TIME_T_MAX ((time_t)0x7fffffffUL)
   #endif

   #ifndef U_TIME_T_MAX
    #define U_TIME_T_MAX ((time_t)0xffffffffUL)
   #endif

   #define DOSTIME_2038_01_18 ((uint)0x74320000L)
   if ((nZipTime >= DOSTIME_2038_01_18) && (nTime < (time_t)0x70000000L))
      nTime = U_TIME_T_MAX;

   if (nTime < (time_t)0L)
      nTime = S_TIME_T_MAX;

   return nTime;
}

// offsets taken from InfoZIP's UnZip 5.52:
#define L_VERSION_NEEDED_TO_EXTRACT_0  0 
#define L_VERSION_NEEDED_TO_EXTRACT_1  1 
#define L_GENERAL_PURPOSE_BIT_FLAG     2 
#define L_COMPRESSION_METHOD           4 
#define L_LAST_MOD_DOS_DATETIME        6 
#define L_CRC32                        10 
#define L_COMPRESSED_SIZE              14 // 32-bit 
#define L_UNCOMPRESSED_SIZE            18 
#define L_FILENAME_LENGTH              22 // 16-bit 
#define L_EXTRA_FIELD_LENGTH           24 // 16-bit

#define L_LOCAL_HEADER_SIZE (L_EXTRA_FIELD_LENGTH+2)

// build md5 over a zip file AND:
// -  read all its filenames
// -  check them against provided list

// USES: szLineBuf2
int getZipMD5(char *pszFile, SFKMD5 &md5, FileList &rFileList, bool bMakeList=0)
{__
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;

   size_t nRead = 0;

   while (1)
   {
      uchar abLocHdrPre[4+4];
      uchar abLocHdrPreTpl[] = { 0x50, 0x4b, 0x03, 0x04 };
      uchar abCntDirHdrTpl[] = { 0x50, 0x4b, 0x01, 0x02 };
   
      // read local file header magic.
      nRead = fread(abLocHdrPre,1,4,fin);
      if (nRead <= 0)
         break;   // EOD
      if (nRead != 4) { fclose(fin); return 9; }

      md5.update(abLocHdrPre, 4);
      nGlblBytes += nRead;
      if (!memcmp(abLocHdrPre, abCntDirHdrTpl, 4))
         break;   // central directory begin: don't parse further
      if (memcmp(abLocHdrPre, abLocHdrPreTpl, 4)) { fclose(fin); return 8; }
   
      // local file header.
      uchar abLocHdr[L_LOCAL_HEADER_SIZE+4];
      if ((nRead = fread(abLocHdr,1,L_LOCAL_HEADER_SIZE,fin)) != L_LOCAL_HEADER_SIZE) { fclose(fin); return 9; }
      md5.update(abLocHdr, L_LOCAL_HEADER_SIZE);
      nGlblBytes += nRead;
   
      uint nCmpSize     = getLong (abLocHdr, L_COMPRESSED_SIZE);
      uint nFileNameLen = getShort(abLocHdr, L_FILENAME_LENGTH);
      uint nExtraLen    = getShort(abLocHdr, L_EXTRA_FIELD_LENGTH);
      // uint nGenFlags = getShort(abLocHdr, L_GENERAL_PURPOSE_BIT_FLAG);

      // if bit 3 of general purpose is set,
      // bool bDataDesc = ((nGenFlags & (1<<3)) != 0);
      // then nCmpSize is null, and a data descriptor follows.

      // printf("bDataDesc %x nCmpSize %x\n", bDataDesc, nCmpSize);

      // PkZip format seems not to support 64-bit sizes and timestamps.
      // num nTimeStamp = getLong (abLocHdr, L_LAST_MOD_DOS_DATETIME);
      num nFileSize   = getLong (abLocHdr, L_UNCOMPRESSED_SIZE);
      num nZipDOSTime = getLong (abLocHdr, L_LAST_MOD_DOS_DATETIME);
      num nTimeStamp  = zipTimeToMainTime(nZipDOSTime);

      // filename.
      if (nFileNameLen > sizeof(szLineBuf2)-10) { fclose(fin); return 9; }
      if ((nRead = fread(szLineBuf2, 1, nFileNameLen, fin)) != nFileNameLen) { fclose(fin); return 9; }
      md5.update((uchar*)szLineBuf2, nFileNameLen);
      nGlblBytes += nRead;
   
      // printf("file: %.*s %d\n", (int)nFileNameLen, szLineBuf2, nFileNameLen);

      szLineBuf2[nFileNameLen] = '\0';

      #ifdef _WIN32
      // convert path chars from zip format '/' to local
      char *psz1 = 0;
      while (psz1 = strchr(szLineBuf2, glblWrongPChar))
         *psz1 = glblPathChar;
      #endif

      if (bMakeList)
         rFileList.addFile(szLineBuf2, str(""), nTimeStamp, nFileSize);
      else {
         int lRC = rFileList.checkAndMark(szLineBuf2, nFileSize);
         if (lRC == 1) {
            static bool bInfoDone = 0;
            logError("info   : outdated file \"%s\" in archive \"%s\"", szLineBuf2, pszFile);
            if (!bInfoDone) {
               bInfoDone = 1;
               logError("info   : if you want to cleanup your archive tree later, see 10-stale-list.txt");
            }
            trackStaleZip(pszFile);
         }
         if (lRC == 2) {
            static bool bInfoDone2 = 0;
            logError("error  : size mismatch of \"%s\" in archive \"%s\"", szLineBuf2, pszFile);
            if (!bInfoDone2) {
               bInfoDone2 = 1;
               logError("error  : maybe the file is too large, empty, unaccessible, or not zip compatible.");
            }
         }
      }

      // skip to next local file header.
      num nRemain = nExtraLen + nCmpSize;
      while (nRemain > 0) {
         size_t nBlockLen = sizeof(abBuf)-10;
         if (nBlockLen > nRemain) nBlockLen = nRemain;
         nRead = fread(abBuf,1,nBlockLen,fin);
         if (nRead <= 0)
            break;
         md5.update(abBuf,nRead);
         nGlblBytes += nRead;
         nRemain -= nRead;
      }
   }

   // read remaining data (central dir) as black box
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      nGlblBytes += nRead;
   }

   // unsigned char *pmd5 = md5.digest();
   // for (int i=0; i<16; i++)
   //    fprintf(stdout,"%02x",pmd5[i]);
   // printf("\n");

   fclose(fin);
   return 0;
}

#ifndef NO_ZIP_LIST

#ifdef _WIN32
int mygetpos(FILE *f, num &rpos, char *pszFile)
{
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   rpos = (num)npos1;
   return 0;
}
int mysetpos(FILE *f, num pos, char *pszFile)
{
   fpos_t npos1 = (fpos_t)pos;
   if (fsetpos(f, &npos1))
      return 9+perr("setpos failed on %s\n", pszFile);
   return 0;
}
#else
int mygetpos(FILE *f, num &rpos, char *pszFile)
{
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   #if defined(MAC_OS_X) || defined(SOLARIS)
   rpos = (num)npos1;
   #else
   rpos = (num)npos1.__pos;
   #endif
   return 0;
}
int mysetpos(FILE *f, num pos, char *pszFile)
{
   // fetch "status" first
   fpos_t npos1;
   if (fgetpos(f, &npos1))
      return 9+perr("getpos failed on %s\n", pszFile);
   #if defined(MAC_OS_X) || defined(SOLARIS)
   npos1 = (fpos_t)pos;
   #else
   npos1.__pos = (__off_t)pos;
   #endif
   if (fsetpos(f, &npos1))
      return 9+perr("setpos failed on %s\n", pszFile);
   return 0;
}
#endif

int getZipList(char *pszFile, FileList &rFileList)
{__
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+perr("unable to open: %s\n", pszFile);
   
   int rc=0;
   uint sig;
   fseek(fin, -18, SEEK_END);
   fread(&sig, 1, sizeof(sig), fin);

   #define ENDOFCDIR_SIZE 18
   #define EOCDIR_CDOFFS  12

   num g_diroff = 0; // offset of central directory

   while (1)
   {
      num npos2 = 0;
      if (mygetpos(fin, npos2, pszFile)) {
         fclose(fin);
         return 9;
      }
      if (npos2 <= 32)
         break;

      if (sig==0x06054b50) 
      {
         rc = fread(abBuf, 1, ENDOFCDIR_SIZE, fin);
         if (rc == ENDOFCDIR_SIZE)
            g_diroff = getLong(abBuf, EOCDIR_CDOFFS);
         break;
      } else {
         fseek(fin, -5, SEEK_CUR);
         fread(&sig, 1, sizeof(sig), fin);
      }
   }

   #define ZIPFHEAD_SIZE   42
   #define ZIPFNAMLEN_OFFS 24 // 2 bytes
   #define ZIPFCRC_OFFS    12 // 4 bytes
   #define ZIPFCMPS_OFFS   16 // 4 bytes
   #define ZIPFORGS_OFFS   20 // 4 bytes
   #define ZIPFEXTL_OFFS   26 // 2 bytes
   #define ZIPFREML_OFFS   28 // 2 bytes
   #define ZIPFIATTR_OFFS  32 // 4 bytes
   #define ZIPFEATTR_OFFS  34 // 4 bytes

   num npos1 = (num)g_diroff;
   if (mysetpos(fin, npos1, pszFile)) {
      fclose(fin);
      return 9;
   }

   rc = fread(&sig, 1, sizeof(sig), fin);

   while (rc > 3)
   {
      if (sig == 0x02014b50)
      {
         num npos1 = 0;
         if (mygetpos(fin, npos1, pszFile))
            break;

         num boo = (num)npos1;
   
         rc = fread(abBuf, 1, ZIPFHEAD_SIZE, fin);
         if (rc < ZIPFHEAD_SIZE)
            break;
   
         uint nNameLen = getShort(abBuf, ZIPFNAMLEN_OFFS);
         if (nNameLen > MAX_LINE_LEN-10)
            break;
   
         rc = fread(szLineBuf, 1, nNameLen, fin);
         if (rc < (int)nNameLen)
            break;
         szLineBuf[nNameLen] = '\0';

         // under windows, convert slashes
         setSystemSlashes(szLineBuf);

         // directory of file entry?
         // uint nExtAttr = getLong(abBuf, ZIPFEATTR_OFFS);
         // NOTE: attributes are NOT given in JAR files.
         // bool  bIsDir   = (nExtAttr & (0040000UL << 16)) ? 1 : 0;
         // printf("attr %xh dir=%d %s\n",nExtAttr,bIsDir,szLineBuf);
         bool  bIsDir   = endsWithPathChar(szLineBuf);

         // list dirs only if withdirs selected
         if (!bIsDir || cs.withdirs)
         {
            // uint nCRCSum  = getLong(abBuf, ZIPFCRC_OFFS );
            uint nCmpSize = getLong(abBuf, ZIPFCMPS_OFFS);
            uint nOrgSize = getLong(abBuf, ZIPFORGS_OFFS);
      
            uint nExtLen  = getShort(abBuf, ZIPFEXTL_OFFS);
            uint nRemLen  = getShort(abBuf, ZIPFREML_OFFS);
   
            #define ZIPTIME_OFFS ZIPFCRC_OFFS-4
            num nZipDOSTime = getLong (abBuf, ZIPTIME_OFFS);
            num nTimeStamp  = zipTimeToMainTime(nZipDOSTime);
   
            rFileList.addFile(szLineBuf, str(""), nTimeStamp, nOrgSize);
      
            if (nCmpSize) {
               if (fseek(fin, nExtLen+nRemLen, SEEK_CUR))
                  { perr("fseek err #3\n"); break; }
            } else {
               npos1 = (num)(boo+1);
               if (mysetpos(fin, npos1, pszFile))
                  break;
            }
         }
      }
      else {
         if (fseek(fin, -3, SEEK_CUR))
            { perr("fseek err #5\n"); break; }
      }  // endif
   
      rc = fread(&sig, 1, sizeof(sig), fin);
      if (rc < (int)sizeof(sig))
         break;
   }  // endwhile

   fclose(fin);

   return 0;
}
#endif

#ifndef USE_SFK_BASE

int execMetaFileUpdate(char *pszFile)
{
   printf("upd: %s\n", pszFile);
   if (!filedb.updateFile(pszFile))
      cs.files++;
   return 0;
}

int execMetaDirUpdate(char *pszFile)
{
   filedb.updateDir(pszFile);
   return 0;
}

int execMetaFileCheck(char *pszSrc)
{
   cs.files++;

   char szAddInfo[200];
   int nVerOK     = filedb.numberOfVerifies();
   int nVerFailed = filedb.numberOfVerFailed();
   if (nVerFailed > 0)
      sprintf(szAddInfo, "%u files ok, %d failed, %u mb %u kbs", nVerOK, nVerFailed, (uint)(nGlblBytes/1000000UL), currentKBPerSec());
   else
      sprintf(szAddInfo, "%u files %u mb %u kbs", nVerOK, (uint)(nGlblBytes/1000000UL), currentKBPerSec());
   info.setProgress(cs.files, filedb.numberOfFiles(), "files");
   info.setStatus("verfy", pszSrc, szAddInfo, eKeepProg);

   int nvrc = filedb.verifyFile(pszSrc);

   if (nvrc >= 9)
      perr("check failed: %s - content modified\n", pszSrc);
   else
   if (nvrc == 8)
      perr("%s - not found in database\n", pszSrc);
   return 0;
}

#endif // USE_SFK_BASE

int execMD5write(Coi *pcoi)
{
   SFKMD5 md5;
   if (getFileMD5(pcoi->name(), md5))
      return 9;

   char *pszRelName = pcoi->name();
   if (bGlblMD5RelNames)
      pszRelName = pcoi->rootRelName();

   unsigned char *pmd5 = md5.digest();
   for (int i=0; i<16; i++)
      fprintf(fGlblOut,"%02x",pmd5[i]);
   fprintf(fGlblOut," *%s\n",pszRelName); // md5sum similar

   glblFileCount.count();
   sprintf(szLineBuf, "%u files %u mb %u kbs", glblFileCount.value(), (uint)(nGlblBytes/1000000UL), currentKBPerSec());
   info.setAddInfoWidth(strlen(szLineBuf));
   info.setStatus("read ", pszRelName, szLineBuf);

   return 0;
}

int execMD5check(char *pIn, char *pszRefDir)
{__
   int nLine=0;
   int nError=0;
   char *pszLine=pIn;
   char *pszNext=0;
   uint nListSize = strlen(pIn);
   if (nListSize==0) nListSize=1;
   int nSkipCnt = 0;
   int lRC = 0;

   // prerun: determine approx. number of targets
   uint nLF = 0;
   for (uint i=0; i<nListSize; i++)
      if (pIn[i] == '\n')
         nLF++;

   if (nGlblMD5Skip > 0) {
      uint nCover = 100/(1+nGlblMD5Skip);
      if (!cs.quiet)
         printf("spot-checking %02u%% of files (skip=%u).\n", nCover, nGlblMD5Skip);
   }

   // check md5, optionally sped up through skips
   for (;pszLine;pszLine=pszNext)
   {
      pszNext = strchr(pszLine, '\n');
      if (pszNext) *pszNext++ = 0;
      strncpy(szLineBuf, pszLine, sizeof(szLineBuf)-10);
      nLine++;
      if (!strlen(szLineBuf))
         continue;
      if (nGlblMD5Skip > 0) {
         if (nSkipCnt <= 0) {
            nSkipCnt = nGlblMD5Skip;
            // and fall through
         } else {
            nSkipCnt--;
            continue;
         }
      }
      char *psz = strstr(szLineBuf, " *"); // md5sum format
      if (!psz) {
         perr("illegal format in line %d:\n\"%s\"\n",nLine,szLineBuf);
         nError++; 
         lRC = 9;
         continue;
      }
      *psz = 0;
      char *pszHex  = szLineBuf;
      if (*pszHex == '\\') pszHex++; // support for md5sum files
      char *pszFile = psz+2;  // skip " *"
      // fix filename ending and path chars
      if ((psz = strchr(pszFile, '\r'))) *psz = 0;
      if ((psz = strchr(pszFile, '\n'))) *psz = 0;
      fixPathChars(pszFile);

      char szAddInfo[200];
      if (nGlblMD5Skip > 0) {
         sprintf(szAddInfo, "%u files %u mb %u kbs skip %u", glblFileCount.value(), (uint)(nGlblBytes/1000000UL), currentKBPerSec(), nGlblMD5Skip);
      } else {
         sprintf(szAddInfo, "%u files %u mb %u kbs", glblFileCount.value(), (uint)(nGlblBytes/1000000UL), currentKBPerSec());
      }
      info.setAddInfoWidth(strlen(szAddInfo));
      info.setProgress(nLF, nLine, "files");
      info.setStatus("verfy", pszFile, szAddInfo, eKeepAdd);

      char *pszAbsName = pszFile;
      if (pszRefDir) {
         joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszRefDir, pszFile);
         pszAbsName = szRefNameBuf;
      }

      {
         SFKMD5 md5;      // auto instanciate
         // NOTE: this uses abBuf, so we shouldn't use abBuf here.
         if (getFileMD5(pszAbsName, md5)) {
            nError++;   // but continue
            if (lRC < 9) lRC |= 2;
         }
         else
         {
            unsigned char *pmd5 = md5.digest();
            char szBuf2[100];
            for (int i=0; i<16; i++)
               sprintf(szBuf2+i*2,"%02x",pmd5[i]);
            if (strcmp(pszHex,szBuf2)) {
               perr("MD5 mismatch: %s\n", pszAbsName); // ,*%s*,*%s*\n", pszFile, pszHex, szBuf2);
               nError++;
               if (lRC < 9) lRC |= 1;
            }            
         }
      }

      glblFileCount.count();

      if (userInterrupt())
         break;
   }
   if (nError) {
      perr("%u files of %u failed verification.\n", nError, glblFileCount.value());
      info.print("info : %u files checked", glblFileCount.value());
   } else {
      info.print("OK. %u files checked", glblFileCount.value());
   }
   if (!cs.quiet)
      info.print(", %u mb, %u sec, %u kb/sec.\n", (uint)(nGlblBytes/1000000UL), (uint)(currentElapsedMSec()/1000), (uint)currentKBPerSec());
   else
      info.print(".\n");
   fflush(stderr);
   fflush(stdout);
   return lRC;
}

int execJamIndex(char *pszFile)
{
   // strip ".\" at start, if any
   char *psz1 = pszFile;
   if (!strncmp(psz1, glblDotSlash, 2))
         psz1 += 2;
   fprintf(fGlblOut, ":# %s\n", psz1);

   // remember in array of targets
   if (nJamTargets < MAX_JAM_TARGETS-10)
      apJamTargets[nJamTargets++] = strdup(psz1);
   else
      return 9+perr("too many snapfile targets\n");

   return 0;
}

// snapto dump of a single text line
int dumpJamLine(char *pszLine, int nLineLen, bool bAddLF) // len 0: zero-terminated
{
   int lRC = 0;

   if (pGlblJamLineCallBack)
      lRC = pGlblJamLineCallBack(pszLine, nLineLen, bAddLF);
   else
   if (nLineLen > 0)
      fprintf(fGlblOut, "%.*s%s", (int)nLineLen, pszLine, bAddLF?cs.addsnaplf:"");
   else {
      fputs(pszLine, fGlblOut);
      if (bAddLF) fputs(cs.addsnaplf, fGlblOut);
   }

   return lRC;
}

// simple check: if a file contains some nulls, it must be binary.
bool isBinaryFile(char *pszFile)
{
   // using same probe size as Coi::isBinaryFile
   int nCheckLen = MY_GETBUF_MAX - 10;

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 0;

   if (nCheckLen > (int)sizeof(abBuf)-10)
       nCheckLen = (int)sizeof(abBuf)-10;

   int nRead = fread(abBuf, 1, nCheckLen, fin);
   fclose(fin);

   // for (int i=0; i<nRead; i++)
   //    if (abBuf[i] == 0x00)
   //       return 1;
   if (memchr(abBuf, 0, nRead))
      return 1;

   return 0;
}

bool isWhitespace(char *psz, int nlen)
{
   for (int i=0; psz[i] && (i<nlen); i++)
      if (!isspace(psz[i]))
         return 0;
   return 1;
}

bool isws(char c)
{
   if (c == ' ') return 1;
   if (c == '\t') return 1;
   return 0;
}

const char *pGlblBlankBuf160 =
   "                                        "
   "                                        "
   "                                        "
   "                                        ";

#ifdef VFILEBASE
class AutoCacheDrop {
public:
    AutoCacheDrop (Coi *pcoi);
   ~AutoCacheDrop ( );
private:
   Coi *pClCoi;
};

AutoCacheDrop::AutoCacheDrop(Coi *pcoi) {
   pClCoi = pcoi; 
}

AutoCacheDrop::~AutoCacheDrop( ) {
   pClCoi->releaseContent(); // IF anything cached
}
#endif // VFILEBASE

void setAddSnapMeta(uint nmask) { cs.addsnapmeta = nmask; }

int (*pGlblCallFileDir)(Coi *pcoi) = 0;

int execCallFileDir(Coi *pcoi)
{
   if (!pGlblCallFileDir) return 9;
   return pGlblCallFileDir(pcoi);
}

int execSnapThrough(Coi *pcoi);

int bGlblPassThroughSnap = 0;

// snapto collect single file
int execJamFile(Coi *pcoi)
{__ _p("sf.jamfile")

   cchar *pPrefix = pszGlblJamPrefix ? pszGlblJamPrefix : ":file:";
   char *pHeadLine = (char*)pPrefix;

   char szHeadBuf[250];
   mclear(szHeadBuf);

   #ifdef VFILEBASE
   // when adding file content to a collection,
   // we can always expect that the source data can be
   // dropped from cache afterwards, therefore:
   AutoCacheDrop odrop(pcoi);
   #endif // VFILEBASE

   bool bIsBinary = pcoi->isBinaryFile();
   // also sets: isUTF16, isSnapFile
   bool bIsSnap   = pcoi->isSnapFile();
   
   if (bIsSnap)
   {
      if (!bGlblPassThroughSnap) 
      {
         pinf("skipping snap file: %s\n", pcoi->name());
         return 0; // skip
      }         
         
      return execSnapThrough(pcoi);
   }

   mtklog(("load: execjam: bin=%d %s", bIsBinary, pcoi->name()));

   if (cs.addsnapmeta)
   {
      bool baddtime = (cs.addsnapmeta & (1<<0)) ? 1 : 0;
      bool baddsize = (cs.addsnapmeta & (1<<1)) ? 1 : 0;
      bool baddcode = (cs.addsnapmeta & (1<<2)) ? 1 : 0;

      // prepare subfile header with time etc.     123456789012345678901234567890
      char szTimeInfo[50]; mclear(szTimeInfo);  // time=1234567890
      char szSizeInfo[50]; mclear(szSizeInfo);  // size=1000000000
      char szCodeInfo[50]; mclear(szCodeInfo);  // code=utf16le
      char szWebInfo[50];  mclear(szWebInfo);   // webrc=404_error_page

      int nMetaLen = 0;

      if (baddtime) {
         num nFileTime = pcoi->getTime();
         strcpy(szTimeInfo, " mtime=");
         numtoa(nFileTime,1,szTimeInfo+7);
         nMetaLen += strlen(szTimeInfo);
      }

      if (baddsize) {
         num nFileSize = pcoi->getSize();
         strcpy(szSizeInfo, " size=");
         numtoa(nFileSize,1,szSizeInfo+6);
         nMetaLen += strlen(szSizeInfo);
      }

      if (baddcode && pcoi->isUTF16()) {
         sprintf(szCodeInfo, " code=utf16%s", (pcoi->isUTF16()==0xFE)?"le":"be");
         nMetaLen += strlen(szCodeInfo);
      }

      #ifdef VFILEBASE
      char *pwebrc = pcoi->header("webrc");
      if (pwebrc) {
         int nwebrc = atol(pwebrc);
         if (nwebrc >= 400) {
            sprintf(szWebInfo, " content=%s_error_page", pwebrc);
            nMetaLen += strlen(szWebInfo);
         }
      }
      #endif // VFILEBASE

      int nPreLen  = strlen(pPrefix);
      if (nPreLen > 50) nPreLen = 50;

      int nPadLen  = 78 - nPreLen - nMetaLen;
      if (nPadLen < 0) nPadLen = 0;

      // construct padded headline with meta informations
      snprintf(szHeadBuf, sizeof(szHeadBuf), "%.50s%.*s%.40s%.40s%.40s%.40s",
         pPrefix, (int)nPadLen, pGlblBlankBuf160, szTimeInfo, szSizeInfo, szCodeInfo, szWebInfo);

      pHeadLine = szHeadBuf;
   }

   int lRC = 0;
   bool bSkipCnt = 0;

   if (cs.addsnapraw)
   {
      // raw mode:

      if (bIsBinary) {
         // skip all binaries
         if (glblFileCount.countSkip(pcoi->name())) {
            if (pGlblJamStatCallBack) {
               int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog(("%d = jam.stat.callback.5", nrc));
               lRC |= nrc;
            } else {
               info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(nGlblBytes/1000000UL));
               info.setStatus("skip", pcoi->name(), 0, eKeepAdd);
            }
         }
         return lRC;
      }

      // add text files 1:1 keeping exactly the same size,
      // and skip all binary files. no conversions whatsoever.
      if (pcoi->open("rb"))
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      // write subfile header
      if (!bGlblJamPure)
      {
         lRC |= dumpJamLine(pHeadLine   , 0, 1);   // :file: mtime size
         lRC |= dumpJamLine(pcoi->name(), 0, 1);   // actual filename
      }

      while (true) 
      {
         num nRead  = pcoi->read(abBuf, sizeof(abBuf)-1000);
         if (nRead <= 0)
            break;

         if (cs.addsnapraw < 2) 
         {
            // replace (unexpected) NULL or EOF characters by '.'
            // also counting the lines
            for (int i=0; i<nRead; i++)
               switch (abBuf[i]) {
                  case 0: case 0x1A: abBuf[i] = '.'; break;
                  case '\n': cs.lines++; break;
               }
         } else {
            // just count the lines
            for (int i=0; i<nRead; i++)
               if (abBuf[i] == '\n')
                  cs.lines++;
         }

         num nWrite = myfwrite(abBuf, nRead, fGlblOut);
         if (nWrite != nRead) {
            perr("failed to fully write %d bytes, possibly disk full\n", (int)nWrite);
            pcoi->close();
            return 9;
         }

         nGlblBytes += nRead;

         // check per block if stat update is required
         if (glblFileCount.checkTime())
         {
            if (pGlblJamStatCallBack) {
               int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog(("%d = jam.stat.callback.4", nrc));
               lRC |= nrc;
            } else {
               info.setAddInfo("%u files, %u mb", (uint)glblFileCount.value(), (uint)(nGlblBytes/1000000UL));
               info.setStatus("snap", pcoi->name(), 0, eKeepAdd);
            }
         }
   
         // STOP in-file processing on non-zero rc
         if (lRC) break;
      }

      pcoi->close();

      lRC |= dumpJamLine(str(""), 0, 1);
   }
   else
   if (bIsBinary || cs.rewrap)
   {
      if (cs.rewrap) {
         mtklog(("rewrap file, %d",cs.incbin));
      } else {
         mtklog(("binary file, %d",cs.incbin));
      }

      // should the binary (or forced wrap) file be included?
      bool bProcess = cs.incbin;  // global switch, process all

      bProcess |= bGlblInSpecificProcessing; // within explicite file list

      // text in forced wrap mode: always include
      if (!bIsBinary && cs.rewrap) bProcess = 1;

      if (!bProcess) {
         char *pszRel = pcoi->relName();
         if (matchesFileMask(pszRel, pcoi->name()) > 1) // matches by non-wildcard pattern
            bProcess = 1;
      }

      // optional check if target accepts file
      if (bProcess && pGlblJamCheckCallBack) {
         if (pGlblJamCheckCallBack(pcoi->name()))
            bProcess = 0;
      }

      // if not, skip
      if (!bProcess) {
         if (glblFileCount.countSkip(pcoi->name())) {
            if (pGlblJamStatCallBack) {
               int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog(("%d = jam.stat.callback.1", nrc));
               lRC |= nrc;
            } else {
               info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(nGlblBytes/1000000UL));
               info.setStatus("skip", pcoi->name(), 0, eKeepAdd);
            }
         }
         return lRC;
      }

      // open binary for read
      if (pcoi->open("rb"))
         { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

      // write subfile header
      lRC |= dumpJamLine(pHeadLine   , 0, 1);   // :file: mtime size
      lRC |= dumpJamLine(pcoi->name(), 0, 1);   // actual filename
      if (lRC)
         return lRC;

      // convert binary to text
      BinTexter bt(pcoi);
      lRC = bt.process(BinTexter::eBT_JamFile);
      pcoi->close();
      if (lRC)
         return lRC;

      // trailer
      lRC |= dumpJamLine(str(""), 0, 1);
   }
   else
   if (pGlblJamFileCallBack)
   {
      num nLocalBytes = 0;
      num nLocalLines = 0;
      lRC = pGlblJamFileCallBack(pcoi->name(), nLocalLines, nLocalBytes);
      // should include header, trailer generation
      cs.lines   += nLocalLines;
      nGlblBytes += nLocalBytes;
   }
   else
   {
    // optional check if target accepts file
    if (pGlblJamCheckCallBack) {
       if (pGlblJamCheckCallBack(pcoi->name()))
          return 1; // skipped
    }

    // add file content, check for illegal entries
    if (pcoi->open("rb"))
      { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

    int nMaxLineLen = sizeof(szLineBuf)-10; // YES, szLineBuf
    memset(abBuf, 0, nMaxLineLen+2); // yes, abBuf is larger by far
    int  nLocalLines = 0;
    bool bWrapMode  = (cs.wrapcol > 0) ? 1 : 0;
    int  nLineLen   = 0;
    bool bPassSnap  = 0;
    bool bNoTrailer = 0;

    while ((nLineLen = pcoi->readLine((char*)abBuf, nMaxLineLen)) > 0)
    {
      cs.lines++;
      nLocalLines++;

      if (nLineLen == nMaxLineLen)
         pwarn("max line length %d reached, splitting. file %s, line %d\n", nMaxLineLen, pcoi->name(), nLocalLines);

      // safety: escape unexpected (mal-format) headers within content
      if (   startsLikeSnapFile((char*)abBuf)
          || strBegins((char*)abBuf, pPrefix)
         )
      {
         if (nLineLen > nMaxLineLen-10)
            continue; // drop

         memmove(abBuf+1,abBuf+0,nLineLen+1); // with zero terminator
         abBuf[0] = '\'';
         nLineLen++;
      }

      if (nLocalLines == 1)
      {
         // first local line: also write header
         if (!bGlblJamPure)
         {
            lRC |= dumpJamLine(pHeadLine   , 0, 1);   // :file: mtime size
            lRC |= dumpJamLine(pcoi->name(), 0, 1);   // actual filename
         }
      }

      if (bWrapMode && ((int)strlen((char*)abBuf) > cs.wrapcol))
      {
         // auto-wrap input line into many smaller output lines
         char *psz1 = (char*)abBuf;
         char *pszOld = 0;
         while (*psz1)
         {
            pszOld = psz1;
            int icnt = 0;
            char *pszGap = 0;
            // step until overflow or eod, remember last whitespace
            while (*psz1 && (icnt < cs.wrapcol)) {
               char c = *psz1;
               switch (c) {
                  case ' ': case '\t': case ',':
                     pszGap = psz1;
                     break;
               }
               psz1++;
               icnt++;
            }
            // if overflow, go back past whitespace. if no whitespace,
            // make a word break at that point (splitting very long words).
            if (*psz1) {
               if (pszGap)
                  psz1 = pszGap+1;
            }
            int nLen = psz1-pszOld;
            if (nLen < 5 && isWhitespace(pszOld, nLen))
               { } // cut trailing whitespace
            else
               lRC |= dumpJamLine(pszOld, nLen, *psz1 ? 1 : 0);
            // continue past whitespace or word break.
         }
      } else {
         if (nLineLen > 0 && abBuf[nLineLen-1] == '\n')
            lRC |= dumpJamLine((char*)abBuf, 0, 0); // has own LF
         else
            lRC |= dumpJamLine((char*)abBuf, 0, 1);
      }

      nGlblBytes += nLineLen;
      abBuf[nMaxLineLen] = '\0';

      // check per line if stat update is required
      if (glblFileCount.checkTime())
      {
         if (pGlblJamStatCallBack) {
            int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
            mtklog(("%d = jam.stat.callback.2", nrc));
            lRC |= nrc;
         } else {
            info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(nGlblBytes/1000000UL));
            info.setStatus("snap", pcoi->name(), 0, eKeepAdd);
         }
      }

      // STOP in-file processing on non-zero rc
      if (lRC) break;

    } // endwhile lines

    pcoi->close();

    lRC |= dumpJamLine(str(""), 0, 1);
    
    // FIX 1652: do not count empty text files
    if (nLocalLines <= 0)
      bSkipCnt = 1;
    
   } // endelse binary
   
   // FIX 1652: stop of load within file: don't count last file
   if (lRC >= cs.treeStopRC)
      bSkipCnt = 1;

   if (!bSkipCnt && glblFileCount.count()) 
   {
      if (pGlblJamStatCallBack) {
         int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
         mtklog(("%d = jam.stat.callback.3", nrc));
         lRC |= nrc;
      } else {
         info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(nGlblBytes/1000000UL));
         info.setStatus("snap", pcoi->name(), 0, eKeepAdd);
      }
   }

   return lRC;
}

int execSnapThrough(Coi *pcoi)
{__
   // expecting: auto cache drop is done by caller

   cchar *pPrefix = pszGlblJamPrefix ? pszGlblJamPrefix : ":file:";
   char *pHeadLine = (char*)pPrefix;

   char szHeadBuf[250];
   mclear(szHeadBuf);

   int lRC  = 0;

   // add file content, check for illegal entries
   if (pcoi->open("rb"))
     { pwarn("cannot read: %s%s\n", pcoi->name(),pcoi->lasterr()); return 0; }

   int nMaxLineLen = sizeof(szLineBuf)-10; // YES, szLineBuf
   memset(abBuf, 0, nMaxLineLen+2); // yes, abBuf is larger by far
   int nLocalLines = 0;
   bool bWrapMode = (cs.wrapcol > 0) ? 1 : 0;
   int nLineLen  = 0;
   bool bPassSnap = 0;
   bool bNoTrailer = 0;
   
   bool bHeadArea = 1;

   while (pcoi->readLine((char*)abBuf, nMaxLineLen) > 0) // yes, exact len
   {
      cs.lines++;
      nLocalLines++;

      nLineLen = strlen((char*)abBuf);
      if (nLineLen == nMaxLineLen)
         pwarn("max line length %d reached, splitting. file %s, line %d\n", nMaxLineLen, pcoi->name(), nLocalLines);

      // as long as head area, don't pass anything.
      // we do not accept any differing prefix.
      if (bHeadArea)
      {
         if (!strBegins((char*)abBuf, pPrefix))
            continue;
         
         // first :file: reached, end of head area.
         bHeadArea = 0;
      }

      // safety: escape unexpected (mal-format) headers within content
      if (startsLikeSnapFile((char*)abBuf))
      {
         if (nLineLen > nMaxLineLen-10)
            continue; // drop
            
         memmove(abBuf+1,abBuf+0,nLineLen+1); // with zero terminator
         abBuf[0] = '\'';
         nLineLen++;
      }

      // also count subfiles as files, however processing of those
      // headers is done by receiver.
      if (strBegins((char*)abBuf, pPrefix)) 
      {
         if (glblFileCount.count())
         {
            if (pGlblJamStatCallBack) {
               int nrc = pGlblJamStatCallBack(pcoi, glblFileCount.value(), cs.lines, (uint)(nGlblBytes/1000000UL), glblFileCount.skipped(), glblFileCount.skipInfo());
               mtklog(("%d = jam.stat.callback.3", nrc));
               lRC |= nrc;
            } else {
               info.setAddInfo("%u files, %u lines, %u mb", (uint)glblFileCount.value(), (uint)cs.lines, (uint)(nGlblBytes/1000000UL));
               info.setStatus("snap", pcoi->name(), 0, eKeepAdd);
            }
         }
      }

      if (nLineLen > 0 && abBuf[nLineLen-1] == '\n')
         lRC |= dumpJamLine((char*)abBuf, 0, 0); // has own LF
      else
         lRC |= dumpJamLine((char*)abBuf, 0, 1);

      nGlblBytes += strlen((char*)abBuf);
      abBuf[nMaxLineLen] = '\0';

      // STOP in-file processing on non-zero rc
      if (lRC) break;

   } // endwhile lines

   pcoi->close();

   return lRC;
}

Array glblRefDst("RefDst");
StringTable glblRefSrc;
StringTable glblRefDstNames;
uchar abGlblRefChars[256];   // map of chars used in destination names

int execRefColDst(Coi *pcoi)
{__
   char *pszFile = pcoi->name();

   char szAddInfo[200];
   sprintf(szAddInfo, "%u targets", glblRefDst.numberOfEntries(0)+1);
   info.setStatus("scan", pszFile, szAddInfo);

   if (cs.rootrelname)
      pszFile = pcoi->rootRelName();

   strncpy(szLineBuf, pszFile, sizeof(szLineBuf)-10);
   szLineBuf[sizeof(szLineBuf)-10] = '\0';

   // force path chars to system path char.
   // the same is done in the source contents to ease comparison.
   char *psz2 = szLineBuf;
   while (*psz2) {
      if (*psz2 == glblWrongPChar)
         *psz2 = glblPathChar;
      psz2++;
   }

   #ifdef _WIN32
   // create lowercase filename, we want to compare case-insensitive
   if (!cs.usecase) {
      char *psz1 = szLineBuf;
      while (*psz1) {
         if (isalpha(*psz1))
            *psz1 = tolower(*psz1);
         psz1++;
      }
   }
   #endif

   // create map of used chars in dest. names, for search optim
   for (uchar *psz5=(uchar*)szLineBuf; *psz5; psz5++)
      abGlblRefChars[*psz5] = 1;

   // RefDst Array (Table) structure
   // ==============================
   //    0     1     2     3     4     ...
   // dstName1 rcnt  src1  src2 ""     ...
   // dstName2 rcnt  src1  src2 src3   ...
   // dstName3 rcnt  src1  ""   ""     ...

   glblRefDst.addString(0, szLineBuf);
   glblRefDst.addLong(1, 0, __LINE__);
   for (int i=0; i<nGlblRefMaxSrc; i++)
      glblRefDst.addNull(2+i);

   return 0;
}

bool isFileNameChar(char c) {
   if (isalnum(c)) return true;
   switch (c) {
      case glblPathChar: return true;
      case glblWrongPChar: return true;
      case '_': return true;
      case ':': return true;
      case '.': return true;
      case '-': return true;
      case '#': return true;
   }
   return false;
}

int execRefColSrc(char *pszFile)
{__
   cs.refsrccnt++;

   char szAddInfo[200];
   sprintf(szAddInfo, "%u sources", cs.refsrccnt);
   info.setStatus("scan", pszFile, szAddInfo);

   // remember also list of source files
   glblRefSrc.addEntry(pszFile);

   // used when auto-including targets as internal sources
   if (cs.coldstnames)
      glblRefDstNames.addEntry(pszFile);

   return 0;
}

int execRefProcSrc(char *pszFile, char *pszOptRoot, int icur, int ntotal)
{__
   if (userInterrupt())
      return 9;

   info.setAddInfo("%d files of %d",icur,ntotal);
   info.setProgress(ntotal, icur, "files");
   info.setStatus("scan", pszFile, 0, eKeepAdd|eKeepProg);

   if (cs.debug) {
      info.printLine(1<<2);
   }

   num nFileSize = getFileSize(pszFile);
   if (nFileSize <= 0)
      return 0;
   if (nFileSize >= nGlblMemLimit) {
      pwarn("file too large, skipping: %s\n", pszFile);
      return 0;
   }

   // load native file content
   char *pInFile = new char[nFileSize+10];
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) { 
      perr("cannot read: %s\n", pszFile); 
      delete [] pInFile; 
      return 0; 
   }
   unsigned int nRead = fread(pInFile, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      perr("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pInFile;
      return 0;
   }
   pInFile[nFileSize] = '\0';

   // convert content to allow strstr.
   // in case of windows prepare case-insensitive comparison.
   // force all path chars to use system path char.
   #ifdef _WIN32
   bool bCase = cs.usecase;
   #endif

   if (cs.refstripsrc)
   {
      // strip source file content from all characters
      // that have not appeared in target filenames.
      uint i1=0, i2=0;
      uint clast = 0xFFFF;
      for (; i1<nFileSize; i1++)
      {
         uchar c = (uchar)pInFile[i1];
   
         #ifdef _WIN32
         if (isalpha((char)c) && !bCase)
            c = (uchar)tolower((char)c);
         #endif
   
         if (!abGlblRefChars[c]) 
         {
            // flatten binary stuff 
            c = 0xFF;
            // reduce if possible
            if (c == clast) continue;
            pInFile[i2++] = (char)c;
            clast = c;
            continue;
         }
         clast = 0xFFFF;
   
         // copy-through readable text char
         if (c == (uchar)glblWrongPChar)
            pInFile[i2++] = glblPathChar;
         else
            pInFile[i2++] = (char)c;
      }
      if (i2 > nFileSize) return 9+perr("internal #278242039\n");
      pInFile[i2] = '\0'; // including offset nFileSize, as above
   }
   else
   {
      for (uint i=0; i<nFileSize; i++) 
      {
         char c = pInFile[i];
         if (c == '\0')
            pInFile[i] = ' ';
         else
         if (c == glblWrongPChar)
            pInFile[i] = glblPathChar;
         #ifdef _WIN32
         else
         if (isalpha(c) && !bCase)
            pInFile[i] = tolower(c);
         #endif
      }
   }

   // for all dst entries
   for (int idst=0; idst<glblRefDst.numberOfEntries(0); idst++)
   {
      char *pszDstRaw = glblRefDst.getString(0, idst);
      char *pszDst    = pszDstRaw;

      // do NOT add our own name as a ref
      if (!strcmp(pszDstRaw, pszFile))
         continue;

      // check for any occurrence of relativized pszDst
      if (bGlblRefRelCmp) {
         char *pszRel = strrchr(pszDst, glblPathChar);
         if (pszRel) pszDst = pszRel+1;
         if (cs.debug) info.print("REL *%s* \n", pszDst);
      }

      // use only basename of pszDst?
      if (bGlblRefBaseCmp) {
         strncpy(szLineBuf, pszDst, sizeof(szLineBuf)-10);
         szLineBuf[sizeof(szLineBuf)-10] = '\0';
         char *pszDot = strrchr(szLineBuf, '.');
         if (pszDot) *pszDot = '\0';
         pszDst = szLineBuf;
         if (cs.debug) info.print("BAS *%s* \n", pszDst);
      }

      char *pszHit = 0;
      if ((pszHit = strstr(pInFile, pszDst)))
      {
         // increment reference count for target
         int iCnt = glblRefDst.getLong(1, idst, __LINE__);
         glblRefDst.setLong(1, idst, iCnt+1, __LINE__);

         // remember (some) source infos referencing this target
         char *pszPre = pszHit;
         while (pszPre > pInFile) {
            #ifdef _WIN32
            bool bColon = (*pszPre == ':');
            #endif
            if (!isFileNameChar(*(pszPre-1)))
               break;
            pszPre--;
            #ifdef _WIN32
            if (bColon)
               break;
            #endif
         }
         char *pszPost = pszHit;
         while (pszPost < pInFile+nFileSize-1) {
            if (!isFileNameChar(*(pszPost+1)))
               break;
            pszPost++;
         }

         // relativize name, to match in later recursive checks
         char *pszRel = pszFile;
         if (cs.rootrelname) {
            pszRel = rootRelativeName(pszRel, pszOptRoot);
            if (!pszRel) return 9;
         }

         int nBruttoLen = pszPost-pszPre+1;
         if (nBruttoLen != (int)strlen(pszDst))
            sprintf(szLineBuf2, "%s\t%s\t[by text \"%s\" within \"%.*s\"]", pszRel, pszDstRaw, pszDst, (int)nBruttoLen, pszPre);
         else
            sprintf(szLineBuf2, "%s\t%s\t[by text \"%.*s\"]", pszRel, pszDstRaw, (int)nBruttoLen, pszPre);

         // we store up to n source infos in the extended rows
         if (iCnt < nGlblRefMaxSrc) {
            if (bGlblRefWideInfo)
               glblRefDst.setString(2+iCnt, idst, szLineBuf2);
            else
               glblRefDst.setString(2+iCnt, idst, pszFile); // pszRel?
         } else {
            bGlblRefLimitReached = 1;
         }
      }
      else {
         // printf("nohit %s: \n", pszFile);
         // sfkmem_hexdump(pInFile, (int)nFileSize);
      }
   }

   delete [] pInFile; 

   // printf("rps: %s done\n", pszFile);

   return 0;
}

bool nameListedIn(StringTable &rasrc, char *pszName)
{
   for (int isrcx=0; isrcx<rasrc.numberOfEntries(); isrcx++) {
      char *pszSrcX = rasrc.getEntry(isrcx, __LINE__);
      if (!strcmp(pszName, pszSrcX))
         return true;
   }
   return false;
}

int listDependencies(StringTable &rasrc, char *pszMixed, int nLevel, bool bPrintRoot, bool &rprinted)
{__
   // pszMixed format:
   // EITHER root\tignore\t[remark]
   //     OR root
   char *p1 = pszMixed;
   char *p2 = strchr(p1, '\t');
   char szRoot[200];
   if (p2) {
      int nroot = p2-p1;
      if (nroot > (int)sizeof(szRoot)-4) return 9+perr("buffer overflow #ld01 %d %d\n",sizeof(szRoot)-4,nroot);
      strncpy(szRoot, p1, nroot); szRoot[nroot] = '\0';
   } else {
      strcopy(szRoot, pszMixed);
   }

   if ((nLevel == 0) && (!bPrintRoot))
      { }
   else {
      // if filenames are collected
      if (cs.depsingle && chain.colfiles) {
         Coi ocoi(szRoot, 0);
         chain.addFile(ocoi); // is copied
      } else {
         chain.print(' ', 0, "%s", szRoot);
         rprinted |= 1;
      }
   }

   // remember we don't have to solve this root again
   char *pszRelRoot = szRoot;
   if (nLevel == 0 && cs.rootrelname) {
      pszRelRoot = rootRelativeName(pszRelRoot, 0);
      if (!pszRelRoot) return 9;
   }
   rasrc.addEntry(pszRelRoot);

   char szAnySrc[200];

   // recurse into dependencies of root
   for (int idst=0; idst<glblRefDst.numberOfEntries(0); idst++)
   {
      // scan ANY target
      char *pszDst  = glblRefDst.getString(0, idst);
      int  nRefCnt = glblRefDst.getLong(1, idst, __LINE__);
      if (nRefCnt <= 0) continue;

      int nDump = nRefCnt;
      if (nDump > nGlblRefMaxSrc)
         nDump = nGlblRefMaxSrc;

      // enumerate sources for ANY target
      for (int isrc=0; isrc<nDump; isrc++) 
      {
         char *pszMixed = glblRefDst.getString(2+isrc, idst);
         if (!pszMixed) return 9+perr("internal: unexpected NULL in RefDst %d %d %d\n",isrc,idst,nDump);

         // static int ntell=0;
         // while (ntell++ < 100)
         //    printf("mixed: %s\n", pszMixed);

         // holding anySource\ttargetForAnySource\t[remark]
         // INDEPENDENTLY from our current szRoot.
         p1 = pszMixed;
         p2 = strchr(p1, '\t'); if (!p2) return 9;
         int nsrc = p2-p1;
         if (nsrc > (int)sizeof(szAnySrc)-4) return 9+perr("buffer overflow #ld02 %d %d\n",sizeof(szAnySrc)-4,nsrc);
         strncpy(szAnySrc, p1, nsrc); szAnySrc[nsrc] = '\0';

         // now holding szAnySrc -> pszDst dependency.
         // are WE the szAnySrc?
         if (strcmp(pszRelRoot, szAnySrc)) continue; // no

         // yes: found another forward dependency as pszDst
         if (nameListedIn(rasrc, pszDst)) continue; // but done this already

         // found a new dependency as pszDst
         if (rprinted & 1) {
            if (rprinted & 2)
               chain.print(' ', 0, "\t"); // after very first output
            else
               chain.print(' ', 0, " ");  // after all other outputs
            rprinted &= 0xFF - 3;   // clear both flags
         }
         listDependencies(rasrc, pszDst, nLevel+1, bPrintRoot, rprinted);

         break; // DONE with current anySrc
      }
   }

   return 0;
}

int execDeblank(char *pszPath)
{__
   // replace blanks in (last part of) path by '_'
   strncpy(szLineBuf, pszPath, MAX_LINE_LEN);
   szLineBuf[MAX_LINE_LEN] = '\0';

   char *psz1 = strrchr(szLineBuf, glblPathChar);
   if (!psz1)
         psz1 = szLineBuf;

   bool bAny = 0;

   while (*psz1)
   {
      char craw = *psz1;
      char c = craw;

      if (cs.packalnum) 
      {
         // alnum reduction mode
         c = tolower(c);
         *psz1 = c;
         if (c != craw)
            bAny = 1;
         if (c == '.' || c == glblPathChar)
            { psz1++; continue; }
         if (c >= 'a' && c <= 'z')
            { psz1++; continue; }
         if (c >= '0' && c <= '9')
            { psz1++; continue; }
         // remove char from string
         int nlen = strlen(psz1);
         memmove(psz1,psz1+1,nlen); // INCLUDES zero term
         bAny = 1;
         continue; // staying at same psz1
      }

      // normal deblank mode
      if (c != ' ')
         { psz1++; continue; }
      // replace blank by underscore
      *psz1 = '_';
      psz1++;
      bAny = 1;
   }

   if (!bAny)
      return 0; // nothing to do

   if (!cs.quiet)
      printf("%s -> %s\n", pszPath, szLineBuf);

   if (cs.yes) {
      int nRC = rename(pszPath, szLineBuf);
      if (nRC) return 1+perr("rename failed on %s\n", pszPath);
   }

   return 0;
}

int sendLine(SOCKET hSock, cchar *psz, bool bQuiet=0);
int readLine(SOCKET hSock, char *pszLineBuf = 0, int nMode=0);

#ifdef WITH_TCP

int execFTPList(char *pszName)
{__
   // list a single file OR directory.

   if (!strcmp(pszName, "."))
      return 0;

   sfkstat_t ostat;

   int bIsDir    = 0;
   int bCanRead  = 1;
   int bCanWrite = 1;
   num  nFTimePre = 0;
   num  nFileSize = 0;
   getFileStat(pszName, bIsDir, bCanRead, bCanWrite, nFTimePre, nFileSize, 
               0, &ostat, sizeof(ostat));

   char szrwx[20];
   mclear(szrwx);
   strcpy(szrwx, "---------");

   uint nmode = ostat.st_mode;

   if (nmode & (1 << 8)) szrwx[0] = 'r';
   if (nmode & (1 << 7)) szrwx[1] = 'w';
   if (nmode & (1 << 6)) szrwx[2] = 'x';

   if (nmode & (1 << 5)) szrwx[3] = 'r';
   if (nmode & (1 << 4)) szrwx[4] = 'w';
   if (nmode & (1 << 3)) szrwx[5] = 'x';

   if (nmode & (1 << 2)) szrwx[6] = 'r';
   if (nmode & (1 << 1)) szrwx[7] = 'w';
   if (nmode & (1 << 0)) szrwx[8] = 'x';

   // -rw-r--r-- 1 ftp ftp         102808 Nov 20  2005 lslr
   // -rw-r--r-- 1 ftp ftp              4 May 27 23:34 tmp1.dat

   mytime_t nFileTime   = (mytime_t)nFTimePre;   // may be 0xFFFF
   mytime_t nSysTime    = getSystemTime();       // may be 0xFFFF
   struct tm *pSysTime  = 0;
   struct tm *pFileTime = 0;
   uint nSysYear = 0;

   #ifdef SFK_W64
   pSysTime  = _localtime64(&nSysTime);    // may be NULL
   nSysYear  = (pSysTime != 0) ? pSysTime->tm_year : 0;
   pFileTime = _localtime64(&nFileTime);   // OVERWRITES pSysTime!
   pSysTime  = 0;
   #else
   pSysTime  = localtime(&nSysTime);       // may be NULL
   nSysYear  = (pSysTime != 0) ? pSysTime->tm_year : 0;
   pFileTime = localtime(&nFileTime);      // OVERWRITES pSysTime!
   pSysTime  = 0;
   #endif

   char abTimeStamp[100];
   abTimeStamp[0] = '\0';

   // files of current year get time added on listing, else list year
   if (pFileTime != 0) {
      if (bGlblFTPListFlatTS) {
         char *pszFlat = timeAsString(nFTimePre, 1); // 1: flat
         if (pszFlat) strcopy(abTimeStamp, pszFlat);
      }
      else
      if (nSysYear == (uint)pFileTime->tm_year)
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %H:%M", pFileTime);
      else
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %Y", pFileTime);
   } else {
      strcpy(abTimeStamp, "Dez 31 9999");
   }

   // FTPClient::list parses binary info, and hands to Coi
   cchar *pszType = "";
   if (bGlblFTPListTextBin) {
      if (bIsDir)
         pszType = "d";
      else
      if (isBinaryFile(pszName))
         pszType = "b";
      else
         pszType = "t";
   }

   // CHG: since 1.6.7 list real attributes
   sprintf(szLineBuf2, "%c%s%s 1 ftp ftp %s %s ",
      bIsDir ? 'd' : '-',
      szrwx, // bGlblFTPReadWrite ? "rw-rw-rw-":"r--r--r--",
      pszType,
      numtoa_blank(nFileSize), abTimeStamp);

   char *pszTail = strrchr(pszName, glblPathChar);
   if (pszTail)
      pszTail++;
   else
      pszTail = pszName;

   char *pszPart = szLineBuf2+strlen(szLineBuf2);
   if (bGlblFTPListAsHTML) {
      strcat(szLineBuf2, "<a href=\"");
      strcat(szLineBuf2, pszName);
      strcat(szLineBuf2, "\">");
      strcat(szLineBuf2, pszName);
      strcat(szLineBuf2, "</a>");
   } else {
      strcat(szLineBuf2, pszTail);
   }
   for (; *pszPart; pszPart++)
      if (*pszPart=='\\')
         *pszPart='/';

   if (cs.debug)
      printf("< %s\n", szLineBuf2);

   if (sendLine(hGlblTCPOutSocket, szLineBuf2, 1)) // uses szLineBuf
      return 9;

   return 0;
}

int execVDirFTPList(char *pszName)
{__
   num nFTimePre = 0;
   num nFileSize = 0;

   char szrwx[20];
   mclear(szrwx);
   strcpy(szrwx, "rwxr-xr-x");

   // -rw-r--r-- 1 ftp ftp         102808 Nov 20  2005 lslr
   // -rw-r--r-- 1 ftp ftp              4 May 27 23:34 tmp1.dat

   mytime_t nFileTime   = (mytime_t)nFTimePre;   // may be 0xFFFF
   mytime_t nSysTime    = getSystemTime();       // may be 0xFFFF
   struct tm *pSysTime  = 0;
   struct tm *pFileTime = 0;
   uint nSysYear = 0;

   #ifdef SFK_W64
   pSysTime  = _localtime64(&nSysTime);    // may be NULL
   nSysYear  = (pSysTime != 0) ? pSysTime->tm_year : 0;
   pFileTime = _localtime64(&nFileTime);   // OVERWRITES pSysTime!
   pSysTime  = 0;
   #else
   pSysTime  = localtime(&nSysTime);       // may be NULL
   nSysYear  = (pSysTime != 0) ? pSysTime->tm_year : 0;
   pFileTime = localtime(&nFileTime);      // OVERWRITES pSysTime!
   pSysTime  = 0;
   #endif

   char abTimeStamp[100];
   abTimeStamp[0] = '\0';

   // files of current year get time added on listing, else list year
   if (pFileTime != 0) {
      if (bGlblFTPListFlatTS) {
         char *pszFlat = timeAsString(nFTimePre, 1); // 1: flat
         if (pszFlat) strcopy(abTimeStamp, pszFlat);
      }
      else
      if (nSysYear == (uint)pFileTime->tm_year)
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %H:%M", pFileTime);
      else
         strftime(abTimeStamp, sizeof(abTimeStamp)-10, "%b %d %Y", pFileTime);
   } else {
      strcpy(abTimeStamp, "Dez 31 9999");
   }

   // FTPClient::list parses binary info, and hands to Coi
   bool cType = 'd';

   // CHG: since 1.6.7 list real attributes
   sprintf(szLineBuf2, "%c%s%c 1 ftp ftp %s %s ",
      'd',
      szrwx, // bGlblFTPReadWrite ? "rw-rw-rw-":"r--r--r--",
      cType,
      numtoa_blank(nFileSize), abTimeStamp);

   char *pszTail = strrchr(pszName, glblPathChar);
   if (pszTail)
      pszTail++;
   else
      pszTail = pszName;

   char *pszPart = szLineBuf2+strlen(szLineBuf2);
   if (bGlblFTPListAsHTML) {
      strcat(szLineBuf2, "<a href=\"");
      strcat(szLineBuf2, pszName);
      strcat(szLineBuf2, "\">");
      strcat(szLineBuf2, pszName);
      strcat(szLineBuf2, "</a>");
   } else {
      strcat(szLineBuf2, pszTail);
   }
   for (; *pszPart; pszPart++)
      if (*pszPart=='\\')
         *pszPart='/';

   if (cs.debug)
      printf("< %s\n", szLineBuf2);

   if (sendLine(hGlblTCPOutSocket, szLineBuf2, 1)) // uses szLineBuf
      return 9;

   return 0;
}

int execFTPNList(char *pszFileName)
{
   return sendLine(hGlblTCPOutSocket, pszFileName, 1);
}

StringTable glblFTPRemList;
StringTable glblFTPLocList;

int execFTPLocList(char *pszFileName)
{
   return glblFTPLocList.addEntry(pszFileName);
}

#endif

class ExecFileScope 
{
public:
      ExecFileScope  (Coi *pCoiOrNull);
     ~ExecFileScope  ( );

static Coi *pClCoi;
};

Coi *ExecFileScope :: pClCoi = 0;

ExecFileScope::ExecFileScope(Coi *pcoi) { pClCoi=pcoi; }
ExecFileScope::~ExecFileScope( ) { pClCoi=0; }

int execSingleFile(Coi *pcoi, int lLevel, int &lFiles, int nDirFileCnt, int &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2)
{__ _p("sf.excfile")

   if (cs.debug)
      { printf("execSingleFile: %s\n", pcoi->name()); }

   ExecFileScope oscope(pcoi);

   char *pszFile     = pcoi->name();
   char *pszOptRoot  = pcoi->root(1);  // raw, returns 0 if none

   if (userInterrupt())
      return 9;

   if (cs.walkFileDelay > 0) doSleep(cs.walkFileDelay);

   // make sure the file really exists.
   // make an exception for "run", as it may use "$text".
   if (nGlblFunc != eFunc_Run) {
      // if no meta info was read yet, do it now.
      if (!pcoi->status())
         pcoi->readStat();
      // if meta reading failed, the file cannot be processed.
      if (pcoi->status() >= 9) {
         if (!cs.quiet && !cs.nowarn)
            pwarn("[nopre] cannot read file status: %s\n",pcoi->name());
         return 0; // do NOT stop dirtree processing
      }
   }

   if (!pszOptRoot && glblFileSet.hasRoot(0))
        pszOptRoot = glblFileSet.getCurrentRoot();
   // optionally supplied root dir can still be NULL.

   info.cycle();

   // skip initial dot slash which might be returned by dir scanning
   if (!strncmp(pszFile, glblDotSlash, 2))
      pszFile += 2;

   // if set, exclude output filename from input fileset,
   // to avoid endless recursions e.g. on snapto function.
   // see also checks for FileCollectionStamp.
   if (pszGlblOutFile)
      if (equalFileName(pszGlblOutFile,pszFile))
         return 0;

   if (cs.minsize > 0 && pcoi->getSize() < cs.minsize) {
      if (nGlblTraceSel & 2) {
         setTextColor(nGlblTraceExcColor);
         info.print("file-exclude: %s too small\n", pszFile);
         setTextColor(-1);
      }
      return 0;
   }

   if (cs.maxsize > 0 && pcoi->getSize() > cs.maxsize) {
      if (nGlblTraceSel & 2) {
         setTextColor(nGlblTraceExcColor);
         info.print("file-exclude: %s too large\n", pszFile);
         setTextColor(-1);
      }
      return 0;
   }

   // -text: process only textfiles
   if (cs.textfiles || cs.binaryfiles) 
   {
      bool bbin = pcoi->isBinaryFile();
      bool binc = 1;
      cchar *ptxt1 = "", *ptxt2 = "";

      if (cs.textfiles && bbin)
         { binc=0; ptxt1="binary"; ptxt2="text"; }

      if (cs.binaryfiles && !bbin)
         { binc=0; ptxt1="text"; ptxt2="binary"; }

      if (!binc) {
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceExcColor);
            info.print("file-exclude: %s is %s\n", pszFile, ptxt1);
            setTextColor(-1);
         }
         return 0;
      } else {
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceIncColor);
            info.print("file-include: %s is %s\n", pszFile, ptxt2);
            setTextColor(-1);
         }
      }
   }

   // -since: process only files newer or equal than timestamp
   if (cs.sincetime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get file time: %s\n", pszFile);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime < cs.sincetime)
         return 0; // skip
   }

   // -before: process only files older or equal than timestamp
   if (cs.untiltime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get file time: %s\n", pszFile);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime >= cs.untiltime)
         return 0; // skip
   }

   // -sincedir: process only files newer than in reference dir
   int nSinceReason = 0;
   if (pszGlblSinceDir)
   {
      // build relative name of file to be processed
      char *pszRel = pszFile;
      if (!bGlblSinceDirIncRef)
         pszRel = pcoi->rootRelName();
      if (!pszRel) return 9;
      // proceed with -sincedir processing
      joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszGlblSinceDir, pszRel);
      if (cs.verbose > 1)
         printf("CMP src %s ref %s\n",pszFile,szRefNameBuf);
      mtklog(("CMP src %s ref %s",pszFile,szRefNameBuf));
      // BEWARE OF MIXUP:
      //    sfk list -sincedir foo bar
      //       means for the user: FOO (szRefNameBuf) is the SOURCE.
      // so pszFile provided in here is actually the DESTINATION for compare.
      FileStat ofsSrc, ofsDst;
      if (ofsDst.readFrom(pszFile))       // the tree processing "target"
         return 9+perr("cannot read file time: %s\n",pszFile);
      if (ofsSrc.readFrom(szRefNameBuf))  // the -sincedir "source"
      {
         // file has been added, compared to source
         nSinceReason |= 4; // added
         if (!(nGlblSinceMode & 1)) {
            // added files not included:
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceExcColor);
               info.print("file-exclude: %s is added file, %s does not exist\n", pszFile, szRefNameBuf);
               setTextColor(-1);
            }
            cs.addedFilesSkipped++;
            return 0; // skip added files
         }
         // added files included:
         if (nGlblTraceSel & 2) {
            setTextColor(nGlblTraceIncColor);
            info.print("file-include: %s is added file, %s does not exist\n", pszFile, szRefNameBuf);
            setTextColor(-1);
         }
      }
      else
      {
         // both files exist

         // quick-check the size
         bool bDiffSize = 0;
         if (ofsSrc.getSize() != ofsDst.getSize())
            bDiffSize = 1;

         // compare times
         int nDiffReason = 0;
         if (!bGlblIgnoreTime) {
            if (!(nDiffReason = ofsSrc.differs(ofsDst, 0))) { // NOT same if older src
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s same time as %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               // if (!bDiffSize) // fall through on size mismatch
               return 0;
            } else {
               nSinceReason |= 1;
            }
         }

         // timestamp, attrib or exist difference: check also content
         if (bDiffSize)
            nSinceReason |= 2; // different size
         else
         if (!equalFileContent(szRefNameBuf, pszFile))
            nSinceReason |= 2; // file content difference

         if (nSinceReason & 2) 
         {
            // file content is different:
            if (cs.verbose)
               printf("differs by content: %s\n", pszFile);
   
            if (!(nGlblSinceMode & 2)) {
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s differs against %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               return 0; // skip differing files
            }

            // differing files included
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceIncColor);
               info.print("file-include: %s content differs against %s\n", pszFile, szRefNameBuf);
               setTextColor(-1);
            }
         }
         else
         {
            // have no content difference:
            if (!(nGlblSinceMode & 4)) {
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s time but no content diff against %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               return 0; // skip only-time diffs
            }

            // are we interested just in content diffs?
            if (bGlblIgnoreTime) {
               if (nGlblTraceSel & 2) {
                  setTextColor(nGlblTraceExcColor);
                  info.print("file-exclude: %s just time diff against %s\n", pszFile, szRefNameBuf);
                  setTextColor(-1);
               }
               return 0; // no content diff, no processing
            }

            // differing files included
            if (nGlblTraceSel & 2) {
               setTextColor(nGlblTraceIncColor);
               info.print("file-include: %s just time diff against %s\n", pszFile, szRefNameBuf);
               setTextColor(-1);
            }
         }
      }

      // sincedir checks passed: register reference
      pcoi->setRef(szRefNameBuf);

   }  // endif sincedir
   
   // the file is selected for processing.
   int icurfilenum = cs.selfilenum++;
   if (cs.selfilerange > 0) 
   {
      // should only process part of selection:
      if (icurfilenum < cs.selfileoff)
         return 0; // before selection start, continue
      if (icurfilenum >= cs.selfileoff + cs.selfilerange) {
         // after selection end: stop silently
         cs.stopfiletree = 1;
         return 0;
      }
   }

   // -to specified? if so, build output filename.
   char *pszOutFile = 0;
   if (cs.tomask)
   {
      if (cs.tomaskfile)
         pszOutFile = cs.tomask;
      else
      {
         int nrc = renderOutMask(szOutNameBuf, pcoi, cs.tomask, cs.curcmd); // generic
         // rc 0: done with replacements
         // rc 1: done without replacements
         if (nrc >= 9) return nrc;
         // if (nrc > 0) 
         // {
         //    perr("-to target name did not contain any patterns.\n");
         //    printx("<time>note : add or insert words like <run>file, <run>relfile, <run>base etc.<def>\n");
         //    printx("<time>note : type \"sfk run\" for a list of possible patterns.\n");
         //    return 9;
         // }
         if (nrc > 0 && cs.verbose > 0) {
            printf("to single output file: %s\n", szOutNameBuf);
         }
         if ((nrc > 0) && !cs.nowarn && !strcmp(szOutNameRecent, szOutNameBuf)) {
            if (!bGlblToldAboutRecent) {
               bGlblToldAboutRecent = 1;
               pwarn("same output used twice: %s\n", szOutNameBuf);
               pinf("specify -tofile filename or -nowarn to avoid this warning.\n");
            }
         }
         strcopy(szOutNameRecent, szOutNameBuf);
         pszOutFile = szOutNameBuf;
      }
   }

   switch (nGlblFunc) 
   {
      case eFunc_MD5Write  : return execMD5write(pcoi); break;
      case eFunc_JamFile   : return execJamFile(pcoi);  break;
      case eFunc_CallBack  : return execCallFileDir(pcoi);  break;
      case eFunc_Detab     : return execDetab(pszFile, pszOutFile); break;
      case eFunc_Scantab   : return execScantab(pszFile);    break;
      case eFunc_Entab     : return execEntab(pszFile, pszOutFile); break;
      case eFunc_JamIndex  : return execJamIndex(pszFile);   break;
      case eFunc_FileStat  : return execFileStat(pcoi, lLevel, lFiles, lDirs, lBytes, nLocalMaxTime, ntime2, nSinceReason);  break;
      case eFunc_FileTime  : return execFileTime(pszFile);   break;
      case eFunc_Touch     : return execTouch(pszFile, 0);   break;
      case eFunc_Find      : return execFind(pcoi);          break;
      case eFunc_Run       : return execRunFile(pcoi, pszOutFile, lLevel, lFiles, lDirs, lBytes);  break;
      case eFunc_FormConv  : return execFormConv(pszFile, pszOutFile);   break;
      #ifdef WITH_FN_INST
      case eFunc_Inst      : return execInst(pszFile, lLevel, lFiles, lDirs, lBytes);  break;
      #endif
      case eFunc_RefColSrc : return execRefColSrc(pszFile);  break;
      case eFunc_RefColDst : return execRefColDst(pcoi);     break;
      case eFunc_Deblank   : return execDeblank(pszFile);    break;
      #ifdef WITH_TCP
      case eFunc_FTPList   : return execFTPList(pszFile);    break;
      case eFunc_FTPNList  : return execFTPNList(pszFile);   break;
      case eFunc_FTPLocList: return execFTPLocList(pszFile); break;
      #endif
      case eFunc_Hexdump   : return execHexdump(pcoi, 0, 0);   break;
      case eFunc_AliasList : return execAliasList(pszFile);  break;
      #ifndef SFKXEREP
      case eFunc_ReplaceFix: return execReplaceFix(pcoi);    break;
      case eFunc_ReplaceVar: return execReplaceVar(pcoi);    break;
      #endif
      case eFunc_Filter    : return execFilter(pcoi, 0, 0, -1, pszOutFile); break;
      case eFunc_Delete    : return execDelFile(pszFile);    break;
      #ifndef USE_SFK_BASE
      case eFunc_Copy      : return execFileCopy(pcoi);      break;
      case eFunc_Cleanup   : return execFileCleanup(pszFile);     break;
      case eFunc_MetaUpd   : return execMetaFileUpdate(pszFile); break;
      case eFunc_MetaCheck : return execMetaFileCheck(pszFile); break;
      case eFunc_DupScan   : return execDupScan(pcoi);    break;
      #endif // USE_SFK_BASE
      case eFunc_Version   : return execVersion(pcoi); break;
      case eFunc_Media     : return execMedia(pszFile, pszOutFile); break;
      default:
         break;
   }

   return 0;
}

char szMirStatBuf[200];
void showMirrorStatus(const char *pszAction, const char *pszStatus,
   char *pszObject, bool bIsFile, int nCount, bool bLF=0)
{
   // if pszObject is a filename with path, show just path.

   int nLen = strlen(pszObject);
   if (bIsFile) {
      char *psz1 = strrchr(pszObject, glblPathChar);
      if (psz1) nLen = psz1-pszObject;
   }
   if (nLen > 40) { pszObject += (nLen-40); nLen = 40; }

   sprintf(szMirStatBuf, "%04u %4.4s %4.4s %03u %.*s ",
      glblFileCount.value(),
      pszAction, pszStatus,
      nCount, nLen, pszObject
      );

   // fill up with blanks to 76 chars
   nLen = strlen(szMirStatBuf);
   while (nLen < 76)
      szMirStatBuf[nLen++] = ' ';
   szMirStatBuf[nLen] = '\0';

   if ((cs.verbose==2) && strcmp(pszAction, "scan") && strcmp(pszStatus, "----"))
      bLF = 1;

   printf("%s%c", szMirStatBuf, bLF ? '\n' : '\r');
   fflush(stdout);
}

#ifdef SFK_CCDIRTIME
StringTable glblCreatedDirs;
#endif

bool isNetDriveRoot(char *psz)
{
   #ifdef _WIN32
   if (strncmp(psz, "\\\\", 2)) return 0;
   #else
   if (strncmp(psz, "//", 2)) return 0;
   #endif
   // jump past \\, check if further dir is appended
   char *psz2 = strchr(psz+2, glblPathChar);
   if (!psz2) return 1;   // yes: e.g. \\foomachine
   // is it JUST a slash or something more?
   psz2++;
   if (!strlen(psz2)) return 1; // just the slash
   return 0; // no: e.g. \\foomachine\c$
}

// uses szLineBuf, abBuf
int createSubDirTree(char *pszDstRoot, char *pszDirTree, char *pszRefRoot=0)
{
   // create all needed target directories
   joinPath(szLineBuf, MAX_LINE_LEN, pszDstRoot, pszDirTree);

   char *psz1 = szLineBuf;
   char *psz2 = 0;
   if (strlen(psz1))
      psz2 = strchr(psz1+1, glblPathChar);
   while (psz2) 
   {
      strncpy((char*)abBuf, psz1, psz2-psz1);
      abBuf[psz2-psz1] = 0;
      char *pszDir = (char*)abBuf;

      #ifdef _WIN32
      if (strlen(pszDir)==2 && pszDir[1]==':')
      { } // don't create "c:"
      else
      #endif
      if (isNetDriveRoot(pszDir))
      { }
      else
      if (!isDir(pszDir)) 
      {
         if (cs.verbose) 
            printf("mkdir.1: %s\n", pszDir);
         #ifdef _WIN32
         if (_mkdir(pszDir))
         #else
         if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
         #endif
         {
            perr("cannot create dir: %s\n", pszDir);
            return 9;
         }
         // if ref root is given, copy its timestamp
         // doesn't work here: file created afterwards updates the dir timestamp
         // trace created dir in global list
         #ifdef SFK_CCDIRTIME
         glblCreatedDirs.addEntry(pszDir);
         #endif
         // count created dir
         cs.dirs++;
      }
      psz2 = strchr(psz2+1, glblPathChar);
   }

   char *pszDir = szLineBuf;

   #ifdef _WIN32
   if (strlen(pszDir)==2 && pszDir[1]==':')
   { } // don't create "c:"
   else
   #endif
   if (isNetDriveRoot(pszDir))
   { }
   else
   if (!isDir(pszDir)) 
   {
      if (cs.verbose)
         printf("mkdir.2: %s\n", pszDir);
      #ifdef _WIN32
      if (_mkdir(pszDir))
      #else
      if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
      #endif
      {
         perr("cannot create dir: %s\n", pszDir);
         return 9;
      }
      #ifdef SFK_CCDIRTIME
      glblCreatedDirs.addEntry(pszDir);
      #endif
      cs.dirs++;
   }
   return 0;
}

// create dir tree required to write the specified filename.
// uses: szLineBuf, abBuf
// note: does NOT add to glblCreatedDirs
//       does not count created dirs.
int createOutDirTree(char *pszOutFile)
{
   if (cs.debug)
      printf("createOutDirTree for: %s\n", pszOutFile);

   // isolate path from filename
   // c:\foo\bar.txt -> c:\foo
   // c:foo\bar.txt -> c:\foo
   // c:bar.txt -> skip
   strcopy(szLineBuf, pszOutFile);
   char *psz = strrchr(szLineBuf, glblPathChar);
   if (!psz) return 0; // nothing to do
   *psz = '\0';

   char *psz1 = szLineBuf;
   char *psz2 = 0;
   if (strlen(psz1))
      psz2 = strchr(psz1+1, glblPathChar);
   while (psz2) 
   {
      strncpy((char*)abBuf, psz1, psz2-psz1);
      abBuf[psz2-psz1] = 0;
      char *pszDir = (char*)abBuf;
      #ifdef _WIN32
      if (strlen(pszDir)==2 && pszDir[1]==':')
      { } // don't create "c:"
      else
      #endif
      if (isNetDriveRoot(pszDir))
      { }
      else
      if (!isDir(pszDir)) 
      {
         if (cs.verbose) 
            printf("mkdir.3: %s\n", pszDir);
         #ifdef _WIN32
         if (_mkdir(pszDir))
         #else
         if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
         #endif
         {
            perr("cannot create dir: %s\n", pszDir);
            return 9;
         }
      }
      psz2 = strchr(psz2+1, glblPathChar);
   }

   char *pszDir = szLineBuf;

   #ifdef _WIN32
   if (strlen(pszDir)==2 && pszDir[1]==':')
   { } // don't create "c:"
   else
   #endif
   if (isNetDriveRoot(pszDir))
   { }
   else
   if (!isDir(pszDir)) 
   {
      if (cs.verbose)
         printf("mkdir.4: %s\n", pszDir);
      #ifdef _WIN32
      if (_mkdir(pszDir))
      #else
      if (mkdir(pszDir, S_IREAD | S_IWRITE | S_IEXEC))
      #endif
      {
         perr("cannot create dir: %s\n", pszDir);
         return 9;
      }
   }
   return 0;
}

int execSingleDir(Coi *pcoi, int lLevel, int &nTreeFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2)
{__ _p("sf.execdir")

   char *pszName     = pcoi->name();
   char *pszOptRoot  = pcoi->root(1);  // raw, returns 0 if none

   if (cs.debug) printf("]  esdir: %s files=%d\n", pszName, nTreeFiles);

   if (userInterrupt())
      return 9;

   if (cs.withdirs || cs.justdirs) 
   {
      // -justdirs: if a path mask is given, we still have
      // to traverse all subfolders, but we don't list
      // or process non matching subfolders.
      // ,1 : take full path, is a directory name
      // ,1 : apply also white masks (?)
      if (!matchesDirMask(pszName, 1, 1)) // on subdir
      {
         if (cs.debug) printf("]  esdir: path mask mismatch\n");
         return 0; // filter from output
      }

      // -justdirs: IF any non-"*" file mask is set,
      if (glblFileSet.anyFileMasks())
      {
         if (cs.debug) printf("]  esdir: using file masks\n");
         //  process dir only if any files within match
         if (!nTreeFiles) return 0; // skip
         // -justdirs: make sure the next-higher dir is not listed again
         if (cs.justdirs)  // FIX: 167: stat mydir .mask always "0 files"
            nTreeFiles = 0;
      } else {
         if (cs.debug) printf("]  esdir: no file masks, process all\n");
      }
   }

   if (cs.walkDirDelay > 0) doSleep(cs.walkDirDelay);

   // skip initial dot slash which might be returned by dir scanning
   if (!strncmp(pszName, glblDotSlash, 2))
      pszName += 2;

   if (pszGlblSinceDir) 
   {
      // build relative name of file to be processed
      char *pszRel = pszName;
      if (!bGlblSinceDirIncRef)
            pszRel = rootRelativeName(pszName, pszOptRoot);
      if (!pszRel) return 9;

      // check if dirs for comparison both exist
      joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszGlblSinceDir, pszRel);
      if (!isDir(szRefNameBuf)) {
         // this is often a user error
         if (cs.verbose) {
            setTextColor(nGlblWarnColor);
            info.print("no reference dir: %s\n", szRefNameBuf);
            setTextColor(-1);
         }
         nGlblMissingRefDirs++;
      } else {
         nGlblMatchingRefDirs++;
      }
   }

   // -since: process only dirs newer or equal than timestamp,
   // relevant only on commands like list -withdirs -since ...
   if (cs.sincetime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get dir time: %s\n", pszName);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime < cs.sincetime)
         return 0; // skip
   }

   // -before: process only dirs older or equal than timestamp
   if (cs.untiltime) {
      num nFileTime = pcoi->getTime();
      if (nFileTime <= 0) return 5+perr("cannot get dir time: %s\n", pszName);
      if (nFileTime > cs.maxFileTime)
         cs.maxFileTime = nFileTime;
      if (nFileTime >= cs.untiltime)
         return 0; // skip
   }

   int lRC = 0;
   switch (nGlblFunc) 
   {
      case eFunc_FileStat:
           lRC = execDirStat(pcoi, lLevel, nTreeFiles, lDirs, lBytes, nLocalMaxTime, ntime2);
           break;
      case eFunc_FileTime:
           lRC = execDirTime(pszName);
           break;
      case eFunc_CallBack:
           lRC = execCallFileDir(pcoi);
           break;
      case eFunc_Run     :
           if (cs.justdirs)
              lRC = execRunDir(pcoi, lLevel, nTreeFiles, lDirs, lBytes);
           break;
      case eFunc_Deblank :
           return execDeblank(pszName);
           break;
      #ifndef USE_SFK_BASE
      case eFunc_Copy    :
           return execDirCopy(pszName, oDirFiles);
      case eFunc_Cleanup :
           return execDirCleanup(pszName, oDirFiles);
      case eFunc_MetaUpd: execMetaDirUpdate(pszName); break;
      #endif // USE_SFK_BASE

      case eFunc_Find:
           if (cs.subdirs) {
              info.setAddInfo("%u files, %u dirs", cs.filesScanned, cs.dirsScanned);
              info.setStatus("scan ", pszName, 0, eKeepAdd);
              cs.dirsScanned++;
           }
           break;

      case eFunc_Delete: 
            execDelDir(pszName, lLevel, nTreeFiles, oDirFiles, lDirs, lBytes, nLocalMaxTime, ntime2);
            break;

      #ifdef WITH_TCP
      case eFunc_FTPList :
            if (!bGlblFTPListAsHTML)
               return execFTPList(pszName);
            break;
      #endif

      default:
           break;
   }

   // localMaxTime was used w/in above methods, reset now
   // to avoid potential further use in other dir trees.
   nLocalMaxTime = 0;

   return lRC;
}

int execTextJoinLines(char *pIn) {
   // join a text file with lines broken by mailing

   // 1. pre-scan for line length maximum
   char *psz = pIn;
   int nLineChars = 0;
   int nLineCharMax = 0;
   while (*psz)
   {
      char c = *psz++;
      if (c == '\r')
         continue;
      if (c == '\n') {
         if (nLineChars > nLineCharMax)
            nLineCharMax = nLineChars;
         nLineChars = 0;
         continue;
      }
      nLineChars++;
   }

   if (!cs.quiet)
      printf("[line break near %d]\n", nLineCharMax);

   // 2. join lines which are broken, pass-through others
   psz = pIn;
   nLineChars = 0;
   while (*psz)
   {
      char c = *psz++;

      if (c == '\r') // drop CR. LF-mapping is done by runtime.
         continue;

      if (c == '\n') {
         // line collected. what to do?
         if (   (nLineChars < nLineCharMax-1)
             || (nLineChars > nLineCharMax)
            )
         {
            fputc(c, fGlblOut);  // not near threshold: do not join
         }
         nLineChars = 0;
         continue;
      } else {
         fputc(c, fGlblOut);
      }

      nLineChars++;
   }
   
   return 0;
}

int hexToBin(char *pszHex, uchar *pBin, uint nBinLen)
{
   int nBinRem = (int)nBinLen; // remaining out buffer
   char szBuf[10];
   memset(szBuf, 0, sizeof(szBuf));
   while (*pszHex && (nBinRem > 0)) {
      szBuf[0] = *pszHex++;
      if (!*pszHex) return 1;
      szBuf[1] = *pszHex++;
      if (!isxdigit(szBuf[0])) return 2;
      if (!isxdigit(szBuf[1])) return 2;
      *pBin++ = (uchar)strtol(szBuf, 0, 0x10);
      nBinRem--;
   }
   if (*pszHex || nBinRem)
      return 3;
   return 0;
}

uchar *memFind(uchar *pNeedle, num nNeedleSize, uchar *pHayStack, num nHaySize)
{
   uchar *pCur = pHayStack;
   uchar *pMax = pHayStack + nHaySize - nNeedleSize; // inclusive
   uchar c1    = *pNeedle;
   while (pCur <= pMax)
   {
      uchar *p1 = pCur;
      // seek to next potential start
      // while ((p1 <= pMax) && (*p1 != c1))
      //   p1++;
      p1 = (uchar*)memchr(p1, c1, pMax - p1 + 1); // +1: pMax is inclusive
      if (!p1 || (p1 > pMax))
         return 0;
      // compare
      if ((p1 <= pMax) && !memcmp(p1, pNeedle, nNeedleSize))
         return p1;  // hit
      // no hit, proceed
      pCur = p1+1;
   }
   return 0;
}

int provideExtractOutFile(char *pszFilename)
{
   if (cs.extractOutFile)
      return 0; // OK
   if (createOutDirTree(pszFilename))
      return 9;
   if ((cs.extractOutFile = fopen(pszFilename, "wb")))
      return 0;
   return 9+perr("cannot write output file: %s", pszFilename);
}

int addToExtractOutFile(uchar *pData, int iSize)
{
   if (!cs.extractOutFile)
      return 9;
   if (fwrite(pData, 1, iSize, cs.extractOutFile) != iSize)
      return 9+perr("cannot fully write output file, probably disk full");
   return 0;
}

void perFileExtractOutCleanup( )
{
   if (!cs.tomaskfile && cs.extractOutFile) {
      fclose(cs.extractOutFile);
      cs.extractOutFile = 0;
   }
}

void globalExtractOutCleanup( )
{
   if (cs.extractOutFile) {
      fclose(cs.extractOutFile);
      cs.extractOutFile = 0;
   }
}

int  nGlblDumpCtx   = 0; // additional context bytes for dump
int  nBinRepExp     = 0; // no. of replacement expressions
uchar **apRepSrcExp = 0; // source expressions
int  *apRepSrcLen   = 0; // length of source expressions
uchar **apRepDstExp = 0; // dest. expressions
int  *apRepDstLen   = 0; // length of dest. expressions
int  *apRepFlags    = 0; // 0:is it text or binary, 1:was it found, 2:use case
num   *apRepOffs    = 0; // current offset in file to continue search
#ifdef WITH_CASE_XNN
uchar **apRepSrcBit = 0; // bit flags per char
#endif

// note: default record size is 100000
#define SFK_CTX_SIZE 32768
#define SFK_CTX_MASK 32767

int execReplaceFix(Coi *pcoi)
{__
   char *pszFile = pcoi->name();

   if (cs.debug)
      { printf("execReplaceFix: %s\n", pszFile); }

   if (!pcoi->existsFile())
      return 1+perr("unable to read: %s - skipping\n", pszFile);

   num nFileSize = pcoi->getSize();
   if (nFileSize < 0 ) return 1+perr("unable to read: %s - skipping\n", pszFile);
   if (nFileSize == 0) return 0+pwarn("empty file: %s - skipping\n", pszFile);

   FileInfo finf;
   if (finf.init(pszFile, 56, nFileSize)) return 9;

   int lRC = 0;

   if (cs.sim) {  // with hexfind, sim MUST be set
      if (pcoi->open("rb"))
         return 1+perr("failed to read: %s - skipping%s\n", pcoi->name(),pcoi->lasterr());
   } else {
      if (cs.keeptime)
         pcoi->setKeepTime(pcoi);
      if (pcoi->open("r+b"))
         return 1+perr("failed to read+write: %s - skipping\n", pcoi->name(),pcoi->lasterr());
   }

   cs.files++; // no. of files read

   bool bFileChanged = 0;

   // reset hit flags etc.
   for (int i5=0; i5<nBinRepExp; i5++) {
      apRepFlags[i5] &= (0xFF ^ (1 << 1));
      apRepOffs[i5] = 0;
   }

   num nBlockPos  =  0;
   num nBlockSize =  0;
   num nReplaced  =  0;
   bool bTold     =  0;
   int nPerc      =  0;
   int nLastPerc  =  0;
   num  nLastOff  = -1;
   bool bbail     =  0;
   bool bLastRecord = 0;

   while (!bbail)
   {
      if (userInterrupt())
         { lRC=2; break; }

      nPerc = (int)(nBlockPos * 100 / nFileSize);

      if (pcoi->seek(nBlockPos, SEEK_SET))
      {
         pcoi->close();
         if (bTold) printf("\n");
         perr("failed to seek within %s%s\n", pszFile, cs.sim ? "" : " - stopping write. file may be damaged.");
         lRC=1; break;
      }

      num nRead = pcoi->read(abBuf, sizeof(abBuf)-1000);

      // printf("erf: read %d from %d\n",(int)nRead,(int)nBlockPos);

      if (nRead <= 0) {
         if (nBlockPos == nFileSize)
            break; // OK, EOF reached
         pcoi->close();
         if (bTold) printf("\n");

         #ifdef VFILEBASE
          #ifndef VFILEMAX
         if (pcoi->isZipSubEntry()) {
            setTextColor(nGlblWarnColor);
            printf("... stopped reading at %d bytes (demo limit).\n",(int)(nBlockPos-54));
            setTextColor(-1);
         }
         else
          #endif
         #endif // VFILEBASE
         perr("failed to fully read %s%s\n", pszFile, cs.sim ? "" : " - stopping write. file may be damaged.");

         lRC=1; break;
      }

      nBlockSize = nRead;
      bool bTouched = 0;

      // over all search expressions
      for (int iexp=0; iexp<nBinRepExp; iexp++) 
      {
         uchar *pExp     = apRepSrcExp[iexp];
         int   nExpLen   = apRepSrcLen[iexp];
         int   nExpFlags = apRepFlags[iexp];
         #ifdef WITH_CASE_XNN
         uchar *pBit     = apRepSrcBit[iexp];
         #endif

         // in case of rep simulation or hexfind, the destination
         // expression length is NOT the same as ExpLen, but ZERO.
         int   nDstLen  = apRepDstLen[iexp];

         // decide if comparison shall be done case-insensitive.
         bool   bBinary  = (nExpFlags & (1<<0)) ? 1 : 0;
         bool   bUseCase = bBinary || cs.usecase;
         if (cs.nocase) bUseCase = 0; // forced nocase on everything

         // is expression (repeatedly) contained in current block?
         // NOTE: blocks are read with overlapping areas, to avoid patterns
         //       getting lost on block boundaries. therefore nOffs is needed
         //       to avoid repeated hits on the same target, esp. in sim mode.
         num    nOffs = apRepOffs[iexp];
         num    nRel  = nOffs - nBlockPos; // last continue pos, w/in current block
         uchar *pSubCur = abBuf;
         if (nRel > 0) pSubCur += nRel; // don't rescan from start
         uchar *pSubMax = abBuf + nBlockSize - nExpLen;
         while (pSubCur <= pSubMax) 
         {
            num nRemain = nBlockSize - (pSubCur - abBuf);

            uchar *pHit = 0;
            if (bUseCase) {
               pHit = memFind(pExp, nExpLen, pSubCur, nRemain);
            } else {
               #ifdef WITH_CASE_XNN
               pHit = memIFind(pExp, nExpLen, pSubCur, nRemain, pBit);
               #else
               pHit = memIFind(pExp, nExpLen, pSubCur, nRemain);
               #endif
            }
            if (!pHit)
               break;

            // yes: replace by dest. expression
            if ((cs.verbose >= 2) && !(apRepFlags[iexp] & (1<<0))) {
               int nslen = (int)nExpLen;
               printf("replace @%s: %.*s -> %.*s\n",numtohex(nBlockPos+(pHit-abBuf),10),nslen,pHit,nslen,apRepDstExp[iexp]);
            }

            if (cs.repDump) 
            {
               num nctx    = nGlblDumpCtx;
               num nAlign0 = bGlblHexDumpWide ? 16 :  8;
               num nAlign1 = bGlblHexDumpWide ? 32+nctx : 16+nctx;
               num nAlign2 = bGlblHexDumpWide ? 48+nctx : 18+nctx;
               num nHitRaw = pHit - abBuf;
               num nHitLow = nHitRaw;
               num nHitHi  = nHitLow + nExpLen;
               if (nHitLow > nAlign1) nHitLow -= nAlign1; else nHitLow = 0;
               if (nHitHi  < (nBlockSize - nAlign2)) {
                  nHitHi += nAlign2;
                  // align dump size to multiples of 16 or 32
                  num nDiff = nHitHi-nHitLow;
                  nDiff = ((num)(nDiff / nAlign0)) * nAlign0; // floor
                  nHitHi = nHitLow + nDiff;
               } else {
                  // near end of file: make sure to dump all bytes
                  nHitHi = nBlockSize;
               }
               num nDumpLen = nHitHi-nHitLow;
               if (nDumpLen < MAX_LINE_LEN) {
                  int iHiOff=-1,iHiLen=-1;
                  memcpy(szRefNameBuf, abBuf+nHitLow, nDumpLen);
                  // this is redundant to cpy below, but doesn't matter
                  if (nExpLen == nDstLen) // else hexfind or sim
                     memcpy(pHit, apRepDstExp[iexp], nExpLen);
                  else 
                  {
                     // hexfind or sim MUST have cs.sim set.
                     if (!cs.sim) return 9+perr("int. #58281821");
                     // calc hilite area for diffdump below
                     iHiOff = (int)(nHitRaw - nHitLow);
                     iHiLen = nExpLen;
                  }
                  num nListOff = nBlockPos + nHitLow;
                  if (bTold) { bTold=0; finf.printBlankLine(78); }
                  // setTextColor(nGlblFileColor);
                  char szOffBuf1[60]; szOffBuf1[0] = '\0';
                  char szOffBuf2[60]; szOffBuf2[0] = '\0';
                  num nAbsOff = nHitRaw+nBlockPos;
                  sprintf(szOffBuf1, "at offset 0x%.20s", numtohex(nAbsOff));
                  if (cs.reldist && nLastOff >= 0) {
                     int nRelOff = (int)(nAbsOff - nLastOff);
                     sprintf(szOffBuf2, " reldist %u (0x%x)", nRelOff, nRelOff);
                  }
                  chain.print('f', 1, "%s : %s %s%s",pszFile,cs.sim?"hit":"change",szOffBuf1,szOffBuf2);
                  // setTextColor(-1);
                  if (cs.hexfind)
                     execHexdump(0, abBuf+nHitLow, nDumpLen, iHiOff, iHiLen, 0, nListOff);
                  else
                     diffDump((uchar*)szRefNameBuf, abBuf+nHitLow, nDumpLen, nListOff, iHiOff, iHiLen);
                  nLastOff = nAbsOff;
               }
            }  // endif dump
            
            // this cpy is done always, no matter if RepDump or not:
            if (nExpLen == nDstLen) // else hexfind or sim
               memcpy(pHit, apRepDstExp[iexp], nExpLen);
            bTouched = 1;
            nReplaced++;
            apRepFlags[iexp] |= (1 << 1);
            // proceed within block, after hit
            pSubCur = pHit + nExpLen;
            // also remember this position to avoid redundant hits, esp. on sim
            nOffs = nBlockPos + (pSubCur - abBuf);
            apRepOffs[iexp] = nOffs;

            if (cs.useFirstHitOnly)
               { iexp = nBinRepExp; bbail = 1; break; }

         }  // endwhile pSubCur

      }  // endfor patterns

      // need to write block back?
      if (bTouched) 
      {
         bFileChanged = 1;

         if (chain.colfiles)
            chain.addFile(*pcoi);
      
         if (cs.sim) {
            if (finf.timeToTell()) {
               printf("%02d%% %s%s : %s hits \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
               fflush(stdout);
               bTold = 1;
            }
         } else {
            if (pcoi->seek(nBlockPos, SEEK_SET)) {
               pcoi->close();
               if (bTold) printf("\n");
               esys("fseek", "failed to seek within %s - stopping write. file may be damaged.\n", pszFile);
               lRC=1; break;
            }
            num nWrite = pcoi->write(abBuf, nBlockSize);
            if (nWrite != nBlockSize) {
               pcoi->close();
               if (bTold) printf("\n");
               esys("fwrite", "failed to write to %s - stopping write. file may be damaged.\n", pszFile);
               lRC=1; break;
            }
            if (!cs.quiet) {
               printf("%02d%% %s%s : %s changes \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
               fflush(stdout);
               bTold = 1;
            }
         }
      }

      // proceed with overlap, to catch expressions on block boundaries
      nBlockPos += nBlockSize;
      if (nBlockPos < nFileSize)
          nBlockPos -= (nBlockSize / 4);

      if (!cs.quiet && (nPerc != nLastPerc)) {
         printf("%02d%% %s%s : %s %s \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced),cs.sim?"hits":"changes");
         bTold = 1;
      }
      nLastPerc = nPerc;

   }  // endwhile input

   if (bFileChanged)
      cs.filesChg++;

   if (lRC) {
      pcoi->close();
      return lRC; 
   }

   // collect stats: all patterns found?
   int nTotPats = nBinRepExp;
   int nHitPats = 0;
   for (int i2=0; i2<nBinRepExp; i2++) 
   {
      if (apRepFlags[i2] & (1 << 1))
         nHitPats++;
      else
      if (cs.verbose) {
         printf("%s : pattern not found: ",pszFile);
         if (apRepFlags[i2] & (1 << 0)) {
            uchar *pBin = apRepSrcExp[i2];
            for (int i9=0; i9<apRepSrcLen[i2]; i9++)
               printf("%02X",pBin[i9]);
            printf(" [binary]\n");
         } else {
            printf("%s\n",apRepSrcExp[i2]);
         }
      }
   }
   int nNotPats = nTotPats - nHitPats;

   if (bTold)
      finf.printBlankLine(78);

   if (cs.dostat || cs.verbose)
   {
      if (!nHitPats && !cs.verbose)
      { } // don't list files we wouldn't change
      else
      {
         cchar *pszPre   = finf.prefix();
         cchar *pszShort = finf.shortName();
         char szNumBuf[100];
         chain.print(' ', 1, "[%s/%d/%d] %s%s", // FIX: 160R2: nReplaced with >2G 
            numtoa(nReplaced,3,szNumBuf),
            (int)nHitPats,(int)nNotPats,pszPre,pszShort);
      }
   }

   pcoi->close();

   return 0;
}

void tellMemLimitInfo() {
   static bool btold = 0;
   if (!btold) { btold = 1;
      pinf("some file(s) are larger than the memory limit. see option -memlimit under \"sfk help opt\"\n");
   }
}

int execReplaceVar(Coi *pcoi)
{__
   char *pszFile = pcoi->name();

   if (cs.debug)
      { printf("execReplaceVar: %s\n", pszFile); }

   if (!pcoi->existsFile())
      return 1+perr("unable to read: %s - skipping\n", pszFile);

   num nFileSize = pcoi->getSize();
   if (nFileSize < 0 ) return 1+perr("unable to read: %s - skipping\n", pszFile);
   if (nFileSize == 0) return 0+pwarn("empty file: %s - skipping\n", pszFile);

   if (!cs.sim && cs.keeptime)
      pcoi->setKeepTime(pcoi);

   FileInfo finf;
   if (finf.init(pszFile, 56)) return 9;

   int lRC = 0;

   if (nFileSize > nGlblMemLimit) {
      perr("file too large to load: %s, %s mbytes", pszFile, numtoa(nFileSize/1000000));
      tellMemLimitInfo();
      return 9;
   }

   num nFileSize2 = 0;
   uchar *praw = loadBinaryFile(pszFile, nFileSize2);
   if (!praw) return 9+perr("cannot load: %s\n", pszFile);
   if (nFileSize2 != nFileSize) {
      delete [] praw;
      return 9+perr("cannot load (2): %s\n", pszFile);
   }

   cs.files++; // no. of files read

   bool bFileChanged = 0;

   // reset hit flags etc.
   for (int i5=0; i5<nBinRepExp; i5++) {
      apRepFlags[i5] &= (0xFF ^ (1 << 1));
      apRepOffs[i5] = 0;
   }

   num nReplaced  = 0;
   bool bTold     = 0;
   int nPerc      = 0;
   int nLastPerc  = 0;
   bool bTouched  = 0;

   num nMaxSizeCur  = nFileSize; // temporary output buffer used size
   num nMaxSizePeak = 0;         // largest expansion reached by output buffer
   uchar *pMaxDat   = 0;         // alloc'ed using MaxSizePeak
   uchar *pMem      = praw;
   num    nMemSize  = nFileSize;
   bool   bGlobalExpand = 0;  // overall memory
   bool   bLocalExpand  = 0;  // current expression

   // NO RETURN W/O DELETE FROM HERE

   int npasses = cs.sim ? 1 : 2;

   for (int npass=0; npass<npasses; npass++)
   {
      if (userInterrupt())
         { lRC=2; break; }

      if (npass == 1) {
         if (nMaxSizePeak > nFileSize) {
            num nTotalUsage = nFileSize + nMaxSizePeak;
            if (nTotalUsage > nGlblMemLimit) {
               perr("memory limit exceeded: %s requires %s mbytes for processing\n", pszFile, numtoa(nTotalUsage/1000000));
               pinf("say \"sfk -memlimit=500m replace ...\" to change the limit to 500 mbytes.\n");
               delete [] praw;
               return 9;
            }
            pMaxDat = new uchar[nMaxSizePeak+1024];
            memset(pMaxDat, 0, nMaxSizePeak+1024);
            memcpy(pMaxDat, praw, nFileSize);
            pMaxDat[nMaxSizePeak] = 0xEE;
            bGlobalExpand = 1;
         } else {
            pMaxDat = praw;
            pMaxDat[nFileSize] = 0xEE; // extended bytes provided by loadBinaryFile
         }
         pMem    = pMaxDat;
         nMemSize= nFileSize; // initially, changes with replacements.
      }

      // over all search expressions
      for (int iexp=0; iexp<nBinRepExp; iexp++) 
      {
         if (userInterrupt())
            { lRC=2; break; }

         // get source pattern
         uchar *pSrc     = apRepSrcExp[iexp];
         int   nSrcLen   = apRepSrcLen[iexp];
         int   nSrcFlags = apRepFlags[iexp];
         #ifdef WITH_CASE_XNN
         uchar *pBit     = apRepSrcBit[iexp];
         #endif

         // decide if comparison shall be done case-insensitive.
         bool   bBinary  = (nSrcFlags & (1<<0)) ? 1 : 0;
         bool   bUseCase = bBinary || cs.usecase;
         if (cs.nocase) bUseCase = 0; // forced nocase on everything

         // get destination pattern
         uchar *pDst    = apRepDstExp[iexp];
         int   nDstLen  = apRepDstLen[iexp];

         // get size diff for current pattern
         int   nSizeDiff = nDstLen - nSrcLen;

         bLocalExpand = (nSizeDiff > 0) ? 1 : 0;

         // scan whole data with current pattern
         uchar *pInCur  = pMem;
         uchar *pInMax  = pMem + nMemSize;

         while (pInCur < pInMax)
         {
            if (userInterrupt())
               { lRC=2; break; }

            num nRemain = nMemSize - (pInCur - pMem);
            uchar *pHit = 0;

            if (bUseCase) {
               pHit = memFind(pSrc, nSrcLen, pInCur, nRemain);
            } else {
               #ifdef WITH_CASE_XNN
               pHit = memIFind(pSrc, nSrcLen, pInCur, nRemain, pBit);
               #else
               pHit = memIFind(pSrc, nSrcLen, pInCur, nRemain);
               #endif
            }
            if (!pHit)
               break;

            // process hit
            if (npass < 1) {
               // first pass: calc target size.
               nMaxSizeCur += nSizeDiff;
               // find the global maximum size for pass2 allocation.
               if (nMaxSizeCur > nMaxSizePeak)
                   nMaxSizePeak = nMaxSizeCur;
               // else do NOT shrink the output size.
            } else {
               // 2nd pass: apply replacement
               num nHitRem = nMemSize - (pHit - pMem);
               // printf("apply replace, %d\n", nSizeDiff);
               // printf("old: %.20s delta %d size %d\n", pHit, nSizeDiff, (int)(nHitRem-nSizeDiff));
               // sfkmem_hexdump(pHit-10, 32);
               if (bLocalExpand)
                  memmove(pHit+nSizeDiff, pHit, nHitRem+0); // memory EXPANDS by nSizeDiff.
               else
                  memmove(pHit, pHit-nSizeDiff, nHitRem+nSizeDiff);
               // printf("     move %p %p %u bytes\n",pHit+nSizeDiff, pHit, (int)(nHitRem-nSizeDiff));
               if (nDstLen) memcpy(pHit, pDst, nDstLen);
               // printf("new: %.20s\n", pHit);
               // sfkmem_hexdump(pHit-10, 32);

               // overall size of memory changes:
               nMemSize += nSizeDiff;
            }

            if (   ( cs.sim && npass==0)
                || (!cs.sim && npass==1)
               )
            {
               bTouched = 1;
               nReplaced++;
               apRepFlags[iexp] |= (1 << 1);
            }

            // proceed within block, after hit
            if (npass == 0)
               pInCur = pHit + nSrcLen;   // there is no replace yet, skip hit
            else
               pInCur = pHit + nDstLen;   // continue search after replaced area

            // recalc max:
            pInMax = pMem + nMemSize;

            // tell progress:
            if (nMemSize) nPerc = (int)((pInCur-pMem) * 100 / nMemSize);
            if (!cs.quiet && (nPerc != nLastPerc) && finf.timeToTell()) {
               printf("%02d%% %s%s : %s %s \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced),cs.sim?"hits":"changes");
               bTold = 1;
               nLastPerc = nPerc;
            }

            if (cs.useFirstHitOnly)
               { iexp = nBinRepExp; break; }

         }  // endwhile pcur < pmax

      }  // endfor patterns

   }  // endfor pass

   // need to write everything back?
   if (!lRC && bTouched)
   do 
   {
      bFileChanged = 1;

      if (chain.colfiles)
         chain.addFile(*pcoi);
   
      if (cs.sim) {
         if (finf.timeToTell()) {
            printf("%02d%% %s%s : %s hits \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
            fflush(stdout);
            bTold = 1;
         }
      } else {
         // whole content is written in one go.
         // coi::write takes care of big block writing.
         if (pcoi->open("wb")) {
            perr("cannot rewrite file: %s%s\n", pcoi->name(),pcoi->lasterr());
            lRC=9;
            break;
         }
         num nWrite = pcoi->write(pMaxDat, nMemSize);
         pcoi->close();
         if (nWrite != nMemSize) {
            if (bTold) printf("\n");
            esys("fwrite", "failed to write to %s - stopping write. file may be damaged.\n", pszFile);
            lRC=1;
         }
         if (!cs.quiet) {
            printf("%02d%% %s%s : %s changes \r",nPerc,finf.prefix(),finf.shortName(),numtoa(nReplaced));
            fflush(stdout);
            bTold = 1;
         }
      }
   }
   while (0);

   // red zone check
   if (!cs.sim && pMaxDat) {
      if (bGlobalExpand) {
         if (pMaxDat[nMaxSizePeak] != 0xEE)
            perr("internal: memory overwrite past target block, on expand\n");
      } else {
         if (pMaxDat[nFileSize] != 0xEE)
            perr("internal: memory overwrite past target block, on shrink\n");
      }
   }

   // NO RETURN W/O DELETE UNTIL HERE

   if (pMaxDat && (pMaxDat != praw))
      delete [] pMaxDat;

   delete [] praw;

   if (bFileChanged)
      cs.filesChg++;

   if (lRC) return lRC;

   // collect stats: all patterns found?
   int nTotPats = nBinRepExp;
   int nHitPats = 0;
   for (int i2=0; i2<nBinRepExp; i2++) 
   {
      if (apRepFlags[i2] & (1 << 1))
         nHitPats++;
      else
      if (cs.verbose) {
         printf("%s : pattern not found: ",pszFile);
         if (apRepFlags[i2] & (1 << 0)) {
            uchar *pBin = apRepSrcExp[i2];
            for (int i9=0; i9<apRepSrcLen[i2]; i9++)
               printf("%02X",pBin[i9]);
            printf(" [binary]\n");
         } else {
            printf("%s\n",apRepSrcExp[i2]);
         }
      }
   }
   int nNotPats = nTotPats - nHitPats;

   if (bTold)
      finf.printBlankLine(78);

   if (cs.dostat || cs.verbose)
   {
      if (!nHitPats && !cs.verbose)
      { } // don't list files we wouldn't change
      else
      {
         cchar *pszPre   = finf.prefix();
         cchar *pszShort = finf.shortName();
         num   nSizeDiff = nMemSize - nFileSize;
         const char *pszSign = (nSizeDiff > 0) ? "+":"";
         char szNumBuf[100];
         printf("[%s/%d/%d] %s%s",  // FIX: 160R2: nReplaced with >2G 
            numtoa(nReplaced,3,szNumBuf),
            (int)nHitPats,(int)nNotPats,pszPre,pszShort);
         if (nSizeDiff) {
            setTextColor(nGlblTimeColor);
            printf("   %s%s bytes\n",pszSign,numtoa(nSizeDiff));
            setTextColor(-1);
         } else {
            printf("\n");
         }
      }
   }

   return 0;
}

int testReplace(int iTestCaseNumber)
{
   int irc = 0;

   srand((unsigned)time(NULL));

   SFKMD5 md5src;
   SFKMD5 md5dst;

   uchar abSrcPat[10][200];
   int   aSrcLen[10];

   uchar abDstPat[10][200];   
   int   aDstLen[10];
   
   int   aPatNum[10];
   
   char szPatFile[200];
   sprintf(szPatFile, "tmp%crep%03dpat.txt" , glblPathChar, iTestCaseNumber);

   FILE *fpat = fopen(szPatFile, "w");
   if (!fpat) return 9+perr("cannot write: %s\n", szPatFile);
   fprintf(fpat, ":binary\n");

   // create search/replace test patterns
   for (int ipat=0; ipat<10; ipat++) 
   {
      int isrclen = rand() % 180 + 5;
      int idstlen = rand() % 180 + 5;
      
      fprintf(fpat, "/");

      for (int i=0; i<isrclen; i++)
      {
         while ((abSrcPat[ipat][i] = (uchar)rand()) == '.');
         fprintf(fpat, "%02X", abSrcPat[ipat][i]);
      }
      aSrcLen[ipat] = isrclen;
      
      fprintf(fpat, "/");

      for (int i=0; i<idstlen; i++)
      {
         while ((abDstPat[ipat][i] = (uchar)rand()) == '.');
         fprintf(fpat, "%02X", abDstPat[ipat][i]);
      }
      aDstLen[ipat] = idstlen;
      
      fprintf(fpat, "/\n");
   }
   fclose(fpat);

   mclear(aPatNum);
   
   // create before/after replace data
   char szName1[200];
   char szName2[200];
   char szName3[200];
   
   sprintf(szName1, "tmp%srep%03dsrc.dat" , glblPathStr, iTestCaseNumber);
   sprintf(szName2, "tmp%srep%03ddst.dat" , glblPathStr, iTestCaseNumber);
   sprintf(szName3, "tmp%srep%03ddst2.dat", glblPathStr, iTestCaseNumber);

   FILE *f1 = fopen(szName1, "wb");
   if (!f1) return 9+perr("cannot write: %s\n", szName1);

   FILE *f2 = fopen(szName2, "wb");
   if (!f2) return 9+perr("cannot write: %s\n", szName2);

   int iTotalSizeMB = rand() % 10 + 5;
   int iTotalSize   = iTotalSizeMB * 1000000;
   int iTotalSrc=0, iTotalDst=0;

   char abText[1024];
   memset(abText, '.', 1024);
   
   uchar *psrc=0,*pdst=0;
   int    nsrc=0, ndst=0;
   
   while (iTotalSrc < iTotalSize)
   {
      // write another text string, or a pattern?
      if ((rand() & 127) < 10)
      {
         // another pattern
         int ipat = rand() % 10;
         
         psrc = abSrcPat[ipat];
         nsrc = aSrcLen[ipat];
         
         pdst = abDstPat[ipat];
         ndst = aDstLen[ipat];
         
         aPatNum[ipat]++;
      }
      else
      {
         int ilen = (rand() % 50) + 5;

         psrc = (uchar*)abText;
         nsrc = ilen;

         pdst = psrc;
         ndst = nsrc;
      }

      if (fwrite(psrc, 1, nsrc, f1) != nsrc)
         return 9+perr("cannot fully write, disk full: %s\n", szName1);
      md5src.update(psrc,nsrc);
      iTotalSrc += nsrc;

      if (fwrite(pdst, 1, ndst, f2) != ndst)
         return 9+perr("cannot fully write, disk full: %s\n", szName2);
      md5dst.update(pdst,ndst);
      iTotalDst += ndst;
   }
   
   fclose(f2);
   fclose(f1);

   uchar *pdigsrc = md5src.digest();
   uchar *pdigdst = md5dst.digest();

   // run replace command
   char szCmd[500];
   sprintf(szCmd, ".%csfk replace -quiet=2 -yes -bylist %s %s -to %s",
      glblPathChar, szPatFile, szName1, szName3);
   int isysrc = system(szCmd);
      
   // verify replace output
   SFKMD5 md5dst2;
   if (getFileMD5(szName3, md5dst2))
      return 9+perr("cannot read checksum\n");
   uchar *pdigdst2 = md5dst2.digest();
   
   if (memcmp(pdigdst, pdigdst2, 16))
   {
      perr("Replace result mismatch:\n");
      perr("   %d = %s\n", isysrc, szCmd);
      perr("   %02X%02X%02X%02X : %s\n", pdigdst[0],pdigdst[1],pdigdst[2],pdigdst[3], szName2);
      perr("   %02X%02X%02X%02X : %s\n", pdigdst2[0],pdigdst2[1],pdigdst2[2],pdigdst2[3], szName3);
      irc = 10;
   }
   
   return irc;
}

int aGlblIndentStats[10];

int execScantab(char *pszFile)
{__
   cs.files++;

   int i=0;

   int aind[100];
   memset(aind, 0, sizeof(aind));

   int amul[10]; // multiples of n counters
   memset(amul, 0, sizeof(amul));

   int nMaxMulIndex = 0;
   int nMaxMulCnt   = 0;
   bool bHaveTabs    = 0;
   
   // collect indent stats
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+perr("cannot read: %s\n", pszFile);

   bool bBinary = 0;

   myfgets_init();
   while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin, &bBinary))
   {
      // binary file detected?
      if (bBinary) {
         fclose(fin);
         if (cs.verbose)
            oprintf("binary  : %s\n", pszFile);
         return 0;
      }

      szLineBuf[sizeof(szLineBuf)-10] = '\0';
      removeCRLF(szLineBuf);
      int nLen = (int)strlen(szLineBuf);

      // any tabs contained?
      if (!bHaveTabs && strchr(szLineBuf, '\t')) {
         bHaveTabs = 1;
         if (!cs.scanIndent)
            break;
      }

      // analyze single line
      int nBlanks = 0;
      for (i=0; i<nLen; i++) {
         if (szLineBuf[i] == ' ') {
            if (++nBlanks >= 60)
               break;
         }
         else
            break;
      }

      // have no. of blanks at line start.
      aind[nBlanks]++;

      // nBlanks is a multiple of ...
      if (nBlanks)
      for (i=3; i<=8; i++) {
         if ( ((nBlanks / i) * i) == nBlanks ) {
            // create sorted stats
            amul[i]++;
            if (amul[i] > nMaxMulCnt) {
               nMaxMulCnt   = amul[i];
               nMaxMulIndex = i;
            }
         }
      }
   }
   fclose(fin);

   if (nMaxMulIndex >= 0 && nMaxMulIndex < 10)
      aGlblIndentStats[nMaxMulIndex]++;

   if (bHaveTabs)
      cs.tabFiles++;

   if (cs.indentFilt) {
      if (nMaxMulIndex != 0 && cs.indentFilt == nMaxMulIndex)
         oprintf("%s\n", pszFile);
      return 0;
   }

   if (bHaveTabs) {
      if (!cs.verbose && !cs.quiet) {
         if (cs.tabFiles==1 && !cs.pure)
            printf("list of files containing tabs:\n");
         if (!strncmp(pszFile, glblDotSlash, 2))
            pszFile += 2;
         setTextColor(nGlblFileColor);
         oprintf("%s\n", pszFile);
         setTextColor(-1);
      }
      if (chain.colfiles) {
         // chain mode: collect (new) filename list
         Coi ocoi(pszFile, glblFileSet.root());
         chain.addFile(ocoi); // is copied
      }
   }

   if (cs.verbose)
      oprintf("indent %d: %s\n", nMaxMulIndex, pszFile);

   // dump indent stats
   if (cs.verbose >= 2) 
   {
      // for (i=1; i<100; i++)
      //   if (aind[i] > 0)
      //      printf("%2.2d : %3.3d times\n", i, aind[i]);
      // printf("\n");
   
      printf("   ");
      for (i=3; i<=8; i++)
         printf("%2.2d/%3.3d ", i, amul[i]);
      printf("\n");
   }

   return 0;
}

int execDelFile(char *pszName)
{__
   cs.filesScanned++;
   bool bwaswp = 0;
   if (!cs.sim) {
      if (remove(pszName)) {
         // file is probably write protected
         if (setWriteEnabled(pszName))
            return 1+pwarn("cannot delete: %s\n", pszName);
         if (remove(pszName))
            return 1+pwarn("cannot delete: %s\n", pszName);
         bwaswp = 1;
         cs.filesDeletedWP++;
      }
   }
   if (!cs.quiet) {
      if (bwaswp) {
         oprintf("DEL : %s", pszName);
         printx("   <time>(was write protected)<def>\n");
      } else {
         oprintf("DEL : %s\n",pszName);
      }
   }
   cs.filesDeleted++;
   return 0;
}

int execDelDir(char *pszName, int lLevel, int &lGlobFiles, FileList &oDirFiles, int &lDirs, num &lBytes, num &nLocalMaxTime, num &ntime2)
{__
   if (!cs.withdirs)
      return 0;

   cs.dirsScanned++;

   // every execDelFile with RC==0 (deleted successfully)
   // lead to an entry in the oDirFiles list.
   int nNumberOfDeletedFiles = oDirFiles.clNames.numberOfEntries();

   // alternatively, if the user supplied "*" as file mask,
   // delete all empty dirs.
   char *pfmask  = glblFileSet.firstFileMask();
   bool  bdelall = !strcmp(pfmask, "*") ? 1 : 0;
   
   // FIX: 166: "0 dirs" statistics on rmtree simulation
   bool bsimdelall = (cs.sim && bdelall) ? 1 : 0;

   // if this number is >0 AND the directory is NOW empty,
   // then it became empty due to a delete action.
   if (bdelall || nNumberOfDeletedFiles > 0)
   {
      if (bsimdelall || isEmptyDir(pszName))
      {
         // todo: delete of readonly dirs
         bool bwaswp = 0;
         if (!cs.sim) {
            if (rmdir(pszName)) {
               // dir is probably write protected
               if (setWriteEnabled(pszName))
                  return 1+pwarn("cannot delete: %s\n", pszName);
               if (rmdir(pszName))
                  return 1+pwarn("cannot delete: %s\n", pszName);
               bwaswp = 1;
               cs.dirsDeletedWP++;
            }
         }
         if (!cs.quiet) {
            if (bwaswp) {
               oprintf("DEL : %s", pszName);
               printx("   <time>(was write protected)<def>\n");
            } else {
               oprintf("DEL : %s\n",pszName);
            }
         }
         cs.dirsDeleted++;
      } else {
         if (bdelall && !cs.sim)
            pinf("dir not empty, cannot delete: %s\n", pszName);
      }
   }

   return 0;
}

int execVersion(Coi *pcoi)
{__
   int nrc = 0;

   uchar *pdata = 0;
   num    nsize = 0;
   if (pcoi->getContent(&pdata, nsize))
      return 9+perr("cannot get version from: %s", pcoi->name());
   // data is managed BY COI.

   char szVerID[50];
   sprintf(szVerID, "$%s:", "version");

   // find version string within binary data
   uchar *ppat = (uchar*)szVerID;
   num    nlen = strlen((char*)ppat);
   uchar *pver = memFind(ppat,nlen, pdata,nsize);

   if (pver)
   {
      // calc max parse range
      num nmax = nsize - (pver - pdata);
      if (nmax <= 0) return 9+perr("int. #28281250");

      StringMap omap;
      if (parseVersion((char*)pver, (int)nmax, omap)) return -1;

      if (cs.justvernum) 
      {
         char *pnum = omap.get(str("vernum"), str(""));
         char *pfix = omap.get(str("fix"   ), str(""));
         if (!pnum)
            return 9+perr("no version number found.");
         char szFull[50];
         strcopy(szFull, pnum);
         if (pfix && *pfix) {
            int ilen = strlen(szFull);
            if (ilen > 0 && szFull[ilen-1] != '.') {
               strcat(szFull, ".");
               ilen++;
            }
            strcat(szFull, pfix);
         }
         chain.print("%s\n", szFull);
      }
      else
      {
         char *pnam = omap.get(str("name"  ), str(""));
         char *ptyp = omap.get(str("type"  ), str(""));
         char *pos  = omap.get(str("os"    ), str(""));
         char *pnum = omap.get(str("vernum"), str(""));
         char *pfix = omap.get(str("fix"   ), str(""));
         char *ptit = omap.get(str("title" ), str(""));
         char *pdat = omap.get(str("date"  ), str(""));
         char *pinf = omap.get(str("info"  ), str(""));
   
         // create integer from version string
         char *psz1 = pnum;
         int nVer = 0;
         int nDot = 3;
         while (*psz1) {
            char c = *psz1++;
            if (c == '.')
               { nVer = nVer * 10; nDot--; }
            else
               nVer = nVer + (c - '0');
         }
         while (nDot-- > 0)
            nVer = nVer * 10;
   
         if (chain.coldata) {
            chain.print("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s", pcoi->name(),
               pnam,ptyp,pos,pnum,pfix,ptit,pdat,pinf);
         } else {
            printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", pcoi->name(),
               pnam,ptyp,pos,pnum,pfix,ptit,pdat,pinf);
         }
      }
   } else {
      if (cs.verbose)
         pwarn("no version found within: %s", pcoi->name());
      nrc = 1;
   }

   // TODO: not sure if to postpone this
   pcoi->releaseContent();

   return nrc;
}

void detabLine(char *pszIn, char *pszOut, uint lMaxOut, int nTabSize)
{
   uint nInsert=0, iout=0;
   for (int icol=0; (pszIn[icol]!=0) && (iout<lMaxOut-1); icol++)
   {
      char c1 = pszIn[icol];
      if (c1 == '\t') {
         nInsert = nTabSize - (iout % nTabSize);
         for (uint i2=0; i2<nInsert; i2++)
            pszOut[iout++] = ' ';
      } else {
         pszOut[iout++] = c1;
      }
   }
   pszOut[iout] = '\0';
}

int execDetab(char *pszFile, char *pszOutFile)
{__
   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut) pszOutFile = pszFile;

   // load file, take care of global mem limit
   num nFileSize = getFileSize(pszFile);
   if (nFileSize <= 0)
      return 5;
   if (nFileSize >= nGlblMemLimit) {
      pwarn("[nopre] skip: %s - file too large\n", pszFile);
      cs.anyFileTooLarge = 1;
      return 5;
   }

   char *pInFile = new char[nFileSize+10];

   // NO RETURN W/O DELETE FROM HERE

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      pwarn("cannot read: %s\n", pszFile);
      delete [] pInFile;
      return 5;
   }
   num nRead = (num)fread(pInFile, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      pwarn("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pInFile;
      return 5;
   }
   pInFile[nFileSize] = '\0';

   // scan for unexpected NULL bytes
   if (memchr(pInFile, 0, nFileSize) != 0) {
      pwarn("[nopre] skip: %s - text contains null byte(s)\n", pszFile);
      delete [] pInFile;
      return 5;
   }

   cs.files++;

   // any tabs at all contained?
   if (!strchr(pInFile, '\t')) {
      delete [] pInFile;
      return 0;
   }

   cs.tabFiles++;

   if (cs.scanTabs) {
      if (cs.tabFiles==1)
         printf("list of files containing tabs:\n");
      if (!strncmp(pszFile, glblDotSlash, 2))
         pszFile += 2;
      printx("<file>%s<def>\n", pszFile);
      delete [] pInFile;
      return 0;
   }

   // write output file:
   //   if different output is specified, also create directory structure.
   if (bHaveOut) {
      if (cs.yes && createOutDirTree(pszOutFile))
         return 9;
      info.setStatus("detab", pszOutFile);
   } else {
      info.setStatus("detab", pszFile);
   }

   FILE *fOut = 0;
   if (cs.yes) {
      if (!(fOut = fopen(pszOutFile, "w"))) {
         delete [] pInFile; 
         return 9+perr("cannot %swrite %s\n", bHaveOut?"":"over", pszOutFile); 
      }
   }

   char *pCur     = pInFile;
   int bBail      = 0;
   int nTabsDone = 0;
   while (!bBail && *pCur)
   {
      char *pNext = strchr(pCur, '\n');

      if (pNext)
         *pNext++ = 0; // remove LF on current line
      else
          bBail   = 1; // last line

      // truncate CR on current line, if any
      char *psz   = strchr(pCur, '\r');
      if (psz) *psz = 0;

      // detab a single line
      int nInsert=0, iout=0;
      for (int icol=0; pCur[icol]; icol++)
      {
         char c1 = pCur[icol];
         if (c1 == '\t') 
         {
            nInsert = cs.tabSize - (iout % cs.tabSize);
            for (int i2=0; i2<nInsert; i2++) {
               if (cs.yes) fputc(' ', fOut);
               iout++;
            }
            nTabsDone++;
            cs.tabsDone++;
         }
         else 
         {
            if (cs.yes) fputc(c1, fOut);
            iout++;
         }
      }

      if (cs.yes) fputc('\n', fOut);

      pCur = pNext;
   }

   if (cs.yes) fclose(fOut);

   // NO RETURN W/O DELETE UNTIL HERE

   delete [] pInFile;

   info.setAddInfo("%5d tabs", nTabsDone);
   info.printLine(1<<2);

   return 0;
}

int execEntab(char *pszFile, char *pszOutFile)
{__
   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut) pszOutFile = pszFile;

   // load file, take care of global mem limit
   num nFileSize = getFileSize(pszFile);
   if (nFileSize <= 0)
      return 5;
   if (nFileSize >= nGlblMemLimit) {
      pwarn("[nopre] skip: %s - file too large\n", pszFile);
      cs.anyFileTooLarge = 1;
      return 5;
   }

   char *pInFile = new char[nFileSize+10];

   // NO RETURN W/O DELETE FROM HERE

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) {
      pwarn("cannot read: %s\n", pszFile);
      delete [] pInFile;
      return 5;
   }
   num nRead = (num)fread(pInFile, 1, nFileSize, fin);
   fclose(fin);
   if (nRead != nFileSize) {
      pwarn("cannot read: %s (%d %d)\n", pszFile, nRead, nFileSize);
      delete [] pInFile;
      return 5;
   }
   pInFile[nFileSize] = '\0';

   // scan for unexpected NULL bytes
   if (memchr(pInFile, 0, nFileSize) != 0) {
      pwarn("[nopre] skip: %s - text contains null byte(s)\n", pszFile);
      delete [] pInFile;
      return 5;
   }

   CharAutoDel odel(pInFile);

   cs.files++;

   int nTabsDone = 0;

   FILE *fout = 0;

   for (int ipass=0; ipass<2; ipass++)
   {
      if (ipass)
      {
         // count files that would be changed
         if (nTabsDone > 0)
            cs.tabFiles++; 

         // run a write pass?
         if (!nTabsDone)
            break;   // nothing to do

         // write output file:
         //   if different output is specified, also create directory structure.
         if (bHaveOut) {
            if (cs.yes && createOutDirTree(pszOutFile))
               return 9;
            info.setStatus("entab", pszOutFile);
         } else {
            info.setStatus("entab", pszOutFile);
         }

         if (!cs.yes)
            break;   // write not allowed

         if (!(fout = fopen(pszOutFile, "w")))
            return 9+perr("cannot overwrite %s\n", pszOutFile);
      }
   
      char *pCur = pInFile;

      while (*pCur)
      {
         // entab a single line
         int i=0,icol=0;
         for (; pCur[icol]!=0 && pCur[icol]!='\r' && pCur[icol]!='\n'; icol++)
         {
            char c1 = pCur[icol];
            if (c1 != ' ') {
               if (fout) fputc(c1, fout);
               continue;
            }
            // calc posn of next tab stop
            int itab  = ((icol / cs.tabSize) + 1) * cs.tabSize;
            // calc distance to this next tab stop
            int ndist = itab-icol;
            // if this distance is >= 2 chars
            if (ndist >= 1)
            {
               // and completely filled with blanks
               for (i=0; i<ndist; i++)
                  if (!pCur[icol+i] || pCur[icol+i]!=' ')
                     break;
               if (i==ndist) {
                  // then replace blanks by tab
                  if (fout) fputc('\t', fout);
                  icol += ndist-1; // MIND icol++
                  nTabsDone++;
                  if (!ipass) cs.tabsDone++;
                  continue;
               }
               // else fall through
            }
            // else copy-through current char
            if (fout) fputc(c1, fout);
         }
         if (pCur[icol]=='\r')
            icol++;
         if (pCur[icol]=='\n')
            icol++;
   
         if (fout) fputc('\n', fout);
   
         pCur = pCur+icol;
      }
   
      if (fout) 
      {
         fclose(fout);
         fout = 0;
      }
   }

   if (nTabsDone)
   {
      info.setAddInfo("%5d tabs", nTabsDone);
      info.printLine(1<<2);
   }

   return 0;
}

int diffDump(uchar *p1, uchar *p2, num nlen, num nListOffset, int iHiOff, int iHiLen)
{__
   num nSubOff = 0, iCurOff = 0;
   num nRemain = nlen;

   while (nRemain > 0)
   {
      num nBlockLen = nRemain;
      int *appos = 0;

      if (bGlblHexDumpWide) 
      {
      strcpy(szLineBuf,
      //  1                                    38               55                73                                   110
      //">00112233 44556677 00112233 44556677< 0123456789ABCDEF 0123456789ABCDEF >00112233 44556677 00112233 44556677< 0123456789ABCDEF");
        ">                                   <                                   >                                   <                 ");
      strcpy(szAttrBuf,
        "i                                   i                                   i                                   i                 ");
      //                          0  1   2   3   4
      static int aPosWide[] = {  1, 38, 55, 73, 110 };
      appos = aPosWide;
      if (nBlockLen > 16) nBlockLen = 16;
      }
      else 
      {
      strcpy(szLineBuf,
      //  1                  20       29        39                 58
      //">00112233 44556677< 01234567 01234567 >00112233 44556677< 0123456789ABCDEF");
        ">                 <                   >                 <                 ");
      strcpy(szAttrBuf,
        "i                 i                   i                 i                 ");
      //                          0  1   2   3   4
      static int aPosBase[] = {  1, 20, 29, 39, 58 };
      appos = aPosBase;
      if (nBlockLen > 8) nBlockLen = 8;
      }

      // create offset info
      char *pszHexOff = numtohex(nListOffset+nSubOff, 8);
      strcpy(szLineBuf+appos[4], pszHexOff); // ipos

      for (num i=0; i<nBlockLen; i++) 
      {
         iCurOff = nSubOff+i;

         // create hex info
         uchar uc1 = p1[nSubOff+i];
         uchar uc2 = p2[nSubOff+i];
         int iof1 = appos[0] + i * 2 + ((i>=4)?1:0) + ((i>=8)?1:0) + ((i>=12)?1:0);
         int iof2 = appos[3] + i * 2 + ((i>=4)?1:0) + ((i>=8)?1:0) + ((i>=12)?1:0);
         sprintf(szLineBuf+iof1, "%02X", uc1);
         sprintf(szLineBuf+iof2, "%02X", uc2);
         szLineBuf[iof1+2] = ' ';
         szLineBuf[iof2+2] = ' ';

         // create printable info
         int iof3 = appos[1] + i;  // ipos
         int iof4 = appos[2] + i;  // ipos

         if(isprint(uc1)) {
            szLineBuf[iof3] = (char)uc1;
            szAttrBuf[iof3] = 'i';
         } else
            szLineBuf[iof3] = '.';

         if(isprint(uc2)) {
            szLineBuf[iof4] = (char)uc2;
            szAttrBuf[iof4] = 'i';
         } else
            szLineBuf[iof4] = '.';

         // highlight different bytes
         if (iHiOff >= 0 && iCurOff >= iHiOff && iCurOff < iHiOff+iHiLen) {
            strncpy(szAttrBuf+iof1, "ee", 2);
            strncpy(szAttrBuf+iof2, "ee", 2);
            szAttrBuf[iof3] = 'e';
            szAttrBuf[iof4] = 'e';
         }
         else if (uc1 != uc2) {
            strncpy(szAttrBuf+iof1, "ee", 2);
            strncpy(szAttrBuf+iof2, "ee", 2);
            szAttrBuf[iof3] = 'e';
            szAttrBuf[iof4] = 'e';
         }
      }
      szLineBuf[appos[1]-2] = '<'; // ipos
      szLineBuf[appos[4]-2] = '<'; // ipos

      // if in binfind mode, show just left part, appending offset
      if (cs.repDumpHalve) 
      {
         int iofm = appos[2];
         int iofo = appos[4];
         strcpy(szLineBuf+iofm, szLineBuf+iofo);
         strcpy(szAttrBuf+iofm, szAttrBuf+iofo);
      }

      if (chain.coldata) {
         chain.addLine(szLineBuf, szAttrBuf);
      } else {
         printColorText(szLineBuf, szAttrBuf);
      }

      nSubOff += nBlockLen;
      nRemain -= nBlockLen;
   }
   return 0;
}

int execHexdump(Coi *pcoi, uchar *pBuf, uint nBufSize, int iHighOff, int iHighLen, FILE *foutopt, num nListOffset)
{__
   FILE *fout = stdout;
   
   if (foutopt)
         fout = foutopt;

   num ntotal = 0;

   uchar *pBufCur = pBuf;
   int nBufRem = (int)nBufSize;

   num nHexDumpOff = nGlblHexDumpOff;
   if (nHexDumpOff < 0) {
      num nInFileSize = pcoi->getSize();
      nHexDumpOff = nInFileSize + nHexDumpOff;
      if (nHexDumpOff < 0)
         nHexDumpOff = 0;
   }

   if (!pBuf) {
      if (pcoi->open("rb")) {
         // non-fatal, continue with other files
         return 1+pwarn("%s : cannot read - skipping\n", pcoi->name());
      }

      const char *pszPrefix = (nGlblHexDumpForm>=5) ? "    ":"";

      if (!cs.nonames) {
         if (chain.coldata) {
            sprintf(szLineBuf2, "%s:file %s", pszPrefix, pcoi->name());
            // note: +view scans extended end of attribute line
            //       to identify 'f'ile header lines, therefore +2:
            setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
            chain.addLine(szLineBuf2, szAttrBuf2);
         } else {
            setTextColor(nGlblFileColor);
            if (cs.rawfilename)
               fprintf(fout, "%s :\n", pcoi->name());
            else
               fprintf(fout, "%s:file %s\n", pszPrefix, pcoi->name());
            setTextColor(-1);
         }
      }

      if (nHexDumpOff) {
         if (pcoi->seek(nHexDumpOff, SEEK_SET)) {
            pcoi->close();
            return 1+pwarn("%s : cannot seek - skipping\n", pcoi->name());
         }
         ntotal = nHexDumpOff;
      }
   }

   int lOutLen2=0, lIndex=0, lIndex2=0;
   int lRelPos=0;
   uchar *pTmp = 0;
   uchar ucTmp;
   uchar abBlockBuf[1000];

   int nbpl  = bGlblHexDumpWide ?  32 : 16; // bytes per line
   int itext = bGlblHexDumpWide ?  75 : 39; // text begin
   int ioffs = bGlblHexDumpWide ? 108 : 56; // offset begin
   int ieol  = ioffs + 20;
   
   if (nGlblHexDumpForm && cs.bytesperline)
       nbpl = cs.bytesperline;

   num  nTotalMax = 0;
   if (nGlblHexDumpLen > 0)
        nTotalMax = nHexDumpOff + nGlblHexDumpLen;

   if (cs.verbose) {
      fprintf(fout, "dump from %s ",numtoa(nHexDumpOff));
      fprintf(fout, "to %s ",numtoa(nTotalMax));
      fprintf(fout, "a total of %s bytes\n",numtoa(nGlblHexDumpLen));
   }

   bool bNoBlockTrail = (cs.dumptrail & 1) ? 1 : 0;
   bool bNoLineTrail  = (cs.dumptrail & 2) ? 1 : 0;

   uint uiCharPos = 0;

   while (1)
   {
      int nread = 0;
      if (pBuf) {
         if (nBufRem <= 0)
            break;
         if (nbpl < nBufRem) nread = nbpl;
         else                nread = nBufRem;
         memcpy(abBlockBuf, pBufCur, nread);
         pBufCur += nread;
         nBufRem -= nread;
      } else {
         nread = pcoi->read(abBlockBuf, nbpl);
      }
      if (nread <= 0) break;
      pTmp = abBlockBuf;

      int lOutLen = nread;
      
      // dump a full or partial output line?
      if (nTotalMax > 0) {
         num nTotalRemain = nTotalMax - ntotal;
         if (lOutLen > nTotalRemain)
            lOutLen = nTotalRemain;
         if (lOutLen <= 0)
            break;
      }

      szLineBuf[0] = '\0';
      bool bshort  = 0;
      bool bEOD    = 0;
      
      // last record?
      if (nTotalMax > 0)
         if (ntotal + nread >= nTotalMax)
            bEOD = 1;

      switch (nGlblHexDumpForm)
      {
         case 0:
            break; // fall through

         case 1: { // pure
            for (int i=0; i<lOutLen; i++)
               mystrcatf(szLineBuf,MAX_LINE_LEN,"%02X",pTmp[i]);
            strcat(szLineBuf,"\n");
            bshort = 1;
            break;
         }

         case 2: { // source, hex
            for (int i=0; i<lOutLen; i++)
               mystrcatf(szLineBuf,MAX_LINE_LEN,"0x%02X,",pTmp[i]);
            int iLen = strlen(szLineBuf);
            if (bNoLineTrail || (bEOD && bNoBlockTrail))
               if (iLen > 0 && szLineBuf[iLen-1] == ',')
                  szLineBuf[iLen-1] = '\0';
            strcat(szLineBuf,"\n");
            bshort = 1;
            break;
         }

         case 3: { // source, dec
            for (int i=0; i<lOutLen; i++)
               mystrcatf(szLineBuf,MAX_LINE_LEN,"%u,",(uint)pTmp[i]);
            int iLen = strlen(szLineBuf);
            if (bNoLineTrail || (bEOD && bNoBlockTrail))
               if (iLen > 0 && szLineBuf[iLen-1] == ',')
                  szLineBuf[iLen-1] = '\0';
            strcat(szLineBuf,"\n");
            bshort = 1;
            break;
         }

         case 4: { // flat, filtering control characters, skipping binary
            for (int i=0; i<lOutLen; i++) {
               uchar c = pTmp[i];
               if (!c) {
                  int nRemain = lOutLen - i;
                  mystrcatf(szLineBuf,MAX_LINE_LEN," [binary, skipping %u bytes]\n", nRemain);
                  break; 
               }
               else
               if (c < 0x20 && (c != '\r' && c != '\n' && c != '\t'))
                  continue; // skip control characters except LF, TAB
               else
                  mystrcatf(szLineBuf,MAX_LINE_LEN,"%c",(char)c);
            }
            bshort = 1;
            break;
         }

         case 5: // forum
         case 6: // minimal
         {
         // strcpy(szLineBuf, "    -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- # ---------------- ----");
            strcpy(szLineBuf, "                                                    #                      ");
                           //  01234567890123456789012345678901234567890123456789012345678901234567890123456789
                           //            1         2         3          4        5         6         7
            for (int i=0; i<lOutLen; i++) {
               uchar c = pTmp[i];
               mystrplot(szLineBuf+4+i*3, 2, "%02X", c);
               if (   (nGlblHexDumpForm==5 && isprint(c)!=0)
                   || (nGlblHexDumpForm==6 && isalnum(c)!=0)
                  )
                  szLineBuf[54+i] = c;
               else
                  szLineBuf[54+i] = '.';
            }
            sprintf(szLineBuf+71, "%04X\n", (int)ntotal);
            bshort = 1;
            break;
         };
      }

      if (bshort) 
      {
         // dump short form created above
         if (chain.coldata) {
            removeCRLF(szLineBuf); // FIX 169
            chain.addLine(szLineBuf, str(""), 0);
         } else {
            fprintf(fout,"%s",szLineBuf);
         }
      }
      else
      {
         // dump full hex format with offset and ascii
         memset(szLineBuf, ' ', ieol);
         memset(szAttrBuf, ' ', ieol);
         szLineBuf[ieol] = '\0';
         szAttrBuf[ieol] = '\0';
   
         szLineBuf[1] = '>';
         szAttrBuf[1] = ' ';
   
         char *pszHexOff = numtohex(ntotal+nListOffset, 8);
         strcpy(&szLineBuf[ioffs], pszHexOff);
         // adds zero terminator after offset info!
         int ieol = strlen(szLineBuf);
         szAttrBuf[ieol] = '\0';
   
         lOutLen2 = lOutLen;
   
         for(lIndex = 2, lIndex2 = itext, lRelPos = 0;
             lOutLen2;
             lOutLen2--, lIndex += 2, lIndex2++
            )
         {
            ucTmp = *pTmp++;
   
            sprintf(szLineBuf + lIndex, "%02X ", (unsigned short)ucTmp);
   
            // optional: highlight CR and LF characters
            if (cs.leattr)
               if (ucTmp == '\r' || ucTmp == '\n') {
                  szAttrBuf[lIndex+0] = cs.leattr;
                  szAttrBuf[lIndex+1] = cs.leattr;
                  szAttrBuf[lIndex2 ] = cs.leattr;
               }

            if(isprint(ucTmp))
               szAttrBuf[lIndex2] = ' ';  // mark printable text
            else
               ucTmp = '.'; // nonprintable char

            // optional: highlight given area
            if (iHighOff != -1) {
               uiCharPos = ntotal + lRelPos;
               if (uiCharPos >= iHighOff && uiCharPos < iHighOff+iHighLen) {
                  szAttrBuf[lIndex+0] = 'i';
                  szAttrBuf[lIndex+1] = 'i';
                  szAttrBuf[lIndex2 ] = 'i';
               }
            }

            szLineBuf[lIndex2] = ucTmp;

            if (!(++lRelPos & 3))     // extra blank after 4 bytes
            {  lIndex++; szLineBuf[lIndex+2] = ' '; }
         }
   
         if (!(lRelPos & 3)) lIndex--;
   
         szLineBuf[lIndex  ]   = '<';
         szLineBuf[lIndex+1]   = ' ';
         szAttrBuf[lIndex ]   = ' ';
   
         if (chain.coldata) {
            chain.addLine(szLineBuf, szAttrBuf);
         } 
         else if (foutopt) {
            fprintf(fout, "%s\n", szLineBuf);
         }
         else {
            printColorText(szLineBuf, szAttrBuf);
         }
      }

      ntotal += (num)nread;

      if (bEOD)
         break;      
   }

   if (foutopt)
      fflush(fout);

   if (!pBuf)
      pcoi->close();

   return 0;
}

int testfwrite(char *pszFile, num nSize)
{__
   if (nSize <= 0 || nSize > 1048576 * 500)
      return 9+perr("illegal size");

   uchar *ptmp = new uchar[nSize];
   if (!ptmp) return 9+perr("out of memory");
   memset(ptmp, 0, nSize);

   FILE *fout = fopen(pszFile, "wb");
      if (!fout) return 9+perr("cannot open");

   num nwrite = fwrite(ptmp, 1, nSize, fout);

   fclose(fout);

   delete [] ptmp;

   printf("expected / written: ");
   printf("%s " , numtoa(nSize));
   printf("%s\n", numtoa(nwrite));

   if (nwrite != nSize)
      printf("... block write failed\n");

   return 0;
}

#ifndef USE_SFK_BASE

#ifdef _WIN32
DWORD CALLBACK cbCopyFileProgress(
   LARGE_INTEGER TotalFileSize,
   LARGE_INTEGER TotalBytesTransferred,
   LARGE_INTEGER StreamSize,
   LARGE_INTEGER StreamBytesTransferred,
   DWORD dwStreamNumber,
   DWORD dwCallbackReason,
   HANDLE hSourceFile,
   HANDLE hDestinationFile,
   LPVOID lpData  // optional
 )
{
   if (userInterrupt(1))
      return 1; // PROGRESS_CANCEL;

   num nTotal =  (((num)TotalFileSize.HighPart) << 32)
               | (((num)TotalFileSize.LowPart ) <<  0);

   num nDone  =  (((num)TotalBytesTransferred.HighPart) << 32)
               | (((num)TotalBytesTransferred.LowPart ) <<  0);

   info.setAddInfo("%u / %u mb", (uint)(nDone/1000000UL), (uint)(nTotal/1000000UL));
   info.setProgress(nTotal, nDone, "bytes");

   return 0; // PROGRESS_CONTINUE;
}

int copyFileWin(char *pszSrc, char *pszDst, char *pszShDst, uchar *pWorkBuf, num nBufSize, uint nflagsin)
{__
   char *pszTell = chain.usefiles ? pszDst : pszSrc;
   if (cs.listTargets) pszTell = pszDst;

   if (cs.sim) {
      info.setStatus("", pszTell, "-----", eNoCycle);
      if (!cs.dostat)
         info.printLine(nGlblCopyStyle);
      cs.files++;
      return 0;
   }

   info.setAction("copy ", pszSrc, "00");

   DWORD nSysFlags = 0;

   // these are yet internal and completely untested
   if (cs.copyLinks)   nSysFlags |= 0x00000800UL; // COPY_FILE_COPY_SYMLINK;
   if (cs.copyNoBuf)   nSysFlags |= 0x00001000UL; // COPY_FILE_NO_BUFFERING;
   if (cs.copyDecrypt) nSysFlags |= 0x00000008UL; // COPY_FILE_ALLOW_DECRYPTED_DESTINATION;

   BOOL bcancel = 0;
   bool brc = CopyFileExA(pszSrc, pszDst, cbCopyFileProgress, 0, &bcancel, nSysFlags);

   if (!brc) {
      uint nerr = GetLastError();
      switch (nerr) {
         case ERROR_ACCESS_DENIED:
            perr("copy failed, access denied (rc=%u): %s\n", nerr, pszDst);
            pinf("make sure you have full access rights. maybe you have to be administrator.\n");
            break;
         case ERROR_REQUEST_ABORTED:
            // the OS cleaned up the target file.
            pwarn("copy stopped, cleanup done.\n");
            return 19; // stop all further processing
         default:
            perr("copy failed, rc=%u: %s\n", nerr, pszDst);
            break;
      }
   } else {
      cs.files++;
      printCopyCompleted(pszTell, nflagsin);
   }

   return brc ? 0 : 9;
}
#endif // _WIN32

int copyFile(char *pszSrc, char *pszDst, char *pszShDst, uchar *pWorkBuf, num nBufSize, uint nflags)
{__
   char *pszTell = chain.usefiles ? pszDst : pszSrc;
   if (cs.listTargets) pszTell = pszDst;

   if (cs.sim) {
      info.setStatus("", pszTell, "-----", eNoCycle);
      if (!cs.dostat)
         info.printLine(nGlblCopyStyle);
      cs.files++;
      return 0;
   }

   int lRC = 0;
   uchar abMD5Src[20];
   bool  bmdsrcset = 0;
   memset(abMD5Src, 0, sizeof(abMD5Src));

   bool bDoneFile = 0;

   // try to copy the file, upto 3 times
   for (int ntry=1; ntry<=3; ntry++)
   {
      info.setAction("read ", pszSrc, "00");
   
      num nFileSize = getFileSize(pszSrc);
   
      FILE *fin = fopen(pszSrc, "rb");
      if (!fin) return 9+perr("cannot open input file %s   \n", pszSrc);
   
      FILE *fout = myfopen(pszDst, "wb");
      if (!fout) { 
         fclose(fin); 
         return 9+perr("cannot open output file %s   \n", pszDst); 
      }

      FILE *fsh = 0;
      if (   filedb.canUpdate() && nGlblCopyShadows && pszShDst
          && (!nGlblShadowSizeLimit || (nFileSize < nGlblShadowSizeLimit))
         )
      {
         fsh = fopen(pszShDst, "wb");
         if (!fsh)
            perr("cannot write shadow file %s   \n", pszShDst);
            // but continue, w/o shadow
      }
     
      num nTime1=0, nTime2=0, nReadTime=0, nWriteTime=0;
      num nReadBytes=0, nWriteBytes=0;
      uint nkbsread=0, nkbswrite=0;
      SFKMD5 md5in;
      int nBlock = 0;
      while (!userInterrupt())
      {
         nTime1 = getCurrentTime();
         info.setStatus("read ", pszSrc, "00");
         size_t nRead = 0;
         if (cs.sim)
            nRead = nBufSize;
         else
            nRead = myfread(pWorkBuf, (size_t)nBufSize, fin, nFileSize, nReadBytes);
         nTime2 = getCurrentTime();
         if (nRead <= 0)
            break; // EOD
         nReadTime  += (nTime2-nTime1);
         nReadBytes += nRead;
   
         md5in.update(pWorkBuf, nRead);
   
         nTime1 = getCurrentTime();
         info.setStatus("write", pszDst, "00");
         size_t nWrite = myfwrite(pWorkBuf, nRead, fout, nFileSize, nWriteBytes);
         nTime2 = getCurrentTime();
         if (nWrite != nRead) {  
            lRC = 9;
            if (!bGlblEscape)
               esys("fwrite", "failed to write %s   \n", pszDst);
            break; 
         }
         nWriteTime  += (nTime2-nTime1);
         nWriteBytes += nWrite;

         // extra shadow write
         if (fsh) {
            nWrite = myfwrite(pWorkBuf, nRead, fsh, nFileSize, nWriteBytes);
            if (nWrite != nRead) {
               // shadow writing fails silently
               fclose(fsh);
               remove(pszShDst);
               fsh = 0;
               pszShDst = 0;
            }
         }
   
         nkbsread  = (nReadBytes  / (nReadTime  ? nReadTime : 1));
         nkbswrite = (nWriteBytes / (nWriteTime ? nWriteTime : 1));
   
         nBlock++;
      }

      if (fsh) {
         fclose(fsh);
         nflags |= 4; // shadow written
         cs.shadowsWritten++;
      }
      pszShDst = 0; // block 2nd writing of shadow
   
      myfclose(fout);
      fclose(fin);
   
      if (bGlblEscape) {
         remove(pszDst);
         if (cs.verbose)
            pwarn("copy stopped, cleaning up: %s\n", pszDst);
         else            
            pwarn("copy stopped, cleanup done.\n");
         return 19;
      }
   
      FileStat ofs;
      if (ofs.readFrom(pszSrc))
         return 9+perr("failed to read attributes: %s\n", pszSrc);
      if (ofs.writeTo(pszDst, __LINE__))
         return 9+perr("failed to write attributes: %s\n", pszDst);
      else
         cs.filesCloned++;

      uchar *pmd5in = md5in.digest();

      // remember source sum in case of late verify:
      if (cs.verifyLate) {
         num nsumlo=0, nsumhi=0;
         for (int i=0,b=64-8; i<8; i++) {
            nsumhi = nsumhi | (((num)pmd5in[0+i]&0xFF) << b);
            nsumlo = nsumlo | (((num)pmd5in[8+i]&0xFF) << b);
            b -= 8;
         }
         glblVerifier.remember(pszDst, nsumhi, nsumlo);
      }

      // remember src file md5 beyond this scope
      memcpy(abMD5Src, pmd5in, 16);
      bmdsrcset = 1;

      if (!cs.sim && cs.verifyEarly)
      {
         info.setAction("verfy", pszTell, "00");
   
         // run target verify
         uchar abmd5[20];
         int nrcsub = getFileMD5NoCache(pszDst, abmd5, 1);
   
         if (userInterrupt(1))
         {
            info.setAction("stop ", pszDst, 0, 4);
            info.printLine();
            break;
         }
         else
         if (nrcsub == 0)
         {
            if (memcmp(pmd5in, abmd5, 16)) {
               if (ntry < 3) {
                  pwarn("verify failed, file differs: %s - retrying write\n", pszDst);
                  // fall through, next retry
                  remove(pszDst);
               } else {
                  perr("verify failed, file differs: %s - giving up\n", pszDst);
                  remove(pszDst);
               }
            } else {
               // verify succeeded
               bDoneFile = 1;
               cs.files++;
               break;
            }
         }
      }
      else
      {
         // no verify selected
         bDoneFile = 1;
         cs.files++;
         break;
      }
   }  // endfor tries

   if (bDoneFile)
      printCopyCompleted(pszTell, nflags);

   if (lRC == 0) {
      if (!bmdsrcset) return 9+perr("internal #0505071820");
      filedb.updateFile(pszSrc, abMD5Src);
   }

   return lRC;
}

#endif // USE_SFK_BASE

// original src : thedir
// have now     : thedir/subdir/thefile.txt
// need relative:        subdir/thefile.txt
char *relName(char *pszRoot, char *pszAbs)
{
   bool bisurl = 0;
   // FIX: 163R5: crash on sfk sel ... +copy due to missing null ptr check
   if (!pszRoot || !strlen(pszRoot))
       return pszAbs;
   #ifdef VFILEBASE
   bisurl = !strncmp(pszRoot, "ftp://", 6) || !strncmp(pszRoot, "http://", 7);
   // TODO: for now, block relativazation of all http: urls
   if (!strncmp(pszRoot, "http://", 7))
      return pszAbs;
   #endif // VFILEBASE
   int nsrclen = strlen(pszRoot);
   if (!strcmp(pszRoot, "."))
       return pszAbs;
   if (!strcmp(pszRoot, pszAbs))
       return pszAbs + nsrclen;
   // have to compare copysrc WITH path separator char!
   if (endsWithPathChar(pszRoot, bisurl))
       nsrclen--;
   // first check name part
   if (strncmp(pszRoot, pszAbs, nsrclen)) {
       pwarn("%s not relative to %s (1)\n",pszAbs,pszRoot);
       return pszAbs; // no match
   }
   // then also path char
   #ifdef _WIN32
   // IF dir is not ending with ':'
   if (endsWithColon(pszRoot))
       return pszAbs + nsrclen;
   #endif
   if (bisurl && pszAbs[nsrclen] == '/')
     { }
   else
   if (pszAbs[nsrclen] != glblPathChar) {
       pwarn("%s not relative to \"%s\" (2) %c\n",pszAbs,pszRoot,pszAbs[nsrclen]);
       return pszAbs; // no match
   }
   char *pszRel = pszAbs + nsrclen + 1; // past separator
   // printf("REL %s => %s\n", pszAbs, pszRel);
   return pszRel;
}

// c:the\foo\bar.txt -> bar.txt
// c:bar.txt -> bar.txt
char *relativeFilename(char *pszPath)
{
   char *pszRel = strrchr(pszPath, glblPathChar);
   if (pszRel) return pszRel+1;

   #ifdef _WIN32
   pszRel = strrchr(pszPath, ':');
   if (pszRel) return pszRel+1;
   #endif

   return pszPath;
}

// returns NULL in case of error.
// returns same name if root doesn't match.
char *rootRelativeName(char *pszFileName, char *pszOptRoot)
{
   if (pszOptRoot)
      return relName(pszOptRoot, pszFileName);

   if (!glblFileSet.hasRoot(0))
      return pszFileName;

   char *pszRoot = glblFileSet.getCurrentRoot();
   if (!pszRoot) { perr("internal 812063\n"); return 0; }

   return relName(pszRoot, pszFileName);
}

#ifndef USE_SFK_BASE

int execDirCopy(char *pszSrc, FileList &oDirFiles)
{__
   // copy metadata of directory
   char *pszDstRaw = pszGlblCopyDst;

   // expect Src to contain a RELATIVE path, e.g.
   //    data\tmp1.txt  data\sub\tmp2.txt
   // strip the original base path, if any
   char *pszRelSrc = relName(pszGlblCopySrc, pszSrc);

   cs.dirsScanned++;
   sprintf(szLineBuf, "%u files %u dirs", cs.filesScanned, cs.dirsScanned);
   if (strlen(szLineBuf) > 20)
      info.setAddInfoWidth(strlen(szLineBuf));
   info.setStatus("scan ", pszRelSrc, szLineBuf);

   // build full target name: d:/tmp/subdir
   joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszDstRaw, pszRelSrc);
   // strip trailing / if any
   int nRefLen = strlen(szRefNameBuf);
   if ((nRefLen > 0) && (szRefNameBuf[nRefLen-1] == glblPathChar))
      szRefNameBuf[nRefLen-1] = '\0';

   // in case we have to copy EMPTY target directories:
   // if (createSubDirTree(szRefNameBuf, ""))
   //   return 9;

   // execFileCopy has created dir tree on demand,
   // so all dirs must exist, IF files have been copied.
   if (!isDir(szRefNameBuf)) {
      if (cs.verbose)
         info.print("%s : skip, no files copied.\n",szRefNameBuf);
      return 0; // no files have been copied in that dir.
   }

   char szReason[50];
   szReason[0] = '\0';

   // check if we really need to copy attributes

   // win: don't try to clone x: to y: etc.
   #ifdef _WIN32
   if (endsWithColon(pszSrc)) return 0;
   if (endsWithColon(szRefNameBuf)) return 0;
   #endif

   // BEWARE OF MIXUP:
   //    sfk list -sincedir foo bar
   //       means for the user: FOO (szRefNameBuf) is the SOURCE.
   // NO problem here, as in
   //    sfk copy foo bar
   //       the provided pszSrc in here IS actually the SOURCE.

   FileStat ofsSrc;
   FileStat ofsDst;
   if (ofsSrc.readFrom(pszSrc)) {
      perr("cannot read dir time: %s\n", pszSrc);
      return 9;
   }

   char *pszTell = pszSrc;
   if (cs.listTargets) pszTell = szRefNameBuf;

   // checked isDir(szRefNameBuf) above
   if (!ofsDst.readFrom(szRefNameBuf))
   {
      // copy the directory timestamp or not? during filecopy,
      // we may have created the dir on demand. in this case,
      // copy the dir timestamp unconditionally. ELSE copy it only
      // if the src is newer than the target.
      bool bOnlyOnNewSrc = 1;
      // this check is not at all beautiful, but it works
      // without restructuring the whole tree processing.
      #ifdef SFK_CCDIRTIME
      int ipos = glblCreatedDirs.find(szRefNameBuf);
      if (ipos >= 0) {
         // the dir was recently created: ignore its new timestamp
         glblCreatedDirs.removeEntry(ipos);
         bOnlyOnNewSrc = 0;
      }
      #endif
      int ndif = ofsSrc.differs(ofsDst, bOnlyOnNewSrc);
      if (!ndif) {
         if (cs.verbose > 1)
            info.print("%s : no time / attrib change\n", szRefNameBuf);
         return 0;   // skip
      }
      if (ndif >= 7 && ndif <= 10 && cs.nodirtime != 0) {
         if (cs.verbose > 1)
            info.print("%s : ignore time difference (%d)\n", szRefNameBuf, ndif);
         return 0;   // skip
      }
      if (cs.verbose > 0)
         info.print("%s : copying attribs, ndif %d\n", szRefNameBuf, ndif);
      // sprintf(szReason, "%d", ndif);
   }

   bool bDone = 0;
   if (bGlblUseCopyCache) {
      int lRes = glblCopyCache.process(pszSrc, szRefNameBuf, 0, 0);
      if (lRes == 0)
         bDone = 1;
   }

   if (!bDone)
   {
      if (cs.sim) {
         cs.dirsCloned++;
      } else {
         if (cloneAttributes(pszSrc, szRefNameBuf, __LINE__))
            return 1; // error, but skip and continue
         cs.dirsCloned++;
      }

      setTextColor(nGlblTimeColor);
      info.setStatus("", pszTell, "copy time", eNoCycle);
      info.printLine(nGlblCopyStyle);
      setTextColor(-1);
   }

   return 0;
}

int execFileCopySub(char *pszSrc, char *pszDst, char *pszShSrc=0, char *pszShDst=0);

// USES:
//    szAttrBuf, szRefNameBuf, szLineBuf1/2 (indirectly)
int execFileCopy(Coi *pcoi)
{__
   char *pszSrc      = pcoi->name();
   char *pszOptRoot  = pcoi->root(1); // null if not set

   cs.filesScanned++;

   // with input chaining, glblCopySrc will not be set.
   char *pszSrcRaw = pszGlblCopySrc;
   if (chain.usefiles) {
      if (cs.rootrelname)
         pszSrcRaw = pszOptRoot; // user selected relative names
      else {
         // autodetect: include source root into target name?
         if (cs.rootabsname || (pszOptRoot && !isAbsolutePath(pszOptRoot)))
            // source root is NOT absolute, or -abs specified: take it
            pszSrcRaw = str("");
         else
            // source root IS absolute (e.g. C:\\) so strip it
            pszSrcRaw = pszOptRoot; // if null, produces error below
      }
   }
   if (!pszSrcRaw) return 9+perr("copy: missing source root dir. file=%s",pszSrc);

   // expect Dst to be a directory, e.g.
   //    x:    x:/   x:/tmp   x:/tmp/
   char *pszDstRaw = pszGlblCopyDst;

   // expect Src to contain a RELATIVE path, e.g.
   //    data\tmp1.txt  data\sub\tmp2.txt
   // strip the original base path, if any
   char *pszRelSrc = relName(pszSrcRaw, pszSrc);
 
   // build full target name: d:/tmp/subdir/thefile.txt
   // sprintf(szRefNameBuf, "%s%c%s", pszDstRaw, glblPathChar, pszRelSrc);
   joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszDstRaw, pszRelSrc);

   if (cs.debug)
      printf("copy.check %s => %s [root=%s]\n",pszSrc,szRefNameBuf,pszSrcRaw);

   char *pszShSrc = 0, *pszShDst = 0;
   if (filedb.canRead()) {
      // create source shadow path
      if (!joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2), pszSrcRaw, pszRelSrc))
         pszShSrc = szRefNameBuf2;
   } else {
      // create dest shadow path
      if (!joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2), pszDstRaw, pszRelSrc))
         pszShDst = szRefNameBuf2;
   }
 
   // prepare target directory(s), if any. first we need the full path,
   strcopy(szAttrBuf, szRefNameBuf);
   char *psz1 = strrchr(szAttrBuf, glblPathChar);
   #ifdef _WIN32
   if (!psz1) {
      // c:thefile.txt -> c:
      if ( (strlen(szAttrBuf) >= 2) && (szAttrBuf[1] == ':' ) )
         psz1 = &szAttrBuf[2];
   }
   #endif
   if (!psz1) return 9+perr("unexpected target name format: %s\n",szAttrBuf);
   *psz1 = '\0';
   // to check if it exists or not,
   if (!cs.sim && !isDir(szAttrBuf)) {
      // then we need to isolate the relative target dir path,
      sprintf(szAttrBuf, "%c%s", glblPathChar, pszRelSrc);
      psz1 = strrchr(szAttrBuf, glblPathChar);
      if (!psz1) return 9+perr("unexpected target name format: %s\n",szAttrBuf);
      *psz1 = '\0';
      // to allow better processing in createSubDirTree.
      if (createSubDirTree(pszDstRaw, szAttrBuf, pszSrcRaw))
         return 9;
   }
   // else we have some path like c:thefile.txt - no directories to create.

   // same for dest. shadow, if any
   if (filedb.canUpdate() && nGlblCopyShadows && pszShDst) 
   {
      strcopy(szAttrBuf, pszShDst);
      char *psz1 = strrchr(szAttrBuf, glblPathChar);
      #ifdef _WIN2
      if (!psz1) {
         // c:thefile.txt -> c:
         if ( (strlen(szAttrBuf) >= 2) && (szAttrBuf[1] == ':' ) )
            psz1 = &szAttrBuf[2];
      }
      #endif
      if (!psz1) return 9+perr("unexpected target name format: %s\n",szAttrBuf);
      *psz1 = '\0';
      // to check if it exists or not,
      if (!cs.sim && !isDir(szAttrBuf)) {
         // then we need to isolate the relative target dir path,
         sprintf(szAttrBuf, "%czz-shadow-01%s%s", glblPathChar, glblPathStr, pszRelSrc);
         psz1 = strrchr(szAttrBuf, glblPathChar);
         if (!psz1) return 9+perr("unexpected target name format: %s\n",szAttrBuf);
         *psz1 = '\0';
         // to allow better processing in createSubDirTree.
         if (createSubDirTree(pszDstRaw, szAttrBuf, pszSrcRaw))
            return 9;
      }
   }
 
   return execFileCopySub(pszSrc, szRefNameBuf, pszShSrc, pszShDst);
}

// does NOT create target subdirs. this is expected to be done by caller.
int execFileCopySub(char *pszSrc, char *pszDst, char *pszShSrc, char *pszShDst)
{__
   mtklog(("fcopysub: %s -> %s",pszSrc,pszDst));

   char szReason[50];
   szReason[0] = '\0';

   // if we tell the filename, do we take src or dst file?
   char *pszTell = chain.usefiles ? pszDst : pszSrc;
   if (cs.listTargets) pszTell = pszDst;
 
   // check if we really need to copy

   // BEWARE OF MIXUP:
   //    sfk list -sincedir foo bar
   //       means for the user: FOO (szRefNameBuf) is the SOURCE.
   // NO problem here, because with
   //    sfk copy foo bar
   //       the pszSrc provided in here REALLY is the SOURCE.

   bool  bJustCopyTime = 0;
   bool  bSrcIsOlder = 0;
   uint nflags = 0;

   FileStat ofsSrc;
   FileStat ofsDst;
   bool  bSrcUnreadable = 0;
   if (ofsSrc.readFrom(pszSrc)) {
      // filename exists in source, but file is unreadable:
      mtklog(("copy: src unreadable"));
      if (filedb.canRead() && pszShSrc) {
         // proceed, as we may use the shadow
         bSrcUnreadable = 1; // but don't issue same error twice
      } else {
         // printf("fatal, %d %p\n", filedb.canRead(), pszShSrc);
         return 9;
      }
   }
   num nFileSize = ofsSrc.getSize();
   if (fileExists(pszDst)) 
   {
      if (!ofsDst.readFrom(pszDst)) 
      {
         bool bSameIOS = cs.syncOlder ? 0 : 1;  // same if older src?
         int ndif = ofsSrc.differs(ofsDst, bSameIOS, &bSrcIsOlder);
         if (bSrcIsOlder) nflags |= (1<<3);
         if (!ndif && !bGlblIgnoreTime) {
            // only with copy, NOT with sync it may happen
            // that src is OLDER than target, skipping copy.
            // with sync, different times ALWAYS lead to copy.
            if (cs.syncFiles && bSrcIsOlder && !cs.noinfo) {
               if (bSrcIsOlder < 2) {
                  info.setStatus("skip", pszTell, "source is older");
                  info.printLine(1<<2);
               }
               // else dst jump, don't even tell notice
            }
            else
            if (cs.verbose)
               info.print("no diff, skip: %s\n", pszTell);
            if (filedb.canUpdate())
               filedb.updateFile(pszSrc, 0, true); // true:JustConfirm
            return 0;   // skip
         }
         // differs by timestamp (src is newer). but does it really mean
         // we have to copy the whole content?
         if (ofsSrc.getSize() == ofsDst.getSize()) {
            // compare file content
            uchar abMD5Src[20];
            if (equalFileContent(pszSrc, pszDst, abMD5Src)) {
               if (bGlblIgnoreTime) {
                  if (filedb.canUpdate())
                     filedb.updateFile(pszSrc, abMD5Src);
                  return 0; // same content, skip
               }
               bJustCopyTime = 1;
            }
            else
            if (!ndif && bGlblIgnoreTime) {
               int ndif2 = ofsSrc.differs(ofsDst, 0); // NOT same if older src
               if (!ndif2 && cs.sim) {
                  // critical: have file with same size and time, but dif. content
                  // this can be reached only through -ignoretime deep verify.
                  // if in simulation, create warning-like special listing
                  pwarn("same time/size, but content diff: %s\n", pszDst);
                  // indicates corrupted file - no filedb update here.
                  cs.files++;
                  return 0;
               }
            }
            if (cs.verbose)
               info.print("[%s : differs, rc %d%s]\n", pszDst, ndif,
                  bJustCopyTime ? ", same content":", diff. content");
         } else {
            if (cs.verbose)
               info.print("[%s : differs, rc %d]\n", pszDst, ndif);
         }
         // sprintf(szReason, "%d", ndif);
      }
   }

   if (bJustCopyTime)
   {
      // this flag says that both files exist with same content.
      if (cs.sim) {
         cs.filesCloned++;
      } else {
         // copy timestamp and attributes, but not the content.
         if (ofsSrc.writeTo(pszDst, __LINE__))
            return 1; // error, skip but continue
         cs.filesCloned++;
      }

      setTextColor(nGlblTimeColor);
      info.setStatus("", pszTell, "copy time", eNoCycle);
      info.printLine(nGlblCopyStyle);
      setTextColor(-1);

      // remember src and dst for verify pass
      // glblVerifier.remember(pszSrc, pszDst);
   }
   else
   {
      // prepare copy of file
      if (filedb.canRead()) {
         // try to check source file if it's still intact
         int nvrc = filedb.verifyFile(pszSrc, pszShSrc, bSrcUnreadable);
         if (nvrc >= 9)
            return 0+perr("check failed: %s - content changed, skipping copy\n", pszSrc);
         else
         if (nvrc == 8)
            return 0+perr("%s - not found in metadb, skipping copy\n", pszSrc);
         else
         if (nvrc == 5) {
            pwarn("master file modified, using shadow: %s\n", pszShSrc);
            pszSrc = pszShSrc;
            cs.shadowFallbacks++;
            nflags |= 3; // with checksum, but shadow
         }
         else
         if (nvrc > 5) {
            // unexpected, issue general message
            return 0+perr("check failed: %s - skipping copy (%d)\n", pszSrc, nvrc);
         } else {
            // rc < 5 is just informal, e.g. time difference
            nflags |= 1; // checksum verified
         }
      }

      // copy the actual file
      bool bDone = 0;
      if (!cs.sim && bGlblUseCopyCache) {
         int lRes = glblCopyCache.process(pszSrc, pszDst, pszShDst, nflags);
         if (lRes == 0)
            bDone = 1;
         if (lRes >= 9)
            return lRes; // fatal error
      }
    
      if (!bDone) 
      {
         int iSubRC = 0;
         #ifdef _WIN32
         if (!nGlblCopyShadows) {
            if (iSubRC = copyFileWin(pszSrc, pszDst, pszShDst, pGlblWorkBuf, nGlblWorkBufSize, nflags))
               return iSubRC;
         }
         else
         #endif
         if (iSubRC = copyFile(pszSrc, pszDst, pszShDst, pGlblWorkBuf, nGlblWorkBufSize, nflags))
            return iSubRC;
      }

      // count direct file size
      nGlblBytes += nFileSize;

      // count shadow size, if any
      if (   nGlblCopyShadows
          && (!nGlblShadowSizeLimit || (nFileSize < nGlblShadowSizeLimit))
         )
      {
         nGlblBytes += nFileSize;
         cs.shadowsWritten++;
      }
   }
 
   return 0;
}

// USES:
//    szAttrBuf, szRefNameBuf, szLineBuf1/2 (indirectly)
int execFileCleanup(char *pszSrc)
{__
   cs.filesScanned++;

   // expect Dst to be a directory, e.g.
   //    x:    x:/   x:/tmp   x:/tmp/
   char *pszDstRaw = pszGlblCopyDst;

   // expect Src to contain a RELATIVE path, e.g.
   //    data\tmp1.txt  data\sub\tmp2.txt
   // strip the original base path, if any
   char *pszRelSrc = relName(pszGlblCopySrc, pszSrc);
 
   // build full target name: d:/tmp/subdir/thefile.txt
   joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszDstRaw, pszRelSrc);
 
   // REORDER: currently, pszSrc is the TARGET file
   char *pszDst = pszSrc;
   pszSrc = szRefNameBuf;
   // NOW, pszSrc is the copy src, pszDst is the cleanup candidate.

   bool b1 = (bool)fileExists(pszSrc);
   bool b2 = (bool)fileExists(pszDst);

   if (!b1 && b2)
   {
      // old trash file, or backsync candidate?
      num nFileAge = getFileAge(pszDst);
      int nAgeDays = nFileAge / (24 * 3600);

      if (!cs.delStaleFiles && (nAgeDays < nGlblActiveFileAgeLimit))
      {
         int nRemain = nGlblActiveFileAgeLimit - nAgeDays;
         if (nRemain < 6)
            setTextColor(nGlblErrColor);
         else
            setTextColor(nGlblWarnColor);
         if (cs.verbose)
            info.print("stale: %s / %s - %d days until deletion\n",pszDst,pszSrc,nRemain);
         else
            info.print("stale: %s - %d days until deletion\n",pszDst,nRemain);
         setTextColor(-1);
         cs.filesStale++;
      }
      else
      {
         setTextColor(nGlblWarnColor);
         if (cs.verbose)
            info.print("DEL: %s / %s",pszDst,pszSrc);
         else
            info.print("DEL: %s",pszDst);
         setTextColor(-1);
   
         // NO LINEFEED FROM HERE
         if (!cs.sim && cs.yes) 
         {
            // delete primary stale file
            if (!canWriteFile(pszDst, 0))
               setWriteEnabled(pszDst);
            if (remove(pszDst)) {
               printf("\n");
               perr("failed to delete: %s", pszDst);
            } else {
               cs.filesDeleted++;
               if (filedb.canUpdate()) {
                  // remove file from filedb
                  filedb.removeFile(pszDst, 1);
               }
            }
            // delete shadow, if any
            if (nGlblCopyShadows && cs.skipOwnMetaDir && (strlen(filedb.metaDir()) > 0))
            {
               char *pszMeta = filedb.metaDir();
               if (!strstr(pszMeta, "zz-shadow-")) {
                  printf("\n"); perr("wrong metadb name: %s", pszMeta);
               } else {
                  joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszMeta, pszRelSrc);
                  char *pszShadow = szRefNameBuf;
                  if (fileExists(pszShadow)) {
                     if (!canWriteFile(pszShadow, 0))
                        setWriteEnabled(pszShadow);
                     if (remove(pszShadow)) {
                        printf("\n");
                        perr("failed to delete: %s", pszShadow);
                     } else {
                        printx("<time> +shadow<def>");
                     }
                  }
               }
            }
         } else {
            cs.filesDeleted++;
         }
         // NO LINEFEED UNTIL HERE

         printf("\n");
      }
   }
   else 
   if (b1 && b2)
   {
      // list touched files
      FileStat ofsSrc;
      FileStat ofsDst;
      if (ofsSrc.readFrom(pszDst))  // SWAPPED
         return 9;
      if (!ofsDst.readFrom(pszSrc)) {  // SWAPPED
         int ndif = ofsSrc.differs(ofsDst, 1); // same if older src
         if (!ndif) {
            if (cs.verbose)
               info.print("no diff, skip: %s\n", pszSrc);
            return 0;   // skip
         }
         if (cs.verbose)
            info.print("[%s : differs, rc %d]\n", pszDst, ndif);
         // the target file was changed after copy
         cs.filesNewerInDst++;
         if (bGlblShowSyncDiff)
            info.print("DIF: %s   (%s)\n",pszDst,ofsSrc.diffReason(ndif));
      }
   }
 
   return 0;
}

int execDirCleanup(char *pszSrc, FileList &oDirFiles)
{__
   // copy metadata of directory
   char *pszDstRaw = pszGlblCopyDst;

   // expect Src to contain a RELATIVE path, e.g.
   //    data\tmp1.txt  data\sub\tmp2.txt
   // strip the original base path, if any
   char *pszRelSrc = relName(pszGlblCopySrc, pszSrc);

   cs.dirsScanned++;
   sprintf(szLineBuf, "%u files %u dirs", cs.filesScanned, cs.dirsScanned);
   if (strlen(szLineBuf) > 20)
      info.setAddInfoWidth(strlen(szLineBuf));
   info.setStatus("scan ", pszRelSrc, szLineBuf);

   // build full target name: d:/tmp/subdir
   joinPath(szRefNameBuf, sizeof(szRefNameBuf), pszDstRaw, pszRelSrc);

   // strip trailing / if any
   int nRefLen = strlen(szRefNameBuf);
   if ((nRefLen > 0) && (szRefNameBuf[nRefLen-1] == glblPathChar))
      szRefNameBuf[nRefLen-1] = '\0';

   // REORDER: currently, pszSrc is the TARGET dir
   char *pszDst = pszSrc;
   pszSrc = szRefNameBuf;
   // NOW, pszSrc is the copy src, pszDst is the cleanup candidate.

   if (!isDir(pszSrc) && isDir(pszDst)) 
   {
      bool isEmptyDir(char *pszIn);
      if (isEmptyDir(pszDst))
      {
         setTextColor(nGlblWarnColor);
         info.print("DEL: %s\n", pszDst);
         setTextColor(-1);
         if (!cs.sim && cs.yes) {
            int nrc = rmdir(pszDst);
            if (nrc)
               perr("failed to delete: %s\n", pszDst);
            else
               cs.dirsDeleted++;
         } else {
            cs.dirsDeleted++;
         }
      }
   }

   return 0;
}

#endif // USE_SFK_BASE

int execFormConv(char *pszFile, char *pszOutFile)
{__
   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut) pszOutFile = pszFile;

   num nFileSize = 0;
   char *pInFile = (char*)loadBinaryFile(pszFile, nFileSize);
   if (!pInFile) return 9;

   CharAutoDel odel(pInFile);

   // SFK 1.7.2: make sure no binary is truncated
   if (cs.textfiles) {
      if (memchr(pInFile, '\0', nFileSize)) {
         if (cs.verbose)
            printx("$skip <def> %s - binary\n", pszFile);
         return 0;
      }
   }

   bool bAny    = 0;
   bool berr    = 0;
   bool bshowle = (nGlblConvTarget & eConvFormat_ShowLE) ? 1 : 0;
   int ipasses  = bshowle ? 1 : 2;

   FILE *fOut = 0;

   uchar abCRLF[] = { 0xD, 0xA };

   int  icr=0, ilf=0, icrlf=0, iut=0;

   for (int ipass=0; ipass<ipasses && berr==0; ipass++)
   {
      char *pszSrcCur = pInFile;
      char *pszSrcMax = pszSrcCur + nFileSize;
      char *pszLine   = pszSrcCur;
      char *pszEOL    = 0;
      int   iLineLen  = 0;
      int   iEOLLen   = 0;
      uchar abEOL[10];
      char  c = 0;

      if (ipass)
      {
         if (!cs.writeall && !bAny) {
            if (cs.verbose)
               printx("$skip <def> %s - nothing to change\n", pszFile);
            return 0; // nothing to do
         }

         cs.files++;

         // write output file:
         //   if different output is specified, also create directory structure.
         if (bHaveOut) {
            if (createOutDirTree(pszOutFile))
               return 9;
            if (!cs.quiet) info.setStatus(cs.curcmd, pszOutFile);
         } else {
            if (!cs.quiet) info.setStatus(cs.curcmd, pszFile);
         }

         if (!cs.sim) {
            fOut = fopen(pszOutFile, "wb");
            if (!fOut) {
               delete [] pInFile;
               return 9+perr("cannot %swrite %s\n", bHaveOut?"":"over", pszOutFile);
            }
         }
      }

      while (pszSrcCur <= pszSrcMax)
      {
         if (pszSrcCur < pszSrcMax) {
            c = *pszSrcCur++;
         } else {
            // end of data
            if (pszLine == pszSrcCur)
               break;
            // line without (CR)LF exists
            c = '\0';
            iut++;
         }

         if (c == '\r' || c == '\n' || c == '\0')
         {
            // line end reached
            iEOLLen = 0;
            if (c) {
               pszEOL  = pszSrcCur-1;
               iEOLLen = 1;
            } else {
               pszEOL  = pszSrcCur;
               iEOLLen = 0;
            }

            if (c == '\r') {
               // eol by CR or CRLF
               if (*pszSrcCur == '\n') {
                  pszSrcCur++;
                  iEOLLen = 2;
                  icrlf++;
               } else {
                  icr++;
               }
            }
            else if (c == '\n') {
               ilf++;
            }

            iLineLen = pszEOL - pszLine;

            if (fOut)
            {
               // write line content
               if ((int)myfwrite((uchar*)pszLine, iLineLen, fOut) != iLineLen)
                  {  berr=1; break; }

               // write new line ending
               if (iEOLLen == 0 && cs.forcele == 0) {
                  // last line has no LF and should be kept as is
               }
               else
               if (nGlblConvTarget & eConvFormat_LF) {
                  if (fOut)
                     if (myfwrite(&abCRLF[1], 1, fOut) != 1)
                        {  berr=1; break; }
               }
               else
               if (nGlblConvTarget & eConvFormat_CRLF) {
                  if (fOut)
                     if (myfwrite(&abCRLF[0], 2, fOut) != 2)
                        {  berr=1; break; }
               }
            }
            else if (ipass == 0)
            {
               // check for differences
               abEOL[0] = '\0';
               abEOL[1] = '\0';

               if (iEOLLen == 0 && cs.forcele == 0) {
                  // last line has no LF and should be kept as is
               }
               else
               {
                  if (iEOLLen)
                     memcpy(abEOL, pszEOL, iEOLLen);
   
                  if (nGlblConvTarget & eConvFormat_LF) {
                     if (abEOL[0] != '\n')
                        bAny = 1;
                  }
                  else
                  if (nGlblConvTarget & eConvFormat_CRLF) {
                     if (memcmp(abEOL, "\r\n", 2))
                        bAny = 1;
                  }
               }
            }

            pszLine = pszSrcCur;
         }
         
         // else step over line content

      }  // endfor text

   }  // endfor pass               

   if (fOut)
      fclose(fOut);

   if (bshowle) {
      printx("$%s %s %s %s<def> %s\n",
         icrlf ? "crlf" : "----",
         ilf   ? "lf"   : "--",
         iut   ? "ut"   : "--",
         icr   ? "cr"   : "--",
         pszFile
         );
      if (icrlf) aGlblConvStat[0]++;
      if (ilf  ) aGlblConvStat[1]++;
      if (iut  ) aGlblConvStat[2]++;
      if (icr  ) aGlblConvStat[3]++;
   }
   else if (!cs.quiet) {
      info.printLine(1<<2);
   }

   if (berr)
      return 9+esys("fwrite", "failed to write %s   \n", pszOutFile);

   return 0;
}

int checkArgCnt(int argc, int lMinCnt) {
   if (argc < lMinCnt)
      return 9+perr("missing arguments. type \"sfk\" without parms for help.\n");
   return 0;
}

bool isWriteable(char *pszTmpFile) 
{
   FILE *fout = fopen(pszTmpFile, "w");
   if (!fout) return 0;
   fclose(fout);
   remove(pszTmpFile); // cleanup zero-length trash file
   return 1;
}

// uses szLineBuf2, and szLineBuf indirectly, for result.
// RC: number of hits
int listPathAny(char *pszCmd, bool bSilent)
{
   int nhits = 0;

   #ifdef _WIN32

   // check PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH
   char *pszExt = getenv("PATHEXT");
   if (!pszExt) {
      char *psz = findPathLocation(pszCmd, 0);
      if (psz) { nhits++; if (!bSilent) printf("%s\n", psz); }
   } else {
      pszExt = strdup(pszExt);
      char *psz1 = pszExt;
      bool beod = 0;
      while (*psz1 && !beod) {
         // recombine base string with any extension like .exe, .cmd
         char *psz2 = psz1;
         while (*psz2 && *psz2 != ';')
            { *psz2 = tolower(*psz2); psz2++; }
         if (*psz2) *psz2++ = '\0';
         else beod = 1;
         // check is such a file is in path. if so, list it.
         sprintf(szLineBuf2, "%s%s", pszCmd, psz1);
         char *psz = findPathLocation(szLineBuf2, 0);
         if (psz) { nhits++; if (!bSilent) printf("%s\n", psz); }
         psz1 = psz2;
      }
      delete [] pszExt;
   }

   #else

   char *psz = findPathLocation(pszCmd, 0);
   if (psz) { nhits++; if (!bSilent) printf("%s\n", psz); }

   #endif

   return nhits;
}

// uses szLineBuf, also for result!
char *findPathLocation(cchar *pszCmd, bool bExcludeWorkDir)
{
   #ifdef _WIN32
   if (!bExcludeWorkDir) {
      // win only: check current dir first (implicite path inclusion)
      getcwd(szLineBuf,MAX_LINE_LEN-10);
      strcat(szLineBuf,glblPathStr);
      strcat(szLineBuf,pszCmd);
      if (fileExists(szLineBuf)) {
         if (cs.debug)
            printf("hit: %s [cwd]\n", szLineBuf);
         return szLineBuf;
      }
   }
   #endif

   char *pszPath = getenv("PATH");
   if (!pszPath) { perr("no PATH variable found.\n"); return 0; }
   char *psz1 = pszPath;
   while (*psz1) 
   {
      char *psz2 = psz1;
      #ifdef _WIN32
      while (*psz2 && (*psz2 != ';'))
         psz2++;
      #else
      while (*psz2 && (*psz2 != ':'))
         psz2++;
      #endif
      // isolate single directory from path.
      int nLen = psz2-psz1;
      strncpy(szLineBuf, psz1, nLen);
      szLineBuf[nLen] = '\0';
      // now holding single dir in szLineBuf.
      if (!strcmp(szLineBuf, ".") && bExcludeWorkDir) {
         if (cs.debug)
            printf("skip: %s\n", szLineBuf);
      } else {
         if (cs.debug)
            printf("probe: %s\n", szLineBuf);
         stripTrailingBackSlashes(szLineBuf);
         strcat(szLineBuf, glblPathStr);
         strcat(szLineBuf, pszCmd);
         if (fileExists(szLineBuf)) {
            if (cs.debug)
               printf("hit: %s\n", szLineBuf);
            return szLineBuf;
         }
      }
      // step to next subpath
      if (*psz2)
         psz2++;
      psz1 = psz2;
   }
   return 0;
}

char *localPath(char *pAbsFile)
{
   static char szPath[SFK_MAX_PATH+10];
   strcopy(szPath, pAbsFile);
   for (char *p=szPath; *p; p++) {
      if (*p == glblWrongPChar)
          *p = glblPathChar;
   }
   return szPath;
}

char *remoteStandardPath(char *pAbsFile)
{
   static char szPath[1024];
   strcopy(szPath, pAbsFile);
   for (char *p=szPath; *p; p++) {
      if (*p == '\\')
          *p = '/';
   }
   return szPath;
}

#ifdef WITH_TCP

enum ESFKFTPReturnCodes
{
   FTPRC_Stopped        = 500,
   FTPRC_OutOfDiskSpace = 552,
   FTPRC_WriteFailed    = 550
};

static void setBlocking(SOCKET hSock, bool bYesNo)
{
   #ifdef _WIN32
   unsigned long ulParm = bYesNo ? 0 : 1;
   ioctlsocket(hSock, FIONBIO, &ulParm);
   #else
   if (bYesNo)
      fcntl(hSock, F_SETFL, (fcntl(hSock,F_GETFL) & ~O_NONBLOCK));
   else
      fcntl(hSock, F_SETFL, (fcntl(hSock,F_GETFL) | O_NONBLOCK));
   #endif
}

bool hasData(SOCKET &hSock, int lTimeoutMS)
{
   #ifdef _WIN32
   struct timeval tv;
   tv.tv_sec  = 0;
   tv.tv_usec = lTimeoutMS * 1000;

   fd_set fds1, fds2, fds3;
   fds1.fd_count    = 1;
   fds1.fd_array[0] = hSock;
   fds2.fd_count    = 0;
   fds3.fd_count    = 0;

   return select(0, &fds1, &fds2, &fds3, &tv) == 1;
   #else
   struct timeval tv;
   tv.tv_sec  = 0;
   tv.tv_usec = lTimeoutMS * 1000;

   fd_set fds;
   FD_ZERO(&fds);
   FD_SET(hSock, &fds);

   int nrc = select(hSock+1, &fds, NULL, NULL, &tv);
   return nrc > 0;
   #endif
}

// by default, recv() returns as much bytes as there are.
// this function forces receival of full length block.
int receiveBlock(SOCKET hSock, uchar *pBlock, uint nLen, cchar *pszInfo)
{
   int nRemain = nLen;
   int nCursor = 0;
   while (nRemain > 0) {
      int nRead = recv(hSock, (char*)pBlock+nCursor, nRemain, 0);
      if (nRead <= 0) {
         if (pszInfo) // else silent mode
            perr("failed to receive %s, %s\n", pszInfo, netErrStr());
         return -1;
      }
      nRemain -= nRead;
      nCursor += nRead;
   }
   return 0;
}

// uses szLineBuf
int sendLine(SOCKET hSock, cchar *psz, bool bQuiet)
{
   strncpy(szLineBuf, psz, MAX_LINE_LEN-10);
   szLineBuf[MAX_LINE_LEN-10] = '\0';
   strcat(szLineBuf, "\r\n");
   // if (!bQuiet && !cs.quiet) printf("< %s", szLineBuf);
   if (cs.verbose) printf("< %s", szLineBuf);
   int nSent = send(hSock, szLineBuf, strlen(szLineBuf), 0);
   if (nSent != (int)strlen(szLineBuf)) return 9;
   return 0;
}

int readLineRaw(SOCKET hSock, char *pszLineBuf, int &rReadLen)
{
   rReadLen = 0;
   int nCursor = 0;
   int nRemain = MAX_LINE_LEN;
   pszLineBuf[0] = '\0';
   while (nRemain > 10) 
   {
      int nRead = recv(hSock, pszLineBuf+nCursor, 1, 0);
      if (nRead == 0) return 1; // eod
      if (nRead < 0)  return 9; // connection close
      nCursor += nRead;
      nRemain -= nRead;
      pszLineBuf[nCursor] = '\0';
      if (nCursor > 0 && pszLineBuf[nCursor-1] == '\n')
         break;
   }
   rReadLen = nCursor;
   return 0;
}

int readLineSub(SOCKET hSock, char *pszLineBuf, int nMode)
{
   bool bAddToRemList = (nMode & 1) ? 1 : 0;
   bool bDirListMode  = (nMode & 4) ? 1 : 0;
   bool bAnyListMode  = bDirListMode || bAddToRemList;
   bool bVerbose      = (nMode & 8) || cs.verbose;

   int  iReplyLineNum  = 0;
   int  iMultiLineCode = 0;
   bool bStop = 0;

  while (!bGlblEscape && !bStop)
  {
   int nCursor = 0;
   int nRemain = MAX_LINE_LEN;
   memset(pszLineBuf, 0, 10);
   // switching from readLine mode to readBinary is tricky,
   // therefore read char by char to exactly get the point
   // of CRLF, from which on we may switch to binary.
   while (nRemain > 10) {
      // recv blocks until at least 1 byte is available.
      int nRead = recv(hSock, pszLineBuf+nCursor, 1, 0);
      if (nRead <= 0) {
         // perr("readLine failed %d %d", nCursor, nRead);
         return 9;
      }
      nCursor += nRead;
      nRemain -= nRead;
      pszLineBuf[nCursor] = '\0';
      if (nCursor > 0 && pszLineBuf[nCursor-1] == '\n')
         break;
   }
   iReplyLineNum++;
   // reading a block of continued lines?
   if (  (bAnyListMode && !isdigit(pszLineBuf[0]))
       || pszLineBuf[3] == '-' || pszLineBuf[0] == '-'
       || (iMultiLineCode>0 && pszLineBuf[0]==' ')
      )
   {
      removeCRLF(pszLineBuf);
      // detect multi line interactive reply.
      // does not apply with directory listings.
      if (!bAnyListMode) {
         char *psz=pszLineBuf;
         if (  !bAnyListMode
             && isdigit(psz[0]) && isdigit(psz[1]) && isdigit(psz[2])
             && (pszLineBuf[3]=='-') 
            )
            iMultiLineCode = atoi(pszLineBuf);
         else 
         if(    iMultiLineCode>0
             && atoi(pszLineBuf)==iMultiLineCode
             && pszLineBuf[3]==' ')
            bStop = 1;
      }
      // on replies to SLST: store list replies, don't print
      if (bAddToRemList) {
         // if (cs.debug)
         //   printf("> [store] %s\n", pszLineBuf);
         glblFTPRemList.addEntry(pszLineBuf);
      } else {
         if (bDirListMode || bVerbose)
            printf("%s\n", pszLineBuf);
      }
      // and continue reading lines
   }
   else 
   {
      // any other record: print printable parts
      bool bskiprec = !strncmp(pszLineBuf, "SKIP ", 5);  // FIX: v160: used szLineBuf
      // dump only if verbose, or on some error codes.
      int ncode = atol(pszLineBuf);                      // FIX: v160: used szLineBuf
      // dump all error codes from 500, except:
      bool blistcode = (ncode >= 500);
      switch (ncode) {
      // case 331: blistcode = 1; break; // pass required
         case 550: blistcode = 0; break; // no such file
      }
      if (!bskiprec && (bVerbose || blistcode))
      {
         int nLen = strlen(pszLineBuf);                  // FIX: v160: used szLineBuf
         for (int i=0; i<nLen; i++)
            if (isprint(pszLineBuf[i]))
               printf("%c", pszLineBuf[i]);
         printf("\n");
         fflush(stdout);
      }
      // and stop reading, return record
      break;
   }
  }
   return 0;
}

// see also forward decl. for default parms
int readLine(SOCKET hSock, char *pszLineBuf, int nMode)
{
   if (!pszLineBuf)
      pszLineBuf = szLineBuf;

   int lRC = readLineSub(hSock, pszLineBuf, nMode);

   // sft101: optional skip records to enforce socket flushing
   if (!strncmp(szLineBuf, "SKIP ", 5)) 
   {
      // read intermediate skip record
      uint nLen = (uint)atol(szLineBuf+5);
      if (nLen > sizeof(abBuf)-10) nLen = sizeof(abBuf)-10;
      if (nLen) receiveBlock(hSock, abBuf, nLen, "SKIP");

      // now read the actual record
      lRC = readLineSub(hSock, pszLineBuf, nMode);
   }

   return lRC;
}

// FIX: 161R3: ftp server unexpected forbidden path.
// complete rewrite of path traversal detection.
bool isPathTraversal(char *pszFile, bool bDeep)
{
   if (!strlen(pszFile)) return 1;

   int ilen = strlen(pszFile);

   // posix style
   if (!strcmp(pszFile, ".")) return 1;
   if (!strcmp(pszFile, "./")) return 1;
   if (!strcmp(pszFile, "/")) return 1;
   if (!strcmp(pszFile, ".."))  return 1;
   if (!strncmp(pszFile, "../", 3)) return 1;
   if (strstr(pszFile, "/../")) return 1;
   if (ilen >= 3 && !strcmp(pszFile + ilen - 3, "/.."))
      return 1;

   // windows style
   if (!strcmp(pszFile, ".\\")) return 1;
   if (!strcmp(pszFile, "\\")) return 1;
   if (!strncmp(pszFile, "..\\", 3)) return 1;
   if (strstr(pszFile, "\\..\\")) return 1;
   if (ilen >= 3 && !strcmp(pszFile + ilen - 3, "\\.."))
      return 1;

   if (!bDeep)
   {
      if (strstr(pszFile, "/")) return 1;
      if (strstr(pszFile, "\\")) return 1;
   }

   return 0;
}

/*
void traversalTest()
{
   bool bdeep = 0;

   printf("expect 0:\n");
   printf("%d\n", isPathTraversal("mydir/foo/bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/foo ../bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/foo.../bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/foo...\\bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir../bar.txt",bdeep));
   printf("%d\n", isPathTraversal("...",bdeep));
   printf("%d\n", isPathTraversal(".cfg",bdeep));
   printf("%d\n", isPathTraversal(".",bdeep));

   printf("expect 1:\n");
   printf("%d\n", isPathTraversal("mydir/../bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/..\\bar.txt",bdeep));
   printf("%d\n", isPathTraversal("mydir/..",bdeep));
   printf("%d\n", isPathTraversal("mydir\\..",bdeep));
   printf("%d\n", isPathTraversal("..",bdeep));
   printf("%d\n", isPathTraversal("..\\",bdeep));
}
*/

// uses abBuf
int readLong(SOCKET hSock, uint &rOut, cchar *pszInfo)
{
   if (receiveBlock(hSock, abBuf, 4, pszInfo)) return 9;
   uint nLen =   (((uint)abBuf[3])<<24)
                | (((uint)abBuf[2])<<16)
                | (((uint)abBuf[1])<< 8)
                | (((uint)abBuf[0])<< 0);
   rOut = nLen;
   return 0;
}

// uses abBuf
int sendLong(SOCKET hSock, uint nOut, cchar *pszInfo)
{
   abBuf[3] = ((uchar)(nOut >> 24));
   abBuf[2] = ((uchar)(nOut >> 16));
   abBuf[1] = ((uchar)(nOut >>  8));
   abBuf[0] = ((uchar)(nOut >>  0));
   int nSent = send(hSock, (char*)abBuf, 4, 0);
   if (nSent != 4) return 9+perr("failed to send %s, %s\n", pszInfo, netErrStr());
   return 0;
}

// uses abBuf
int readNum(SOCKET hSock, num &rOut, cchar *pszInfo)
{
   if (receiveBlock(hSock, abBuf, 8, pszInfo)) return 9;
   num nOut = 0;
   for (int i=0; i<8; i++) {
      nOut <<= 8;
      nOut |= (uint)abBuf[i];
   }
   rOut = nOut;
   return 0;
}

int readNum(uchar *pbuf, int &roff, num &rOut, cchar *pszInfo)
{
   num nOut = 0;
   for (int i=0; i<8; i++) {
      nOut <<= 8;
      nOut |= (uint)pbuf[roff+i];
   }
   roff += 8;
   rOut = nOut;
   return 0;
}

// uses abBuf
int sendNum(SOCKET hSock, num nOut, cchar *pszInfo)
{
   // this may fail with num's >= 2 up 63.
   for (int i=7; i>=0; i--) {
      abBuf[i] = (uchar)(nOut & 0xFF);
      nOut >>= 8;
   }
   int nSent = send(hSock, (char*)abBuf, 8, 0);
   if (nSent != 8) return 9+perr("failed to send %s, %s\n", pszInfo, netErrStr());
   return 0;
}

// Note: caller must set info.status
int sendFileRaw(SOCKET hSock, char *pszFile, bool bSentStdPath=0, uchar *pmd5=0)
{__
   num nLen = getFileSize(pszFile);
   if (nLen < 0) return 9+perr("cannot get size of %s\n", pszFile);

   SFKMD5 md5;
   
   info.setStatus("send", pszFile);

   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9+perr("cannot read %s\n", pszFile);

   num nLen2 = 0;
   num nTellStep = 10;
   num nTellNext = 0;
   while ((nLen2 < nLen) && !bGlblEscape)
   {
      int nRead = fread(abBuf, 1, sizeof(abBuf)-10, fin);
      if (nRead <= 0) return 9+perr("cannot fully read %s (1)\n", pszFile);

      int nSentTotal = 0;
      
      // actually send() should block until the whole block is sent.
      // this loop is just in case it unexpectedly sends only part of the message.
      while (nSentTotal < nRead)
      {
         int nSentCur = send(hSock, (char*)abBuf+nSentTotal, nRead-nSentTotal, 0);
         
         if (nSentCur <= 0)
         {
            perr("connection closed while sending %s %s\n", pszFile, netErrStr());
            perr("the file cannot be written at receiver.\n");
            fclose(fin);
            return 9;
         }
         
         nSentTotal += nSentCur;
         
         // in case of VM transfer on same PC
         if (nSentTotal < nRead)
            doSleep(10);
      }
      
      if (pmd5) md5.update(abBuf, nRead);

      nLen2 += nRead;

      info.setProgress(nLen/1000,nLen2/1000,"kb");
   }
   fclose(fin);

   if (pmd5) memcpy(pmd5, md5.digest(), 16);
   
   if (bGlblEscape) {
      pwarn("send stopped by user.\n");
      return 9;
   }

   char szBuf1[100], szBuf2[100];

   if (nLen2 != nLen) {
      perr("> send incomplete: %s (%s/%s)\n",
         pszFile,
         numtoa(nLen2,1,szBuf1), numtoa(nLen,1,szBuf2)
         );
   }
   else
   if (cs.quiet < 2) {
      if (bSentStdPath)
         info.print("< %s sent, %s bytes.       \n", remoteStandardPath(pszFile), numtoa(nLen2));
      else
         info.print("< %s sent, %s bytes.       \n", pszFile, numtoa(nLen2));
   }      

   return 0;
}

// send SKIP record to force socket flush on linux systems.
int sendSkipBlock(SOCKET hSock)
{
   // so far, no extra dummy data is appended.
   int nSkipSize = 0;
   if (nSkipSize) {
      if ((int)sizeof(abBuf) < (nSkipSize+10000))
         return 9+perr("internal #201\n");
      memset(abBuf, 0xEE, nSkipSize);
      abBuf[nSkipSize-1] = '\n';
   }
   // the LF at the end of record should flush the socket.
   sprintf((char*)abBuf, "SKIP %d\r\n", nSkipSize);
   int nLen = strlen((char*)abBuf)+nSkipSize;
   send(hSock, (char*)abBuf, nLen, 0);
   return 0;
}

int preScanFile(char *pszFile, uchar *pmd5out, uint &nattrout)
{
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) return 9;

   bool bbinary = 0;

   SFKMD5 md5;
   size_t nRead = 0;
   while ((nRead = fread(abBuf,1,sizeof(abBuf)-10,fin)) > 0) {
      md5.update(abBuf,nRead);
      if (!bbinary && memchr(abBuf, '\0', nRead))
         bbinary = 1;
      nGlblBytes += nRead;
   }

   fclose(fin);

   uchar *pmd5 = md5.digest();
   for (uint k=0; k<16; k++)
      pmd5out[k] = pmd5[k];

   uint nattrib = bbinary ? 1 : 0;

   nattrout = nattrib;

   return 0;
}

bool bdebug = 0;

int sendRaw(char *pszFile, FILE *fin, SOCKET hSock, num nLen, SFKMD5 *pmd5)
{
   num nLen2 = 0;
   while (nLen2 < nLen)
   {
      int nrem = nLen - nLen2;

      int nreqlen = sizeof(abBuf)-10;
      if (nreqlen > nrem) nreqlen = nrem;

      int nRead = fread(abBuf, 1, nreqlen, fin);
      if (nRead <= 0) return 9+perr("cannot fully read %s (2)\n", pszFile);

      int nSentTotal = 0;

      // actually send() should block until the whole block is sent.
      // this loop is just in case it unexpectedly sends only part of the message.
      while (nSentTotal < nRead)
      {
         int nSentCur = send(hSock, (char*)abBuf+nSentTotal, nRead-nSentTotal, 0);

         if (nSentCur <= 0)
         {
            perr("connection closed while sending %s %s\n", pszFile, netErrStr());
            perr("the file cannot be written at receiver.\n");
            return 9;
         }

         nSentTotal += nSentCur;

         // in case of VM transfer on same PC
         if (nSentTotal < nRead)
            doSleep(10);
      }

      if (pmd5) pmd5->update(abBuf, nRead);

      nLen2 += nRead;
   }
   return 0;
}

// INCLUDES ackReceive past file send.
int putFileBySFT(SOCKET hSock, Coi *pcoi, int nSFTVer, bool bQuiet=0, bool bIgnoreAck=0, bool bBlockMode=0)
{__
   char *pszFile = pcoi->name();

   num nLen   = pcoi->getSize();
   if (nLen < 0) return 9+perr("cannot read %s\n", pszFile);
   num nTime  = pcoi->getTime();
   num nFlags = 0;

   // sft <= 101: 8_size 16_md5_pre
   uint nMetaSize = 8+16;

   // sft >= 102: 8_size 8_time 8_flags NO md5_pre
   if (nSFTVer >= 102) nMetaSize = 24;

   uchar abmd5[20]; mclear(abmd5);

   // build md5 before sending the file?
   if (nSFTVer < 102)
      if (getFileMD5(pszFile, abmd5))
         return 9;

   if (nSFTVer < 105)
   {
      // old flags, never written by getFile
      nFlags = (1 << 0);  // readable
      if (pcoi->isWriteable())   nFlags |= (1 << 1);
      if (pcoi->rawIsDir   ())   nFlags |= (1 << 3);
      if (pcoi->isLink     ())   nFlags |= (1 << 4);
      if (pcoi->isHidden   ())   nFlags |= (1 << 5);
   }
   else
   {
      // since SFT 105:
      //    bits 0...31: linux flags with sfk extension
      //    bit  32    : force full preserve by client
      nFlags = pcoi->getAttr();
      if (cs.preserve)
         nFlags |= (((num)1UL) << 32);
   }

   if (sendLong(hSock, nMetaSize, "metalen")) return 9;

   // meta 1: filesize, timestamp, flags
   if (sendNum(hSock, nLen, "size")) return 9;

   if (nSFTVer >= 102) {
      if (sendNum(hSock, nTime , "time" )) return 9;
      if (sendNum(hSock, nFlags, "flags")) return 9;
   } else {
      if (cs.verbose > 2)
         info.print("[using sft101 for compatibility.]\n");
   }

   info.setStatus("send", pszFile);

   if (nSFTVer < 102) {
      // meta 2: 16 bytes md5 BEFORE content
      int nSent = send(hSock, (char*)abmd5, 16, 0);
      if (nSent != 16) return 9+perr("failed to send md5, %s\n", netErrStr());
   }

   if (nSFTVer < 102) {
      // if receiver can't write file, this will fail.
      if (sendFileRaw(hSock, pszFile, 0, abmd5))
         return 9;
   }
   else
   if (!bBlockMode) {
      // sft 102 bulk transfer, send all in one
      if (sendFileRaw(hSock, pszFile, 0, cs.verify ? abmd5 : 0))
         return 9;
      if (cs.verify) {
         // 16 bytes md5 AFTER content
         int nSent = send(hSock, (char*)abmd5, 16, 0);
         if (nSent != 16)
            return 9+perr("failed to send md5, %s\n", netErrStr()); 
      }
   }
   else
   {
      // sft 102 block transfer, triggered by peer

      FILE *fin = fopen(pszFile, "rb");
      if (!fin) return 9+perr("cannot read %s\n", pszFile);

      SFKMD5 md5;

      num nLen2 = 0;
      num nTellStep = 10;
      num nTellNext = 0;

      char szCmd[200];

      while (1)
      {
         if (bdebug) printf("> waiting for i/o commands.\n");

         // wait for SREAD, SSUM or SCLOSE.
         mclear(szCmd);
         int nRead = recv(hSock, szCmd, sizeof(szCmd)-10, 0);
         if (nRead <= 0) { 
            fclose(fin);
            return 9+perr("unexpected EOD or close, %s\n", netErrStr()); 
         }

         if (bdebug) printf("> got cmd: %s", szCmd);

         if (strBegins(szCmd, "SREAD ")) 
         {
            num nsendreq = atonum(&szCmd[6]);

            if (sendRaw(pszFile, fin, hSock, nsendreq, cs.verify ? &md5 : 0)) {
               fclose(fin);
               return 9+perr("failed to send requested %d bytes\n",(int)nsendreq);
            }

            if (bdebug) printf("< sent %d\n", (int)nsendreq);

            nLen2 += nsendreq;

            info.setProgress(nLen/1000000,nLen2/1000000,"mb");

            continue;
         }

         if (strBegins(szCmd, "SSUM"))
         {
            if (!cs.verify) {
               fclose(fin);
               return 9+perr("unexpected verify request\n");
            }
            // 16 bytes md5 AFTER content
            if (bdebug) printf("< sending sum\n");
            int nSent = send(hSock, (char*)md5.digest(), 16, 0);
            if (nSent != 16) { 
               fclose(fin); 
               return 9+perr("failed to send md5, %s\n", netErrStr());
            }
            continue;
         }

         if (strBegins(szCmd, "SCLOSE"))
            break;

      }  // endwhile content transfer

      fclose(fin);

      if (cs.quiet < 2)
         info.print("< %s sent, %s bytes.       \n", pszFile, numtoa(nLen2));
   }

   bool bSentSkip = 0;
   if (nSFTVer >= 101) {
      // flush the socket through an extra record.
      if (bdebug) printf("< send skip\n");
      sendSkipBlock(hSock);
      bSentSkip = 1;
   }

   // wait until receival of ack, to avoid transmission break by premature close.
   #ifndef _WIN32
   // known issue: bytes sent from linux may sometimes not receive other side
   //              until connection is closed, e.g. through CTRL+C.
   if (!cs.quiet) {
      info.setStatus("send", "waiting for ack. if this blocks, try CTRL+C.", 0, eKeepProg);
      info.print();
   }
   #endif

   if (bdebug) printf("> wait for ack\n");

   memset(abBuf, 0, 10);
   receiveBlock(hSock, abBuf, 4, 0); // 0 == silent mode

   if (bIgnoreAck) {
      // do not verify, receiver may have closed connection already.
      #ifndef _WIN32
      if (cs.quiet < 2)
         info.clear();
      #endif
   } else {
      // possible replies:
      //    OK\n\n   ok\n\n (older sft)
      //    EE\n\n
      if (   tolower((char)abBuf[0]) == 'o'
          && tolower((char)abBuf[1]) == 'k') {
      #ifndef _WIN32
      if (cs.quiet < 2)
         info.clear();
      #endif
      } else {
         info.clear();
         perr("transfer or write of file failed: %s    (%s)\n", pszFile, abBuf);
      }
   }

   return 0;
}

// MODE 1: receive until END OF DATA (nMaxBytes < 0)
// MODE 2: receive until nMaxBytes   (nMaxBytes > 0)
// Note: caller must set info.status
int receiveFileRaw(SOCKET hSock, char *pszFile, num nMaxBytes,
   bool bQuiet, uchar *pmd5, num nFlags, num nDiskFree=-1)
{__
   int iRC = 0;

   info.setStatus("recv", pszFile);

   FILE *fout = fopen(pszFile, "wb");
   if (!fout)
      return FTPRC_WriteFailed+perr("cannot write to \"%s\"\n", pszFile);

   if (nFlags & (1UL << 31)) 
   {
      bool bPreserve = (nFlags & (((num)1) << 32)) ? 1 : 0;
      if (cs.debug)
         printf("> set attr=%s for %s\n", numtohex(nFlags), pszFile);
      Coi::writeAttrRaw(pszFile, (uint)nFlags, bPreserve, 1); // recv.file.raw
   }

   SFKMD5 md5;
 
   num nLen2 = 0;
   num nTellStep = 10;
   num nTellNext = 0;
   num nRemain = nMaxBytes;
   int nRead = 0;
   bool bCleanup = 0;

   // raw ftp uses variable length mode
   bool bvarmode = (nMaxBytes < 0);

   while (bvarmode || (nRemain > 0))
   {
      if (bGlblEscape)
         break;

      if (!bvarmode && (nLen2 >= nMaxBytes))
         break;
         
      int nBlockLen = sizeof(abBuf)-10;
      if (!bvarmode && (nBlockLen > nRemain))
         nBlockLen = nRemain;
         
      if ((nRead = recv(hSock, (char*)abBuf, nBlockLen, 0)) <= 0)
         break; // EOD

      if (bGlblEscape) {
         bCleanup = 1;
         iRC = FTPRC_Stopped;
         break;
      }

      if (    cs.diskspace > 0 && nDiskFree >= 0
          && (nDiskFree - (nLen2+nRead) < cs.diskspace)
         )
      {
         esys("fwrite", "out of disk space: %s\n", pszFile);
         bCleanup = 1;
         iRC = FTPRC_OutOfDiskSpace;
         break;
      }

      if ((int)myfwrite(abBuf, nRead, fout) != nRead) {
         esys("fwrite", "failed to write %s (disk full?)\n", pszFile);
         bCleanup = 1;
         iRC = FTPRC_WriteFailed;
         // but no special rc, continue with other files.
         break;
      }

      nLen2 += nRead;
      nRemain -= nRead;

      if (pmd5) md5.update(abBuf, nRead);

      info.setProgress(nMaxBytes/1000,nLen2/1000,"kb");
   }
   fclose(fout);

   if (pmd5) memcpy(pmd5, md5.digest(), 16);
   
   char szBuf1[100], szBuf2[100];

   if (nMaxBytes >= 0 && nLen2 != nMaxBytes)
      bCleanup = 1;
   
   if (bCleanup)
   {
      info.print("> incomplete file, cleaning up: %s (%s/%s)\n",
         pszFile,
         numtoa(nLen2,1,szBuf1), numtoa(nMaxBytes,1,szBuf2)
         );
      remove(pszFile);
   }
   else
   if (cs.quiet < 2)
      info.print("> %s received, %s bytes.       \n", pszFile, numtoa(nLen2));
 
   return iRC;
}

// INCLUDES ack send past file transfer
int getFileBySFT(SOCKET hSock, char *pszFile, int nSFTVer, 
   bool bQuiet=0, bool bBlockMode=0, num nDiskFree=-1)
{__
   // read variable-length header with meta info
   uchar abHead[512+10]; mclear(abHead);

   uint nMetaSize = 0;
   if (readLong(hSock, nMetaSize, "metalen")) return 9;
   if (nMetaSize > sizeof(abHead)-10)
      return 9+perr("unsupported SFT protocol version\n");
   if (receiveBlock(hSock, abHead, nMetaSize, "head")) return 9;

   // take from header what we need
   int ioff = 0;

   // meta 1: 8bytes_size [time flags]
   num nLen = 0, nTime = 0, nFlags = 0;
   if (readNum(abHead, ioff, nLen, "size")) return 9;

   if (nGlblTCPMaxSizeMB)
      if (nLen > (num)nGlblTCPMaxSizeMB * (num)1000000)
         return 9+perr("illegal length received (%s). use -maxsize to change limit.\n", numtoa(nLen));

   if (    cs.diskspace > 0 && nDiskFree >= 0
       && (nDiskFree - nLen < cs.diskspace)
      )
      return 9+perr("out of disk space: %s\n", pszFile);

   if (nSFTVer >= 102) {
      if (readNum(abHead, ioff, nTime , "time" )) return 9;
      if (readNum(abHead, ioff, nFlags, "flags")) return 9;
   }

   uchar abMD5Remote[20]; mclear(abMD5Remote);
   uchar abMD5Local[20];  mclear(abMD5Local);

   if (nSFTVer < 102) {
      // meta 2: 16 bytes md5 BEFORE content
      if (nSFTVer == 105) ioff += 20;
      memcpy(abMD5Remote, abHead+ioff, 16);
      ioff += 16;
   }

   // since SFT 105: write file attributes
   if (nSFTVer >= 105 && (nFlags & (1UL << 31)))
   {
      // server side preserve option
      if (cs.preserve)
         nFlags |= (((num)1) << 32);

      bool bPreserve = (nFlags & (((num)1) << 32)) ? 1 : 0;
      
      if (!bPreserve)
      {
         // never allow sender to clear "rw" for owner,
         // as this would block future re-transfers.
         nFlags |= (((num)1) << 8); // readable by owner
         nFlags |= (((num)1) << 7); // writeable by owner
      }
   }
   else
   {
      // make sure no unwanted attribs are set
      nFlags = 0;
   }

   info.setStatus("recv", pszFile);

   if (nSFTVer < 102) {
      // if this fails, return w/o ack, connection will be dropped.
      if (receiveFileRaw(hSock, pszFile, nLen, bQuiet, abMD5Local, nFlags, nDiskFree)) // sft
         return 9;
   }
   else
   if (!bBlockMode) {
      // sft 102 bulk transfer, receive all in one.
      // do NOT build checksum of received data, as we will
      // re-read the whole file anyway in verify case.
      if (receiveFileRaw(hSock, pszFile, nLen, bQuiet, 0, nFlags, nDiskFree)) // sft
         return 9;
      if (cs.verify)
         if (receiveBlock(hSock, abMD5Remote, 16, "md5"))
            return 9;
   }
   else
   {
      // sft 102 block transfer, we trigger the peer

      FILE *fout = fopen(pszFile, "wb");
      if (!fout) return 9+perr("cannot write to \"%s\"\n", pszFile);

      if (nFlags & (1UL << 31)) 
      {
         if (cs.debug)
            printf("> set attr=%s for %s\n", numtohex(nFlags), pszFile);
         bool bPreserve = (nFlags & (((num)1) << 32)) ? 1 : 0;
         Coi::writeAttrRaw(pszFile, (uint)nFlags, bPreserve, 1); // getfile.sft
      }
      
      // sft receive file

      // SFKMD5 md5;

      num nLen2      =    0;
      num nRemain    = nLen;
      num nMaxBytes  = nLen;
      num nTellStep  =   10;
      num nTellNext  =    0;
      int nRead      =    0;

      char szCmd[200];

      while (nRemain > 0)
      {
         // request next block from server
         int nBlockLen = sizeof(abBuf)-10;

         if (nBlockLen > nRemain)
            nBlockLen = nRemain;

         if (bdebug) printf("< sread %d, remain=%d\n",nBlockLen,(int)nRemain);

         sprintf(szCmd, "SREAD %d\n", nBlockLen);
         int nsent = send(hSock, szCmd, strlen(szCmd), 0);
         if (nsent != (int)strlen(szCmd)) {
            fclose(fout);
            remove(pszFile);
            return 9+perr("failed to send SREAD for \"%s\" %s\n", pszFile, netErrStr());
         }

         if (receiveBlock(hSock, abBuf, nBlockLen, "data")) {
            fclose(fout);
            remove(pszFile);
            return 9+perr("failed to fully receive \"%s\"\n", pszFile);
         }
         nRead = nBlockLen;

         if (    cs.diskspace > 0 && nDiskFree >= 0
             && (nDiskFree - (nLen2+nRead) < cs.diskspace)
            )
         {
            fclose(fout);
            remove(pszFile);
            return 9+perr("out of disk space: %s\n", pszFile);
         }

         nLen2 += nRead;
         nRemain -= nRead;

         if ((int)myfwrite(abBuf, nRead, fout) != nRead) {
            fclose(fout);
            remove(pszFile);
            return 9+perr("failed to fully write, probably disk full: \"%s\"\n", pszFile);
         }

         // if (cs.verify) md5.update(abBuf, nRead);
         
         info.setProgress(nMaxBytes/1000000,nLen2/1000000,"mb");
      }

      fclose(fout);

      if (cs.quiet < 2)
         printf("> %s received, %s bytes.       \n", pszFile, numtoa(nLen2));

      sprintf(szCmd, "SSUM\n");
      int nsent = send(hSock, szCmd, strlen(szCmd), 0);
      if (nsent != (int)strlen(szCmd))
         return 9+perr("failed to receive checksum, %s\n", netErrStr());

      if (cs.verify) {
         if (bdebug) printf("> wait for sum\n");
         if (receiveBlock(hSock, abMD5Remote, 16, "md5")) return 9;
      }
      
      if (bdebug) printf("send close\n");

      sprintf(szCmd, "SCLOSE\n");
      nsent = send(hSock, szCmd, strlen(szCmd), 0);
      if (nsent != (int)strlen(szCmd))
         return 9+perr("failed to send close, %s\n", netErrStr());

   }  // endif nSFTVer

   if (bdebug) printf("wait for skip\n");

   // expect and receive SKIP record of any length
   // FIX: v160: occasional transfer interrupt recv() may get only partial record
   //      recv(hSock, (char*)abBuf, sizeof(abBuf)-100, 0);
   abBuf[0] = '\0';
   readLineSub(hSock, (char*)abBuf, 0); // should be "SKIP 0\r\n"
   
   // since SFT 103, we check for the word "SKIP"
   if (strncmp((char*)abBuf, "SKIP", 4)) {
      send(hSock, (char*)"EE01\n\n", 4, 0);
      info.clear();
      perr("unexpected data received, transfer broken.\n");
      return 9;
   }

   if (nSFTVer >= 102 && !cs.noclone) 
   {
      // update file's timestamp and attributes
      FileStat ofs;
      if (ofs.readFrom(pszFile)) {
         pinf("cannot read file time: %s\n", pszFile);
      } else {
         if (nTime) {
            ofs.src.nMTime = nTime;
            ofs.src.nCTime = nTime;
            #ifdef _WIN32
            ofs.src.nHaveWFT = 0;
            #endif
         }
         ofs.writeTo(pszFile, __LINE__, 1); // 1: write just time
         // printf("time set: %d %s\n",(int)nTime,pszFile);
      }
   }

   // sender will wait now until we confirm successful transfer.

   if (cs.verify) 
   {
      // default: re-read the local file after write,
      // to be sure it was written completely.
      info.setStatus("verfy", pszFile);
      SFKMD5 md5;
      if (getFileMD5(pszFile, md5, 0, 1)) {
         send(hSock, (char*)"EE\n\n", 4, 0);
         return 9;
      }
      memcpy(abMD5Local, md5.digest(), 16);

      if (memcmp(abMD5Local, abMD5Remote, 16)) {
         send(hSock, (char*)"EE\n\n", 4, 0);
         info.clear();
         perr("md5 mismatch - transfered file corrupted.\n");
         if (cs.verbose) {
            printf("local: %02X %02X %02X %02X\n",abMD5Local[0],abMD5Local[1],abMD5Local[2],abMD5Local[3]);
            printf("remot: %02X %02X %02X %02X\n",abMD5Remote[0],abMD5Remote[1],abMD5Remote[2],abMD5Remote[3]);
         }
         pinf("check if the file is in use by another process.\n");
         return 9;
      }
   }

   info.clear();

   // send short confirmation, so client can safely close socket.
   int nSent = send(hSock, (char*)"OK\n\n", 4, 0);
   if (nSent != 4) return 9+perr("failed to send reply, %d, %s\n", nSent, netErrStr());

   return 0;
}

int ftpLogin(char *pszHost, uint nPort, SOCKET &hSock, bool &bSFT, int &nOutSFTVer, char *pszUser, char *pszPW)
{__
   prepareTCP();

   int nSFTVer  = 105;  // may be downgraded below
   int nServVer = 0;    // yet unknown
 
   struct hostent *pTarget;
   struct sockaddr_in sock;
   hSock = socket(AF_INET, SOCK_STREAM, 0);
   if (hSock == INVALID_SOCKET) return 9+perr("cannot create socket\n");

   if ((pTarget = sfkhostbyname(pszHost)) == NULL)
      return 9+perr("cannot get host, rc=%d\n", netErrno());

   memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
   sock.sin_family = AF_INET;
   sock.sin_port = htons((unsigned short)nPort);

   if ((connect(hSock, (struct sockaddr *)&sock, sizeof(sock))) == -1) {
      perr("cannot connect to %s:%u, %s\n", pszHost, nPort, netErrStr());
      return 9;
   }

   char szBuf1[200];

   // SFT: first handle FTP handshake
   if (readLine(hSock)) return 9; // 220
   char *psz1 = strstr(szLineBuf, ". sft ");
   if (psz1) {
      nServVer = atol(psz1+6);
      if (nServVer >= 100) {
         bSFT = 1;
         if (!cs.quiet)
            printf("> server speaks sft %d.\n", nServVer);
         nOutSFTVer = nServVer;
      } else {
         printf("> unexpected sft info \"%s\"\n", psz1);
      }
   }

   snprintf(szBuf1, sizeof(szBuf1)-10, "USER %s", pszUser);
   if (sendLine(hSock, szBuf1)) return 9;
   if (readLine(hSock)) return 9; // 331

   if (bSFT) {
      // login at sfk ftpserv: password after '@'
      if (!pszPW) pszPW = str("");
      snprintf(szBuf1, sizeof(szBuf1)-10, "PASS sft%d@%s", nSFTVer, pszPW);
      if (sendLine(hSock, szBuf1)) return 9;
   } else {
      // login at any ftp server: either password or dummy info
      if (pszPW)
         snprintf(szBuf1, sizeof(szBuf1)-10, "PASS %s", pszPW);
      else
         snprintf(szBuf1, sizeof(szBuf1)-10, "PASS sft%d@", nSFTVer);
      if (sendLine(hSock, szBuf1)) return 9;
   }
   if (readLine(hSock)) return 9; // 230 login done
   if (strBegins(szLineBuf, "500 ")) return 9;

   if (sendLine(hSock, "TYPE I")) return 9;
   if (readLine(hSock)) return 9; // 200 OK
   
   if (cs.verify && (nServVer >= 103))
   {
      // have to enable verify explicitely with new server.
      // it was default with older servers.
      if (sendLine(hSock, "SCHK 1")) return 9;
      if (readLine(hSock)) return 9; // 200 OK
   }

   return 0;
}

int connectSocket(char *pszHost, uint nPort, struct sockaddr_in &ClntAdr, SOCKET &hSock, cchar *pszInfo);

int setPassive(SOCKET &hSock, struct sockaddr_in &SoAdr, SOCKET &hData)
{
   if (hData != INVALID_SOCKET)
      return 0; // already done, reuse hData

   if (sendLine(hSock, "PASV")) return 9;
   if (readLine(hSock)) return 9;
   // 227 Entering Passive Mode (127,0,0,1,117,246)
   char *psz = strchr(szLineBuf, '(');
   if (!psz) return 9;
   psz++; 
   uchar n[6];
   for (int i=0; i<6; i++) {
      n[i] = (uchar)atol(psz);
      psz = strchr(psz+1, ',');
      if (psz) psz++; else break;
   }
   char szIP[50];
   sprintf(szIP, "%d.%d.%d.%d",n[0],n[1],n[2],n[3]);
   uint nPort = (((uint)n[4])<<8)|((uint)n[5]);
   if (connectSocket(szIP, nPort, SoAdr, hData, "pasv data")) return 9;

   return 0;
}

bool canSkipFile(SOCKET hSock, char *pszFileName, num ndsttime, bool bput)
{
   bool bskip = 0;

   // check if target file at server has different time.
   // so far works only with SFT, as normal ftp servers
   // may return UTC time which is of no help here.
   sprintf(szLineBuf2, "MDTM %s", pszFileName);
   if (sendLine(hSock, szLineBuf2)) return 0;
   if (readLine(hSock)) return 0; // 213 TimeString, 500 Error
   // may return: 550 no such file
   if (!strncmp(szLineBuf, "213 ", 4)) {
      char *ptime = szLineBuf+4;  // 20060604111037
      num   nfartime = 0;
      removeCRLF(ptime);
      if (!timeFromString(ptime, nfartime)) {
         num nowntime = ndsttime;
         num ndiff = bput ? (nfartime - nowntime) : (nowntime - nfartime);
         if (cs.verbose)
            printf("time: local=%u far=%u diff=%d\n",(uint)nowntime,(uint)nfartime,(int)ndiff);
         if (ndiff >= 0)
            bskip = 1;
      }
   }
   return bskip;
}

int ftpClient(char *pszHost, uint nPort, char *pszCmd, char *pszUser, char *pszAuthPW, bool bChained)
{__
   SOCKET hSock = 0;
   bool bSFT = 0;
   int nSFTVer = 0;
   if (ftpLogin(pszHost, nPort, hSock, bSFT, nSFTVer, pszUser, pszAuthPW)) return 9;

   // select features dependent on protocol version
   if (!cs.verify && bSFT && (nSFTVer < 103)) 
   {
      // old SFT server, MUST use md5 checksums
      if (cs.verbose)
         pinf("Old SFT server, verify enforced.\n");
      cs.verify = 1;
   }

   struct sockaddr_in DataAdr;
   SOCKET hData = INVALID_SOCKET;
   bool   bfail = 0;

   for (bool bLoop=1; bLoop && !userInterrupt();)
   {
      num tstart = getCurrentTime();
      
      if (pszCmd) {
         strcpy(szLineBuf, pszCmd);
         bLoop = 0;
      } else {
         printf("> ");
         fflush(stdout);
         if (!(fgets(szLineBuf, sizeof(szLineBuf)-10, stdin)))
            break;
         removeCRLF(szLineBuf);
         // parse interactive options, MUST be at line end.
         cs.yes = 0;
         int ilen = strlen(szLineBuf);
         if (ilen > 5 && !strcmp(szLineBuf+ilen-5, " -yes")) {
            szLineBuf[ilen-5] = '\0';
            cs.yes = 1;
         }
         // strip possible trailing spaces
         myrtrim(szLineBuf);
      }

      if (   !strcmp(szLineBuf, "?")
          || !strcmp(szLineBuf, "h")
          || !strcmp(szLineBuf, "help")
         )
      {
         printf("client commands:\n");
         printf("   cd lcd dir !dir put get mput mget bye\n");
         printf("   run (with sfk sft server)\n");
         printf("\n");
         printf("server commands:\n");
         sprintf(szLineBuf2, "HELP");
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK
      }
      else
      if (!strcmp(szLineBuf, "cd")) {
         // sfk ftp client: auto pwd on "cd"
         sprintf(szLineBuf2, "PWD");
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK
      }
      else
      if (!strncmp(szLineBuf, "cd ", 3)) {
         char *pszDir = strdup(szLineBuf+3);
         CharAutoDel odel(pszDir);
         sprintf(szLineBuf2, "CWD %s", pszDir);
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK
      }
      else
      if (!strncmp(szLineBuf, "lcd ", 4)) {
         char *pszDir = strdup(szLineBuf+4);
         CharAutoDel odel(pszDir);
         if (chdir(pszDir))
            printf("cannot cd to %s\n", pszDir);
         if (!getcwd(szLineBuf2,sizeof(szLineBuf2)-10))
            szLineBuf2[0]='\0';
         printf("%s\n", szLineBuf2);
      }
      else
      if (!strncmp(szLineBuf, "ccd ", 4)) {
         char *pszDir = strdup(szLineBuf+4);
         CharAutoDel odel(pszDir);
         // check if local dir exists
         if (!isDir(pszDir)) {
            printf("no such local dir: %s\n", pszDir);
            continue;
         }
         // try remote cd
         sprintf(szLineBuf2, "CWD %s", pszDir);
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK
         if (szLineBuf[0] != '2') {
            printf("ccd stopped, no such remote dir: %s\n", pszDir);
            continue;
         }
         // remote cd ok, also do local
         if (chdir(pszDir))
            printf("cannot cd local to %s\n", pszDir);
         if (!getcwd(szLineBuf2,sizeof(szLineBuf2)-10))
            szLineBuf2[0]='\0';
         printf("%s\n", szLineBuf2);
      }
      else
      if (strBegins(szLineBuf, "dir")) {
         if (!bSFT) {
            // szLineBuf is reused in setPassive
            snprintf(szLineBuf2, sizeof(szLineBuf2)-10,
               "LIST%s", szLineBuf+3);
            // either create pasv connection or reuse existing
            if (setPassive(hSock, DataAdr, hData)) break;
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Listing
            while (readLine(hData, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
            if (readLine(hSock)) break; // 226 Closing
            closesocket(hData); hData = INVALID_SOCKET;
         } else {
            snprintf(szLineBuf2, sizeof(szLineBuf2)-10,
               "SLST%s", szLineBuf+3);
            if (sendLine(hSock, szLineBuf2)) break;
            while (readLine(hSock, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
         }
      }
      else
      if (strBegins(szLineBuf, "ls")) {
         if (!bSFT) {
            // szLineBuf is reused in setPassive
            snprintf(szLineBuf2, sizeof(szLineBuf2)-10,
               "NLST%s", szLineBuf+2);
            // either create pasv connection or reuse existing
            if (setPassive(hSock, DataAdr, hData)) break;
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Listing
            while (readLine(hData, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
            if (readLine(hSock)) break; // 226 Closing
            closesocket(hData); hData = INVALID_SOCKET;
         } else {
            snprintf(szLineBuf2, sizeof(szLineBuf2)-10,
               "NLST%s", szLineBuf+2);
            if (sendLine(hSock, szLineBuf2)) break;
            while (readLine(hSock, szLineBuf, 4) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
         }
      }
      else
      if (!strncmp(szLineBuf, "!", 1)) {
         // run local command
         int iRC = system(szLineBuf+1);
         if (iRC)
            printf("RC: %d\n", iRC);
      }
      else
      if (!strncmp(szLineBuf, "run ", 4)) {
         char *pszCmd = strdup(szLineBuf+4);
         CharAutoDel odel(pszCmd);
         // try to run remote command. requires -run option set at server.
         if (!bSFT) {
            printf("cannot run, remote server speaks no SFT.\n");
         } else {
            sprintf(szLineBuf2, "SRUN %s", pszCmd);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock, 0, 8)) break; // 200 OK, 500 Error
            // keep socket open.
         }
      }
      else
      if (strBegins(szLineBuf, "put ")) 
      {
         DisableCtrlCProcessExit(); // ftp.client

         char *pszFileName = strdup(szLineBuf+4);
         CharAutoDel odel1(pszFileName);

         Coi *pcoi = new Coi(localPath(pszFileName), 0);
         CoiAutoDelete odel2(pcoi, 0); // no decref

         if (pcoi->getSize() < 0) { // FIX 1654: missing check on put
            perr("cannot read %s\n", pcoi->name());
            if (!cs.force) break;
         }
         else
         if (!bSFT) {
            if (setPassive(hSock, DataAdr, hData)) break;
            sprintf(szLineBuf2, "STOR %s", remoteStandardPath(pszFileName));
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Receiving
            if (sendFileRaw(hData, localPath(pszFileName), 1)) break;
            closesocket(hData); hData = INVALID_SOCKET;         
            if (readLine(hSock)) break; // 226 Closing
         } else {
            sprintf(szLineBuf2, "SPUT %s", pszFileName); // put
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 200 OK, 500 Error
            if (!strncmp(szLineBuf, "200", 3))
               if (putFileBySFT(hSock, pcoi, nSFTVer))
                  break;
            // ack receive was done above. keep socket open.
         }
      }
      else
      if (   !bChained 
          && (strBegins(szLineBuf, "mput") || strBegins(szLineBuf, "cput"))
         )
      {
         DisableCtrlCProcessExit(); // ftp.client

         // direct multi file put (not chained)
         char szParmBuf[300]; mclear(szParmBuf);

         bool bupdate = strBegins(szLineBuf, "cput") ? 1 : 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;

         char *pparms = szLineBuf+strlen("mput");
         skipWhite(&pparms);
         strcopy(szParmBuf, pparms);
         cs.sim = !cs.yes;

         char *pszMask = szParmBuf;
         if (!*pszMask) {
            perr("missing mask. supply a name fragment or just \"*\"\n");
            continue;
         }
         if (cs.debug)
            printf("mask: \"%s\"\n", pszMask);

         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         int lFiles=0, lDirs=0;
         num nBytes=0;
         glblFTPLocList.resetEntries();
         walkAllTrees(eFunc_FTPLocList, lFiles, lDirs, nBytes);

         int nfiles = glblFTPLocList.numberOfEntries();

         // now ALL local files are listed in glblFTPLocList
         int ifile=0, nSent=0, nSkipped=0, nFailed=0;
         for (ifile=0; ifile<nfiles; ifile++) 
         {
            char *pszFile = glblFTPLocList.getEntry(ifile, __LINE__);
            
            // normalize name, temporary for comparison
            if (normalizePath(pszFile, szLineBuf2, sizeof(szLineBuf2)))
               continue;

            if (isWildStr(pszMask) || matchesNormName(szLineBuf2, pszMask))
            {
               Coi *pcoi = new Coi(pszFile, 0);
               CoiAutoDelete odel(pcoi, 0); // no decref

               if (pcoi->getSize() < 0) { // FIX 1654: missing check on mput.nochain
                  perr("cannot read %s\n", pcoi->name());
                  if (!cs.force) break;
                  nFailed++;
                  continue;
               }

               num ndsttime = getFileTime(pszFile);

               if (   bupdate && (ndsttime > 0)
                   && canSkipFile(hSock, pszFile, ndsttime, 1))
               {
                  if (cs.verbose)
                     printf("skip: %s - unchanged. (or use -all)\n", pszFile);
                  nSkipped++;
                  continue;
               }

               if (cs.sim) {
                  if (!cs.quiet)
                     printf("< %s\n", pszFile);
                  nSent++;
                  continue; 
               }

               do {
                  bfail = 1;
                  if (!bSFT) {
                     if (setPassive(hSock, DataAdr, hData)) break;
                     sprintf(szLineBuf2, "STOR %s", remoteStandardPath(pszFile));
                     if (sendLine(hSock, szLineBuf2)) break;
                     if (readLine(hSock)) break; // 150 Receiving
                     if (sendFileRaw(hData, localPath(pszFile), 1)) break;
                     closesocket(hData); hData = INVALID_SOCKET;
                     if (readLine(hSock)) break; // 226 Closing
                     nSent++;
                     bfail = 0;
                  } else {
                     sprintf(szLineBuf2, "SPUT %s", pszFile); // mput.nochain
                     if (sendLine(hSock, szLineBuf2, 1)) break;
                     if (readLine(hSock, szLineBuf , 2)) break; // 200 OK, 500 Error
                     if (strncmp(szLineBuf, "200", 3)) break;
                     if (putFileBySFT(hSock, pcoi, nSFTVer, 1)) break;
                     nSent++;
                     bfail = 0;
                     // ack receive was done above. keep socket open.
                  }
               } while (0);
               if (hData != INVALID_SOCKET)
                  { closesocket(hData); hData = INVALID_SOCKET; }
               if (bfail) {
                  perr("cannot send: %s", pszFile);
                  nFailed++;
                  if (!cs.force) break;
               }
            } else {
               nSkipped++;
            }
         }

         int nelaps = (int)(getCurrentTime() - tstart)/1000;

         if (nFailed > 0) {
            printf("%d files of %d %ssent, %d failed, %d sec.\n", nSent, nfiles, cs.sim?"would be ":"", nFailed, nelaps);
            if (!cs.force)
               pinf("add option -force to continue transfer after errors.\n");
         } else {
            printf("%d files of %d %ssent, %d sec.\n", nSent, nfiles, cs.sim?"would be ":"", nelaps);
         }

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");

         if (ifile < glblFTPLocList.numberOfEntries())
            bLoop = 0; // fatal, server probably closed connection
      }
      else
      if (    bChained
          && (strBegins(szLineBuf, "mput") || strBegins(szLineBuf, "cput"))
         )
      {
         DisableCtrlCProcessExit(); // ftp.client

         // chained multi file put (after select)

         // with SFT, update is default.
         // with FTP, update isn't supported.
         // simulate is always default.
         
         bool bupdate = strBegins(szLineBuf, "cput") ? 1 : 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;

         char *pparms = szLineBuf+strlen("mput");
         skipWhite(&pparms);
         cs.sim = !cs.yes;

         int nfiles = chain.numberOfInFiles();

         if (nfiles < 1)
            { printf("ftp: have no filenames from previous commands.\n"); break; }

         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         int ifile=0, nSent=0, nSkipped=0, nFailed=0;
         for (ifile=0; ifile<nfiles; ifile++) 
         {
            Coi *pcoi = chain.getFile(ifile);
            if (!pcoi) return 9+perr("int. #204292351\n");

            if (pcoi->getSize() < 0) { // FIX 1654: missing check
               perr("cannot read %s\n", pcoi->name());
               nFailed++;
               if (!cs.force) break;
               continue;
            }

            char *pszFileName = pcoi->name();
            num ndsttime = pcoi->getTime();

            if (   bupdate && bSFT && (ndsttime > 0)
                && canSkipFile(hSock, pszFileName, ndsttime, 1))
            {
               if (cs.verbose)
                  printf("skip: %s - unchanged. (or use -all)\n", pszFileName);
               nSkipped++;
               continue;
            }

            if (cs.sim) {
               if (!cs.quiet)
                  printf("< %s\n", pszFileName);
               nSent++;
               continue; 
            }

            do {
               bfail = 1;
               if (!bSFT) {
                  if (setPassive(hSock, DataAdr, hData)) break;
                  sprintf(szLineBuf2, "STOR %s", remoteStandardPath(pszFileName));
                  if (sendLine(hSock, szLineBuf2)) break;
                  if (readLine(hSock)) break; // 150 Receiving
                  if (sendFileRaw(hData, localPath(pszFileName), 1)) break;
                  closesocket(hData); hData = INVALID_SOCKET;         
                  if (readLine(hSock)) break; // 226 Closing
                  nSent++;
                  bfail = 0;
               } else {
                  // FIX 1654: redundant pcoi for file access
                  sprintf(szLineBuf2, "SPUT %s", pszFileName); // mput.chain
                  if (sendLine(hSock, szLineBuf2)) break;
                  if (readLine(hSock)) break; // 200 OK, 500 Error
                  if (strncmp(szLineBuf, "200", 3)) break;
                  if (putFileBySFT(hSock, pcoi, nSFTVer)) break;
                  nSent++;
                  bfail = 0;
                  // ack receive was done above. keep socket open.
               }
            } while (0);
            if (hData != INVALID_SOCKET)
               { closesocket(hData); hData = INVALID_SOCKET; }
            if (bfail) {
               perr("cannot send: %s", pszFileName);
               nFailed++;
               if (!cs.force) break;
            }
         }  // endfor files

         int nelaps = (int)(getCurrentTime() - tstart)/1000;

         if (nFailed > 0) {
            printf("%d files of %d %ssent, %d failed, %d sec.\n", nSent, nfiles, cs.sim?"would be ":"", nFailed, nelaps);
            if (!cs.force)
               pinf("add option -force to continue transfer after errors.\n");
         } else {
            printf("%d files of %d %ssent, %d sec.\n", nSent, nfiles, cs.sim?"would be ":"", nelaps);
         }

         if (cs.sim && !cs.nohead) {
            printx("$[add -yes to execute.]\n");
         }

         if (ifile < nfiles)
            break;
      }
      else
      if (!strncmp(szLineBuf, "get ", 4)) 
      {
         DisableCtrlCProcessExit(); // ftp.client

         char *pszFileName = strdup(szLineBuf+4);
         CharAutoDel odel(pszFileName);
         if (!bSFT) {
            if (setPassive(hSock, DataAdr, hData)) break;
            sprintf(szLineBuf2, "RETR %s", pszFileName);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 150 Sending
            if (strBegins(szLineBuf, "150")) {
               createOutDirTree(localPath(pszFileName));
               if (receiveFileRaw(hData, localPath(pszFileName), -1, 0,0,0)) // client
                  break;
               if (readLine(hSock)) break; // 226 Closing
            } else {
               if (!cs.verbose) printf("%s", szLineBuf);
            }
            closesocket(hData); hData = INVALID_SOCKET;         
         } else {
            sprintf(szLineBuf2, "SGET %s", pszFileName);
            if (sendLine(hSock, szLineBuf2)) break;
            if (readLine(hSock)) break; // 200 OK
            if (!strncmp(szLineBuf, "200", 3)) {
               createOutDirTree(localPath(pszFileName));
               if (getFileBySFT(hSock, localPath(pszFileName), nSFTVer))
                  break;
            }
            // ack send was done above. keep socket open.
         }
      }
      else
      if (   !bChained 
          && (strBegins(szLineBuf, "mget") || strBegins(szLineBuf, "cget"))
         )
      {
         DisableCtrlCProcessExit(); // ftp.client

         // direct multi file get (not chained)
         char szParmBuf[300]; mclear(szParmBuf);

         bool bupdate = strBegins(szLineBuf, "cget") ? 1 : 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;

         char *pparms = szLineBuf+strlen("mget");
         skipWhite(&pparms);
         strcopy(szParmBuf, pparms);
         cs.sim = !cs.yes;

         char *pszMask = szParmBuf;
         if (!*pszMask) {
            perr("missing mask. supply a name fragment (without *), or just \"*\"\n");
            continue;
         }
         if (cs.debug)
            printf("mask: \"%s\"\n", pszMask);

         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         glblFTPRemList.resetEntries();
         if (!bSFT) {
            if (setPassive(hSock, DataAdr, hData)) break;
            if (sendLine(hSock, "LIST")) break;
            if (readLine(hSock)) break; // 150 Listing
            while (readLine(hData, szLineBuf, 1) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
            if (readLine(hSock)) break; // 226 Closing
            closesocket(hData); hData = INVALID_SOCKET;
         } else {
            sendLine(hSock, "SLST");
            while (readLine(hSock, szLineBuf, 1) == 0)
               if (!strncmp(szLineBuf, "226 ", 4))
                  break;
         }

         if (cs.debug)
            printf("> received %d filenames\n",glblFTPRemList.numberOfEntries());

         char *apcol[20];
         memset(apcol, 0, sizeof(apcol));

         // now ALL remote files are listed in glblFTPRemList
         // in a RAW format:
         // -rw-rw-rw- 1 ftp ftp        30353 Sep 08 13:47   readme.txt
         //    0       1  2   3          4    5   6   7      8
         // -rw-rw-rw- 1 ftp ftp        30353 20061231235959 readme.txt
         //    0       1  2   3          4    5              6
         // drwxr-xr-x 1 ftp ftp              0 Apr 06 09:23 thedir01
         int i=0, nRecv=0, nSkipped=0, nFailed=0, nskip=0;
         for (; i<glblFTPRemList.numberOfEntries(); i++) 
         {
            char *pszFileRaw = glblFTPRemList.getEntry(i, __LINE__);

            // parse raw line
            int ncol = 0;
            strcopy(szRefNameBuf, pszFileRaw);
            char *psz1 = szRefNameBuf;
            while (ncol < 15) {
               // store column start
               apcol[ncol++] = psz1;
               // find end of column
               skipToWhite(&psz1);
               if (!*psz1) break;
               *psz1++ = '\0';
               // find start of next column
               skipWhite(&psz1);
               if (!*psz1) break;
            }

            char *pattr = apcol[0];
            
            // skip directories
            if (pattr && (pattr[0] == 'd'))
                 continue;

            char *pszMonTS = apcol[5]; // month or timestamp
            bool bHaveFlatTime = 0;
            if (pszMonTS && isdigit(*pszMonTS))
                 bHaveFlatTime = 1;

            int iName = 8;
            if (bHaveFlatTime) {
               if (ncol < 7)
                  {  pwarn("wrong format: %s - skipping\n", pszFileRaw); continue; }
               iName = 6;
            }
            else
            if (ncol < 9)
               {  pwarn("wrong format: %s - skipping\n", pszFileRaw); continue; }

            // always take filename from original buffer,
            // blanks may have been replaced by zeros in RefNameBuf.
            char *pszFile = pszFileRaw + (apcol[iName]-szRefNameBuf);
            char *pszSize = apcol[4];

            num nFileTime = 0;

            if (bGlblFTPSetAttribs) {
               if (bHaveFlatTime) {
                  timeFromString(pszMonTS, nFileTime);
               } else {
                  if (apcol[5] && apcol[6] && apcol[7]) {
                     sprintf(szLineBuf, "%s %s %s",apcol[5],apcol[6],apcol[7]);
                     timeFromString(szLineBuf, nFileTime);
                  }
               }
            }

            num nFileSize = atonum(pszSize);
            if (nFileSize <= 0) {
               printf("] skip, size=%s: %s\n", pszSize, pszFile);
               continue;
            }

            // normalize name, temporary for comparison
            if (normalizePath(pszFile, szLineBuf2, sizeof(szLineBuf2)))
               continue;

            if (isWildStr(pszMask) || matchesNormName(szLineBuf2, pszMask))
            {
               num ndsttime = getFileTime(pszFile);

               if (   bupdate && (ndsttime > 0)
                   && canSkipFile(hSock, pszFile, ndsttime, 0))
               {
                  if (cs.verbose)
                     printf("skip: %s - unchanged. (or use -all)\n", pszFile);
                  nskip++;
                  continue;
               }
               if (cs.sim) {
                  if (!cs.quiet)
                     printf("> %s, %s bytes.\n", pszFile, numtoa(nFileSize));
                  nRecv++;
                  continue; 
               }

               if (!isWriteable(pszFile)) {
                  perr("cannot write: %s\n", pszFile);
                  nFailed++;
                  continue;
               }

               if (!bSFT) {
                  if (setPassive(hSock, DataAdr, hData)) break;
                  sprintf(szLineBuf2, "RETR %s", pszFile);
                  if (sendLine(hSock, szLineBuf2)) break;
                  if (readLine(hSock)) break; // 150 Sending
                  createOutDirTree(localPath(pszFile));
                  if (receiveFileRaw(hData, localPath(pszFile), -1, 0,0,0)) // client
                     break;
                  if (readLine(hSock)) break; // 226 Closing
                  closesocket(hData); hData = INVALID_SOCKET;         
               } else {
                  sprintf(szLineBuf2, "SGET %s", pszFile);
                  if (sendLine(hSock, szLineBuf2, 1)) break;
                  if (readLine(hSock, szLineBuf , 2)) break; // 200 OK
                  if (strncmp(szLineBuf, "200", 3)) {
                     printf("\n");
                     perr("%s", szLineBuf); // no LF. readLine was QUIET
                  } else {
                     if (getFileBySFT(hSock, pszFile, nSFTVer, 1))
                        break;
                     if (bGlblFTPSetAttribs) {
                        // set the file time
                        FileStat ofs;
                        ofs.readFrom(pszFile);
                        ofs.src.nMTime = nFileTime;
                        #ifdef _WIN32
                        ofs.src.nHaveWFT = 0; // no windows filetime
                        #endif
                        int lRCT = ofs.writeTo(pszFile, __LINE__);
                        printf("] filetime set: %s, %d\n", timeAsString(nFileTime), lRCT);
                     }
                  }
               }

               // ack receive was done above. keep socket open.
               nRecv++;
            } else {
               nSkipped++;
            }
         }

         int nelaps = (int)(getCurrentTime() - tstart)/1000;

         if (i < glblFTPRemList.numberOfEntries())
            bLoop = 0; // fatal, server probably closed connection
         if (nFailed > 0)
            printf("%d files received, %d failed, %d sec.\n", nRecv, nFailed, nelaps);
         else
            printf("%d files %sreceived, %d sec.\n", nRecv, cs.sim?"would be ":"", nelaps);

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");
      }
      else
      if (   bChained
          && (strBegins(szLineBuf, "mget") || strBegins(szLineBuf, "cget"))
         )
      {
         DisableCtrlCProcessExit(); // ftp.client

         // chained multi file get (after select)

         // with SFT, update is default.
         // with FTP, update isn't supported.
         // simulate is always default.
         char szParmBuf[300]; mclear(szParmBuf);
         char szDstBuf[400];  mclear(szDstBuf);

         bool bupdate = strBegins(szLineBuf, "cget") ? 1 : 0;

         if (cs.ftpupdate) bupdate = 1;
         if (cs.ftpall   ) bupdate = 0;

         char *pparms = szLineBuf+strlen("mget");
         skipWhite(&pparms);
         strcopy(szParmBuf, pparms);
         cs.sim = !cs.yes;

         if (!szParmBuf[0]) 
         {
            // SFK 169: simply use '.' as target
            strcpy(szParmBuf, ".");
         }

         int nfiles = chain.numberOfInFiles();
         int ifile  = 0;

         if (nfiles < 1)
            { printf("ftp: have no filenames from previous commands.\n"); break; }
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         int nskip = 0;
         int ndone = 0;
         for (ifile=0; ifile<nfiles; ifile++) 
         {
            // the reference coi, e.g. mydir/foo.txt
            Coi *pcoi = chain.getFile(ifile);
            if (!pcoi) return 9+perr("int. #204292352\n");

            char *pszFileName = pcoi->name();
            char *pszLocFile  = localPath(pszFileName);
            snprintf(szDstBuf, sizeof(szDstBuf), "%s%c%s", szParmBuf, glblPathChar, pszLocFile);

            // the destination coi, e.g. dstdir/mydir/foo.txt
            // this coi's time is checked against the remote time.
            Coi *pcoidst = new Coi(szDstBuf, 0);
            CoiAutoDelete odel(pcoidst, 0); // no decref
            num  ndsttime = pcoidst->getTime(); // if any

            if (   bupdate && bSFT && (ndsttime > 0)
                && canSkipFile(hSock, pszFileName, ndsttime, 0))
            {
               if (cs.verbose)
                  printf("skip: %s - unchanged. (or use -all)\n", pszFileName);
               nskip++;
               continue;
            }
            if (cs.sim) {
               if (!cs.quiet)
                  printf("> %s\n", szDstBuf);
               ndone++;
               continue; 
            }

            if (!bSFT) {
               if (setPassive(hSock, DataAdr, hData)) break;
               sprintf(szLineBuf2, "RETR %s", pszFileName);
               if (sendLine(hSock, szLineBuf2)) break;
               if (readLine(hSock)) break; // 150 Sending
               createOutDirTree(szDstBuf);
               if (receiveFileRaw(hData, szDstBuf, -1, 0,0,0)) // client
                  break;
               if (readLine(hSock)) break; // 226 Closing
               closesocket(hData); hData = INVALID_SOCKET;
               ndone++;
            } else {
               sprintf(szLineBuf2, "SGET %s", pszFileName);
               if (sendLine(hSock, szLineBuf2)) break;
               if (readLine(hSock)) break; // 200 OK
               if (!strncmp(szLineBuf, "200", 3)) {
                  createOutDirTree(szDstBuf);
                  if (getFileBySFT(hSock, szDstBuf, nSFTVer))
                     break;
                  ndone++;
               }
               // ack send was done above. keep socket open.
            }
         }
         
         int nelaps = (int)(getCurrentTime() - tstart)/1000;
         
         if (!cs.quiet) {
            if (cs.sim) {
               if (bupdate)
                  printf("would receive %d files, skip %d unchanged.\n", ndone, nskip);
               else
                  printf("would receive %d files.\n", ndone);
            }
            else
            if (nskip)
               printf("%d files received, %d unchanged skipped, %d sec.\n", ndone, nskip, nelaps);
            else
               printf("%d files received, %d sec.\n", ndone, nelaps);
         }
         if (cs.sim && !cs.nohead) {
            printx("$[add -yes to execute.]\n");
         }
         if (ifile<nfiles)
            break;
      }
      else
      if (!strcmp(szLineBuf, "bye")) {
         break;
      }
      else 
      {
         // any other command: apply simple alias remapping
         static const char *pszmap[] = {
            "del ", "DELE ",
            "mkdir ", "MKD ",
            "md ", "MKD ",
            "rmdir ", "RMD ",
            0, 0 // eot
         };
         strcopy(szLineBuf2, szLineBuf);
         for (int i=0; pszmap[i]; i+=2) {
            if (stribeg(szLineBuf,pszmap[i+0])) {
               int ilen=strlen(pszmap[i+0]);
               snprintf(szLineBuf2,sizeof(szLineBuf2)-10,
                  "%s%s", pszmap[i+1], szLineBuf+ilen);
               break;
            }
         }
         if (sendLine(hSock, szLineBuf2)) break;
         if (readLine(hSock, 0, 8)) break; // 200 OK, 500 Error
      }
   }

   if (!pszCmd)
      printf("connection closed.\n");

   closesocket(hSock);

   #ifdef _WIN32
   WSACleanup();
   #endif

   return 0;
}

int makeServerSocket(
   uint  &nNewPort,                // i/o parm
   struct sockaddr_in &ServerAdr,   // i/o parm
   SOCKET &hServSock,
   cchar  *pszInfo,
   uint  nAltPort=0                // e.g. 2121 for ftp
   )
{
   uint nPort = nNewPort;

   socklen_t nSockAdrSize = sizeof(sockaddr_in);

   ServerAdr.sin_family      = AF_INET;
   ServerAdr.sin_addr.s_addr = htonl(INADDR_ANY);
   ServerAdr.sin_port        = htons((unsigned short)nPort);

   hServSock = socket(AF_INET, SOCK_STREAM, 0);
   if (hServSock == INVALID_SOCKET)
      return 9+perr("cannot create %s (%u)\n", pszInfo, nPort);

   int nOnVal = 1;
   setsockopt(hServSock, SOL_SOCKET, SO_REUSEADDR, (char *)&nOnVal, sizeof(nOnVal));

   int nrc = bind(hServSock, (struct sockaddr *)&ServerAdr, sizeof(sockaddr_in));

   if (nrc == SOCKET_ERROR && nAltPort > 0)
   {
      pinf("cannot bind on port %u, using alternative port %d.\n", nPort, nAltPort);
      nPort = nAltPort;
      ServerAdr.sin_port = htons((unsigned short)nPort);
      nrc = bind(hServSock, (struct sockaddr *)&ServerAdr, sizeof(sockaddr_in));
   }

   if (nrc == SOCKET_ERROR)
   {
      perr("cannot bind %s (%u)\n", pszInfo, nPort);
      fprintf(stderr, "info : maybe a different app is running, or firewall blocks access.\n");
      fprintf(stderr, "info : you may retry with a different port, e.g. -port=30199.\n");
      return 9; 
   }

   int nerr = getsockname(hServSock, (struct sockaddr *)&ServerAdr, &nSockAdrSize);
   if (nerr == SOCKET_ERROR)
      return 9+perr("getsockname failed, %d\n", netErrno());

   bool bTell = (nPort == 0);
   nPort    = (uint)ntohs(ServerAdr.sin_port);
   nNewPort = nPort;
   if (bTell)
      printf("- local port %u (%u, %u)\n", nPort, (nPort>>8), nPort&0xFF);

   // make accept non-blocking:
   setBlocking(hServSock, 0);

   if (listen(hServSock, 4) == SOCKET_ERROR)
      return 9+perr("cannot listen on %s (%u)\n", pszInfo, nPort);

   return 0;
}

int connectSocket(char *pszHost, uint nPort, struct sockaddr_in &ClntAdr, SOCKET &hSock, cchar *pszInfo)
{
   hSock = socket(AF_INET, SOCK_STREAM, 0);
   if (hSock == INVALID_SOCKET)
      return 9+perr("cannot create %s\n", pszInfo);

   struct hostent *pTarget = 0;
   if ((pTarget = sfkhostbyname(pszHost)) == NULL)
      return 9+perr("cannot get host for %s\n", pszInfo);

   memcpy(&ClntAdr.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
   ClntAdr.sin_family = AF_INET;
   ClntAdr.sin_port = htons((unsigned short)nPort);
   if (cs.verbose)
      printf("< connect to %s:%u\n", pszHost, nPort);
   if ((connect(hSock, (struct sockaddr *)&ClntAdr, sizeof(struct sockaddr_in))) == -1)
      return 9+perr("cannot establish connection for %s\n", pszInfo);

   return 0;
}

// internal, some knx support
int makeKnxReq(uchar cmd[], int ga1, int ga2, int ga3, uint nlen, uchar data[])
{
   uchar nKnxDA0=1, nKnxDA1=1, nKnxDA2=199;

   uint nbytelen = 0;

   switch (nlen) {
      case  1: nbytelen =  0; break;
      case  8: nbytelen =  1; break;
      case 14: nbytelen = 14; break;
   }

   cmd[0] = 6;
   cmd[1] = 0x10;
   cmd[2] = 0x05;
   cmd[3] = 0x30;
   cmd[4] = 0x00;
   cmd[5] = 11+6+nbytelen;

   uchar *pcemi = &cmd[6];

   pcemi[0] = 0x29; // L_DATA_CON
   pcemi[1] = 0x00;
   pcemi[2] = 0x8c;
   pcemi[3] = 0xbc; // normal prio, no repeat
   pcemi[4] = (nKnxDA0<<4) | nKnxDA1;
   pcemi[5] = nKnxDA2;

   uchar *pga = pcemi + 6;
   
   pga[0] =    ((ga2 & 0x07) << 0)
            |  ((ga1 & 0x0F) << 3);
   pga[1] =    ga3;

   pcemi[8]  = 0x01 + nbytelen;
   pcemi[9]  = 0x00;
   pcemi[10] = 0x80; // 0x80=write, 0x40=reply, 0x00=read
   
   // data size dependent
   switch (nlen) 
   {
      case 1:
         pcemi[10] = 0x80 + data[0];
         break;
      case 8:
         cmd[17] = data[0];
         break;
      case 14:
         memcpy(&cmd[17], &data[0], 14);
         break;
   }
   
   return cmd[5];
}

int parseKnxReq(uchar cmd[], char *psz)
{
   // "1 4 200 1 0"
   // "1 4 200 14 test string"
   int ga1,ga2,ga3,nlen,nval;

   if (!isdigit(*psz)) return -1+perr("first GA part must be a number: \"%s\"", psz);
   ga1 = atoi(psz); skipToWhite(&psz); skipWhite(&psz);

   if (!isdigit(*psz)) return -1+perr("2nd GA part must be a number: \"%s\"", psz);
   ga2 = atoi(psz); skipToWhite(&psz); skipWhite(&psz);

   if (!isdigit(*psz)) return -1+perr("3rd GA part must be a number: \"%s\"", psz);
   ga3 = atoi(psz); skipToWhite(&psz); skipWhite(&psz);

   if (!isdigit(*psz)) return -1+perr("data length must be a number: \"%s\"", psz);
   nlen= atoi(psz); skipToWhite(&psz); skipWhite(&psz);

   uchar abdata[20];
   mclear(abdata);

   if (nlen < 14) {
      if (!isdigit(*psz)) return -1+perr("missing number data value: \"%s\"", psz);
      nval = (uchar)myatonum(psz);
      abdata[0] = nval;
      printf("KNX: %d/%d/%d len=%d data=%02X\n", ga1,ga2,ga3,nlen,nval);
   } else {
      nval = 0;
      strncpy((char*)abdata, psz, 14);
      printf("KNX: %d/%d/%d len=%d data=\"%s\"\n", ga1,ga2,ga3,nlen,abdata);
   }

   return makeKnxReq(cmd,ga1,ga2,ga3,nlen,abdata);
}

void dumpKnxInfo(uchar *pData, int iSize, char *pBuf, int iMaxBuf)
{__
   pBuf[0] = '\0';

   if (iSize < 2) return;

   uint    nservice =   ((uint)pData[2] << 8)
                      | ((uint)pData[3] << 0);
   uint    ioffset  = 0;
   cchar  *pszType  = 0;

   char szga[30];
   memset(szga, 0, sizeof(szga));

   switch (nservice)
   {
      case 0x0420: // tunneling request
         ioffset = 4;
         pszType = "tunnel";
         // and fall through
      case 0x0530: // routing indication
      {
         uchar *pCemi   = pData + 6 + ioffset;
         if (!pszType)
             pszType    = "route";

         uchar  nmc     = pCemi[0];
         uchar  naddil  = pCemi[1];

         uchar  nctl1   = pCemi[2];
         uchar  nctl2   = pCemi[3];

         uchar  nsrc1   = pCemi[4];
         uchar  nsrc2   = pCemi[5];

         uchar  ndest1  = pCemi[6];
         uchar  ndest2  = pCemi[7];

         uchar  b5      = pCemi[8];
         uchar  b6      = pCemi[9];
         uchar  b7      = pCemi[10];

         uchar  nga2    = (ndest1 >> 0) & 0x07;
         uchar  nga1    = (ndest1 >> 3) & 0x0F;
         uchar  nga3    = (ndest2 >> 0) & 0xFF;
         uchar  nlen    = b5 & 0x0F;
         uchar  ndata6  = b7 & 0x3F;
         uchar  ndata8  = pCemi[11]; // sic
         
         uchar  dsttype = (b5 >> 7) & 0x01; // destination type
         uchar  rcount  = (b5 >> 6) & 0x07; // routing count
         
         uchar  tcpi    = (b6 >> 6) & 0x03;
         uchar  ncount  = (b6 >> 2) & 0x0F;
         uchar  acpitype=(((b6 >> 0) & 0x03) << 2)
                         |((b7 >> 6) & 0x03);
         uchar  acpidata= (b7 >> 0) & 0x3F;

         // 15/1/123
         snprintf(szga, sizeof(szga)-1, "%u/%u/%u", nga1,nga2,nga3);
         while (strlen(szga) < 8)
            strcat(szga, " ");

         if (nlen == 1)
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s bit(s): %X\n", pszType, szga, ndata6);
         else
         if (nlen == 2)
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s byte  : %03u (0x%02X)\n", pszType, szga, ndata8, ndata8);
         else
         if (nlen == 14 || nlen == 15)
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s text%u: \"%.*s\"\n", pszType, szga, nlen, (int)nlen, (char*)pCemi+11);
         else
            mystrcatf(pBuf,iMaxBuf, " KNX: %s %s data%u: %03u (0x%02X)\n", pszType, szga, nlen, ndata8, ndata8);

         if (cs.knx != 2)
         {
            mystrcatf(pBuf,iMaxBuf, " KNX: nmc=%X addil=%X ctl1=%02X ctl2=%02X src1/2=%02X%02X dest1/2=%02X%02X\n",
               nmc, naddil, nctl1, nctl2, nsrc1,nsrc2, ndest1,ndest2);
            mystrcatf(pBuf,iMaxBuf, " KNX: dsttype=%u routcnt=%u tcpi=%u ncnt=%u acpitype=%u acpidata=%u\n", 
               dsttype, rcount, tcpi, ncount, acpitype, acpidata);
         }

         break;
      }

      case 0x0201:
         mystrcatf(pBuf,iMaxBuf, " KNX: search request\n");
         break;

      case 0x0202:
         mystrcatf(pBuf,iMaxBuf, " KNX: search response\n");
         break;

      default:
         mystrcatf(pBuf,iMaxBuf, " KNX: service %04X\n", nservice);
         break;
   }
}

int udpAnyServ(uint nPort, char *pszForward, int nForward, char *pszGroup, bool bEcho,
   char *pszFromMask, int iMinSize, int iMaxSize, uchar *pPat, int nPat, uint nFlags)
{__
   char szTime[100];
   char szKNX[512];

   // optional -tofile support
   FILE *fout = stdout;
   bool btofile = 0;
   if (cs.tomask && cs.tomaskfile) {
      // if (nGlblHexDumpForm != 4)
      //   return 9+perr("-tofile requires -flat output option\n");
      if (!(fout = fopen(cs.tomask, "wb")))
         return 9+perr("cannot write: %s\n", cs.tomaskfile);
      btofile = 1;
   }

   prepareTCP();

   struct sockaddr_in oOwnAddr; mclear(oOwnAddr);
   oOwnAddr.sin_family      = AF_INET;
   oOwnAddr.sin_addr.s_addr = htonl(INADDR_ANY);
   oOwnAddr.sin_port        = htons(nPort);

   SOCKET nsock = socket(AF_INET, SOCK_DGRAM, 0);

   int nOnVal = 1;
   setsockopt(nsock, SOL_SOCKET, SO_REUSEADDR, (const char *)&nOnVal, sizeof(nOnVal));

   int iPackets = 0;

   // when passing on chain data to another command,
   // do this by default on every single received package.
   if (chain.coldata && !cs.stopcnt)
      cs.stopcnt = 1;

   // for multicast
   struct ip_mreq mreq;
   memset(&mreq, 0, sizeof(mreq));
   mreq.imr_interface.s_addr = htonl(INADDR_ANY);
   bool bCleanupMCast = 0;

   // show just a single line info w/o dump?
   bool bOneLine = (cs.knx == 2) ? 1 : 0;

   do
   {
      if (bind(nsock, (struct sockaddr *)&oOwnAddr, sizeof(oOwnAddr)) != 0)
      {
         perr("cannot bind UDP socket to port %d (%d %s).\n", nPort, netErrno(), netErrStr());
         break;
      }

      if (pszGroup)
      {
         // multicast receive
         
         #if defined(MAC_OS_X) || defined(SOLARIS)
            #define SOL_IP IPPROTO_IP
         #endif
         
         #ifdef _WIN32
         
         char name[512];
         PHOSTENT hostinfo;
         mclear(name);
         mclear(hostinfo);

         if (gethostname(name, sizeof(name)))
            { perr("gethostname failed\n"); break; }
            
         if (!(hostinfo=gethostbyname(name)))
            { perr("get ownhost failed (%s) (1)\n", name); break; }

         struct in_addr *pin_addr = (struct in_addr *)*hostinfo->h_addr_list;

         mreq.imr_interface.s_addr = pin_addr->s_addr;
         mreq.imr_multiaddr.s_addr = inet_addr(pszGroup);
         
         // force IP_ADD_MEMBERSHIP of ws2tcpip.h
         #define MY_IP_ADD_MEMBERSHIP 12

         int iRC = 0;
         if (iRC = setsockopt(nsock, IPPROTO_IP, MY_IP_ADD_MEMBERSHIP, (char *)&mreq, sizeof(mreq))) {
            perr("cannot join multicast: rc=%d %s", iRC, netErrStr());
            perr("host=%s sock=%d group=%s",name,nsock,pszGroup);
            break;
            // in case of error 10042 see
            //    http://support.microsoft.com/kb/257460
            // wrong winsock header, runtime linkage etc.
         }
         
         #else            
         
         if (inet_aton(pszGroup, &mreq.imr_multiaddr) == 0)
            { perr("bad address: %s", pszGroup); break; }
            
         if (setsockopt(nsock, SOL_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) != 0 ) {
            perr("no default route to support multicast.");
            perr("try 'route add -net 224.000 netmask 240.000 eth0'");
            break;
         }
         
         #endif

         bCleanupMCast = 1;
      }

      listen(nsock, 10);

      if (!cs.quiet) {
         if (pszGroup)
            printf("[waiting on %s port %d for data.]\n", pszGroup, nPort);
         else
            printf("[waiting on port %d for data.]\n", nPort);
      }         

      struct timeval tv;
      fd_set fdvar;

      uchar *pHit=0;
      int    iHit=0,nHit=0;

      while (!userInterrupt())
      {
         tv.tv_sec  = 0;
         tv.tv_usec = 0;
   
         FD_ZERO(&fdvar);
         FD_SET(nsock, &fdvar);
   
         if (select(nsock+1, &fdvar, 0, 0, &tv) > 0)
         {
            struct sockaddr_in inAddr;

            socklen_t nadrlen = sizeof(inAddr);

            int nRead = recvfrom(nsock, (char*)abBuf, sizeof(abBuf)-100, 0, (struct sockaddr *)&inAddr, &nadrlen);

            struct in_addr addr;
            memcpy(&addr,&inAddr.sin_addr,sizeof(struct in_addr));
            char *premip = inet_ntoa(addr);
            
            // apply ip filter?
            if (pszFromMask && !strstr(premip, pszFromMask))
               continue;
            if (iMinSize != -1 && nRead < iMinSize)
               continue;
            if (iMaxSize != -1 && nRead > iMaxSize)
               continue;

            iHit=-1; nHit=0;
            if (nPat > 0) {
               if ((pHit = memFind(pPat, nPat, abBuf, nRead))) {
                  iHit = pHit - abBuf;
                  nHit = nPat;
               } else {
                  if (!(nFlags & 1))
                     continue;
               }
            }

            if (cs.knx) {
               dumpKnxInfo(abBuf,nRead,szKNX,sizeof(szKNX));
               int ioff=0,ilen=0;
               if (cs.knxtext && !matchstr(szKNX, cs.knxtext, 0, ioff, ilen))
                  continue;
            }

            iPackets++;

            if (cs.separator && !bOneLine)
            {
               mytime_t nTime = (mytime_t)time(NULL);
               #ifdef SFK_W64
               struct tm *pLocTime = _localtime64(&nTime);   // may be NULL
               #else
               struct tm *pLocTime = localtime(&nTime);      // may be NULL
               #endif
               szTime[0] = '\0';
               if (pLocTime)
                  strftime(szTime, sizeof(szTime)-10, "%d.%m.%Y %H:%M:%S", pLocTime);
               fprintf(fout, "%s----- #%03d from %s at %s (%d bytes) -----\n", 
                  cs.nolf ? "":"\n", iPackets, premip, szTime, nRead);
            }

            if (cs.knx) {
               if (bOneLine) {
                  if (btofile)
                     fprintf(fout, "%-15.15s%s", premip, szKNX);
                  else
                     printx("$%-15.15s<def>%s", premip, szKNX);
               } else {
                  fprintf(fout, "%s", szKNX);
               }
            }

            if (btofile && !cs.nohead && !cs.quiet) {
               // optical feedback although writing to file
               printf("[#%03d received %d bytes from %s]   \r",iPackets,nRead,premip);
               fflush(stdout);
            }
            if (btofile!=0 && nGlblHexDumpForm==4)
               { } // -tofile -flat : no received info
            else
            if (!cs.nohead && !cs.quiet && !cs.separator)
               fprintf(fout, "[#%03d received %d bytes from %s]\n",iPackets,nRead,premip);

            if (!bOneLine) {
               if (btofile!=0 && nGlblHexDumpForm==4 && cs.separator==0) // flat w/o separators
                  fwrite(abBuf, 1, nRead, fout);
               else
                  execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nRead):nRead, iHit, nHit, btofile ? fout : 0);
            }
            
            if (!chain.coldata)
               fflush(stdout);

            if (bEcho)
            {
               if (!cs.nohead && !cs.quiet)
                  printf("[echoing back]\n");
               sendto(nsock, (char*)abBuf, nRead, 0, (struct sockaddr*)&inAddr, nadrlen);
            }

            if (pszForward)
            {
               // forward message to given host, port
               struct sockaddr_in saDstAddr;
               memset((char *)&saDstAddr, 0,sizeof(saDstAddr));

               saDstAddr.sin_family      = AF_INET;
               saDstAddr.sin_addr.s_addr = inet_addr(pszForward);
               saDstAddr.sin_port        = htons((int)nForward);

               if (!cs.nohead && !cs.quiet)
                  printf("[forwarding to %s:%d]\n", pszForward, nForward);
               sendto(nsock, (char*)abBuf, nRead, 0, (struct sockaddr*)&saDstAddr, sizeof(saDstAddr));
            }

            if (cs.stopcnt > 0 && iPackets >= cs.stopcnt)
               break;

            if (btofile)
               fflush(fout);
         }
         else
         {
            doSleep(1);
         }
      }

      if (bCleanupMCast)
      {
         #ifdef _WIN32
         
         // force IP_DROP_MEMBERSHIP of ws2tcpip.h
         #define MY_IP_DROP_MEMBERSHIP 13

         int iRC = 0;
         if (iRC = setsockopt(nsock, IPPROTO_IP, MY_IP_DROP_MEMBERSHIP, (char *)&mreq, sizeof(mreq)))
            perr("cannot drop multicast membership: rc=%d %s", iRC, netErrStr());
         
         #else            
         
         if (setsockopt(nsock, SOL_IP, IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq)) != 0)
            perr("cannot drop multicast membership.");
         
         #endif
      }

      closesocket(nsock);
   }
   while (0);

   return 0;
}

void dumpNTPInfo(uchar *pData, int iSize, char *pszIP)
{
   if (iSize < 48) return;

   /*
      uint rootDelay          00
      uint rootDispersion     04
      uint refIdentifier      08
      uint refTimeFrac        12
      uint refTimeSec         16
      uint origTimeFrac       20
      uint origTimeSec        24
      uint recvTimeFrac       28
      uint recvTimeSec        32
      uint trxTimeFrac        36
      uint trxTimeSec         40
      uint keyIdentifier      44
   */
   ulong ntime1 =
         ((ulong)pData[40] << 24)
      |  ((ulong)pData[41] << 16)
      |  ((ulong)pData[42] <<  8)
      |  ((ulong)pData[43] <<  0);

   ntime1 -= 2208988800UL;

   mytime_t nTime2 = (mytime_t)ntime1;

   #ifdef SFK_W64
   struct tm *pLocTime = _localtime64(&nTime2); // may be NULL
   #else
   struct tm *pLocTime = localtime(&nTime2);    // may be NULL
   #endif

   strftime(szLineBuf , MAX_LINE_LEN, "%Y%m%d%H%M%S", pLocTime);
   strftime(szLineBuf2, MAX_LINE_LEN, "%d.%m.%Y %H:%M:%S", pLocTime);

   chain.print("%sNTP-time %s %s from %s\n", cs.quiet ? "":" ", szLineBuf, szLineBuf2, pszIP);
}

int udpSend(char *phost, int ndstport, 
   int nlisten, int nownport, 
   uchar *abMsg, int nMsg, 
   num nTimeout, uint nMode
 )
{__
   bool bQuiet  = (nMode & 1) ? 1 : 0;
   bool bTextIO = (nMode & 2) ? 1 : 0;

   prepareTCP();

   uint uiFlags = 0;
   
   if (cs.multicast)
      uiFlags |= 1;

   int isubrc = 0;

   if (!sfkNetIO.isOpen())
   {
      isubrc = sfkNetIO.initSendReceive("udpsend", nownport, ndstport, phost, uiFlags);
      
      if (isubrc)
         return isubrc;
   }
   
   if (bTextIO) {
      isubrc = sfkNetIO.addOrSendText((char*)abMsg, nMsg, 0);
      if (nlisten > 0)
         isubrc |= sfkNetIO.flushSend(0);
   } else {
      isubrc = sfkNetIO.sendData(abMsg, nMsg);
   }
   
   if (isubrc)
      return isubrc+perr("failed to send data (%d)", isubrc);

   if (!bQuiet && !cs.nohead && !cs.quiet)
      chain.print("[sent %d bytes, %s]\n", nMsg, netErrStr());

   if (!bQuiet && !cs.quiet)
      execHexdump(0, abMsg, nMsg);

   // receive and dump replies

   if (nlisten > 0)
   {
      uchar abBuffer[2000+100];

      struct sockaddr_in inAddr;

      socklen_t clilen = sizeof(inAddr);

      num nstart = getCurrentTime();

      for (int ndone=0; ndone<nlisten;)
      {
         if (sfkNetIO.isDataAvailable())
         do
         {
            memset(abBuffer, 0, sizeof(abBuffer));

            int iBytes = sfkNetIO.receiveData(abBuffer, sizeof(abBuffer), &inAddr, clilen);
            
            if (iBytes < 0)
               break; // no data, wait

            struct in_addr addr;
            memcpy(&addr,&inAddr.sin_addr,sizeof(struct in_addr));
            char *premip = inet_ntoa(addr);
      
            if (!cs.nohead && !cs.quiet)
              chain.print("[received %d bytes from %s %s]\n", iBytes, premip, netErrStr());
      
            if (cs.ntp && cs.quiet)
               { }
            else
               execHexdump(0, abBuffer, iBytes);
      
            if (cs.ntp)
               dumpNTPInfo(abBuffer, iBytes, premip);

            ndone++;
            continue;
         }
         while (0);

         num nelaps = getCurrentTime() - nstart;

         if (nTimeout > 0 && nelaps >= nTimeout) 
         {
            chain.print("[timeout]\n");
            break;
         }

         doSleep(10);
      }
   }

   return 0;
}

int tcpClient(char *phost, int ndstport, int nlisten, int nownport, uchar *abMsg, int nMsg, num nTimeout)
{__
   prepareTCP();

   int nsocket = socket(AF_INET, SOCK_STREAM, 0);

   struct sockaddr_in oTargetAddr;
   memset((char *)&oTargetAddr, 0,sizeof(oTargetAddr));

   // send data to target server
   struct hostent *pTarget;
   if ((pTarget = sfkhostbyname(phost)) == NULL)
      return 9+perr("cannot get host %s, rc=%d\n", phost, netErrno());

   memcpy(&oTargetAddr.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
   oTargetAddr.sin_family      = AF_INET;
   oTargetAddr.sin_port        = htons((int)ndstport);

   if ((connect(nsocket, (struct sockaddr *)&oTargetAddr, sizeof(oTargetAddr))) == -1) {
      perr("cannot connect to %s:%u, %s\n", phost, ndstport, netErrStr());
      return 9;
   }

   int n = send(nsocket, (char*)abMsg, nMsg, 0);

   if (!cs.nohead && !cs.quiet)
      chain.print("[sent %d bytes, %s]\n", n, netErrStr());

   if (!cs.quiet)
      execHexdump(0, abMsg, nMsg);

   // receive and dump replies

   // if (nlisten)
   while (1)
   {
      int nRead = recv(nsocket, (char*)abBuf, sizeof(abBuf)-10, 0);

      if (nRead <= 0)
         break;

      if (nGlblHexDumpForm == 4 && memchr(abBuf, '\0', nRead)) {
         // pure form: dump start of binary, but not all
         int nHexLimit = 1000;
         if (nRead > nHexLimit) {
            if (!cs.nohead && !cs.quiet)
               printf("[received reply with binary, %d bytes. dumping first %d:]\n", nRead, nHexLimit);
            int nCurForm = nGlblHexDumpForm;
            nGlblHexDumpForm = 0;
            execHexdump(0, abBuf, nHexLimit);
            nGlblHexDumpForm = nCurForm;
         } else {
            if (!cs.nohead && !cs.quiet)
               printf("[received reply with binary, %d bytes:]\n", nRead);
            execHexdump(0, abBuf, nRead);
         }
      } else {
         if (!cs.nohead && !cs.quiet)
            printf("[received reply, %d bytes:]\n", nRead);
         execHexdump(0, abBuf, nRead);
      }
   }
   
   closesocket(nsocket);

   return 0;
}

int tcpAnyServ(uint nPort, char *pszForward, int nForward)
{__
   prepareTCP();

   struct sockaddr_in ServerAdr;
   struct sockaddr_in ClientAdr;
   struct sockaddr_in FrontAdr;
   socklen_t nSoLen = sizeof(sockaddr_in);
   SOCKET hServer   = INVALID_SOCKET;
   SOCKET hBack     = INVALID_SOCKET;
   SOCKET hFront    = INVALID_SOCKET;
   if (makeServerSocket(nPort, ServerAdr, hServer, "server main port")) return 9;

   printf("waiting on port %u for connections", nPort);
   if (pszForward) printf(", to forward to %s:%d", pszForward, nForward);
   if (cs.timeOutAutoSelect)
      printf(".\n");
   else
      printf(". timeout is %d milliseconds.\n", cs.timeOutMSec);

   // http autodetect:
   bool bFirstReq = 1;
   bool bHttp     = 0;

   int lRC = 0;
   while (!userInterrupt())
   {
      hBack = accept(hServer, (struct sockaddr *)&ClientAdr, &nSoLen);
      if (hBack == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(50); continue; }
         perr("accept on server main port failed\n");
         lRC = 9;
         break;
      }
      setBlocking(hBack, 0);

      // forward-connect
      if (pszForward) {
         if (!cs.quiet) {
            printf("[got connection, trying forward-connect]\r");
            fflush(stdout);
         }
         hFront = socket(AF_INET, SOCK_STREAM, 0);
         if (hFront == INVALID_SOCKET) return 9+perr("cannot create forward socket\n");
         static struct hostent *pTarget = 0;
         if (!pTarget) {
            pTarget = sfkhostbyname(pszForward);
            if (!pTarget) return 9+perr("cannot get host: %s\n", pszForward);
            memcpy(&FrontAdr.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
            FrontAdr.sin_family = AF_INET;
            FrontAdr.sin_port = htons((unsigned short)nForward);
         }
         if ((connect(hFront, (struct sockaddr *)&FrontAdr, sizeof(FrontAdr))) == -1) {
            perr("cannot connect to %s:%u, %s\n", pszForward, nForward, netErrStr());
            return 9;
         }
         printf("[forward-connected to %s:%d]       \n",pszForward,nForward);
         setBlocking(hFront, 0);
      } else {
         printf("[got connection]\n");
      }

      num nLastTime = getCurrentTime();

      // outer loop: try to repeat data forwarding for 30 secs
      while (!userInterrupt())
      {
         // any data from back?
         int nRead = recv(hBack, (char*)abBuf, sizeof(abBuf)-10, 0);
         // NOTE: non-blocking receives may return -1 inbetween,
         //       but the connection stays open.
         if (nRead > 0) 
         {
            // autodetect http protocol on first request
            abBuf[nRead] = '\0';
            if (bFirstReq) {
               bFirstReq = 0;
               // isolate first line of first request
               char *psz = strchr((char*)abBuf, '\n');
               if (psz) {
                  int nlen = psz-(char*)abBuf;
                  memcpy(szLineBuf, abBuf, nlen);
                  szLineBuf[nlen] = '\0';
                  if (   (!strncmp(szLineBuf, "GET ", 4) || !strncmp(szLineBuf, "POST ", 5))
                      && (strstr(szLineBuf, "HTTP") != 0)
                     )
                  {
                     bHttp = 1;
                     if (cs.timeOutAutoSelect)
                         cs.timeOutMSec = 10000;
                  }
               }
            }
            if (nGlblHexDumpForm == 4 && memchr(abBuf, '\0', nRead)) {
               // pure form: skip binary record
               printf("[received request from back: binary, %d bytes]\n",nRead);
            } else {
               printf("[received request from back with %d bytes:]\n",nRead);
               execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nRead):nRead);
            }
            nLastTime = getCurrentTime();
            // forward to front
            if (pszForward) {
               int nSend = send(hFront, (char*)abBuf, nRead, 0);
               // ignore no. of actually sent bytes
               if (nSend == nRead)
                  printf("[forwarded %d bytes]\n", nSend);
               else
                  pwarn("[forwarded %d bytes of %d - incomplete]\n", nSend, nRead);
            }
         }

         // any data from front?
         if (pszForward)
         {
            int nRead = recv(hFront, (char*)abBuf, sizeof(abBuf)-10, 0);
            if (nRead > 0) {
               if (nGlblHexDumpForm == 4 && memchr(abBuf, '\0', nRead)) {
                  // pure form: dump start of binary, but not all
                  int nHexLimit = 1000;
                  if (nRead > nHexLimit) {
                     printf("[received reply from front with binary, %d bytes. dumping first %d:]\n", nRead, nHexLimit);
                     int nCurForm = nGlblHexDumpForm;
                     nGlblHexDumpForm = 0;
                     execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nHexLimit):nHexLimit);
                     nGlblHexDumpForm = nCurForm;
                  } else {
                     printf("[received reply from front with binary, %d bytes:]\n", nRead);
                     execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nRead):nRead);
                  }
               } else {
                  printf("[received reply from front:]\n");
                  execHexdump(0, abBuf, cs.maxdump?mymin(cs.maxdump,nRead):nRead);
               }
               nLastTime = getCurrentTime();
               // backward reply
               int nSend = send(hBack, (char*)abBuf, nRead, 0);
               if (nSend == nRead)
                  printf("[backwarded %d bytes]\n", nSend);
               else
                  pwarn("[backwarded %d bytes of %d - incomplete]\n", nSend, nRead);
            }
         }

         // no data at all over timeout?
         if (getCurrentTime() > nLastTime + cs.timeOutMSec) {
            printf("[timeout, no data over %d msec]\n", cs.timeOutMSec);
            break;
         }

         {
            doSleep(500);
            cchar *pszCircle = ". ";
            static int nCircle = 0;
            num nElapse = getCurrentTime() - nLastTime;
            if (!cs.quiet) {
               printf("[%c waiting for input, %d/%d sec]\r",pszCircle[(nCircle++)%2],(int)(nElapse/1000),cs.timeOutMSec/1000);
               fflush(stdout);
            }
         }

      } // end outer loop

      if (pszForward) {
         printf("[closing forward connection]\n");
         closesocket(hFront);
      }

      printf("[client disconnected]\n");
      closesocket(hBack);
   }

   closesocket(hServer);

   #ifdef _WIN32
   WSACleanup();
   #endif

   return 0;
}

cchar *pUploadForm =
   "<p>"
   "<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/\">\n"
   "<table><tr><td>\n"
   "<input type=\"file\" name=\"filename\"/>\n"
   "</td><td>\n"
   "<input type=\"submit\" value=\"upload\"/>\n"
   "</td></tr></table>\n"
   "</form>\n";

int recvHead(SOCKET hBack, char *pbuf, int nrem)
{
   bool bbail = 0;
   int nhead = 0;
   while (1) {
      int nread = recv(hBack, pbuf+nhead, 1, 0);
      if (nread <= 0) { bbail=1; break; }
      nhead++;
      // scan for \r\n\r\n
      if (nhead > 4 && !strncmp(pbuf+nhead-4, "\r\n\r\n", 4))
         break;
      // scan for \n\n
      if (nhead > 2 && !strncmp(pbuf+nhead-2, "\n\n", 2))
         break;
   }
   pbuf[nhead] = '\0';
   return bbail ? -1 : nhead;
}

// used mainly by file upload of http server
int senderr(SOCKET hSock, cchar *pszFormat, ...)
{__
   va_list argList;
   va_start(argList, pszFormat);
   ::vsnprintf(szErrBuf, sizeof(szErrBuf)-10, pszFormat, argList);
   strcat(szErrBuf, "\r\n");

   sendLine(hSock, "HTTP/1.1 500 server error");
   sendLine(hSock, "Server: Swiss File Knife " SFK_VERSION " " VER_STR_OS);
   sendLine(hSock, "Content-Type: text/html");
   sendLine(hSock, "");

   sendLine(hSock, "<html><body>");
   send(hSock, szErrBuf, strlen(szErrBuf), 0);
   sendLine(hSock, "</body></html>");

   num nstart = getCurrentTime();

   // browser tries to upload data, so we have to dummy-receive
   // them for a while, otherwise it will show a connection abort
   // instead of the error message.

   setBlocking(hSock, 0);
   int nread = 0;
   while ((nread = recv(hSock, (char*)abBuf, sizeof(abBuf)-10, 0)) > 0)
      if (getCurrentTime() - nstart > 3000)
         break;
   setBlocking(hSock, 1);

   if (cs.quiet < 2)
      printf("< ERROR: %.80s\n", szErrBuf);

   return 0;
}

int httpServ(uint nPort, uint nPort2, bool bDeep, bool bNoList, bool bRW)
{__
   prepareTCP();

   struct sockaddr_in ServerAdr;
   struct sockaddr_in ClientAdr;
   socklen_t nSoLen = sizeof(sockaddr_in);
   SOCKET hServer   = INVALID_SOCKET;
   SOCKET hBack     = INVALID_SOCKET;
   if (makeServerSocket(nPort, ServerAdr, hServer, "server main port", nPort2)) return 9;

   printf("SFK Instant HTTP Server. For help, type \"sfk httpserv -help\".\n");

   // get own ip
   int   namount = 0;
   char *pownip  = ownIPList(namount, (nPort==80) ? 0 : nPort);
   struct in_addr addr;

   if (strlen(pownip)) {
      if (namount == 1) {
         printf("Waiting on port %u. Try http://%s/ in your browser.\n", nPort, pownip, nPort);
      } else {
         printf("Waiting on port %u. Try http://%s in your browser.\n", nPort, pownip, nPort);
      }
   } else {
      printf("Waiting on port %u.\n", nPort);
   }
 
   char szClientIP[50]; mclear(szClientIP);
   char szStatus[200];  mclear(szStatus);

   int lRC = 0;
   while (!userInterrupt())
   {
      hBack = accept(hServer, (struct sockaddr *)&ClientAdr, &nSoLen);
      if (hBack == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(50); continue; }
         perr("accept on server main port failed\n");
         lRC = 9;
         break;
      }
      setBlocking(hBack, 1);

      // list IP of client machine whenever it changes
      memcpy(&addr,&ClientAdr.sin_addr,sizeof(struct in_addr));
      char *premip = inet_ntoa(addr);
      if (strcmp(szClientIP, premip)) {
         strcopy(szClientIP, premip);
         printf("> connect from %s\n", premip);
      }

      char szFile[SFK_MAX_PATH+50]; mclear(szFile);

      mclear(szStatus);

      do
      {
         // read header line by line
         int nhead = recvHead(hBack, (char*)abBuf, sizeof(abBuf)-10);
         if (nhead < 0) break;

         // GET /favicon.ico HTTP/1.1
         char *preq = (char*)abBuf;

         mtklog(("http: req: \"%.200s\"", preq));

         if (strBegins(preq, "POST / ")) 
         {
            // ===== single file upload =====

            // printf("req: %s\n", preq);
            
            int iError = 0;

            // separate content from header
            char *pcont = strstr(preq, "\r\n\r\n");
            if (!pcont) pcont = strstr(preq, "\n\n");
            if (!pcont) { senderr(hBack, "wrong POST format"); break; }
            *pcont = '\0';
            pcont += 4;

            // parse header lines:

            // szLineBuf3 contains boundary.
            mclear(szLineBuf3);
            num nContLen = -1;

            bool bfirst = 1;
            char *psz1 = preq;
            while (psz1 && *psz1)
            {
               char *psz2 = strchr(psz1, '\n');
               if (psz2) *psz2++ = '\0';
               removeCRLF(psz1);
               if (bfirst)
                  { bfirst=0; printf("> %s\n",psz1); }

               mtklog(("http: post.head: %s", psz1));

               if (   striBegins(psz1, "content-type")
                   && mystrstri(psz1, "multipart/form-data")
                  )
               {
                  char *psz3 = strstr(psz1, "boundary=");
                  if (!psz3)
                     { senderr(hBack, "wrong content-type: %s",psz1); break; }
                  psz3 += strlen("boundary=");
                  char *psz4 = psz3;
                  skipToWhite(&psz4);
                  int nlen = psz4-psz3;
                  if (nlen > MAX_LINE_LEN-100)
                     { senderr(hBack, "content-boundary too long"); break; } 
                  snprintf(szLineBuf3, MAX_LINE_LEN, "\r\n--%.*s--\r\n", (int)nlen, psz3);
               }
               if (striBegins(psz1, "content-length")) {
                  num nlen = -1;
                  char *psz3 = strchr(psz1, ':');
                  if (psz3) {
                     psz3++;
                     skipWhite(&psz3);
                     nlen = atonum(psz3);
                  }
                  if (nlen < 0) { senderr(hBack, "wrong content-length: %s",psz1); break; }
                  nContLen = nlen;
               }
               psz1 = psz2;
            }

            if (!szLineBuf3[0]) { senderr(hBack, "missing boundary header"); break; }
            if (nContLen < 0)   { senderr(hBack, "missing content length"); break; }

            mtklog(("http: post.bound \"%s\"", szLineBuf3));
            mtklog(("http: post.clen %d", (int)nContLen));

            // get first part header
            int nhead2 = recvHead(hBack, (char*)abBuf, sizeof(abBuf)-10);
            if (nhead2 < 0) break;
            abBuf[nhead2] = '\0';

            mtklog(("http: post.firsthead: \"%.300s\"", abBuf));

            char *pname = strstr(preq, "filename=\"");
            if (!pname) { senderr(hBack, "missing filename"); break; }
            pname += strlen("filename=\"");
            char *psz3 = strchr(pname, '\"');
            if (!psz3) { senderr(hBack, "missing quote"); break; }
            *psz3 = '\0';

            mtklog(("http: post.filename \"%s\"", pname));

            // c:\the\dir\foo.txt -> foo.txt
            if (strrchr(pname, '/'))  pname = strrchr(pname, '/') + 1;
            if (strrchr(pname, '\\')) pname = strrchr(pname, '\\') + 1;
            strcopy(szFile, localPath(pname));
            
            // FIX: 163R5: decode POST URLs with blanks or special chars
            decodeUrl(szFile);

            // receive file data
            if (isPathTraversal(szFile, 0))
               { senderr(hBack, "path traversal not allowed: %s", szFile); break; }

            FILE *fout = fopen(szFile, "wb");
            if (!fout)
               { senderr(hBack, "cannot write: %s",szFile); break; }

            char *pbnd = szLineBuf3;
            int  nbnd = strlen(pbnd);

            // mtkdump("http: post.bnd: ",pbnd,nbnd);

            num nTotal  = 0;

            // requires overlapping read with boundary search
            char *pbuf    = (char*)abBuf;
            int  nused   = 0;
            int  nbufmax = sizeof(abBuf)-10;
            
            bool bCompleted = 0;

            SFKMD5 md5;

            while (nTotal < nContLen)
            {
               int nbufrem =  nbufmax  - nused;
               num  ntotrem = (nContLen - nTotal) - nused;

               if (ntotrem < 0) {
                  senderr(hBack, "int. error during POST read, %d %d %d",(int)nContLen,(int)nTotal,(int)nused);
                  break;
               }

               if (nbufrem > ntotrem) nbufrem = (int)ntotrem;

               // if (nbufrem < 1000) { mtkdump("http: buf: ", pbuf, nused); }

               mtklog(("http: post.wait: rem=%d used=%d total=%d clen=%d", nbufrem, nused, (int)nTotal, (int)nContLen));

               int nread = recv(hBack, pbuf+nused, nbufrem, 0);
               if (nread <= 0) break;

               nused += nread;
               pbuf[nused] = '\0'; // safety

               mtklog(("http:  post.read: len=%d used=%d total=%d", nread, nused, (int)nTotal));

               // another boundary?
               char *phit = 0;

               if (nused >= nbnd)
                  if (!strncmp(pbuf+nused-nbnd, pbnd, nbnd))
                      phit = pbuf+nused-nbnd;

               if (phit) 
               {
                  int nlen = phit - pbuf;
                  if (myfwrite((uchar*)pbuf, nlen, fout) != nlen) {
                     perr("cannot fully write (disk full?): %s", szFile); 
                     iError = 1;
                     break; 
                  }
                  md5.update((uchar*)pbuf, nlen);
                  nTotal += nlen;
                  char *ppost = phit + nbnd;
                  char *pend  = strstr(ppost, "\r\n\r\n");
                  if (!pend) pend = ppost;
                  // printf("sub: \"%s\"\n", phit);
                  ppost = pend;
                  int nlen2 = ppost - pbuf;
                  int nrem2 = nused - nlen2;
                  memmove(pbuf, ppost, nrem2);
                  nused = nrem2;
                  mtklog(("http:  post.hitblock: take %d, move %d",nlen,nused));
                  bCompleted = 1;
                  break;
               }

               // normal processing: write halve of buffer
               int nlen = nused / 2;

               mtklog(("http:  post.nblk: take %d",nlen));

               if (myfwrite((uchar*)pbuf, nlen, fout) != nlen) {
                  perr("cannot fully write (disk full?): %s", szFile);
                  iError = 2;
                  break;
               }
               md5.update((uchar*)pbuf, nlen);
               nTotal += nlen;
               char *ppost = pbuf + nlen;
               int nrem2 = nused - nlen;
               memmove(pbuf, ppost, nrem2);
               nused = nrem2;
            }

            fclose(fout);
            
            if (!bCompleted && !iError)
               iError = 3;

            char szmd5[100];
            uchar *pmd5 = md5.digest();
            for (int i=0; i<16; i++)
               sprintf(szmd5+i*2, "%02x", pmd5[i]);
               
            if (iError) {
               remove(szFile);
               snprintf(szStatus, sizeof(szStatus)-10, "failed: %s (error %d)",szFile,iError);
            } else {
               snprintf(szStatus, sizeof(szStatus)-10, "saved : %s (%s bytes) md5=%s",szFile,numtoa(nTotal),szmd5);
            }
            printf("> %s\n", szStatus);
            
            mtklog(("http: post: %s", szStatus));

            strcpy((char*)abBuf, "GET / HTTP/1.1\r\n\r\n");

            // fall through to index listing, with szStatus being displayed.

         }  // endif POST

         // isolate first line
         char *plf = strchr(preq, '\r');
         if (!plf) plf = strchr(preq, '\n');
         if (plf) *plf = '\0';
         printf("> %s\n", preq);

         bool bget  = strBegins(preq, "GET ");
         bool bhead = strBegins(preq, "HEAD ");

         if (!bget && !bhead)
         {
            senderr(hBack, "500 unsupported command: %.200s", preq);
            break;
         }

         char *psz1 = preq + (bget ? 4 : 5);
         if (*psz1=='/') psz1++;
         char *psz2 = psz1;
         skipToWhite(&psz2);
         int nlen = psz2 - psz1;
         if (nlen > SFK_MAX_PATH) nlen = SFK_MAX_PATH;
         memcpy(szFile, psz1, nlen);
         szFile[nlen] = '\0';

         // FIX: 163R5: decode GET URLs with blanks or special chars
         decodeUrl(szFile);

         // requested file is now in szFile
         if (!szFile[0] && bNoList) {
            strcpy(szFile, "index.html");
         }

         if (!szFile[0]) 
         {
            // list files of current dir
            hGlblTCPOutSocket = hBack;
            sendLine(hBack, "HTTP/1.1 200 OK");
            sendLine(hBack, "Server: Swiss File Knife " SFK_VERSION " " VER_STR_OS);
            sendLine(hBack, "Content-Type: text/html");
            sendLine(hBack, "Cache-Control: no-cache");
            sendLine(hBack, ""); // plus added \r\n

            if (bget)
            {
               sendLine(hBack, "<html><body>");
               sendLine(hBack, "Swiss File Knife Instant HTTP Server, " SFK_VERSION ", " VER_STR_OS);
   
               sendLine(hBack, "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"/\">refresh</a>");
   
               if (bRW) sendLine(hBack, pUploadForm);
   
               sendLine(hBack, "<pre>");
   
               if (szStatus[0]) {
                  snprintf(szLineBuf2, MAX_LINE_LEN, "%s\n", szStatus);
                  sendLine(hBack, szLineBuf2);
               }
   
               int lFiles=0,lDirs=0;
               num  nBytes=0;
               bGlblFTPListFlatTS = 1;
               bGlblFTPListAsHTML = 1;
               lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
   
               sendLine(hBack, "</pre></body></html>");
               if (!cs.quiet)
                  printf("< sent content listing.\n");
            }
            break;
         }

         // block any ".." etc.
         if (isPathTraversal(szFile, bDeep)) {
            senderr(hBack, "path traversal not allowed: %s", szFile);
            break;
         }

         // all other files
         Coi *pcoi = new Coi(localPath(szFile), 0);
         CoiAutoDelete odel(pcoi, 0); // no decref

         if (!pcoi->existsFile()) {
            sendLine(hBack, "HTTP/1.1 404 no such file");
            sendLine(hBack, "");
            sprintf(szLineBuf2, "404 no such file: %.200s", szFile);
            sendLine(hBack, szLineBuf2);
            break;
         }

         bool bbin  = pcoi->isBinaryFile();
         num  nsize = pcoi->getSize();

         sendLine(hBack, "HTTP/1.1 200 OK");

         cchar *pctype = "application/octet-stream";

         if (bbin) {
            if (strstr(szFile, ".jp"))  pctype = "image/jpg";
            if (strstr(szFile, ".png")) pctype = "image/png";
            if (strstr(szFile, ".gif")) pctype = "image/gif";
            if (!strcmp(szFile, "favicon.ico")) pctype = "image/x-icon";
         } else {
            pctype = "text/plain";
            if (strstr(szFile, ".htm"))
               pctype = "text/html";
         }
         sprintf(szLineBuf2, "Content-Type: %s", pctype);
         sendLine(hBack, szLineBuf2);

         sprintf(szLineBuf2, "Content-Length: %s", numtoa(nsize));
         sendLine(hBack, szLineBuf2);

         sendLine(hBack, "");

         if (bget)
         {
            if (pcoi->open("rb")) {
               if (strcmp(szFile, "favicon.ico"))
                  senderr(hBack, "failed to open: \"%s\"", pcoi->name());
               break; 
            }
   
            int nread = 0;
            num  ndone = 0;
            while ((nread = pcoi->read(abBuf, sizeof(abBuf)-1000)) > 0)
            {
               if (cs.verbose>1) printf("< [%d bytes data]\n", (int)nread);
               int nsent = send(hBack, (char*)abBuf, nread, 0);
               ndone += nsent;
               if (nsent != nread)
                  { perr("failed to send data (%d/%d) %s\n",nsent,nread,netErrStr()); break; }
            }
   
            pcoi->close();
   
            if (!cs.quiet) {
               if (ndone == nsize)
                  printf("< sent %s bytes, content-type: %s\n",numtoa(ndone),pctype);
               else
                  printf("< transfer incomplete.\n");
            }
         }

         // connection close after every request
      }
      while (0);

      // not sure when we can close connection safely
      doSleep(500);

      closesocket(hBack);

   }  // endwhile accept loop

   closesocket(hServer);

   #ifdef _WIN32
   WSACleanup();
   #endif

   return 0;
}

bool startsLikeHttpCommand(char *psz)
{
   if (strBegins(psz, "GET "))  return 1;
   if (strBegins(psz, "POST ")) return 1;
   if (strBegins(psz, "HEAD ")) return 1;
   return 0;
}

#define MAX_FTP_VDIR 10

class FTPServer
{
public:
      FTPServer   ( );
     ~FTPServer   ( );

   int run           (uint nPort, bool bRW, bool bRun, bool bDeep, uint nPort2);
   char *absPath     (char *pszFilePath=0);
   char *sysPath     (char *pszFilePath=0);
   int   mapPath     (char *pszRelPath, bool bAllowRoot=0, bool bCheckDiskSpace=0);
   int   reply       (cchar *pszMask, ...);
   int   replyFromRC (int iSubRC);
   int   readLine    ( );
   void  setStart    ( );
   int   isTimeout   (int iTimeout);
   int   addUseDir   (char *psz);
   int   setFixDir   (char *psz);

private:
   int   addTrailSlash     (char *pszBuf, int iMaxBuf);
   void  stripTrailSlash   (char *pszPath);
   char *notslash          (char *pszPath);
   int   setLocalWalkDir   (char *pszPath);
   bool  pathTraversal     (char *pszPath, bool bDeep);
   int   checkPath         (char *pszPath, bool bDeep);
   int   copyNormalized    (char *pdst, int imaxdst, char *psrc);

public:
char
   szClAuthUser   [50],
   szClAuthPW     [50],
   szClRunPW      [50];

private:
char
   szClWorkDir    [800],
   szClOldWorkDir [800],
   szClAbsPathBuf [800],
   szClSysPathBuf [800],
   szClTmpPathBuf [800],
   szClCmpPathBuf [800],
   szClFixSysDir  [800],
   szClRenameFrom [800],
   szClReplyBuf   [1024];

int  iClVDir;
char aClVDirSrc[MAX_FTP_VDIR+2][100];
char aClVDirDst[MAX_FTP_VDIR+2][200];

struct sockaddr_in
   clServerAdr,
   clPasServAdr,
   clClientAdr,
   clDataAdr;

SOCKET
   hClServer,
   hClClient,
   hClPasServ,
   hClData;
   
num
   nClStart,
   nClDiskFree;

bool
   bClSendFailed,
   bClTimeout,
   bClDeep;
};

FTPServer::FTPServer( )
{
   memset(this, 0, sizeof(*this));

   char szInfo[100];
   mclear(szInfo);
   cchar *ppre = "";
   
   if (getenv("SFK_FTP_USER")) {
      strcopy(szClAuthUser, getenv("SFK_FTP_USER"));
      strcat(szInfo, ppre);
      strcat(szInfo, "_USER");
      ppre = "/";
   }

   if (getenv("SFK_FTP_PW")) {
      strcopy(szClAuthPW, getenv("SFK_FTP_PW"));
      strcat(szInfo, ppre);
      strcat(szInfo, "_PW");
      ppre = "/";
   }

   if (!szClAuthPW[0] && getenv("SFK_FTP_RUNPW")) {
      strcopy(szClRunPW, getenv("SFK_FTP_RUNPW"));
      strcat(szInfo, ppre);
      strcat(szInfo, "_RUNPW");
   }

   if (szInfo[0] && !cs.quiet)
      printf("[using SFK_FTP%s for authentication]\n", szInfo);
}

FTPServer::~FTPServer( )
{
}

int FTPServer::copyNormalized(char *pdst, int imaxdst, char *psrc)
{
   char *pdstmax = pdst+imaxdst-10;

   strcpy(pdst, "/");
   pdst++;
   if (*psrc=='/') psrc++;

   if (pdst+strlen(psrc)>pdstmax)
      return 9+perr("string too long: %s\n", psrc);

   strcat(pdst,psrc);
   pdst += strlen(pdst);

   int ilen = strlen(pdst);
   if (pdst[ilen-1]!='/')
      strcat(pdst, "/");

   return 0;
}

int FTPServer::setFixDir(char *psz)
{
   if (iClVDir > 0)
      return 9+perr("work dir parameter cannot be combined with -usedir: %s\n", psz);

   strcopy(szClFixSysDir, psz);

   return 0;
}

int FTPServer::addUseDir(char *psz)
{
   if (szClFixSysDir[0])
      return 9+perr("-usedir cannot be combined with work dir parameter: %s", szClFixSysDir);

   if (iClVDir >= MAX_FTP_VDIR)
      return 9+perr("too many -usedir statements\n");

   // FROM /Musik/audiofiles=audio
   // TO   /Musik/audiofiles/=/audio/
   // FROM thedir
   // TO   thedir/=/thedir/
   char *pszCur = psz;
   while (pszCur && *pszCur)
   {
      char *pszRawSrc = pszCur;
      char *pszRawDst = 0;

      while (*pszCur!=0 && *pszCur!='=')
         pszCur++;

      if (*pszCur=='=') {
         // take right side after "="
         *pszCur++ = '\0';
         pszRawDst = pszCur;
         while (*pszCur!=0 && *pszCur!=',')
            pszCur++;
         if (*pszCur)
            *pszCur++ = '\0';
      } else {
         // take (relative part of) single parameter
         pszRawDst = pszRawSrc;
         char *psz = strrchr(pszRawSrc, glblPathChar);
         // FROM foo/bar to just bar
         if (psz!=0 && psz[1]!=0)
            pszRawDst = psz+1;
      }

      // now have one pair of src/dst
      if (copyNormalized(aClVDirSrc[iClVDir], sizeof(aClVDirSrc[iClVDir]), pszRawDst))
         return 9;

      strcopy(aClVDirDst[iClVDir], pszRawSrc);
      if (strlen(aClVDirDst[iClVDir]) >= sizeof(aClVDirDst[iClVDir])-10)
         continue;
      strcat(aClVDirDst[iClVDir], glblPathStr);

      if (cs.verbose)
         printf("FROM %s TO %s\n", aClVDirSrc[iClVDir], aClVDirDst[iClVDir]);

      iClVDir++;
   }
   
   return 0;
}

void  FTPServer::setStart ( )
{
   nClStart = getCurrentTime();
   bClTimeout = 0;
}

int   FTPServer::isTimeout(int iTimeout)
{
   int iElapsed = getCurrentTime() - nClStart;
   if (iElapsed > iTimeout) {
      bClTimeout = 1;
      return 1;
   }
   return 0;
}

// IF input file name starts absolute "/"
//    THEN returns that name, without leading slash
// ELSE
//    returns workdir+that name, without leading slash
char *FTPServer::absPath(char *pszFilePath)
{
   if (!pszFilePath)
      return szClAbsPathBuf;

   szClAbsPathBuf[0] = '\0';

   int nMaxDst = sizeof(szClAbsPathBuf)-10;
   
   if (*pszFilePath == '/')
   {
      strcopy(szClAbsPathBuf, pszFilePath);
   }
   else
   {
      strcopy(szClAbsPathBuf, szClWorkDir);
   
      // append "/" on demand
      int iWorkLen = strlen(szClAbsPathBuf);
      if (iWorkLen > 0) {
         char clast = szClAbsPathBuf[iWorkLen-1];
         if (clast != '/') {
            strcat(szClAbsPathBuf, "/");
            iWorkLen++;
         }
      }
      
      int iAddLen = strlen(pszFilePath);
   
      if (iWorkLen+iAddLen < nMaxDst)
         strcpy(szClAbsPathBuf+iWorkLen, pszFilePath);
   }

   return szClAbsPathBuf;
}

char *FTPServer::sysPath(char *pszFilePath)
{
   if (!pszFilePath)
      return szClSysPathBuf;

   szClSysPathBuf[0] = '\0';

   strcopy(szClTmpPathBuf, pszFilePath);
   strcopy(szClCmpPathBuf, pszFilePath);

   szClSysPathBuf[0] = '\0'; // safety

   // 2. replace virtual dir mappings, if any
   if (iClVDir > 0)
   {
      addTrailSlash(szClCmpPathBuf, sizeof(szClCmpPathBuf));

      // -mapdir /audio/=/Musik/audiofiles
      bool bMapped=0;
      char *pTail=0;
      for (int i=0; i<iClVDir; i++)
      {
         if (stribeg(szClCmpPathBuf, aClVDirSrc[i]))
         {
            int iSrcLen = strlen(aClVDirSrc[i]);
            strcpy(szClSysPathBuf, aClVDirDst[i]);
            pTail = szClSysPathBuf+strlen(szClSysPathBuf);
            strcat(szClSysPathBuf, szClTmpPathBuf+iSrcLen);
            bMapped=1;
            break;
         }
      }
      if (!bMapped) {
         if (cs.verbose)
            printf("no mapping for: %s\n", pszFilePath);
         return 0;
      }
   }
   else if (szClFixSysDir[0])
   {
      // "/thedir/foo.txt" -> docs/thedir/foo.txt
      char *pszRel = szClTmpPathBuf;
      if (*pszRel=='/')
            pszRel++;
      joinPath(szClSysPathBuf, sizeof(szClSysPathBuf), szClFixSysDir, pszRel);
      // expand "" to "."
      if (!szClSysPathBuf[0])
         strcpy(szClSysPathBuf, ".");
   }
   else
   {
      // "/thedir/foo.txt" actually means "thedir/foo.txt"
      if (szClTmpPathBuf[0] == '/')
         strcopy(szClSysPathBuf, szClTmpPathBuf+1);
      else
         strcopy(szClSysPathBuf, szClTmpPathBuf);
      // expand "" to "."
      if (!szClSysPathBuf[0])
         strcpy(szClSysPathBuf, ".");
   }

   // 3. convert to OS FS
   for (char *p=szClSysPathBuf; *p; p++)
      if (*p == glblWrongPChar)
          *p = glblPathChar;

   if (cs.verbose>=2)
      printf("map.sys: %s\n", szClSysPathBuf);

   // return normalized OS FS path
   return szClSysPathBuf;
}

// RC 1: any error
// RC 2: unallowed root path
int FTPServer::mapPath(char *pszRelPath, bool bAllowRoot, bool bCheckDiskSpace)
{
   nClDiskFree = -1;

   char *pszAbsPath = absPath(pszRelPath);
   // must now be /workdir/thepath/
   
   if (cs.verbose>=2)
      printf("use.abs: %s\n", pszAbsPath);

   if (pszAbsPath[0]!='/')
      { reply("550 Invalid path"); return 1; }

   if (pszAbsPath[1] && pathTraversal(pszAbsPath+1, bClDeep)) 
      { reply("550 Invalid path"); return 1; }

   char *pszSysPath = sysPath(pszAbsPath);
   if (!pszSysPath)
      { reply("550 Invalid path"); return 1; }

   if (cs.verbose>=2)
      printf("use.sys: %s\n", pszSysPath);

   if (iClVDir > 0 && !strcmp(pszRelPath, "/")) {
      if (!bAllowRoot)
         reply("550 forbidden path");
      return 2;
   }

   if (bCheckDiskSpace && cs.diskspace) {
      num nTotal=0;
      char szFSName[200];
      char szVolID[200];
      uint nVolID=0;
      if (getFileSystemInfo(sysPath(), nTotal, nClDiskFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10, nVolID)) {
         reply("552 No disk space info");
         return 1;
      }
      if (nClDiskFree < cs.diskspace) {
         char szBuf1[100],szBuf2[100];
         if (cs.quiet < 2)
            printf("# out of disk space. free=%s mb, limit=%s mb\n",
               numtoa(nClDiskFree/1000000,0,szBuf1), numtoa(cs.diskspace/1000000,0,szBuf2));
         reply("552 Out of disk space");
         return 1;
      }
   }

   return 0;
}

int FTPServer::addTrailSlash(char *pszBuf, int iMaxBuf)
{
   int iLen = strlen(pszBuf);
   if (iLen < 1) {
      strcpy(pszBuf, "/");
      return 0;
   }
   if (pszBuf[iLen-1] == '/')
      return 0;
   if (iLen >= iMaxBuf-10)
      return 0;
   strcat(pszBuf, "/");
   return 0;
}

void FTPServer::stripTrailSlash(char *pszPath)
{
   char *psz = strrchr(pszPath, '/');
   if (psz!=0 && psz>pszPath)
      *psz = '\0';
}

char *FTPServer::notslash(char *pszPath)
{
   strcopy(szClTmpPathBuf, pszPath);
   char *psz = strrchr(szClTmpPathBuf, '/');
   if (psz!=0 && psz>szClTmpPathBuf)
      *psz = '\0';
   return szClTmpPathBuf;
}

bool FTPServer::pathTraversal(char *pszFile, bool bDeep)
{
   if (!strlen(pszFile)) return 1;

   int ilen = strlen(pszFile);

   // posix style
   if (*pszFile=='/') return 1;
   if (!strcmp(pszFile, ".")) return 1;
   if (!strcmp(pszFile, "./")) return 1;
   if (!strcmp(pszFile, "/")) return 1;
   if (!strcmp(pszFile, ".."))  return 1;
   if (!strncmp(pszFile, "../", 3)) return 1;
   if (strstr(pszFile, "/../")) return 1;
   if (ilen >= 3 && !strcmp(pszFile + ilen - 3, "/.."))
      return 1;

   // windows style
   if (*pszFile=='\\') return 1;
   if (!strcmp(pszFile, ".\\")) return 1;
   if (!strcmp(pszFile, "\\")) return 1;
   if (!strncmp(pszFile, "..\\", 3)) return 1;
   if (strstr(pszFile, "\\..\\")) return 1;
   if (ilen >= 3 && !strcmp(pszFile + ilen - 3, "\\.."))
      return 1;

   if (!bDeep)
   {
      if (strstr(pszFile, "/")) return 1;
      if (strstr(pszFile, "\\")) return 1;
   }

   return 0;
}

int FTPServer::checkPath(char *pszPath, bool bDeep)
{
   if (pathTraversal(pszPath, bDeep)) {
      reply("550 invalid path");
      if (!cs.verbose && !cs.quiet)
         printf("] invalid path: %s\n", pszPath);
      return 9;
   }
   return 0;
}

// default: no subdirs, include root dir, no hidden files
int FTPServer::setLocalWalkDir(char *pszDir)
{
   glblFileSet.reset();
   if (glblFileSet.beginLayer(false, __LINE__))
      { reply("500 internal error"); return 9; }
   glblFileSet.addRootDir(pszDir, __LINE__, false);
   glblFileSet.autoCompleteFileMasks(3);
   glblFileSet.setBaseLayer();

   cs.subdirs = 0;
   cs.withrootdirs = 1;
   cs.hidden = 0;

   return 0;
}

int FTPServer::reply(cchar *pszMask, ...)
{
   va_list argList;
   va_start(argList, pszMask);
   ::vsnprintf(szClReplyBuf, sizeof(szClReplyBuf)-10, pszMask, argList);
   szClReplyBuf[sizeof(szClReplyBuf)-10] = '\0';

   strcat(szClReplyBuf, "\r\n");

   if (cs.verbose) printf("< %s", szClReplyBuf);

   int nSent = send(hClClient, szClReplyBuf, strlen(szClReplyBuf), 0);

   if (nSent != (int)strlen(szClReplyBuf)) {
      bClSendFailed = 1;
      return 9;
   }

   return 0;
}

int FTPServer::replyFromRC(int iSubRC)
{
   cchar *info = "unknown error";

   switch (iSubRC)
   {
      case FTPRC_Stopped       : info = "Stopped by admin"; break;
      case FTPRC_OutOfDiskSpace: info = "Out of disk space"; break;
      case FTPRC_WriteFailed   : info = "Write failed"; break;
   }

   reply("%03u %s", iSubRC, info);

   return 0;
}

// see also forward decl. for default parms
int FTPServer::readLine( )
{
   char *pszLineBuf = szLineBuf;
   int   nMode = 0;

   int lRC = readLineSub(hClClient, pszLineBuf, nMode);

   // sft101: optional skip records to enforce socket flushing
   if (!strncmp(szLineBuf, "SKIP ", 5)) 
   {
      // read intermediate skip record
      uint nLen = (uint)atol(szLineBuf+5);
      if (nLen > sizeof(abBuf)-10) nLen = sizeof(abBuf)-10;
      if (nLen) receiveBlock(hClClient, abBuf, nLen, "SKIP");

      // now read the actual record
      lRC = readLineSub(hClClient, pszLineBuf, nMode);
   }

   return lRC;
}

int FTPServer::run(uint nPort, bool bRW, bool bRun, bool bDeep, uint nPort2)
{__
   prepareTCP();

   // user, authpw, runpw have been set by env and options
   if (!szClRunPW[0])
      strcopy(szClRunPW, szClAuthPW); // if any

   bClDeep = bDeep;

   bGlblFTPReadWrite = bRW;

   socklen_t nSoLen = sizeof(sockaddr_in);

   hClServer   = INVALID_SOCKET;
   hClClient   = INVALID_SOCKET;
   hClPasServ  = INVALID_SOCKET;
   hClData     = INVALID_SOCKET;

   bClSendFailed = 0;

   uint  nPasPort = 0;

   cchar *ppreip = "";
   cchar *pownip = "";
   cchar *pposip = ". ";
   char szRepBuf[200];

   int   namount = 0;
   pownip = ownIPList(namount, 0);

   if (strlen(pownip))
   {
      ppreip = ", IP ";
      pposip = " - ";
      // on multiple ip's, create another line
      if (strlen(pownip) > 20)
         pposip = ".\n";
   }

   int nDefSFTVer = 105;
   // 104: support for CWD, MKD, DELE, RMD
   // 105: linux based file attributes with sfk extensions

   if (makeServerSocket(nPort, clServerAdr, hClServer, "server main port", nPort2)) return 9;

   printf("SFK Instant FTP %d. For help, type \"sfk ftpserv -help\".\n", nDefSFTVer);
   if (bRW)
      printf("waiting on port %u%s%s%swrite allowed, %u MB limit per file. ", nPort, ppreip, pownip, pposip, nGlblTCPMaxSizeMB);
   else
      printf("waiting on port %u%s%s%sonly read allowed. ", nPort, ppreip, pownip, pposip);
   printf("%d sec timeout.\n",cs.timeOutMSec / 1000);

   int iRunRC=0,iAnim=0;
   
   // ----- single client accept loop -----
   while (!userInterrupt())
   {
      hClClient = accept(hClServer, (struct sockaddr *)&clClientAdr, &nSoLen);
      if (hClClient == INVALID_SOCKET) {
         int nerr = netErrno();
         if (nerr == WSAEWOULDBLOCK) { doSleep(50); continue; }
         perr("accept on server main port failed\n");
         iRunRC = 9;
         break;
      }
      setBlocking(hClClient, 1);

      strcpy(szClWorkDir, "/");

      // this is set if reply() fails to send
      bClSendFailed = 0;

      // set default mode compatible to old clients
      cs.verify = 1;

      // default for SFT version, may be downgraded:
      int nSFTVer = nDefSFTVer;

      // list IP of client machine
      struct in_addr addr;
      memcpy(&addr,&clClientAdr.sin_addr,sizeof(struct in_addr));
      char *premip = inet_ntoa(addr);
      printf("> connect from %s\n", premip);

      // login, pseudo-authentication
      if (reply("220 sfk instant ftp, %d sec timeout. sft %d.", cs.timeOutMSec / 1000, nSFTVer))
         { closesocket(hClClient); continue; }
      if (readLine()) { closesocket(hClClient); continue; } // > USER username
      removeCRLF(szLineBuf);

      char szClientUser[100],szClientPW[100];
      mclear(szClientUser);
      mclear(szClientPW);

      // expecting: "USER username".
      // if client uses a wrong protocol, we should detect it now.
      bool startsLikeHttpCommand(char *psz);
      if (startsLikeHttpCommand(szLineBuf)) {
         reply("500 wrong protocol (http), please use ftp://");
         shutdown(hClClient, SHUT_WR);
         closesocket(hClClient); continue;
      }
      if (stribeg(szLineBuf, "feat")) {
         reply("211-Features:");
         reply(" MDTM");
         reply(" SIZE");
         reply("211 End");
         if (readLine()) { closesocket(hClClient); continue; } // > USER username
         removeCRLF(szLineBuf);
      }
      if (!stribeg(szLineBuf, "user ")) {
         reply("530 missing username");
         shutdown(hClClient, SHUT_WR);
         closesocket(hClClient); continue;
      }
      strcopy(szClientUser, szLineBuf+5);
      if (reply("331 User name ok, need password")) { closesocket(hClClient); continue; }
      if (readLine()) { closesocket(hClClient); continue; } // > PASS passwd
      removeCRLF(szLineBuf);

      if (!strncmp(szLineBuf, "PASS sft", 8)) {
         int nClientSFT = atol(szLineBuf+8);
         if (cs.quiet < 2)
            printf("> client speaks sft: %d\n", nClientSFT);
         char *pszPW = strchr(szLineBuf+8, '@');
         if (pszPW) strcopy(szClientPW, pszPW+1);
         // auto-adapt to client SFT version
         if (nClientSFT >= 101)
            nSFTVer = nClientSFT;
         if (nClientSFT >= 103) {
            // default since 103 is no verify,
            // may be changed by following SCHK.
            cs.verify = 0;
         }
      }
      else
      if (!strncmp(szLineBuf, "PASS ", 5))
         strcopy(szClientPW, szLineBuf+5);

      if (szClAuthUser[0])
      {
         if (!szClientUser[0]) {
            if (!cs.quiet)
               printf("> missing client username\n");
            reply("530 missing authentication.");
            continue;
         }
         if (strcmp(szClientUser, szClAuthUser)) {
            if (!cs.quiet)
               printf("> wrong client username (%s/%s)\n", szClientUser, szClAuthUser);
            reply("530 wrong authentication.");
            doSleep(1000);
            continue;
         }
         if (cs.verbose)
            printf("> client user ok.\n");
      }

      if (szClAuthPW[0])
      {
         if (!szClientPW[0]) {
            if (!cs.quiet)
               printf("> missing client pw\n");
            reply("530 missing authentication.");
            continue;
         }
         if (strcmp(szClientPW, szClAuthPW)) {
            if (!cs.quiet)
               printf("> wrong client pw\n");
            reply("530 wrong authentication.");
            doSleep(1000);
            continue;
         }
         if (!cs.quiet)
            printf("> client pw ok.\n");
      }
      // the RunPW, if any, is checked later.

      if (reply("230 User logged in")) { closesocket(hClClient); continue; }
      if (cs.quiet == 1)
         printf("> client connected.\n");

      // inits per client
      mclear(szClRenameFrom);

      // ----- client command loop -----
      int nbail = 0;
      while (!bClSendFailed && (nbail < 3))
      {
         int lTimeout = cs.timeOutMSec;
         num t1 = getCurrentTime();
         bool bOtherCon = 0;
         while (getCurrentTime() < t1 + lTimeout)
         {
            if (hasData(hClClient, 500))
               break;
            if (cs.autoclose && hasData(hClServer, 500)) {
               if (!cs.quiet)
                  printf("# new incoming connection, closing current\n");
               reply("226 closing connection due to new client");
               bOtherCon = 1;
               break;
            }
            if (userInterrupt())
               break;
            doSleep(10);
         }
         if (bOtherCon || userInterrupt())
            break;
         if (getCurrentTime() >= t1 + lTimeout) {
            reply("500 inactivity timeout (%d sec)", lTimeout/1000);
            if (cs.quiet == 1)
               printf("> client disconnected (timeout).\n");
            break;
         }

         // use readline without implicite skip processing
         if (readLineSub(hClClient, szLineBuf, 0)) break;
         removeCRLF(szLineBuf);

         mclear(szClAbsPathBuf);
         mclear(szClSysPathBuf);
         mclear(szClTmpPathBuf);
         
         if (stribeg(szLineBuf, "help")) { nbail=0;
            reply("214-Possible commands:");
            reply("   USER   PASS   QUIT   CWD    PWD    PORT   PASV");
            reply("   CDUP   RETR   STOR   SIZE   DELE   SYST   MDTM");
            reply("   LIST   NLST   MKD    RMD    RMTREE FEAT");
            reply("   TYPE  (only binary transfer supported)");
            reply("214 Command list end.");
            continue;
         }
         else
         if (stribeg(szLineBuf, "feat")) { nbail=0;
            reply("211-Features:");
            reply(" MDTM");
            reply(" SIZE");
            reply("211 End");
            continue;
         }
         else
         if (   stricase(szLineBuf, "NOOP")
             || stribeg(szLineBuf, "ALLO ")
            )
         { 
            nbail=0;
            reply("200 OK");
            continue;
         }
         else
         if (stribeg(szLineBuf, "SYST")) { nbail=0;
            reply("215 UNIX emulated by SFK.");
            continue;
         }
         else
         if (stribeg(szLineBuf, "TYPE ")) { nbail=0;
            reply("200 Command OK");
            continue;
         }
         else
         if (stribeg(szLineBuf, "SCHK ")) { nbail=0;
            int iMode = atoi(szLineBuf+5);
            if (iMode >= 0 && iMode < 2) {
               cs.verify = iMode ? 1 : 0;  
               reply("200 CheckMode=%d", iMode);
            } else {
               reply("502 checkmode not supported");
            }
            continue;
         }
         else
         if (   stribeg(szLineBuf, "PWD")
             || stribeg(szLineBuf, "XPWD")
            ) 
         {  nbail=0;
            reply("257 \"%s\" is current directory.", szClWorkDir);
            continue;
         }
         else
         if (stribeg(szLineBuf, "SIZE ")) { nbail=0;
            num nFileSize=0;
            switch (mapPath(szLineBuf+5,1)) {
               case 1: continue;
               case 2: break;
               default:
                  nFileSize = getFileSize(sysPath());
            }
            reply("213 %s", numtoa(nFileSize));
            continue;
         }
         else
         if (stribeg(szLineBuf, "MDTM ")) { nbail=0;
            // MDTM 20060604111037
            num nFileTime=0;
            switch (mapPath(szLineBuf+5,1)) {
               case 1: continue;
               case 2: 
                  reply("213 %s", timeAsString(0, 1));
                  continue;
               default:
                  nFileTime = getFileTime(sysPath());
            }
            if (nFileTime <= 0)
               reply("550 no such file");
            else
               reply("213 %s", timeAsString(nFileTime, 1));
            continue;
         }
         else
         if (stricase(szLineBuf, "RETR /")) { nbail=0;
            reply("550 File not found");
            closesocket(hClData);
            hClData = INVALID_SOCKET;
            continue;
         }
         else
         if (stribeg(szLineBuf, "CWD ")) { nbail=0; // since 104
            strcopy(szClOldWorkDir, szClWorkDir);
            char *pszRawPath = szLineBuf+4;
            if (   !strcmp(pszRawPath, ".")
                || !strncmp(pszRawPath, "./", 2)) {
               reply("550 Invalid dir");
               continue;
            }
            if (!strcmp(pszRawPath, "/")) {
               strcpy(szClWorkDir, "/");
               reply("250 CWD OK. \"%s\"", notslash(szClWorkDir));
               continue;
            }
            while (!strncmp(pszRawPath, "..", 2)) {
               char *psz = szClWorkDir+strlen(szClWorkDir);
               if (psz <= szClWorkDir)
                  break;
               if (psz[-1] == '/')
                  psz--;
               while (psz > szClWorkDir && psz[-1] != '/')
                  psz--;
               if (psz <= szClWorkDir+1) {
                  strcpy(szClWorkDir, "/");
               } else {
                  *psz = '\0';
               }
               pszRawPath += 2;
               if (*pszRawPath!='/')
                  break;
               pszRawPath++;
            }
            // cd .. or ../../.. to top level
            if (!strcmp(szClWorkDir, "/") && !pszRawPath[0]) {
               reply("250 CWD OK. \"%s\"", szClWorkDir);
               continue;
            }
            // cd ../ or ../../../ to any level
            if (!strcmp(pszRawPath, "/")) {
               reply("250 CWD OK. \"%s\"", szClWorkDir);
               continue;
            }
            // cd thedir /thedir ../thedir/subdir
            if (pszRawPath[0]) {
               switch (mapPath(pszRawPath,1)) {
                  case 1:
                     strcopy(szClWorkDir, szClOldWorkDir);
                     continue;
                  case 2: 
                     strcpy(szClWorkDir, "/");
                     break;
                  default:
                     strcopy(szClWorkDir, absPath());
               }
            } else {
               if (!strcmp(szClWorkDir, "/"))
                  { }
               else
               if (szClWorkDir[0]!='/' || pathTraversal(szClWorkDir+1, bDeep)) {
                  strcopy(szClWorkDir, szClOldWorkDir);
                  reply("550 Invalid dir");
                  continue;
               }
            }
            if (!isDir(sysPath(szClWorkDir))) {
               strcopy(szClWorkDir, szClOldWorkDir);
               reply("550 No such directory");
               continue;
            }
            addTrailSlash(szClWorkDir, sizeof(szClWorkDir));
            reply("250 CWD OK. \"%s\"", notslash(szClWorkDir));
            continue;
         }
         else
         if (   stricase(szLineBuf, "CDUP")
             || stricase(szLineBuf, "XCUP")
            )
         {  nbail=0; // since 104
            char *psz = strrchr(szClWorkDir, '/');
            if (psz!=0 && psz>szClWorkDir)
               *psz='\0';
            else
               strcpy(szClWorkDir, "/");
            reply("250 CWD OK. \"%s\"", notslash(szClWorkDir));
         }
         else
         if (   stribeg(szLineBuf, "MKD ")
             || stribeg(szLineBuf, "XMKD ")
            )
         {  nbail=0; // since 104
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            char *pszRawDir = szLineBuf+4;
            if (stribeg(szLineBuf, "XMKD "))
                  pszRawDir = szLineBuf+5;
            switch (mapPath(pszRawDir,0,1)) { // w/disk space check
               case 1: continue;
               case 2: 
                  reply("532 Write not allowed");
                  continue;
            }
            #ifdef _WIN32
            if (_mkdir(sysPath()))
            #else
            if (mkdir(sysPath(), S_IREAD | S_IWRITE | S_IEXEC))
            #endif
               reply("550 Cannot create. err=%d/%s",errno,strerror(errno));
            else
               reply("257 \"%s\" created.", absPath());
            continue;
         }
         else
         if (stribeg(szLineBuf, "PASV"))
         {
            nbail=0;
            // establish passive data connection server on demand
            if (hClPasServ == INVALID_SOCKET) {
               nPasPort = 0; // find new local port
               if (makeServerSocket(nPasPort, clPasServAdr, hClPasServ, "passive server port"))
                  break;
            }
            int   ihowmany = 1; // force first ip
            char *pszOwnIP = ownIPList(ihowmany);
            char *psz = 0;
            while (psz = strchr(pszOwnIP, '.'))
               *psz = ',';
            if (cs.verbose)
               printf("- reply pasv with ip %s\n", pszOwnIP);
            if (reply("227 Entering Passive Mode (%s,%u,%u)",pszOwnIP,(nPasPort>>8),(nPasPort&0xFF)))
               break;
            if (hClData != INVALID_SOCKET)
               closesocket(hClData);

            if (cs.verbose)
               printf("- wait for accept on %s:%u\n", pszOwnIP, nPasPort);
            setStart();
            while (!isTimeout(3000))
            {
               nSoLen = sizeof(sockaddr_in);
               hClData  = accept(hClPasServ, (struct sockaddr *)&clClientAdr, &nSoLen);
               if (hClData == INVALID_SOCKET) {
                  int nerr = netErrno();
                  if (nerr == WSAEWOULDBLOCK) { doSleep(10); continue; }
                  perr("accept on passive port failed\n");
                  break;
               }
               else
                  break;
            }
            if (bClTimeout) { perr("accept timeout for passive port\n"); break; }
            setBlocking(hClData, 1);
            if (cs.verbose)
               printf("> accept done\n");

            if (hClData == INVALID_SOCKET)
               { perr("passive accept failed\n"); break; }
         }
         else
         if (stribeg(szLineBuf, "PORT ")) 
         {
            nbail=0;
            // establish active data connection
            uchar n[6];
            char *psz = szLineBuf+strlen("PORT ");
            for (int i=0; i<6; i++) {
               n[i] = (uchar)atol(psz);
               psz = strchr(psz+1, ',');
               if (psz) psz++; else break;
            }
            char szIP[50];
            sprintf(szIP, "%d.%d.%d.%d",n[0],n[1],n[2],n[3]);
            uint nPort = (((uint)n[4])<<8)|((uint)n[5]);
            if (connectSocket(szIP, nPort, clDataAdr, hClData, "active data")) break;
            reply("200 Okay");
         }
         else
         if (stribeg(szLineBuf, "LIST")) // ftp.list: ftp full detail
         {
            if (hClData == INVALID_SOCKET) {
               reply("503 Wrong command sequence");
               continue;
            }

            int lRC=0,nbail=0;
            
            char *pszAbsDir = szClWorkDir;
            char *pszParm = szLineBuf+4;
            bool  bstop = 0;
            bool  bhidden = 0;
            while (!bstop && *pszParm) {
               skipWhite(&pszParm);
               if (!strcmp(pszParm, "-a"))
                  { pszParm+=2; bhidden=1; continue; }
               if (strBegins(pszParm, "-a "))
                  { pszParm+=3; bhidden=1; continue; }
               if (pszParm[0]=='-') {
                  reply("501 unsupported option: %s", pszParm);
                  continue;
               }
               // dir or file parameter from client
               switch (mapPath(pszParm,1)) {
                  case 1: bstop=1; continue;
                  default:
                     pszAbsDir = absPath();
                     break;
               }
               break;
            }
            if (bstop) continue;

            // list the dir.
            char *pszSys = str(glblPathStr);
            if (!strcmp(pszAbsDir, "/") && iClVDir) {
               // virtual dir list
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
               hGlblTCPOutSocket = hClData;
               for (int i=0; i<iClVDir; i++) {
                  char *pvdir = aClVDirSrc[i];
                  if (*pvdir!='/') continue;
                  strcopy(szClTmpPathBuf, pvdir+1);
                  stripTrailSlash(szClTmpPathBuf);
                  execVDirFTPList(szClTmpPathBuf);
               }
            } else {
               // real file list
               if (*pszAbsDir!='/')
                  { reply("550 invalid work dir"); continue; }
               if (!(pszSys = sysPath(pszAbsDir)))
                  { reply("550 invalid work dir"); continue; }
               if (setLocalWalkDir(pszSys))
                  continue;
   
               cs.subdirs = 0;
               cs.withrootdirs = 0;
               cs.hidden = bhidden;
   
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
   
               bGlblFTPListFlatTS = 0;  // ux style time stamps
               bGlblFTPListTextBin = 0; // no text/binary info
   
               int lFiles=0, lDirs=0;
               num nBytes=0;
               hGlblTCPOutSocket = hClData;
               lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
            }

            closesocket(hClData); hClData = INVALID_SOCKET;

            if (cs.verbose) {
               if (lRC==0 && cs.verbose>1)
                  printf("- done list \"%s\"\n", pszSys);
               if (lRC!=0)
                  printf("- done list, rc=%d: \"%s\"\n", lRC, pszSys);
            }

            reply("226 Closing data connection");
         }
         else
         if (stribeg(szLineBuf, "NLST")) // ftp.list: ftp no detail
         {
            if (hClData == INVALID_SOCKET) {
               reply("503 Wrong command sequence");
               continue;
            }

            int lRC=0,nbail=0;

            char *pszAbsDir = szClWorkDir;
            char *pszParm = szLineBuf+4;
            bool  bstop = 0;
            bool  bhidden = 0;
            while (!bstop && *pszParm) {
               skipWhite(&pszParm);
               if (!strcmp(pszParm, "-a"))
                  { pszParm+=2; bhidden=1; continue; }
               if (strBegins(pszParm, "-a "))
                  { pszParm+=3; bhidden=1; continue; }
               if (pszParm[0]=='-') {
                  reply("501 unsupported option: %s", pszParm);
                  continue;
               }
               // dir or file parameter from client
               switch (mapPath(pszParm,1)) {
                  case 1: bstop=1; continue;
                  default:
                     pszAbsDir = absPath();
                     break;
               }
               break;
            }
            if (bstop) continue;

            // list the dir.
            char *pszSys = str(glblPathStr);
            if (!strcmp(pszAbsDir, "/") && iClVDir) {
               // virtual dir list
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
               // nothing to do - vdir has no files
            } else {
               // real file list
               if (*pszAbsDir!='/')
                  { reply("550 invalid work dir"); continue; }
               if (!(pszSys = sysPath(pszAbsDir)))
                  { reply("550 invalid work dir"); continue; }
               if (setLocalWalkDir(pszSys))
                  continue;
   
               cs.subdirs = 0;
               cs.withrootdirs = 0;
               cs.hidden = bhidden;
   
               if (reply("150 Listing Directory %s", pszAbsDir)) break;

               bGlblFTPListFlatTS = 0;  // ux style time stamps
               bGlblFTPListTextBin = 0; // no text/binary info

               int lFiles=0, lDirs=0;
               num nBytes=0;
               hGlblTCPOutSocket = hClData;
               lRC = walkAllTrees(eFunc_FTPNList, lFiles, lDirs, nBytes);
            }

            closesocket(hClData); hClData = INVALID_SOCKET;

            if (cs.verbose) {
               if (lRC==0 && cs.verbose>1)
                  printf("- done list \"%s\"\n", pszSys);
               if (lRC!=0)
                  printf("- done list, rc=%d: \"%s\"\n", lRC, pszSys);
            }

            reply("226 Closing data connection");
         }
         else
         if (stribeg(szLineBuf, "RETR ")) 
         {
            nbail=0;
            if (hClData == INVALID_SOCKET) {
               reply("500 internal error 1");
               continue;
            }
            // send file
            strcpy(szLineBuf2, szLineBuf);
            if (!mapPath(szLineBuf2+5)) {
               reply("150 Sending File");
               if (cs.quiet < 2)
                  printf("send file: \"%s\"\n", absPath());
               int lRC = sendFileRaw(hClData, sysPath());
               if (cs.quiet < 2)
                  printf("send file done, RC %d\n", lRC);
            }
            closesocket(hClData); hClData = INVALID_SOCKET;
            reply("226 Closing data connection");
         }
         else
         if (stribeg(szLineBuf, "STOR ")) 
         {
            nbail=0;
            if (hClData == INVALID_SOCKET) {
               reply("500 internal error 2");
               continue;
            }
            int iSubRC = 0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW)
               reply("532 Write not allowed");
            else
            if (!mapPath(szLineBuf2+5,0,1)) { // w/disk space check
               if (reply("150 Receiving File")) break;
               if (cs.verbose)
                  printf("> recv file: \"%s\"\n", absPath());
               iSubRC = receiveFileRaw(hClData, sysPath(), -1, 0,0,0, nClDiskFree); // stor
               if (cs.verbose || iSubRC)
                  printf("> recv file done, RC %d\n", iSubRC);
            }
            closesocket(hClData); hClData = INVALID_SOCKET;
            if (iSubRC)
               replyFromRC(iSubRC);
            else
               reply("226 Closing data connection");
         }
         else
         if (stribeg(szLineBuf, "RNFR ")) // since 104
         {
            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            // remember rename source name
            if (mapPath(szLineBuf2+5))
               continue;
            if (!fileExists(sysPath(), 1)) {
               reply("550 file not found: %s", absPath());
               continue;
            }
            strcopy(szClRenameFrom, sysPath());
            reply("350 File exists, please send target name.");
         }
         else
         if (stribeg(szLineBuf, "RNTO ")) // since 104
         {
            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               mclear(szClRenameFrom);
               continue;
            }
            if (mapPath(szLineBuf2+5)) {
               mclear(szClRenameFrom);
               continue;
            }
            if (fileExists(sysPath(), 1)) {
               reply("550 file exists: %s", absPath());
               mclear(szClRenameFrom);
               continue;
            }
            if (!szClRenameFrom[0]) {
               reply("503 Bad command sequence");
               mclear(szClRenameFrom);
               continue;
            }
            int iSubRC = rename(szClRenameFrom, sysPath());
            if (iSubRC)
               reply("500 rename failed (%s)", mystrerr());
            else
               reply("250 rename successful");
            mclear(szClRenameFrom);
         }
         else
         if (stribeg(szLineBuf, "DELE ")) // since 104
         {
            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            // delete file
            if (mapPath(szLineBuf2+5))
               continue;
            remove(sysPath());
            reply("250 OK DELETED");
         }
         else
         if (   stribeg(szLineBuf, "RMD ") // since 104
             || stribeg(szLineBuf, "XRMD ")
            )
         {
            // standard behaviour of RMD is to delete the dir only
            // if it's empty. ftp clients have high effort to walk
            // through everything to delete a directory tree.

            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            // delete directory tree
            char *pszRawDir = szLineBuf2+4;
            if (stribeg(szLineBuf, "XRMD "))
                  pszRawDir = szLineBuf2+5;
            if (mapPath(pszRawDir))
               continue;
            // RMD thedir/
            char *pszDir = sysPath();
            if (!isDir(pszDir)) {
               reply("550 no such directory");
               continue;
            }

            int nrc = rmdir(pszDir);
            if (nrc)
               reply("300 DELETE FAILED. err=%d,%s. (try rmtree?)", errno, strerror(errno));
            else
               reply("250 OK DELETED");
         }
         else
         if (stribeg(szLineBuf, "RMTREE ")) // sfk only, since sft 107
         {
            // especially for interactive command line clients,
            // SFK server allows to remove a dir tree instantly.

            nbail=0;
            strcpy(szLineBuf2, szLineBuf);
            if (!bRW) {
               reply("532 Write not allowed");
               continue;
            }
            // delete directory tree
            if (mapPath(szLineBuf2+7))
               continue;
            // RMD thedir/
            char *pszDir = sysPath();
            if (!isDir(pszDir)) {
               reply("550 no such directory");
               continue;
            }

            if (setLocalWalkDir(pszDir))
               continue;

            cs.subdirs  = 1;
            cs.withdirs = 1;
            cs.hidden   = 1;

            int lFiles=0,lDirs=0; num nBytes=0;
            if (walkAllTrees(eFunc_Delete, lFiles, lDirs, nBytes))
               reply("300 DELETE INCOMPLETE");
            else
               reply("250 OK DELETED");
         }
         else
         if (stribeg(szLineBuf, "QUIT")) { nbail=0;
            break;
         }
         else
         if (   stribeg(szLineBuf, "SGET ")
             || stribeg(szLineBuf, "SOPEN ")
            )
         { 
            nbail = 0;

            bool bBlockMode = 0;

            // save linebuf as it's reused below
            char *pszRelFile = szLineBuf+5;
            if (strBegins(szLineBuf, "SOPEN ")) {
                 bBlockMode = 1;
                 pszRelFile = szLineBuf+6;
            }
            if (mapPath(pszRelFile))
               continue;

            // sft file retrieve, within control connection
            char *pszLocFile = sysPath();
            if (!fileExists(pszLocFile))
               { reply("550 no such file, or unreadable"); continue; }

            reply("200 OK, data follows");

            {
               // sending a file from server to client by SFT: here, the ack "OK\n\n"
               // is often overhauled by connection close from client, therefore server
               // doesn't verify it. should there be errors, then they're shown at client only.
               Coi *pcoi = new Coi(pszLocFile, 0);
               CoiAutoDelete odel(pcoi, 0); // no decref
               int lRC = putFileBySFT(hClClient, pcoi, nSFTVer, 0, 1, bBlockMode); // not quiet, ignore ack
               if (cs.quiet < 2 && lRC > 0)
                  info.print("send sft file done, RC %d\n", lRC);
            }
         }
         else
         if (stribeg(szLineBuf, "SPUT ")) { nbail=0;
            if (!bRW)
               reply("532 Write not allowed");
            else {
               // sft receive file, via control connection
               strcpy(szLineBuf2, szLineBuf);
               if (mapPath(szLineBuf2+5,0,1)) // w/disk space check
                  continue;
               if (bDeep)
                  createOutDirTree(sysPath()); // sput
               if (Coi::forceWriteable(sysPath()) >= 9) {
                  reply("500 cannot write: %s", absPath());
                  // break;
               } else {
                  reply("200 OK, send data");
                  // if (cs.quiet < 2)
                  //    printf("> recv sft file: \"%s\"\n", pszFile);
                  int lRC = getFileBySFT(hClClient, sysPath(), nSFTVer, 0,0,nClDiskFree);
                  if (cs.quiet < 2 && lRC > 0)
                     info.print("recv sft file done, RC %d\n", lRC);
                  if (lRC) break; // block potential content remainder
               }
            }
            // getFileBySFT includes ack send
         }
         else
         if (   stribeg(szLineBuf, "SLST") // ftp.list: sft full detail
             || stribeg(szLineBuf, "SLSB") // with text/binary info
            )
         { 
            int lRC=0,nbail=0;

            // since SFT 105: no text/binary infos by default.
            // if client wants those, SLSB is required.
            bool bWithTextBin = stribeg(szLineBuf, "SLSB") ? 1 : 0;

            char *pszAbsDir = szClWorkDir;
            char *pszParm = szLineBuf+4;
            bool  bstop = 0;
            bool  bhidden = 0;
            while (!bstop && *pszParm) {
               skipWhite(&pszParm);
               if (!strcmp(pszParm, "-a"))
                  { pszParm+=2; bhidden=1; continue; }
               if (strBegins(pszParm, "-a "))
                  { pszParm+=3; bhidden=1; continue; }
               if (pszParm[0]=='-') {
                  reply("501 unsupported option: %s", pszParm);
                  continue;
               }
               // dir or file parameter from client
               switch (mapPath(pszParm,1)) {
                  case 1: bstop=1; continue;
                  default:
                     pszAbsDir = absPath();
                     break;
               }
               break;
            }
            if (bstop) continue;

            // list the dir.
            char *pszSys = str(glblPathStr);
            if (!strcmp(pszAbsDir, "/") && iClVDir) {
               // virtual dir list
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
               hGlblTCPOutSocket = hClClient;
               for (int i=0; i<iClVDir; i++) {
                  char *pvdir = aClVDirSrc[i];
                  if (*pvdir!='/') continue;
                  strcopy(szClTmpPathBuf, pvdir+1);
                  stripTrailSlash(szClTmpPathBuf);
                  execVDirFTPList(szClTmpPathBuf);
               }
            } else {
               // real file list
               if (*pszAbsDir!='/')
                  { reply("550 invalid work dir"); continue; }
               if (!(pszSys = sysPath(pszAbsDir)))
                  { reply("550 invalid work dir"); continue; }
               if (setLocalWalkDir(pszSys))
                  continue;
   
               cs.subdirs = 0;
               cs.withrootdirs = 0;
               cs.hidden = bhidden;
   
               if (reply("150 Listing Directory %s", pszAbsDir)) break;
   
               bGlblFTPListFlatTS = 1;  // flat time stamps
               bGlblFTPListTextBin = bWithTextBin;
   
               int lFiles=0, lDirs=0;
               num nBytes=0;
               hGlblTCPOutSocket = hClClient;
               lRC = walkAllTrees(eFunc_FTPList, lFiles, lDirs, nBytes);
            }

            if (cs.verbose) {
               if (lRC==0 && cs.verbose>1)
                  printf("- done list \"%s\"\n", pszSys);
               if (lRC!=0)
                  printf("- done list, rc=%d: \"%s\"\n", lRC, pszSys);
            }

            reply("226 Listing done");
         }
         else
         if (stribeg(szLineBuf, "SRUN")) { nbail=0;
            // execute user command, IF -run option was set
            if (!bRun)
               reply("500 run forbidden");
            else 
            if (!szClientPW[0] || !szClRunPW[0])
               reply("530 run requires authentication");
            else
            if (strcmp(szClientPW, szClRunPW)) {
               if (cs.verbose)
                  printf("/%s/%s/\n",szClientPW, szClRunPW);
               reply("530 wrong run authentication");
            }
            else
            {
               int lRC = system(szLineBuf+5);
               reply("200 Run Done, RC %d", lRC); // 226, 250
            }
         }
         else
         if (!strncmp(szLineBuf, "SKIP ", 5)) { nbail=0;
            // dummy record follows, to enforce line flush.
            // should be far smaller than abBuf.
            uint nLen = (uint)atol(szLineBuf+5);
            if (nLen > sizeof(abBuf)-10) nLen = sizeof(abBuf)-10;
            if (nLen) receiveBlock(hClClient, abBuf, nLen, "SKIP");
            // no ack sending
         }
         else {
            if (reply("500 not supported: \"%.20s\"", szLineBuf))
               break;
            // count invalid command, maybe connection is out of control:
            nbail++;
            // on 3rd invalid command, connection will be dropped.
         }
      }  // endwhile

      if (cs.quiet < 2)
         printf("disconnecting client\n");
      closesocket(hClClient);
   }

   closesocket(hClServer);

   #ifdef _WIN32
   WSACleanup();
   #endif

   return iRunRC;
}

#endif // WITH_TCP

#ifndef USE_SFK_BASE

class TestDB
{
public:
   TestDB   (char *pszFile);
  ~TestDB   ( );
   int     load     (bool bSilent);
   int     write    ( );
   void     shutdown ( );

   int     update   (char *pszInKey, char *pszInVal);
   char    *getValue (char *pszInKey);

private:
   char  *pszClFile;
   StringTable clKeys;
   StringTable clVals;
};

TestDB::TestDB(char *pszFile)
{
   pszClFile = strdup(pszFile);
}

TestDB::~TestDB() { shutdown(); }

void TestDB::shutdown() {
   if (pszClFile) { delete [] pszClFile; pszClFile = 0; }
}

// uses szLineBuf
int TestDB::load(bool bSilent) {
   FILE *fin = fopen(pszClFile, "r");
   if (!fin) {
      if (!bSilent)
         perr("unable to load %s\n", pszClFile); 
      return 9; 
   }
   int nLine = 0;
   while (fgets(szLineBuf, sizeof(szLineBuf)-10, fin)) {
      nLine++;
      removeCRLF(szLineBuf);
      char *psz = strchr(szLineBuf, ':');
      if (!psz) {
         perr("wrong record format in %s line %d\n", pszClFile, nLine); 
         fclose(fin);
         return 9; 
      }
      *psz = '\0';
      char *pszVal = psz+1;
      char *pszKey = szLineBuf;
      clKeys.addEntry(pszKey);
      clVals.addEntry(pszVal);
   }
   fclose(fin);
   return 0;
}

int TestDB::write() {
   FILE *fout = fopen(pszClFile, "w");
   if (!fout) return 9+perr("unable to write %s\n", pszClFile);
   int nRec = clKeys.numberOfEntries();
   for (int i=0; i<nRec; i++) {
      char *pszKey = clKeys.getEntry(i, __LINE__);
      char *pszVal = clVals.getEntry(i, __LINE__);
      if (!pszKey || !pszVal) { fclose(fout); return 9; }
      fprintf(fout, "%s:%s\n", pszKey, pszVal);
   }
   fclose(fout);
   return 0;
}

int TestDB::update(char *pszInKey, char *pszInVal) {
   int nRec = clKeys.numberOfEntries();
   for (int i=0; i<nRec; i++) {
      char *pszKey = clKeys.getEntry(i, __LINE__);
      char *pszVal = clVals.getEntry(i, __LINE__);
      if (!pszKey || !pszVal) return 9;
      if (!strcmp(pszKey, pszInKey)) {
         clVals.setEntry(i, pszInVal);
         return 0;
      }
   }
   // not yet contained:
   clKeys.addEntry(pszInKey);
   clVals.addEntry(pszInVal);
   return 0;
}

char *TestDB::getValue(char *pszInKey) {
   int nRec = clKeys.numberOfEntries();
   for (int i=0; i<nRec; i++) {
      char *pszKey = clKeys.getEntry(i, __LINE__);
      char *pszVal = clVals.getEntry(i, __LINE__);
      if (!pszKey || !pszVal) return 0;
      if (!strcmp(pszKey, pszInKey))
         return pszVal;
   }
   return 0;
}

#endif // USE_SFK_BASE

#ifndef USE_SFK_BASE
extern int patchMain(int argc, char *argv[], int noffs);
#endif // USE_SFK_BASE

static bool skipspace(char **ppsz) {
   char *psz = *ppsz;
   while (*psz && isspace(*psz))
      psz++;
   *ppsz = psz;
   return (*psz != 0);
}

static bool skipto(char **ppsz, char c) {
   char *psz = *ppsz;
   while (*psz && *psz != c)
      psz++;
   *ppsz = psz;
   return (*psz != 0);
}

int copyFormStr(char *pszDst, int nMaxDst, char *pszSrc, int nSrcLen, uint nflags)
{
   // flags: bit 0: convert also \, to ,

   // printf("copyFormStr \"%.*s\" %d spat=%d\n",(int)nSrcLen,pszSrc,nflags,cs.spat);

   char *pszin = pszSrc;
   int iout = 0;
   while (*pszin && (nSrcLen > 0))
   {
      if (iout >= nMaxDst-10)
         return 9+perr("format string too long: \"%s\"\n", pszSrc); 

      if (!cs.spat)
         { } // skip all following interpretations
      else
      if (nSrcLen>=4 && !strncmp(pszin, "\\x", 2)) {
         // \xnn - any character with hex code nn
         pszin+=2; nSrcLen-=2; // skip \x
         int nhex = getTwoDigitHex(pszin);
         if (nhex <= 0) return 9+perr("illegal value for \\xnn in format string. use 01 to FF, e.g. \\x09\n");
         pszin+=2; nSrcLen-=2; // skip nn
         pszDst[iout++] = (char)nhex;
         continue;
      }
      else
      if (cs.spat==2 && nSrcLen>=5 && !strncmp(pszin, "\\d", 2)) {
         // \dnnn - any character with decimal code nnn
         pszin+=2; nSrcLen-=2; // skip \d
         int ndec = getThreeDigitDec(pszin);
         if (ndec <= 0) return 9+perr("illegal value for \\dnnn in format string. use 001 to 255, e.g. \\d065\n");
         pszin+=3; nSrcLen-=3; // skip nnn
         pszDst[iout++] = (char)ndec;
         continue;
      }
      else
      if (nSrcLen>=2) {
         if (!strncmp(pszin, "\\\\", 2))
            { pszDst[iout++] = '\\'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\t", 2))
            { pszDst[iout++] = '\t'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\q", 2))
            { pszDst[iout++] = '"'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\n", 2))
            { pszDst[iout++] = '\n'; pszin+=2; nSrcLen-=2; continue; }
         else
         if (!strncmp(pszin, "\\r", 2))
            { pszDst[iout++] = '\r'; pszin+=2; nSrcLen-=2; continue; }
         else
         if ((nflags & 1) && !strncmp(pszin, "\\,", 2))
            { pszDst[iout++] = ','; pszin+=2; nSrcLen-=2; continue; }
      }
      pszDst[iout++] = *pszin++; 
      nSrcLen--;
   }
   pszDst[iout] = '\0';
   // printf("-> \"%s\"\n",pszDst);
   return 0;
}

#ifndef USE_SFK_BASE

class Phraser;

class Symbol
{
public:
   Symbol   (char *pszName, Phraser *parent);
   void     collect(char *pszContent);
   char    *name() { return szClName; }
   char    *solve(char *pout, int nmaxout, int nlevel, int istatic);
   bool     issep(char c);
   bool     ispunctortab(char c);
private:
   char     szClName[100];
   char     szClOpt[100];
   char     szClCont[1024];
   char     szClBuf[100];
   char     szClBuf2[200];
   // int      astatic[100];
   Phraser  *phraser;
};

class Phraser
{
public:
   Phraser  ();
   int     load(char *pszAll, char *pszData);
   int     load(char *pszFile);
   char    *solve(char *psz);
   int     add(Symbol *p);
   Symbol  *get(char *pszName,int *pstatic);
   void     reset();
   void     resetIndexes();
   int      astatic[1000+10];
private:
   void     fetch(char *pbuf, char *psrc, int nlen);
   char     *pszClFilename;
   char     szClBuf1[200];
   char     szClOut[10000];
   Symbol   *psym[1000];
   int     nsym;
};

Symbol::Symbol(char *pszName, Phraser *parent)
{
   memset(this,0,sizeof(*this));
   szClOpt[0] = '\0';
   if (cs.debug)
      printf(" create symbol: %s\n", pszName);
   char *pszopt = strchr(pszName, ',');
   if (pszopt) {
      strncpy(szClName, pszName, pszopt-pszName);
      szClName[pszopt-pszName] = '\0';
      strcopy(szClOpt, pszopt);
   } else {
      strcopy(szClName, pszName);
   }
   memset(szClCont, 0, sizeof(szClCont));
   phraser = parent;
}

bool Symbol::issep(char c)
{
   if (c == ',' || c== '\t')
      return 1;
   return 0;
}

bool Symbol::ispunctortab(char c)
{
   if (ispunct(c))
      return 1;
   if (c == '\t' || c == '\x01')
      return 1;
   return 0;
}

void Symbol::collect(char *pszContent)
{
   szLineBuf2[0] = '\0';
   copyFromFormText(pszContent, strlen(pszContent), szLineBuf2, MAX_LINE_LEN, 2);

   if (cs.debug)
      printf("   %s collects \"%s\"\n", szClName, szLineBuf2);

   strcat(szClCont, szLineBuf2);

   if (cs.debug)
      printf("   %s now holds \"%s\"\n", szClName, szClCont);
}

char *Symbol::solve(char *pout, int nmaxout, int nlevel, int istatic)
{
   if (cs.debug)
      printf(" %s %p solves \"%s\"\n", szClName, this, szClCont);

   char *pcont = szClCont;

   // if comma-separated phrases are given,
   // which are not escaped like \,
   bool biscsep = 0;
   char clast = 0;
   char *psz = 0;
   for (psz=pcont; *psz; psz++) {
      if (issep(*psz) == 1 && clast != '\\')
         {  biscsep=1; break; }
      clast = *psz;
   }

   if (biscsep)
   {
      // then random-select phrase

      // count phrases
      int nwords = 0;
      char *psz1 = pcont;
      for (clast=0; *psz1; psz1++) {
         if (issep(*psz1) == 1 && clast != '\\')
            nwords++;
         clast = *psz1;
      }
      nwords++;

      // select a phrase
      int itarg = 0;
      int imaxsymstat = (sizeof(phraser->astatic)/sizeof(int))-10;
      if (istatic > 0 && istatic < imaxsymstat) {
         if (phraser->astatic[istatic] < 0)
            phraser->astatic[istatic] = rand();
         itarg = phraser->astatic[istatic];
      } else {
         itarg = rand();
      }
      itarg = itarg % nwords;
      int iword = 0;
      psz1 = pcont;
      while (psz1 && *psz1) 
      {
         char *psz2 = psz1;
         for (clast=0; *psz2; psz2++) {
            if (issep(*psz2) == 1 && clast != '\\')
               break;
            clast = *psz2;
         }
         if (iword == itarg) {
            mystrcopy(szClBuf2, psz1, psz2-psz1+1);
            if (cs.debug)
               printf("   sel \"%s\"\n", szClBuf2);
            pcont = szClBuf2;
            break;
         }
         iword++;
         if (issep(*psz2) == 1) psz2++;
         while (*psz2 == ' ') psz2++;
         psz1 = psz2;
      }
      if (pcont == szClCont) {
         perr("syntax error: probably too many commas in line: %s\n",szClCont);
         return 0;
      }
   }

   int iout = strlen(pout);

   if (!strchr(pcont, '$')) {
      // solve terminal
      strcat(pout, pcont);
   } else {
      // solve non-terminal
      char *psz1 = pcont;
      while (psz1 && *psz1) 
      {
         char *psz2 = psz1;
         // find next sub symbol call, if any
         while (*psz2 && *psz2 != '$') psz2++;
         if (*psz2 == '$') 
         {
            // flush pre-symbol content
            if (psz2 > psz1) {
               mystrcopy(szClBuf, psz1, psz2-psz1+1);
               if (cs.debug)
                  printf("   cat \"%s\"\n", szClBuf);
               strcat(pout, szClBuf);
            }
            // then solve sub symbol
            char *psz3 = psz2+1;
            while (   *psz3 && *psz3 != ' ' 
                   && *psz3 != '\\'
                   && !ispunctortab(*psz3)) psz3++;
            mystrcopy(szClBuf, psz2, psz3-psz2+1); // +1 for mystrcopy
            if (cs.debug)
               printf("  call \"%s\"\n", szClBuf);
            int istatic=0;
            Symbol *psub = phraser->get(szClBuf,&istatic);
            if (!psub) { perr("no such symbol: \"%s\"\n", szClBuf); return 0; }
            if (!psub->solve(pout, nmaxout, nlevel+1, istatic)) return 0;
            if (!strncmp(psz3, "\\+", 2))
               psz3 += 2;
            psz1 = psz3;
            if (cs.debug)
               printf("   now on \"%s\"\n",psz1);
            // strcat(pout, " ");
            continue;
         }
         // none found: flush rest of line
         if (cs.debug)
            printf("   cat \"%s\"\n", psz1);
         strcat(pout, psz1);
         // strcat(pout, " ");
         break;
      }
   }

   // post-process output:
   // printf("%02d appended \"%s\" at offs %d\n",nlevel,pout+iout,iout);

   // apply options, if any
   int nlen = strlen(pout);
   if (strstr(szClOpt, "upper") || strstr(szClOpt, "anycase"))
   {
      // random-vary word casing
      int ncase = 0;
      if (strstr(szClOpt, "anycase")) ncase = rand() % 4;
      if (strstr(szClOpt, "upper2"))  ncase = rand() % 2;
      // printf("%02d MIXCASE %d %c of %.30s\n",nlevel,ncase,pout[iout],pout+iout);
      int i=0;
      switch (ncase) {
         case 0: pout[iout] = toupper(pout[iout]); break;
         case 1:
            for (i=iout; i<nlen; i++)
               pout[i] = toupper(pout[i]);
            break;
         case 2: pout[iout] = tolower(pout[iout]); break;
         case 3:
            for (i=iout; i<nlen; i++)
               pout[i] = tolower(pout[i]);
            break;
         // case 4: break; // leave as it is
      }
   }

   // convert format strings
   for (psz=pout+iout; *psz; psz++) {
      char brep=0;
      if (clast == '\\')
       switch (*psz) {
         case ',' : brep=',' ; break;
         case 't' : brep='t' ; break;
         case '\t' : brep='\t' ; break;
         case 'n' : brep='n' ; break;
         case '\\': brep='\\'; break;
       }
      if (brep) {
         // standing on "," of "\,"
         psz--;
         memmove(psz, psz+1, strlen(psz+1)+1);
         clast = 0;
         *psz = brep;
      } else {
         clast = *psz;
      }
   }

   return pout;
}

Phraser::Phraser()
{
   pszClFilename = 0;
   memset(szClBuf1, 0, sizeof(szClBuf1));
   memset(psym, 0, sizeof(psym));
   nsym = 0;
   resetIndexes();
}

void Phraser::resetIndexes()
{
   int imaxsymstat=sizeof(astatic)/sizeof(int);
   for (int i=0; i<imaxsymstat; i++)
      astatic[i]=-1;
}

void Phraser::reset()
{
   for (int i=0; i<nsym; i++)
      delete psym[i];
   nsym = 0;
}

int Phraser::add(Symbol *p)
{
   if (nsym > (int)(sizeof(psym)/sizeof(Symbol*))-5)
      return 9+perr("too many symbols\n");
   psym[nsym++] = p;
   return 0;
}

Symbol *Phraser::get(char *pszNameIn,int *pstatic)
{
   char szName[200];
   strcopy(szName, pszNameIn);
   int istatic=0;
   if (isdigit(szName[1])) {
      istatic=atoi(szName+1);
      int imove=1;
      while (isdigit(szName[imove]))
         imove++;
      memmove(szName+1,szName+imove,strlen(szName+imove)+1);
      if (pstatic)
         *pstatic=istatic;
   }
   for (int i=0; i<nsym; i++) {
      if (!psym[i])
         return 0;
      if (!strcmp(psym[i]->name(), szName))
         return psym[i];
   }
   return 0;
}

void Phraser::fetch(char *pbuf, char *psrc, int nlen) {
   if (nlen > (int)sizeof(szClBuf1)-4)
      {  perr("buffer overflow.1\n"); exit(9); }
   strncpy(pbuf, psrc, nlen);
   pbuf[nlen] = '\0';
}

int Phraser::load(char *pszAll, char *pszData)
{
   char *pszSymb = 0;
   Symbol *ps = 0;
   int nstate = 1, nline = 0;
   int  iLineLen = 0;
   bool bAddLineFeed = 0;

   char *pszSrcCur = pszData;
   char *pszNext   = 0;

   while (*pszSrcCur)
   {
      if (pszAll) {
         snprintf(szLineBuf, MAX_LINE_LEN, "all: %s", pszAll);
         pszAll = 0;
      } else {
         pszNext = strchr(pszSrcCur, '\n');
         if (!pszNext)
            pszNext = pszSrcCur + strlen(pszSrcCur);
         int ilen = (int)(pszNext - pszSrcCur);
         if (ilen > MAX_LINE_LEN)
             ilen = MAX_LINE_LEN;
         memcpy(szLineBuf, pszSrcCur, ilen);
         szLineBuf[ilen] = '\0';
      }

      // symbol: word1 word2 $symbol word4
      //         word5 $symbol word6 ...
      removeCRLF(szLineBuf);
      nline++;

      if (cs.debug)
         printf("LINE \"%s\"\n", szLineBuf);

      char *psz1 = szLineBuf;

      if (szLineBuf[0]=='#' || szLineBuf[0]=='\0')
      {
         // skip
      }
      else
      while (psz1 && *psz1)
      {
         if (cs.debug)
            printf("state %d on \"%s\"\n", nstate, psz1);
         char *psz2 = psz1;
         switch (nstate)
         {
            case 1:  // expect new symbol name
               if (!skipto(&psz2, ':'))
                  return 9+perr("syntax error: missing \"symbol:\" in line %d\n", nline);
               fetch(szClBuf1, psz1, psz2-psz1);
               pszSymb = szClBuf1;
               psz1 = psz2+1;
               nstate = 2;
               break;

            case 2:  // expect content in symbol name line
               if (!skipspace(&psz2))
                  return 9+perr("syntax error: missing content after \"%s:\"\n", pszSymb);
               ps = new Symbol(pszSymb, this);
               if (add(ps)) return 9;
            case 4:
               if (!skipspace(&psz2))
                  return 9+perr("syntax error in line %d\n",nline);
               iLineLen = strlen(psz2);
               bAddLineFeed = 0;
               if (iLineLen >= 2 && strncmp(psz2+iLineLen-2, "\\n", 2) == 0) {
                  psz2[iLineLen-2] = '\0';
                  bAddLineFeed = 1;
               }
               ps->collect(psz2);
               psz1 = 0;
               nstate = 3;
               break;

            case 3:  // either additional content, or new symbol name
               if (*psz2 == ' ') {
                  // additional content
                  if (bAddLineFeed)
                     ps->collect(str("\n"));
                  else
                     ps->collect(str(" "));
                  nstate = 4;
                  continue;
               } else {
                  // new symbol name
                  nstate = 1;
                  continue;
               }
         }
      }

      if (pszNext) {
         pszSrcCur = pszNext;
         if (*pszSrcCur)
            pszSrcCur++;
      }
   }

   return 0;
}

char *Phraser::solve(char *pszName)
{
   // e.g. solving "all"
   Symbol *proot = get(pszName,0);
   if (!proot) return 0;
   szClOut[0] = '\0';
   char *pres = proot->solve(szClOut, sizeof(szClOut)-10, 0, 0);
   // convert ,, replacement code back to printable ,
   if (pres) {
      char *psz = pres;
      while ((psz = strchr(psz, 0x01)))
         *psz++ = ',';
   }
   return pres;
}

#endif // USE_SFK_BASE

int encodeUrl(char *pszSrcIn, char *pszDstIn, int nMaxDst)
{
    char *pszSrc = pszSrcIn;
    char *pszDst = pszDstIn;

    // mtklog(("ENCODE \"%s\"\n",pszSrc));

    static const char *pszUnsafe = "\"<>%\\^[]`+$,@:;/!#?=&";
    int nrem = nMaxDst-2;
    for (; *pszSrc; pszSrc++)
    {
        uchar uc = (uchar)*pszSrc;
        if (    strchr(pszUnsafe, (char)uc)
            ||  uc <= 32
            ||  uc >= 123
            )
        {
            if (nrem < 4) {
                *pszDst = '\0'; 
                // mtklog(("OFLOW: \"%s\", \"%s\"", pszSrcIn, pszDstIn));
                return 9+perr("encodeUrl buffer overflow\n"); 
            }
            sprintf(pszDst, "%%%02X", uc);
            pszDst += 3;
            nrem   -= 3;
        }
        else {
            *pszDst++ = (char)uc;
            nrem--;
        }
    }
    *pszDst = '\0';
    return 0;
}

int decodeUrl(char *pszInOut)
{
    char *psz = pszInOut;
    while (*psz) {
        if (    *psz == '%'
            &&  isxdigit(*(psz+1))  // also catches terminator
            &&  isxdigit(*(psz+2))  // also catches terminator
           )
        {
            char ahex[10];
            ahex[0] = *(psz+1);
            ahex[1] = *(psz+2);
            ahex[2] = '\0';
            uchar abin[10];
            if (hexToBin(ahex, abin, 1)) {
                if (!cs.quiet)
                    pwarn("wrong url entity code: %%%s\n", ahex);
                psz++;
            } else {
                *psz = (char)abin[0];
                psz++;
                memmove(psz, psz+2, strlen(psz+2)+1); // incl. terminator
            }
        }
        else
            psz++;
    }
    return 0;
}

// -------- base64 en/decoding ----------

// also used by makepw w/o last 2 chars
static const char aenc64[] = 
   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
   "0123456789+/";

void encodeSub64(uchar in[3], uchar out[4], int nlen)
{
   out[0] = aenc64[in[0] >> 2];
   out[1] = aenc64[((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
   out[2] = (uchar)(nlen > 1 ? aenc64[((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6)] : '=');
   out[3] = (uchar)(nlen > 2 ? aenc64[in[2] & 0x3f ] : '=');
}

// rc  0: ok
// rc >0: error
int encode64(uchar *psrc, int nsrc, uchar *pdst, int nmaxdst, int nlinechars)
{
   uchar in[3], out[4];
   int i=0, nlen=0, nchars = 0;

   uchar *pmaxsrc = psrc + nsrc;
   uchar *pmaxdst = pdst + nmaxdst;
   
   while (psrc < pmaxsrc)
   {
      nlen = 0;
      for (i = 0; i < 3; i++ ) 
      {
         if (psrc < pmaxsrc) {
            in[i] = *psrc++;
            nlen++;
         } else {
            in[i] = 0;
         }
      }
      if (nlen) {
         encodeSub64(in, out, nlen);
         for (i = 0; i < 4; i++ ) {
            if (pdst >= pmaxdst-1)
               return 9;   // output buffer overflow
            *pdst++ = out[i];
         }
         nchars++;
      }
      if (nchars >= (nlinechars/4) || (psrc >= pmaxsrc)) {
         if (nchars) {
            if (pdst < pmaxdst-3) {
               *pdst++ = '\r';
               *pdst++ = '\n';
            }
         }
         nchars = 0;
      }
   }

   // zero terminate output as it's a string
   *pdst = '\0';

   return 0;
}

void decodeSub64(uchar in[4], uchar out[3])
{   
   out[0] = (uchar)(in[0] << 2 | in[1] >> 4);
   out[1] = (uchar)(in[1] << 4 | in[2] >> 2);
   out[2] = (uchar)(((in[2] << 6) & 0xc0) | in[3]);
}

// return valid value+1, or 0 if it is noise.
uchar mapchar(char ch)
{
   if ((ch >= 'A') && (ch <= 'Z'))
      return (uchar)(ch - 'A')+1;
   else if ((ch >= 'a') && (ch <= 'z'))
      return (uchar)(ch - 'a' + 26)+1;
   else if ((ch >= '0') && (ch <= '9'))
      return (uchar)(ch - '0' + 52)+1;
   else if (ch == '+')
      return 62+1;
   else if (ch == '/')
      return 63+1;
   return 0;
}

// result: number of bytes decoded, or -1 on error
int decode64(uchar *psrc, int nsrc, uchar *pdst, int nmaxdst)
{
   uchar in[4], out[3], v;
   int i=0, nlen=0;
   
   uchar *pmaxsrc = psrc + nsrc;
   uchar *pmaxdst = pdst + nmaxdst;
   uchar *pdstraw = pdst;

   while (psrc < pmaxsrc) {
      for (nlen=0, i=0; i < 4 && (psrc < pmaxsrc); i++ ) {
         v = 0;
         while ((psrc < pmaxsrc) && v == 0) {
            v = *psrc++;
            v = mapchar(v);
         }
         if (psrc < pmaxsrc) {
            nlen++;
            if (v) in[i] = v - 1;
         } else {
            in[i] = 0;
         }
      }
      if (nlen) {
         decodeSub64(in, out);
         for (i=0; i<nlen-1; i++) {
            if (pdst >= pmaxdst)
               return -1;
            *pdst++ = out[i];
         }
      }
   }

   // no zero termination as it's a binary

   return pdst - pdstraw;
}

// convert "*pattern" or "pattern*" to pattern with left/right flags isolated.
int copyMatchPattern(char *pszDst, int nMaxDst, char *pszSrc, int &rSrcLen,
   bool &rFromLeft, bool &rToRight, bool &rForceRepeat
   )
{
   rFromLeft = 0;
   rToRight  = 0;
   int icopyoff  = 0;
   int nSrcLen   = rSrcLen;
   int ncopylen  = nSrcLen;
   if (cs.wpat && pszSrc[0] == '*') {
      rFromLeft = 1;
      rForceRepeat = 1;
      icopyoff++;
      ncopylen--;
   }
   if (cs.wpat && ncopylen > 0 && pszSrc[nSrcLen-1] == '*') {
      int nslash = 0;
      if (cs.spat) {
         // the '*' might be escaped, as in \\\\\*
         // if there is an EVEN (or zero) no. of slashes before '*',
         // then '*' really is an active wildcard.
         for (int k=nSrcLen-2; k>=0; k--) {
            if (pszSrc[k] == '\\')
               nslash++;
            else
               break;
         }
      }
      if (!(nslash & 1)) {
         rToRight = 1;
         rForceRepeat = 1;
         ncopylen--;
      }
   }
   if (ncopylen > nMaxDst-1) return 9+perr("buffer overflow: pattern too large: \"%s\"\n", pszSrc);
   memcpy(pszDst, pszSrc+icopyoff, ncopylen);
   pszDst[ncopylen] = '\0';
   rSrcLen = ncopylen;
   return 0;
}

int reperr(cchar *pszMsg, cchar *pszObj, char *pszRepFile, int nLine)
{
   if (pszRepFile)
      perr("%s: %s [within %s:%d]\n", pszMsg, pszObj, pszRepFile, nLine);
   else
      perr("%s: %s\n", pszMsg, pszObj);
      
   if (!strcmp(pszMsg, "unexpected command")) {
      if (pszRepFile)
         pinf("use :text or :binary followed by pattern lines\n");
      else
         pinf("use -text ... or -binary ...\n");
   }
   pinf("patterns must look like _src_dst_ or \"/from/ to /\"\n");
   pinf("if \"%s\" is a single filename, specify it as first parameter.\n", pszObj);
   if (strchr(pszObj, '\"')) {
      pinf("surround your expression by two double quotes \"\n");
      pinf("escape inner quotes as \\\" or \\q (with -spat option)\n");
   }
   pinf("say -dir ... -file ... to specify multiple target files.\n");
   nGlblError = 1; // disable memory leak listing on parameter errors
   return 9;
}

// io: szLineBuf. also uses szLineBuf2.
// io: szAttrBuf. also uses szAttrBuf2.
int applyReplace(char *pszPat, int &rHitCnt, bool blstart, bool blend)
{__
   // _src_dest_
   char szSrc[200];
   char szDst[200];

   // isolate source and destination.
   char *psz1 = pszPat;
   char cbnd = '\0'; // boundary char
   if (*psz1) cbnd = *psz1++;
   char *pszSrc1 = psz1;
   while (*psz1 && (*psz1 != cbnd))
      psz1++;
   if (!*psz1) return 9+perr("illegal replacement string \"%s\"\n", pszPat);
   char *pszSrc2 = psz1;
   psz1++;
   char *pszDst1 = psz1;
   while (*psz1 && (*psz1 != cbnd))
      psz1++;
   if (!*psz1) return 9+perr("illegal replacement string \"%s\"\n", pszPat);
   char *pszDst2 = psz1;
   int nSrcLen = pszSrc2-pszSrc1;
   int nDstLen = pszDst2-pszDst1;
   if (nSrcLen < 1) return 9+perr("source pattern is empty\n");
   if (nSrcLen > (int)sizeof(szSrc)-10) return 9+perr("source pattern too large \"%.*s\"\n", nSrcLen, pszSrc1);
   if (nDstLen > (int)sizeof(szDst)-10) return 9+perr("destination pattern too large \"%.*s\"\n", nDstLen, pszDst1);
   psz1++; // step past final cbnd
   if (*psz1) {
      perr("wrong replacement string syntax \"%s\"\n", pszPat);
      pinf("if \"%c\" is the delimiter then \"%s\" is unexpected.\n",cbnd,psz1);
      return 9;
   }

   if (cs.debug)
      printf("aprep: input src %.*s\n", (int)nSrcLen, pszSrc1);

   // if source starts or ends with *
   bool bFromLeft    = 0;
   bool bToRight     = 0;
   bool bForceRepeat = 0;  // repeat replace although *\\ etc supplied
   if (copyMatchPattern(szSrc, sizeof(szSrc)-10, pszSrc1, nSrcLen, bFromLeft, bToRight, bForceRepeat))
      return 9;
   // -> sets szSrc, nSrcLen, bFromLeft, bToRight.

   if (nSrcLen < 1)
      return 9+perr("wrong source pattern. try \\%c or option -literal to replace %c\n",glblWildChar,glblWildChar);

   // convert \\ \t \n \r \x in destination
   if (copyFormStr(szDst, sizeof(szDst)-10, pszDst1, nDstLen))
      return 9;
   // if (cs.debug) printf("replace dst \"%.*s\" => \"%s\" len %d => %d\n",(int)nDstLen,pszDst1,szDst,nDstLen,strlen(szDst));
   nDstLen = strlen(szDst); // adapt to \t, \x conversions

   int nflags = cs.usecase ? eMatchCase : 0;
   int ifirst=0, ihitlen=0;

   if (cs.debug)
      printf("aprep: fromleft %d toright %d szsrc %s\n", bFromLeft, bToRight, szSrc);

   // apply replacements
   psz1 = szLineBuf;
   int ibase   = 0; // used ONLY for single line end replacing
   int ntmplen = strlen(szLineBuf); // ditto
   while (1)
   {
      ifirst=0; ihitlen=0;
      if (!matchstr(psz1+ibase, szSrc, nflags, ifirst, ihitlen))
         break;

      // replace start of line?
      if (blstart) {
         if (ifirst != 0)
            break; // no hit
         // else fall through. there is no further loop cycle.
      }

      // replace end of line?
      if (blend) {
         if ((ibase+ifirst+ihitlen) != ntmplen) {
            // no hit as it's not (yet) at line end:
            // step-thru by incrementing ibase
            ibase += ifirst+ihitlen;
            continue;
         }
         // found hit: fix ifirst, as rest is ignoring ibase
         ifirst += ibase;
         // fall through. there is no further loop cycle.
      }

      if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
      if (bToRight)   { ihitlen = strlen(psz1+ifirst); }

      psz1   += ifirst;    // to 1st char of hit
      nSrcLen = ihitlen;

      // left part, before hit
      int nLenLeft = psz1-szLineBuf;
      strncpy(szLineBuf2, szLineBuf, nLenLeft);
      szLineBuf2[nLenLeft] = '\0';
      strncpy(szAttrBuf2, szAttrBuf, nLenLeft);
      szAttrBuf2[nLenLeft] = '\0';
      if (cs.debug) printf("rleft \"%s\" ifirst %d\n",szLineBuf2,ifirst);

      // replace middle part, check output length
      int nLenRep  = strlen(szDst);
      char *pszSrcRite = psz1+nSrcLen;
      int nLenRite = strlen(pszSrcRite);
      if (nLenLeft + nLenRep + nLenRite >= MAX_LINE_LEN) {
         perr("buffer overflow during replace");
         pinf("input lines might be too long, or too many changes per line.\n"); 
         pinf("if input is stream text, you may try filter -wrap +filter ...\n");
         return 9;
      }
      strcat(szLineBuf2, szDst);
      memset(&szAttrBuf2[nLenLeft], 'a', nLenRep);
      szAttrBuf2[nLenLeft+nLenRep] = '\0';
      if (cs.debug) printf("rmid  \"%s\"\n",szDst);

      // step continue position to post-insert
      psz1 = szLineBuf+strlen(szLineBuf2);

      // right part, after hit
      strcat(szLineBuf2, pszSrcRite);
      strcat(szAttrBuf2, szAttrBuf+nLenLeft+nSrcLen);
      if (cs.debug) printf("rrite \"%s\"\n",pszSrcRite);

      // copy back result
      strcpy(szLineBuf, szLineBuf2);
      strcpy(szAttrBuf, szAttrBuf2);
      if (cs.debug) printf("rout: \"%s\"\n",szLineBuf);

      rHitCnt++;

      // if replacing linestart or lineend
      if (bFromLeft || bToRight)
         if (!bForceRepeat)
            break; // after first hit

      // replacing line start or end is a single operation
      if (blstart || blend)
         break;
   }
   return 0;
}

char aMaskSep[200];
bool isMaskSep(char c) {
   if (strchr(aMaskSep, c))
      return true;
   return false;
}

#define WITH_EVAL

#ifdef WITH_EVAL
static char szGlblFormEvalBuf[MAX_LINE_LEN+100];

// evaluate inner content of "$(column+100)"
int evalFormBlock(char *pfrom, char *pto,
   StringTable &oCol,
   int nSrcLine,
   int nDstLine
   )
{__
   char szword[100]; szword[0] = '\0';
   char szform[100]; szform[0] = '\0';

   int ncurval = 0;
   int nmixval = 0;

   char ccurop  = '\0';
   bool bquoted = 0;

   static char szFormTmpBuf[MAX_LINE_LEN+100];

   szGlblFormEvalBuf[0] = '\0';
   szFormTmpBuf[0] = '\0';

   char *pOutBuf = szFormTmpBuf;

   int ntype = 0; // 1:string 2:int

   char *psz1 = pfrom;
   char *psz2 = 0;
   for (; *psz1 && (psz1 < pto); psz1=psz2)
   {
      // format spec as first word?
      char *pszf = psz1;
      if (!ntype && !szform[0]) 
      {
         bool bfirst = 1;
         while (*pszf) {
            char c = *pszf;
            if (isdigit(c) || (c=='-' && bfirst) || c=='.' || c=='q')
               pszf++;
            else
               break;
            bfirst = 0;
         }
         // if directly followed by an op, it's not a format
         switch (*pszf) {
            case '+': case '-':
               pszf = psz1;
               break;
         }
         if (pszf > psz1) {
            int nlen = pszf-psz1;
            if (nlen > (int)sizeof(szform)-10)
               return 11+perr("format overflow: %s", psz1);
            memcpy(szform, psz1, nlen);
            szform[nlen] = '\0';
            // check and strip quotation
            bquoted = 0;
            if (nlen > 0 && szform[nlen-1] == 'q') {
               bquoted = 1;
               szform[nlen-1] = '\0';
            }
            psz1 = pszf;
            // if followed by a ':', force as format and skip ':'
            if (*psz1 == ':')
               psz1++;
         }
      }

      // operator or word?
      if (!isalnum(*psz1)) {
         switch (*psz1) {
            case '+':
            case '-':
               ccurop = *psz1;
               psz2 = psz1+1;
               continue;
            default:
               return 6+perr("unexpected: %s", psz1);
         }
      }

      psz2 = psz1;
      while (isalnum(*psz2)) psz2++;

      int nlen = psz2-psz1;
      if (nlen < 1 || nlen > (int)sizeof(szword)-10)
         return 8;
      memcpy(szword, psz1, nlen);
      szword[nlen] = '\0';

      // printf("WORD: %s ntype=%d ccurop=%c\n",szword,ntype,ccurop);

      if (strBegins(szword, "col"))
      {
         // parse column number
         int ncol = atol(szword+3);
         if (ncol < 1 || ncol-1 >= oCol.numberOfEntries()) {
            // non-existing column: leave empty
            // TODO: optionally issue a notice
         } else {
            // use column text
            char *pszcol = oCol.getEntry(ncol-1, __LINE__);
            int nlen = strlen(pszcol);
            int nrem = MAX_LINE_LEN - strlen(pOutBuf);
            // what to do with this column content?
            switch (ntype) {
               default:
                  // string mode: simply append
                  if (nrem < nlen)
                     return 10+perr("string buffer overflow");
                  strcat(pOutBuf, pszcol);
                  ntype = 1;
                  break;
               case 2:
                  // int mode: convert string to int
                  if (!isdigit(*pszcol))
                     return 12+perr("not a number: %s", pszcol);
                  ncurval = atol(pszcol);
                  // int processing is done below
                  break;
            }
         }
      }
      else
      if (!strcmp(szword, "line")) { 
         ncurval = nSrcLine;
         ntype = 2;
      }
      else
      if (!strcmp(szword, "count")) {
         ncurval = nDstLine;
         ntype = 2;
      }
      else
      if (isdigit(szword[0])) {
         ncurval = atol(szword);
         ntype = 2;
      }

      if (ntype == 2)
         switch (ccurop) {
            case '+': nmixval += ncurval; break;
            case '-': nmixval -= ncurval; break;
            default : nmixval += ncurval; break;
         }
   }

   // auto-convert result?
   if (ntype == 2)
      sprintf(pOutBuf, "%d", nmixval);

   // copy and reformat result
   if (szform[0]) {
      // "-10.10col1" -> "%-10.10s"
      char szform2[50];
      const char *pquot = bquoted ? "\"" : "";
      snprintf(szform2, sizeof(szform2)-10, "%s%%%ss%s", pquot, szform, pquot);
      snprintf(szGlblFormEvalBuf, MAX_LINE_LEN, szform2, pOutBuf);
   } else {
      strcopy(szGlblFormEvalBuf, pOutBuf);
   }

   return 0;
}
#endif

static bool isWordChar(char c)
{
   if (c >= 'a' && c <= 'z') return 1;
   if (c >= 'A' && c <= 'Z') return 1;
   if (c == '_') return 1;
   return 0;
}

// io: szLineBuf. also uses szLineBuf2.
int applyForm(char *pszPat, bool bBlockSep, int nLineNum, int nOutLineNum)
{__
   StringTable oCol;

   // parse szLineBuf, split into columns
   char *psz1 = szLineBuf;
   char *psz2 = 0;

   if (bBlockSep)
      while (*psz1 && isMaskSep(*psz1))
         psz1++;

   while (*psz1)
   {
      psz2 = psz1;
      while (*psz2 && !isMaskSep(*psz2))
         psz2++;

      // have column from psz1 to psz2
      strncpy(szLineBuf2, psz1, psz2-psz1);
      szLineBuf2[psz2-psz1] = '\0';
      oCol.addEntry(szLineBuf2);

      // continue past separator, find next token
      if (bBlockSep) {
         // treat adjacent separators as one
         while (*psz2 && isMaskSep(*psz2))
            psz2++;
      } else {
         if (isMaskSep(*psz2))
            psz2++;
      }

      psz1 = psz2;
   }

   // oCol now holds all columns. apply mask.
   psz1 = pszPat;
   szLineBuf[0] = '\0';
   int iOut = 0;
   char *psz3 = 0;
   char szFormat1[100];
   char szFormat2[100];
   while (*psz1) 
   {
      psz2 = 0;

      if (*psz1==glblRunChar) 
      {
         // parse format info, if any
         psz2 = psz1+1;
         while (*psz2 && !strBegins(psz2, "col") && !strBegins(psz2, "line")
                 && !strBegins(psz2, "count") && !strBegins(psz2, "(")
               )
         {
            // let only -n.q pass as format prefixes
            char c = *psz2;
            if (isdigit(c) || c=='-' || c=='.' || c=='q')
               psz2++;
            else {
               psz2 = 0;
               break; 
            }
         }
      }

      if (psz2 && *psz2)
      {
         int nFormLen = psz2-psz1-1;
         if (nFormLen > (int)sizeof(szFormat1)-10)
            break;
         strncpy(szFormat1, psz1+1, nFormLen);
         szFormat1[nFormLen] = '\0';
         // quoted format prefix?
         bool bquoted = 0;
         if (nFormLen > 0 && szFormat1[nFormLen-1] == 'q') {
            bquoted = 1;
            szFormat1[nFormLen-1] = '\0';
         }
         if (!strncmp(psz2, "col(start:", 10)) 
         {
            // parse column mask
            psz2 += 10;
            psz3 = szLineBuf2;
            while (*psz2!='\0' && *psz2!=')')
               *psz3++ = *psz2++;
            *psz3 = '\0';
            if (*psz2==')') psz2++;
            // search oCol table for column starting like this
            int imasklen = strlen(szLineBuf2);
            char *pszAddText = str("");
            for (int icol=0; icol<oCol.numberOfEntries(); icol++) {
               char *pszcol = oCol.getEntry(icol, __LINE__);
               if (!mystrncmp(pszcol, szLineBuf2, imasklen, cs.usecase)) {
                  // match: take whole colum text
                  pszAddText = pszcol;
                  break;
               }
            }
            {
               // add column
               if (bquoted) strcat(szLineBuf, "\"");
               if (strlen(szFormat1)) {
                  // use specified printf-like format.
                  // we cannot check this - user must know.
                  sprintf(szFormat2, "%%%ss", szFormat1);
                  sprintf(szLineBuf2, szFormat2, pszAddText);
                  strcat(szLineBuf, szLineBuf2);
               } else {
                  strcat(szLineBuf, pszAddText);
               }
               if (bquoted) strcat(szLineBuf, "\"");
            }
         }
         else
         if (!strncmp(psz2, "col", 3)) 
         {
            // parse column number
            psz2 += 3;
            psz3 = szLineBuf2;
            while (*psz2 && isdigit(*psz2))
               *psz3++ = *psz2++;
            *psz3 = '\0';
            int ncol = atol(szLineBuf2);
            if (ncol < 1 || ncol-1 >= oCol.numberOfEntries()) {
               static bool btold = 0;
               if (!btold) {
                  btold = 1;
               }
            } else {
               // add column
               if (bquoted) strcat(szLineBuf, "\"");
               if (strlen(szFormat1)) {
                  // use specified printf-like format.
                  // we cannot check this - user must know.
                  sprintf(szFormat2, "%%%ss", szFormat1);
                  char *pszcol = oCol.getEntry(ncol-1, __LINE__);
                  sprintf(szLineBuf2, szFormat2, pszcol);
                  strcat(szLineBuf, szLineBuf2);
               } else {
                  char *pszcol = oCol.getEntry(ncol-1, __LINE__);
                  strcat(szLineBuf, pszcol);
               }
               if (bquoted) strcat(szLineBuf, "\"");
            }
         }
         else
         if (!strncmp(psz2, "line", 4)) 
         {
            // insert input line number, counting from 1
            psz2 += 4;
            char szNum[30];
            sprintf(szNum, "%u", (uint)nLineNum);
            char *pszcol = szNum;
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, pszcol);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, pszcol);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         else
         if (strBegins(psz2, "count"))
         {
            // insert output line number, counting from 1
            psz2 += strlen("count");
            char szNum[30];
            sprintf(szNum, "%u", (uint)nOutLineNum);
            char *pszcol = szNum;
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, pszcol);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, pszcol);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         #ifdef WITH_EVAL
         else
         if (strBegins(psz2, "("))
         {
            psz2++;
            char *pfrom = psz2;
            psz2 = strchr(psz2, ')');
            if (!psz2)
               return 9+perr("missing ')' on expression: %s", psz1);
            char *pto = psz2; // exclusive
            psz2++;
            int nrc = evalFormBlock(pfrom, pto, oCol, nLineNum, nOutLineNum);
            if (nrc)
               return 9+perr("cannot evaluate: %s (rc=%d)", pfrom, nrc);
            // result is in szGlblFormEvalBuf
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, szGlblFormEvalBuf);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, szGlblFormEvalBuf);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         #endif
         else
         if (strBegins(psz2, "(count"))
         {
            // insert output line number, counting from 1
            psz2 += strlen("(count");
            int nCntOffset = atol(psz2);
            psz2 = strchr(psz2, ')');
            if (!psz2)
               return 9+perr("(count not closed by ')'");
            psz2++;
            char szNum[30];
            sprintf(szNum, "%d", (int)(nOutLineNum+nCntOffset));
            char *pszcol = szNum;
            if (bquoted) strcat(szLineBuf, "\"");
            if (strlen(szFormat1)) {
               sprintf(szFormat2, "%%%ss", szFormat1);
               sprintf(szLineBuf2, szFormat2, pszcol);
               strcat(szLineBuf, szLineBuf2);
            } else {
               strcat(szLineBuf, pszcol);
            }
            if (bquoted) strcat(szLineBuf, "\"");
         }
         iOut = strlen(szLineBuf);
         // continue past token, including separator
         psz1 = psz2;
      } else {
         // apply \\t and \\xnn replacements, else copy
         if (cs.spat && !strncmp(psz1, "\\\\", 2)) {
            szLineBuf[iOut++] = '\\';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\t", 2)) {
            szLineBuf[iOut++] = '\t';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\q", 2)) {
            szLineBuf[iOut++] = '"';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\n", 2)) {
            szLineBuf[iOut++] = '\n';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\r", 2)) {
            szLineBuf[iOut++] = '\r';
            psz1 += 2;
         }
         else
         if (cs.spat && !strncmp(psz1, "\\x", 2)) {
            int n = getTwoDigitHex(psz1+2);
            if (n <= 0) return 9+perr("wrong syntax or not supported: %s\n", psz1);
            szLineBuf[iOut++] = (char)n;
            psz1 += 4;
         }
         else
            szLineBuf[iOut++] = *psz1++;
         szLineBuf[iOut] = '\0';
      }
   }

   return 0;
}

struct FilterParms 
{
   char  **argv;
   int  iPat;
   int  nPat;
   bool  bVerb;
   bool  bLNum;
   bool  bCnt;
   bool  bReWrite;
   bool  bDumpLF;
   bool  bSingleFile;
   bool  bSkipBinaries;
   bool  bFilenames;
   bool  bPassHitFiles;
   bool  bGlobalUnique;
   int  nTotalRC;
   char *pBlockMark;
   int  nprecon;
   int  npostcon;
   char  cprecolor;
   char  cpostcolor;
   char *pPreConMark;
   char *pPostConMark;
}
gfilter; // global filter settings

#define MAX_CONTEXT_LINES 105
class FilterContextLines
{
public:
      FilterContextLines   ( );
      void  shutdown       ( );

   void  putLine  (char *psz);
   char *getLine  (int   iPreIndex);
   void  reset    ( );

   char  szClLineTmp [MAX_LINE_LEN+100];
   char  szClAttrTmp [MAX_LINE_LEN+100];

private:
   char *aClLines [MAX_CONTEXT_LINES+4];
   char  aClValid [MAX_CONTEXT_LINES+4];
   int   iClIndex;
}
gfiltPreContext;

FilterContextLines::FilterContextLines( )
   { memset(this, 0, sizeof(*this)); }

void FilterContextLines::shutdown( ) 
{
   for (int i=0; i<MAX_CONTEXT_LINES; i++)
      if (aClLines[i])
         delete [] aClLines[i];
}

void FilterContextLines::reset( )
   { mclear(aClValid); }

void FilterContextLines::putLine(char *psz) 
{
   if (!aClLines[iClIndex])
      if (!(aClLines[iClIndex] = new char[MAX_LINE_LEN+100]))
         return;
   mystrcopy(aClLines[iClIndex], psz, MAX_LINE_LEN);
   aClValid[iClIndex] = 1;
   iClIndex = (iClIndex + 1) % MAX_CONTEXT_LINES;
}

// In : pre index >= 1
// Out: pre context line, or NULL if n/a
char *FilterContextLines::getLine(int iPreIndex) 
{
   if (iPreIndex < 1) return 0;
   int iCurIndex = iClIndex;
   for (int i=0; i<iPreIndex; i++) {
      if (--iCurIndex < 0)
         iCurIndex = MAX_CONTEXT_LINES-1;
      if (!aClValid[iCurIndex])
         return 0;
   }
   if (aClValid[iCurIndex])
      return aClLines[iCurIndex];
   return 0;
}

int getContextParms(char *psz, int &rlines, char &rcolor, char **ppConMark, int nlimit=0)
{
   rlines = atol(psz);
   if (nlimit > 0 && rlines > nlimit) {
      perr("-(pre)context supports only up to %d lines\n",nlimit);
      return 9;
   }
   while (*psz && isdigit(*psz))
      psz++;
   if (*psz==':' || *psz==',') 
   {
      // parse color
      char szcol[50];   
      char *pszs = ++psz;
      while (isalpha(*psz)) psz++;
      int nlen = psz - pszs;
      if (nlen > (int)sizeof(szcol)-10) return 0;
      memcpy(szcol, pszs, nlen);
      szcol[nlen] = '\0';
      if (szcol[0])
         rcolor = attribFromHumanColor(szcol, ' ');

      // parse marker
      if (*psz!=':' && *psz!=',')
         return 0;

      psz++;
      *ppConMark = psz;
   }
   return 0;
}

int setFilterParms(
   char *argv[], int argc, int iPat, int &nPat,
   struct FilterParms &rparms,
   char  **pszInFile,
   int   *iDir = 0,     // if dir parms are found
   int   *iChain = 0    // if further chaining is found
   )
{
   // valid options w/o parameters
   cchar *pszValFilt1[] = {
      "-+","-ls+","-le+","++","+ls+",
      "-!", "-ls!", "-le!", // accept win specific form
      "-:", "-ls:", "-le:", // and ux specific as well
      "-no-empty-lines", "-no-blank-lines",
      "-unique", "-keep-empty", "-keep-blank"
   };

   // valid options with one or more parameters
   cchar *pszValFilt2[] = {
      "1-pat", "1-notpat",
      "3-inc", "3-ex", "3-cut", "1-addmark",
      "1-keep"
   };

   // valid processing options w/o parms
   cchar *pszValOpt1[] = {
      "-encode-", "-decode-",
      "-ansitodos", "-todos", "-dostoansi",
      "-toupper", "-tolower",
      "-toiso", "-iso", "-toutf",
      "-ltrim", "-rtrim", "-trim"
   };

   // valid processing options with one parameter
   cchar *pszValOpt2[] = {
      "-rep","-lsrep","-lerep",
      "-sep","-blocksep","-form","-tabform","-noop",
      "-where","-lswhere","-lewhere",
      "-within","-lswithin","-lewithin"
   };

   // set processing options, check syntax
   bool bHadProc = 0;
   bool bHadFilt = 0;
   for (int iPat2=iPat; iPat2<argc; iPat2++)
   {
      char *pszOpt = argv[iPat2];
      if (!strcmp(pszOpt, "-lnum"))
         { rparms.bLNum = 1; continue; }
      if (!strcmp(pszOpt, "-count") || !strcmp(pszOpt, "-cnt"))
         { rparms.bCnt = 1; continue; }
      if (!strcmp(pszOpt, "-c")) // -case done in setGeneralOption
         { cs.usecase = 1; continue; }
      if (!strcmp(pszOpt, "-join"))
         { rparms.bDumpLF = 0; continue; }
      if (!strncmp(pszOpt, "-bin", 4))
         { rparms.bSkipBinaries = 0; continue; }
      if (!strncmp(pszOpt, "-nofile", 7))
         { rparms.bFilenames = 0; continue; }
      if (!strcmp(pszOpt, "-hitfiles"))
         { rparms.bPassHitFiles = 1; continue; }
      if (!strcmp(pszOpt, "-global-unique"))
         { rparms.bGlobalUnique = 1; continue; }

      if (strBegins(pszOpt, "-precontext="))
         { if (getContextParms(pszOpt+12, rparms.nprecon, rparms.cprecolor, &rparms.pPreConMark, MAX_CONTEXT_LINES-5)) return 9; continue; }
      if (strBegins(pszOpt, "-precon="))
         { if (getContextParms(pszOpt+8, rparms.nprecon, rparms.cprecolor, &rparms.pPreConMark, MAX_CONTEXT_LINES-5)) return 9; continue; }

      if (strBegins(pszOpt, "-postcontext="))
         { getContextParms(pszOpt+13, rparms.npostcon, rparms.cpostcolor, &rparms.pPostConMark); continue; }
      if (strBegins(pszOpt, "-postcon="))
         { getContextParms(pszOpt+9, rparms.npostcon, rparms.cpostcolor, &rparms.pPostConMark); continue; }

      if (strBegins(pszOpt, "-context=")) {
         if (getContextParms(pszOpt+9, rparms.nprecon, rparms.cprecolor, &rparms.pPostConMark, MAX_CONTEXT_LINES-5)) return 9;
         rparms.npostcon = rparms.nprecon;
         rparms.cpostcolor = rparms.cprecolor;
         continue; 
      }

      int i=0;

      // check for filter options w/o parms
      for (i=0; i<(int)(sizeof(pszValFilt1)/sizeof(char*)); i++)
         if (!strncmp(pszOpt, pszValFilt1[i], strlen(pszValFilt1[i])))
            break;
      if (i < (int)(sizeof(pszValFilt1)/sizeof(char*))) {
         if (bHadProc) {
            perr("selection options (%s) are not allowed after processing options.\n", pszOpt);
            perr("say +filter %s instead.\n", pszOpt);
            return 9;
         }
         bHadFilt=1;
         continue;
      }

      // check for filter options w/ parms
      int nParms = 0;
      for (i=0; i<(int)(sizeof(pszValFilt2)/sizeof(char*)); i++) {
         cchar *psz = pszValFilt2[i];
         // 1st char is no. of parms
         if (strBegins(pszOpt, psz+1)) {
            nParms = *psz - '0';
            break;
         }
      }
      if (nParms) {
         if (bHadProc) {
            perr("selection options (%s) are not allowed after processing options.\n", pszOpt);
            perr("say +filter %s instead.\n", pszOpt);
            return 9;
         }
         if (strBegins(pszOpt, "-addmark") && (iPat2+1 < argc))
            gfilter.pBlockMark = argv[iPat2+1];
         iPat2 += nParms;  // skip additional parameter
         if (iPat2 >= argc) return 9+perr("missing parameter(s) after %s\n",pszValFilt2[i]);
         bHadFilt=1;
         continue;
      }

      // check for highlight
      if (   !strncmp(pszOpt, "-high", 5)
          || !strncmp(pszOpt, "-lshigh", 7) || !strncmp(pszOpt, "-lehigh", 7)
         )
      {
         // if (bHadProc) {
         //    perr("%s is not allowed after processing options.\n", pszOpt);
         //    perr("say +filter %s instead.\n", pszOpt);
         //    return 9;
         // }
         iPat2 += 2;  // skip additional parameters
         if (iPat2 >= argc) return 9+perr("missing parameter(s) after %s\n",pszOpt);
         // bHadFilt=1;
         continue;
      }

      // check for processing opts w/o parms
      for (i=0; i<(int)(sizeof(pszValOpt1)/sizeof(char*)); i++)
         if (!strncmp(pszOpt, pszValOpt1[i], strlen(pszValOpt1[i])))
            break;
      if (i < (int)(sizeof(pszValOpt1)/sizeof(char*)))
         { bHadProc=1; continue; }
      
      // check for processing opts w/ one parm
      for (i=0; i<(int)(sizeof(pszValOpt2)/sizeof(char*)); i++)
         if (isxopt(pszOpt, pszValOpt2[i]))
            break;
      if (i < (int)(sizeof(pszValOpt2)/sizeof(char*))) {
         iPat2++;  // skip additional parameter
         if (iPat2 >= argc) {
            perr("missing parameter after %s\n",pszOpt);
            #ifndef _WIN32
            pinf("try to use quotes \"\" with %s parameters.\n",pszOpt);
            #endif
            return 9;
         }
         // typical mistake: -sep -form w/o separator patterns
         if (  (isxopt(pszOpt, "-sep") || isxopt(pszOpt, "-blocksep"))
             && isxopt(argv[iPat2], "-form")
            )
            return 9+perr("%s must be followed by separator characters, e.g. %s \"; \"\n",pszOpt,pszOpt);
         bHadProc=1;
         continue;
      }
      else
      if (!strncmp(pszOpt, "-write", 6) || !strcmp(pszOpt, "-rewrite")) {
         rparms.bReWrite = 1;
         if (!strcmp(pszOpt, "-writeall"))
            cs.writeall = 1;
         continue; 
      }

      if (   strncmp(pszOpt, "-", 1)
          && strncmp(pszOpt, "+", 1)
         )
      {
         // non-option: assume single input file
         if (chain.useany()) {
            perr("unexpected parameter: %s\n", pszOpt);
            if (strchr(pszOpt, glblRunChar))
               pinf("you may forgot -form or -tabform\n");
            else
               pinf("filter input is coming from a previous command.\n");
            return 9;
         }
         if (*pszInFile) {
            perr("unexpected parameter: %s\n", pszOpt);
            if (pszOpt[0] == '<' || pszOpt[0] == '>') {
               pinf("if you try to redirect output, there might be a quote count problem.\n");
               pinf("try using -spat ... and \\q instead of \\\"\n");
            } else {
               pinf("filter does not support short dir+file selection syntax.\n");
               pinf("specify a single input file, or -dir ... -file ... format.\n");
            }
            return 9;
         }

         *pszInFile = pszOpt;
         continue;
      }

      if (!strncmp(pszOpt, "-", 1))
         if (isDirParm(pszOpt)) {
            *iDir = iPat2;
            return 0;
         }

      if (isChainStart(pszOpt, argv, argc, iPat2, iChain)) {
         nPat = iPat2 - iPat;
         if (cs.verbose)
            printf("[filter npats=%d before %s]\n", nPat, pszOpt);
         // tell caller that there is another chain cmd:
         // was done in isChainStart via iChain
         return 0; // pdp will process chaining further
      }

      if (setGeneralOption(argv, argc, iPat2))
         continue;

      return 9+perr("unknown option: %s\n", pszOpt);
   }

   if (bHadFilt && rparms.bReWrite && !cs.force && !cs.noinfo && !cs.yes) {
      pinf("line selection option(s) AND -write may cause massive changes.\n");
   }
   else
   if ((rparms.bLNum || rparms.bCnt) && rparms.bReWrite && !cs.force && !cs.noinfo && !cs.yes) {
      pinf("-lnum or -count AND -write will change all selected files.\n");
   }

   if (cs.wrapcol && (rparms.bReWrite || pszGlblSaveTo))
      return 9+perr("-wrap together with -write is not supported.\n");

   return 0;
}

// filter -unique support:
KeyMap glblFilterDups;

// filter test matrix: used with -test
#define FILT_MAXTESTMASKS 50
struct FilterTestStat {
   char *apPosMasks  [FILT_MAXTESTMASKS+4];
   int  anPosHits   [FILT_MAXTESTMASKS+4];
   char *apNegMasks  [FILT_MAXTESTMASKS+4];
   int  anNegHits   [FILT_MAXTESTMASKS+4];
}  ftest;

// io: szLineBuf. also uses szLineBuf2.
// io: szAttrBuf. also uses szAttrBuf2.
// rc: 0 if line is included, 1 if excluded, >1 on error.
int selectTextLine(char *argv[], int iPat, int nPat, bool bVerb,
   int &rIncCnt, int &rExCnt, int &rExState, 
   char *pCurFile, int nCurLineNum
   )
{__
   bool bHasPositive = 0;
   bool bHasNegative = 0;
   bool bHavePosFilt = 0;
   bool bHaveNegFilt = 0;
   int nOptState = 0;
   int nHitIndex = 0;
   int nHitLen   = 0;
   bool bCase = cs.usecase;
   bool bForceExclude = 0;
   bool bForceInclude = 0;
   bool bHaveIncCmd   = 0;
   bool bDoneSingleIC = 0; // done a single inc/cut in this line

   for (int i=0; i<nPat; i++) 
   {
      char *pszPat = argv[iPat+i];
      if (!strncmp(pszPat, "-+", 2)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " %s\"%s\"", (i>0)?"OR ":"OPTIONAL ", pszPat+2);
         // if (mystrhit(szLineBuf, pszPat+2, bCase, &nHitIndex)) {
         int nflags = bCase ? eMatchCase : 0;
         int nlen = strlen(szLineBuf);
         for (int ibase=0; ibase<nlen;)
         {
            if (cs.test && i<FILT_MAXTESTMASKS)
               ftest.apPosMasks[i] = pszPat;
            if (!matchstr(szLineBuf+ibase, pszPat+2, nflags, nHitIndex, nHitLen))
               break; // no further hit
            bHasPositive = 1;
            if (ibase+nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[ibase+nHitIndex], 'i', nHitLen);
            // continue to highlight ALL occurrences
            ibase += nHitIndex+nHitLen;
            if (cs.test && i<FILT_MAXTESTMASKS)
               ftest.anPosHits[i]++;
         }
      }
      else
      if (!strncmp(pszPat, "-ls+", 4)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " %sLINE START \"%s\"", (i>0)?"OR ":"",pszPat+4);
         // if (!mystrncmp(szLineBuf, pszPat+4, strlen(pszPat)-4, bCase)) {
         int nflags = (bCase ? eMatchCase : 0) | eMatchHead;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasPositive = 1;
            if (nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
         }
      }
      else
      if (!strncmp(pszPat, "-le+", 4)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         int nPatLen = strlen(pszPat)-4;
         int nBufLen = strlen(szLineBuf);
         int nIndex  = nBufLen-nPatLen;
         if (nIndex < 0) nIndex = 0;
         if (bVerb) fprintf(stderr, " %sLINE END \"%s\"", (i>0)?"OR ":"",pszPat+4);
         int nflags = (bCase ? eMatchCase : 0) | eMatchTail;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasPositive = 1;
            if (nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
         }
      }
      else
      if (!strncmp(pszPat, "++", 2)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " %s\"%s\"", (i>0)?"AND ":"", pszPat+2);
         // if (mystrhit(szLineBuf, pszPat+2, bCase, &nHitIndex)) {
         int nflags = bCase ? eMatchCase : 0;
         int nlen = strlen(szLineBuf);
         bool bLocalPos = 0;
         for (int ibase=0; ibase<nlen;)
         {
            if (!matchstr(szLineBuf+ibase, pszPat+2, nflags, nHitIndex, nHitLen))
               break;
            bLocalPos = 1;
            if (ibase+nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[ibase+nHitIndex], 'i', nHitLen);
            ibase += nHitIndex+nHitLen;
         }
         if (bLocalPos) 
            bHasPositive = 1;
         else
            bHasNegative = 1;
      }
      else
      if (!strncmp(pszPat, "+ls+", 4)) {
         if (nOptState) { nOptState=2; break; }
         bHavePosFilt = 1;
         if (bVerb) fprintf(stderr, " LINE MUST START \"%s\"", pszPat+4);
         // if (!mystrncmp(szLineBuf, pszPat+4, strlen(pszPat)-4, bCase)) {
         int nflags = (bCase ? eMatchCase : 0) | eMatchHead;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasPositive = 1;
            if (nHitIndex+nHitLen < MAX_LINE_LEN)
               memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
         } else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strncmp(pszPat, "-!", 2) || !strncmp(pszPat, "-:", 2))
      {
         if (cs.test && (i<FILT_MAXTESTMASKS))
            ftest.apNegMasks[i] = pszPat;
         if (nOptState) { nOptState=2; break; }
         bHaveNegFilt = 1;
         if (bVerb) fprintf(stderr, " NOT \"%s\"", pszPat+2);
         // if (mystrhit(szLineBuf, pszPat+2, bCase, &nHitIndex))
         int nflags = bCase ? eMatchCase : 0;
         if (matchstr(szLineBuf, pszPat+2, nflags, nHitIndex, nHitLen)) {
            bHasNegative = 1;
            if (cs.test && (i<FILT_MAXTESTMASKS))
               ftest.anNegHits[i]++;
         }
      }
      else
      if (!strncmp(pszPat, "-ls!", 4) || !strncmp(pszPat, "-ls:", 4))
      {
         if (nOptState) { nOptState=2; break; }
         bHaveNegFilt = 1;
         if (bVerb) fprintf(stderr, " NOT \"%s\"", pszPat+4);
         // if (!mystrncmp(szLineBuf, pszPat+4, strlen(pszPat)-4, bCase)) {
         int nflags = (bCase ? eMatchCase : 0) | eMatchHead;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strncmp(pszPat, "-le!", 4) || !strncmp(pszPat, "-le:", 4))
      {
         if (nOptState) { nOptState=2; break; }
         bHaveNegFilt = 1;
         int nPatLen = strlen(pszPat)-4;
         int nBufLen = strlen(szLineBuf);
         int nIndex  = nBufLen-nPatLen;
         if (nIndex < 0) nIndex = 0;
         if (bVerb) fprintf(stderr, " NOT \"%s\"", pszPat+4);
         // if (!mystrncmp(&szLineBuf[nIndex], pszPat+4, nPatLen, bCase)) {
         int nflags = (bCase ? eMatchCase : 0) | eMatchTail;
         if (matchstr(szLineBuf, pszPat+4, nflags, nHitIndex, nHitLen)) {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strcmp(pszPat, "-no-empty-lines")) {
         if (strlen(szLineBuf))
            bHasPositive = 1;
         else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (!strcmp(pszPat, "-no-blank-lines")) {
         char *psz = szLineBuf;
         while (*psz && isspace(*psz))
            psz++;
         if (*psz) // landed on non-space
            bHasPositive = 1;
         else {
            bHasNegative = 1;
            break;
         }
      }
      else
      if (   !strcmp(pszPat, "-unique")
          || !strcmp(pszPat, "-global-unique")
         )
      {
         // check for -unique -keep pat1 -keep pat2 ...
         bool bForceKeep = 0;
         int iPost = iPat+i+1;
         for (; (iPost<iPat+nPat) && !bForceKeep; iPost++) {
            char *pszPost1 = argv[iPost];
            if (!strcmp(pszPost1, "-keep-empty") && !szLineBuf[0])
                  { bForceKeep=1; break; }
            if (!strcmp(pszPost1, "-keep-blank") && isWhitespace(szLineBuf, strlen(szLineBuf)))
                  { bForceKeep=1; break; }
            if ((iPost+1<iPat+nPat) && !strcmp(pszPost1, "-keep")) {
               char *pszPost2 = argv[++iPost];
               if (mystrhit(szLineBuf, pszPost2, cs.usecase, 0)) 
                  { bForceKeep=1; break; }
            }
         }
         if (bForceKeep) {
            // pass-through -keep line
            bHasPositive = 1;
         } else {
            // apply -unique
            char *psz = szLineBuf;
            if (!glblFilterDups.isset(psz)) {
               glblFilterDups.put(psz);
               bHasPositive = 1;
            } else {
               bHasNegative = 1;
               break;
            }
         }
      }
      else
      if (!strncmp(pszPat, "-keep-", 6)) {
         // processing was done before
      }
      else
      if (!strcmp(pszPat, "-keep")) {
         // processing was done before
         i++;
      }
      else
      if (!strncmp(pszPat, "-inc", 4)) {
         // -inc[lude] "foo*begin" to  "foo*end"
         // -inc-      "foo*begin" to  "foo*end"
         //  i+0        i+1        i+2  i+3
         if (nPat < 4) return 9; // should've been checked before
         char *pfrom = argv[iPat+i+1];
         char *plito = argv[iPat+i+2];
         char *pto   = argv[iPat+i+3];
         if (strcmp(plito, "to"))
            return 9+perr("filter -inc: missing \"to\" keyword");
         bool bStripBnd = (strlen(pszPat) >= 5 && pszPat[4] == '-');
         int nflags = bCase ? eMatchCase : 0;
         if (!strcmp(pfrom, "*") || !strcmp(pto, "*")) 
         {
            // -inc single block mode with one open end
            if (bDoneSingleIC) {
               perr("filter %s: only one -inc or -cut with * allowed", pszPat);
               pinf("... you may try \"+filter %s\" instead of \"%s\".\n", pszPat, pszPat);
               return 9;
            }
            if (!strcmp(pfrom, "*")) {
               // inc from first line until "to" marker
               switch (rIncCnt) {
                  case  0:
                     // keep default to include line
                     if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) {
                        rIncCnt = -1; // boundary hit
                        if (bStripBnd) bForceExclude = 1; // exclude boundary
                     }
                     break;
                  case -1:
                     bForceExclude = 1;
                     break;
               }
            } else {
               // inc from "from" marker until last line
               switch (rIncCnt) {
                  case  0:
                     if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) {
                        rIncCnt = -1; // boundary hit
                        if (bStripBnd) bForceExclude = 1; // exclude boundary
                     }
                     else
                        bForceExclude = 1;
                     break;
                  case -1:
                     // keep default to include line
                     break;
               }
            }
            bDoneSingleIC = 1;
         }
         else 
         {
            // -inc multi block mode with precise boundaries
            bHaveIncCmd = 1;
            if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) 
            {
               // ex start boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               rIncCnt++; // include active
               if (bStripBnd) bForceExclude = 1; // but exclude boundary
            }
            else
            if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) 
            {
               // ex end boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               if (rIncCnt > 0) {
                  rIncCnt--; // include inactive
                  if (!bStripBnd) // if boundary exclude is not active
                     bForceInclude = 1; // then include this line
               } 
               else
               if (!cs.nocheck) {
                  perr("filter -inc: found end of block without start: %s", szLineBuf);
                  pinf("file %s line %d\n",pCurFile,nCurLineNum);
                  pinf("add option -nocheck to ignore unexpected block endings.\n");
                  return 9;
               }
            }
         }
      }
      else
      if (   strBegins(pszPat, "-cut")
          || strBegins(pszPat, "-ex")
         ) 
      {
         // -ex[clude] "foo*begin" to  "foo*end"
         //  i+0        i+1        i+2  i+3
         if (nPat < 4) return 9; // should've been checked before
         char *pfrom = argv[iPat+i+1];
         char *plito = argv[iPat+i+2];
         char *pto   = argv[iPat+i+3];
         if (strcmp(plito, "to"))
            return 9+perr("filter %s: missing \"to\" keyword", pszPat);
         bool bStripBnd = !strcmp(pszPat, "-cut-");
         int nflags = bCase ? eMatchCase : 0;
         if (!strcmp(pfrom, "*") || !strcmp(pto, "*")) 
         {
            // -cut single block mode with one open end
            if (bDoneSingleIC) {
               perr("filter %s: only one -inc or -cut with * allowed", pszPat);
               pinf("... you may try \"+filter %s\" instead of \"%s\".\n", pszPat, pszPat);
               return 9;
            }
            if (!strcmp(pfrom, "*")) {
               // cut from first line until "to" marker
               rExState |= 1; // there is a -cut from *
               switch (rExCnt) {
                  case  0:
                     if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) {
                        rExState |= 2; // a -cut from * found end boundary
                        rExCnt = -1; // boundary hit
                        if (!bStripBnd) bForceExclude = 1;
                     }
                     else
                        bForceExclude = 1;
                     break;
                  case -1:
                     // keep default to include line
                     break;
               }
            } else {
               // cut from "from" marker until last line
               switch (rExCnt) {
                  case  0:
                     // keep default to include line
                     if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) {
                        rExCnt = -1;       // boundary hit
                        if (!bStripBnd) bForceExclude = 1;
                     }
                     break;
                  case -1:
                     bForceExclude = 1;
                     break;
               }
            }
            bDoneSingleIC = 1;
         }
         else 
         {
            // -cut multi block mode with precise boundaries
            if (matchstr(szLineBuf, pfrom, nflags, nHitIndex, nHitLen)) 
            {
               // ex start boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               rExCnt++; // exclude active
               // exclude boundary from cutting?
               if (bStripBnd) bForceInclude = 1;
            }
            else
            if (matchstr(szLineBuf, pto, nflags, nHitIndex, nHitLen)) 
            {
               // ex end boundary hit: highlight first hit
               if (nHitIndex+nHitLen < MAX_LINE_LEN)
                  memset(&szAttrBuf[nHitIndex], 'i', nHitLen);
               // adapt block status
               if (rExCnt > 0) {
                  rExCnt--; // exclude inactive
                  if (!bStripBnd) bForceExclude = 1; // but still exclude the current line
               }
               else
               if (!cs.nocheck) {
                  perr("filter %s found end of block without start: %s", pszPat, szLineBuf);
                  pinf("file %s line %d\n",pCurFile,nCurLineNum);
                  pinf("add option -nocheck to ignore unexpected block endings.\n");
                  return 9;
               }
            }
         }
      }

   }  // endfor nPat

   if (bVerb) {
      if (bHavePosFilt || bHaveNegFilt)
         fprintf(stderr, "]\n");
      else
         fprintf(stderr, " ALL LINES: no filters given.]\n");
   }

   // block include/exclude active?
   if (rExCnt > 0 && !bForceInclude) return 1; // no match
   if (bForceExclude) return 1;
   if (bHaveIncCmd && !rIncCnt && !bForceInclude) return 1;

   bool bMatch = 0;

   // if ANY positive filter is given, matches MUST contain this.
   if (bHavePosFilt && bHasPositive && !bHasNegative)
      bMatch = 1;

   // if NO positive filter is given, ANYTHING matches,
   // except if there is a negative filter match.
   if (!bHavePosFilt && !bHasNegative)
      bMatch = 1;

   return bMatch ? 0 : 1;   
}

static char szPatBuf[MAX_LINE_LEN+100];
static char szSaveBuf[MAX_LINE_LEN+100];
static char szSaveAttr[MAX_LINE_LEN+100];
static char szJoinBuf[MAX_LINE_LEN+100];

// io: szLineBuf. also uses szLineBuf2.
// io: szAttrBuf. also uses szAttrBuf2.
int processTextLine(char *argv[], int iPat, int nPat,
   int &nReplaced, bool &bUseColor, int nLineNum, int nOutLineNum
   )
{__
   bool bCase = cs.usecase;
   aMaskSep[0]     = '\0';
   bool bBlockSep  = 0;
   bool bWhereMode = 0; // a -where is active
   bool bWhereHit  = 0; // the current line matches active -where
   bool bSkipWhere = 0; // if set, -rep etc. must be skipped

   for (int i=0; i<nPat; i++)
   {
      char *pszPat = argv[iPat+i];

      if (   isxopt(pszPat, "-within")
          || isxopt(pszPat, "-lswithin") || isxopt(pszPat, "-lewithin")
         )
      {
         if (i+3 >= nPat) return 9+perr("missing arguments after %s\n", pszPat);

         bool blstart = strstr(pszPat, "lswithin") ? 1 : 0;
         bool blend   = strstr(pszPat, "lewithin") ? 1 : 0;

         char *psz     = argv[iPat+i+1];
         char *pRepCmd = argv[iPat+i+2];
         if (!strBegins(pRepCmd, "-rep"))
            return 9+perr("missing -replace after %s\n", pszPat);
         char *pszRep  = argv[iPat+i+3];

         // -within "{*}" -replace /foo/bar/
         // if pattern starts or ends with * is ignored
         bool bFromLeft = 0;
         bool bToRight  = 0;
         bool bForceRep = 0;
         int nPatLen   = strlen(psz);
         if (copyMatchPattern(szPatBuf, MAX_LINE_LEN, psz, nPatLen, bFromLeft, bToRight, bForceRep))
            return 9;
         // -> sets szPatBuf, nPatLen, bFromLeft, bToRight.
         int nflags = bCase ? eMatchCase : 0;
         // determine if current line matches the [ls/le]within expression
         int nlen = strlen(szLineBuf);
         for (int ibase=0; ibase<nlen;)
         {
            int ifirst=0, ihitlen=0;
            if (!matchstr(szLineBuf+ibase, szPatBuf, nflags, ifirst, ihitlen))
               break; // no further hit
            if (blstart && (ibase+ifirst) != 0)
               break; // no hit as it's not at line start
            if (blend && (ibase+ifirst+ihitlen) != nlen) {
               // no hit as it's not (yet) at line end
               ibase += ifirst+ihitlen;
               continue;
            }
            bWhereHit = 1;
            if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
            if (bToRight)   { ihitlen = strlen(szLineBuf+ibase+ifirst); }

            // isolate selected part of line:
            //  from ibase+ifirst over ihitlen chars
            strcpy(szSaveBuf , szLineBuf);
            memmove(szLineBuf, szLineBuf+ibase+ifirst, ihitlen);
            szLineBuf[ihitlen] = '\0';

            strcpy(szSaveAttr, szAttrBuf);
            memmove(szAttrBuf, szAttrBuf+ibase+ifirst, ihitlen);
            szAttrBuf[ihitlen] = '\0';

            // mark the selected area as blue:
            memset(szAttrBuf, 't', ihitlen);

            // in+out: szLineBuf. also uses szLineBuf2.
            // changes szAttrBuf contents.
            if (applyReplace(pszRep, nReplaced, 0, 0)) return 9;

            // rebuild line text
            char *pleft = szSaveBuf;
            int  nleft = ibase+ifirst;
            char *pmid  = szLineBuf;
            int  nmid  = strlen(pmid);
            char *prite = szSaveBuf+nleft+ihitlen;
            int  nrite = strlen(prite);

            if (nleft+nmid+nrite > MAX_LINE_LEN-10)
               return 9+perr("buffer overflow on %s ...", pszPat);

            memcpy(szJoinBuf, pleft, nleft);
            memcpy(szJoinBuf+nleft, pmid, nmid);
            memcpy(szJoinBuf+nleft+nmid, prite, nrite);
            szJoinBuf[nleft+nmid+nrite] = '\0';
            strcpy(szLineBuf, szJoinBuf);

            // rebuild attributes
            pleft = szSaveAttr;
            nleft = ibase+ifirst;
            pmid  = szAttrBuf;
            nmid  = strlen(pmid);
            prite = szSaveAttr+nleft+ihitlen;
            nrite = strlen(prite);

            memcpy(szJoinBuf, pleft, nleft);
            memcpy(szJoinBuf+nleft, pmid, nmid);
            memcpy(szJoinBuf+nleft+nmid, prite, nrite);
            szJoinBuf[nleft+nmid+nrite] = '\0';
            strcpy(szAttrBuf, szJoinBuf);

            // continue searching after replaced part
            ibase = nleft+nmid;
            nlen = strlen(szLineBuf);
         }

         // skip over all -within parms, then continue
         i += 3;
         continue;
      }
      else
      if (   isxopt(pszPat, "-where")
          || isxopt(pszPat, "-lswhere") || isxopt(pszPat, "-lewhere")
         )
      {
         bool blstart = !strcmp(pszPat, "-lswhere");
         bool blend   = !strcmp(pszPat, "-lewhere");
         bool bshow   = !strstr(pszPat, "-noshow");

         bWhereMode = 1;
         bWhereHit  = 0;
         bSkipWhere = 0;

         // -where "??:??:??" -replace /foo/bar/
         i++;
         if (i >= nPat) return 9+perr("missing argument after %s\n", pszPat);
         char *psz = argv[iPat+i];
         // if pattern starts or ends with * is ignored
         bool bFromLeft = 0;
         bool bToRight  = 0;
         bool bForceRep = 0;
         int nPatLen   = strlen(psz);
         if (copyMatchPattern(szLineBuf2, MAX_LINE_LEN, psz, nPatLen, bFromLeft, bToRight, bForceRep))
            return 9;
         // -> sets szLineBuf2, nPatLen, bFromLeft, bToRight.
         int nflags = bCase ? eMatchCase : 0;
         // determine if current line matches the [ls/le]where expression
         int nlen = strlen(szLineBuf);
         for (int ibase=0; ibase<nlen;)
         {
            int ifirst=0, ihitlen=0;
            if (!matchstr(szLineBuf+ibase, szLineBuf2, nflags, ifirst, ihitlen))
               break; // no further hit
            if (blstart && (ibase+ifirst) != 0)
               break; // no hit as it's not at line start
            if (blend && (ibase+ifirst+ihitlen) != nlen) {
               // no hit as it's not (yet) at line end
               ibase += ifirst+ihitlen;
               continue;
            }
            bWhereHit = 1;
            if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
            if (bToRight)   { ihitlen = strlen(szLineBuf+ibase+ifirst); }
            char cattr = 'i';
            if (bshow)
               if (ibase+ifirst+ihitlen < MAX_LINE_LEN)
                  memset(&szAttrBuf[ibase+ifirst], cattr, ihitlen);
            // continue searching after current hit
            ibase += ifirst+ihitlen;
         }
         // -rep etc. will follow, using bWhere... flags
         if (!bWhereHit)
            bSkipWhere = 1;
      }
      else
      if (isxopt(pszPat, "-rep") || isxopt(pszPat, "-lsrep") || isxopt(pszPat, "-lerep"))
      {
         bool blstart = isxopt(pszPat, "-lsrep");
         bool blend   = isxopt(pszPat, "-lerep");

         // next argument is a sed-like replacement pattern
         i++;
         if (i >= nPat) return 9+perr("-rep must be followed by a pattern\n");
         char *pszRep = argv[iPat+i];
         // execute at all?
         if (bSkipWhere)
            continue;
         // in+out: szLineBuf. also uses szLineBuf2.
         if (applyReplace(pszRep, nReplaced, blstart, blend)) return 9;
      }
      else
      if (isopt(pszPat, str("-noop"))) // skip a parameter
      {
         // next argument contains something that should be skipped
         if (i >= nPat-1) return 9+perr("-noop must be followed by a parameter (which is ignored)\n");
         i++;
         continue;
      }
      else
      if (isxopt(pszPat, "-high") || isxopt(pszPat, "-lshigh") || isxopt(pszPat, "-lehigh"))
      {
         bool blstart = isxopt(pszPat, "-lshigh");
         bool blend   = isxopt(pszPat, "-lehigh");

         // -highlight red "POST * HTTP/"
         char *pcol = str("");
         i++;
         if (i >= nPat) return 9+perr("missing argument after %s\n", pszPat);
         pcol = argv[iPat+i];
         i++;
         if (i >= nPat) return 9+perr("missing argument after %s\n", pszPat);
         char *psz = argv[iPat+i];
         // execute at all?
         if (bSkipWhere)
            continue;
         // if pattern starts or ends with *
         bool bFromLeft = 0;
         bool bToRight  = 0;
         bool bForceRep = 0;
         int nPatLen   = strlen(psz);
         if (copyMatchPattern(szLineBuf2, MAX_LINE_LEN, psz, nPatLen, bFromLeft, bToRight, bForceRep))
            return 9;
         // -> sets szLineBuf2, nPatLen, bFromLeft, bToRight.
         int nflags = bCase ? eMatchCase : 0;
         // mark ALL hits within current line
         int nlen = strlen(szLineBuf);
         for (int ibase=0; ibase<nlen;)
         {
            int ifirst=0, ihitlen=0;
            if (!matchstr(szLineBuf+ibase, szLineBuf2, nflags, ifirst, ihitlen))
               break; // no further hit
            if (blstart && (ibase+ifirst) != 0)
               break; // no hit as it's not at line start
            if (blend && (ibase+ifirst+ihitlen) != nlen) {
               // no hit as it's not (yet) at line end
               ibase += ifirst+ihitlen;
               continue;
            }
            if (bFromLeft)  { ihitlen += ifirst; ifirst = 0; }
            if (bToRight)   { ihitlen = strlen(szLineBuf+ibase+ifirst); }
            // map human color to attribute code
            char cattr = attribFromHumanColor(pcol);
            if (ibase+ifirst+ihitlen < MAX_LINE_LEN)
               memset(&szAttrBuf[ibase+ifirst], cattr, ihitlen);
            // continue searching after current hit
            ibase += ifirst+ihitlen;
         }
      }
      else
      if (isxopt(pszPat, "-sep") || isxopt(pszPat, "-blocksep"))
      {
         // parse user-defined separators for format input.
         // blocksep takes several separators as a single one.
         bBlockSep = (!strcmp(pszPat, "-blocksep")) ? 1 : 0;
         i++;
         if (i >= nPat) return 9+perr("-sep must be followed by separators, e.g. -sep ;\n");
         char *pszStrForm = argv[iPat+i]; // e.g. "; \t"
         // execute at all?
         if (bSkipWhere)
            continue;
         // "-sep -form" user error is checked in setFilterParms.
         // "\t" is NOT replaced by sprintf (belongs to preprocessor),
         // so we have to replace it by native 0x09 here.
         int iout=0;
         char *pszin=pszStrForm;
         while (*pszin && (iout < (int)sizeof(aMaskSep)-10)) 
         {
            if (cs.spat && !strncmp(pszin, "\\\\", 2))
               { aMaskSep[iout++] = '\\'; pszin += 2; continue; }
            else
            if (cs.spat && !strncmp(pszin, "\\t", 2))
               { aMaskSep[iout++] = '\t'; pszin += 2; continue; }
            else
            if (cs.spat && !strncmp(pszin, "\\q", 2))
               { aMaskSep[iout++] = '"'; pszin += 2; continue; }
            else
            if (cs.spat && !strncmp(pszin, "\\x", 2)) {
               // \xnn - any character with hex code nn
               pszin += 2; // skip \x
               int nhex = getTwoDigitHex(pszin);
               if (nhex <= 0) return 9+perr("illegal value for \\xnn in -sep. use 01 to FF, e.g. \\x09\n");
               pszin += 2; // skip nn
               aMaskSep[iout++] = (char)nhex;
               continue;
            }
            else
               aMaskSep[iout++] = *pszin;
            pszin++;
         }
         aMaskSep[iout] = '\0';
         // printf("masksep: %02x %02x %02x %s\n",aMaskSep[0],aMaskSep[1],aMaskSep[2],pszStrForm);
         continue;
      }
      else
      if (isxopt(pszPat, "-form") || isxopt(pszPat, "-tabform"))
      {
         // alias for -ssep "\t" -form?
         if (isxopt(pszPat, "-tabform")) {
            aMaskSep[0] = '\t';
            aMaskSep[1] = '\0';
         }
         // split lines into whitespace-separated columns, selecting some.
         i++;
         if (i >= nPat) return 9+perr("-form must be followed by %ccol1 etc., e.g. -form \"%ccol2 %ccol5\"\n", glblRunChar, glblRunChar, glblRunChar);
         char *pszMask = argv[iPat+i];
         // execute at all?
         if (bSkipWhere)
            continue;
         // in+out: szLineBuf. also uses szLineBuf2.
         if (applyForm(pszMask, bBlockSep, nLineNum, nOutLineNum)) return 9;
         // form change was really applied:
         nReplaced++;
         // -form does not yet support attributes, therefore reset them.
         memset(szAttrBuf, ' ', MAX_LINE_LEN-10);
         szAttrBuf[MAX_LINE_LEN-10] = '\0';
         continue;
      }
      else
      if (isopt(pszPat, str("-encode-perc"))) {
         if (encodeUrl(szLineBuf, szLineBuf2, MAX_LINE_LEN))
            return 9;
         strcpy(szLineBuf, szLineBuf2);
      }
      else
      if (isopt(pszPat, str("-decode-perc"))) {
         decodeUrl(szLineBuf); // ignore rc
      }
      else
      if (   !strcmp(pszPat, "-ansitodos")
          || !strcmp(pszPat, "-todos"))
      {
         ansiToDos(szLineBuf);
      }
      else
      if (!strcmp(pszPat, "-dostoansi")) {
         dosToAnsi(szLineBuf);
      }
      else
      if (isopt(pszPat, str("-toupper"))) {
         changeLineCase(szLineBuf, 1);
      }
      else
      if (isopt(pszPat, str("-tolower"))) {
         changeLineCase(szLineBuf, 2);
      }
      else
      if (isopt(pszPat, str("-toiso="))) {
         cs.toisodef = pszPat[strlen("-toiso=")];
         utf8ToIso(szLineBuf);
      }
      else
      if (   isopt(pszPat, str("-toiso"))
          || isopt(pszPat, str("-iso"))) {
         utf8ToIso(szLineBuf);
      }
      else
      if (   isopt(pszPat, str("-toutf"))
          || isopt(pszPat, str("-utf"))) {
         bool bSafe = strcmp(pszPat, "-toutfsafe") ? 0 : 1;
         UTF8Codec::toutf8(szLineBuf2, MAX_LINE_LEN, szLineBuf, bSafe);
         strcopy(szLineBuf, szLineBuf2);
      }
      else
      if (isopt(pszPat, str("-ltrim"))) {
         trimLine(szLineBuf, 1);
      }
      else
      if (isopt(pszPat, str("-rtrim"))) {
         trimLine(szLineBuf, 2);
      }
      else
      if (isopt(pszPat, str("-trim"))) {
         trimLine(szLineBuf, 3);
      }
   }
   return 0;
}

class FileCloser {
public:
    FileCloser  (Coi *pcoi); // can be NULL
   ~FileCloser  ( );
private:
    Coi *pClCoi;
};

FileCloser::FileCloser(Coi *pcoi) {
   pClCoi = pcoi;
}
FileCloser::~FileCloser() { 
   if (pClCoi && pClCoi->isFileOpen())
      pClCoi->close();
}

void initRandom(char *penv[])
{
   // seed randomizer with time and environment
   SFKMD5 md5;
   
   num nnow = time(NULL);
   md5.update((uchar*)&nnow, sizeof(nnow));

   for (int i=0; penv[i] != 0; i++) 
   {
      char *psz = penv[i];
      if (strlen(psz) > 0)
         md5.update((uchar*)psz, strlen(psz));
   }
   
   uchar *pdig = md5.digest();

   uint32_t nseed = 0;
   memcpy(&nseed, pdig, sizeof(nseed));
   
   srand(nseed);
}

// dump szLineBuf/szAttrBuf to output.
// also uses szLineBuf2/3 and szAttrBuf2/3.
int dumpFilterLine
 (
   bool     bReWrite,
   SFKMD5    &md5out,
   StringTable &oOut,   // used by rewrite
   int       &nLine,
   int        &nCnt,   // output line counter
   char    *paddmark,
   char     *abLFBuf,
   bool bDumpedFileName
 )
{__
   bool  bLNum      = gfilter.bLNum;
   bool  bCnt       = gfilter.bCnt;
   bool  bDumpLF    = gfilter.bDumpLF;
   bool  bFilenames = gfilter.bFilenames;
   bool  bUseColor  = bGlblUseColor;

   char  *pszLine   = szLineBuf;
   char  *pszAttr   = szAttrBuf;

   if (bReWrite)
   {
      // create cache line. have to do this always, in case.
      szLineBuf2[0] = '\0';
      char *psz1 = szLineBuf2;
      if (bLNum) { sprintf(psz1, "%03u ",nLine); psz1 += strlen(psz1); }
      if (bCnt ) { sprintf(psz1, "%03u ",nCnt ); psz1 += strlen(psz1); }
      int nRem = MAX_LINE_LEN - (psz1 - szLineBuf2);
      mystrcopy(psz1, pszLine, nRem-10);
      if (oOut.addEntry(szLineBuf2))
         return 9+perr("out of memory\n");
      int nLineLen2 = strlen(szLineBuf2);
      if (!nLineLen2)
         md5out.update((uchar*)abLFBuf, 1);
      else
         md5out.update((uchar*)szLineBuf2, nLineLen2);
      nCnt++; // output line counter

      // append extra line after block inclusion?
      if (paddmark) {
         oOut.addEntry(paddmark); // ignore rc
         md5out.update((uchar*)paddmark, strlen(paddmark));
         nCnt++;
      }
   }
   else
   if (!cs.justrc)
   {
      // now holding one large output line in pszLine / pszAttr.
      if (cs.wrapcol > 0)
      {
         int nWrapCol = cs.wrapcol;
         if (bLNum) nWrapCol -= 4;
         if (bCnt ) nWrapCol -= 4;

         // -wrap selected: create multiple output lines
         char *psz1 = pszLine;
         char *pszOld = 0;
         while (*psz1)
         {
            pszOld = psz1;
            int icnt = 0;
            char *pszGap = 0;
            // step until overflow or eod, remember last whitespace
            while (*psz1 && (icnt < nWrapCol)) {
               char c = *psz1;
               switch (c) {
                  case ' ': case '\t': case ',':
                     pszGap = psz1;
                     break;
               }
               psz1++;
               icnt++;
            }
            // if overflow, go back past whitespace. if no whitespace,
            // make a word break at that point (splitting very long words).
            if (*psz1) {
               if (pszGap)
                  psz1 = pszGap+1;
            }
            uint noff = pszOld - pszLine;
            uint nlen = psz1 - pszOld;

            // isolate section
            memcpy(szLineBuf2, pszLine+noff, nlen);
            szLineBuf2[nlen] = '\0';
            memcpy(szAttrBuf2, pszAttr+noff, nlen);
            szAttrBuf2[nlen] = '\0';

            // then dump
            if (chain.coldata)
            {
               szLineBuf3[0] = '\0';
               szAttrBuf3[0] = '\0';

               if (bFilenames && bDumpedFileName)
                  strcat(szLineBuf3, "   ");
               if (bLNum) mystrcatf(szLineBuf3, 0, "%03u ", nLine);
               if (bCnt ) mystrcatf(szLineBuf3, 0, "%03u ", nCnt );
               padBuffer(szAttrBuf3, MAX_LINE_LEN, ' ', strlen(szLineBuf3));

               mystrcatf(szLineBuf3, 0, "%s", szLineBuf2);
               mystrcatf(szAttrBuf3, 0, "%s", szAttrBuf2);

               if (bDumpLF) {
                  chain.addLine(szLineBuf3, szAttrBuf3, 1); // 1: splitByLF
               } else {
                  chain.addToCurLine(szLineBuf3, szAttrBuf3);
               }

               if (paddmark) { chain.addLine(paddmark, str("")); nCnt++; }
            } else {
               if (bFilenames && bDumpedFileName)
                  printf("   ");
               if (bLNum) printx("<prefix>%03u<def> ", nLine);
               if (bCnt ) printx("<prefix>%03u<def> ", nCnt );
               if (!bUseColor)
                  printf("%s%s", szLineBuf2, bDumpLF ? "\n":"");
               else
                  printColorText(szLineBuf2, szAttrBuf2, bDumpLF);

               if (paddmark) { printf("%s\n", paddmark); nCnt++; }

               fflush(stdout);
            }
            nCnt++; // output line counter
         }
      }
      else
      {
         // dump whole line in one step
         if (chain.coldata)
         {
            szLineBuf3[0] = '\0';
            szAttrBuf3[0] = '\0';

            if (bFilenames && bDumpedFileName)
               strcat(szLineBuf3, "   ");
            if (bLNum) mystrcatf(szLineBuf3, 0, "%03u ", nLine);
            if (bCnt ) mystrcatf(szLineBuf3, 0, "%03u ", nCnt );
            padBuffer(szAttrBuf3, MAX_LINE_LEN, ' ', strlen(szLineBuf3));

            mystrcatf(szLineBuf3, 0, "%s", pszLine);
            mystrcatf(szAttrBuf3, 0, "%s", pszAttr);

            if (bDumpLF) {
               chain.addLine(szLineBuf3, szAttrBuf3, 1); // 1: splitByLF
            } else {
               chain.addToCurLine(szLineBuf3, szAttrBuf3);
            }

            if (paddmark) { chain.addLine(paddmark, str("")); nCnt++; }
         } else {
            if (bFilenames && bDumpedFileName)
               printf("   ");
            if (bLNum) printf("%03u ", nLine);
            if (bCnt ) printf("%03u ", nCnt );
            // printf("ucl %d\nlbuf %s\nattr %s\n",bUseColor,pszLine,pszAttr);
            if (!bUseColor)
               printf("%s%s", pszLine, bDumpLF ? "\n":"");
            else
               printColorText(pszLine, pszAttr, bDumpLF);
            if (paddmark) { printf("%s\n", paddmark); nCnt++; }
            fflush(stdout);
         }
         nCnt++; // output line counter
      }
   }

   return 0;
}

void mirrorAttrBuf(char ccolin)
{
   int nNewLen = strlen(szLineBuf);
   char ccol = ccolin ? ccolin : ' ';
   memset(szAttrBuf, ccol, nNewLen);
   szAttrBuf[nNewLen] = '\0';
}

// caller supplies either pszInFile or fin.
int execFilter(Coi *pcoi, FILE *fin, StringPipe *pInData, int nMaxLines, char *pszOutFile)
{__
   // only for display etc., not for fopen:
   char *pszInFile = pcoi ? pcoi->name() : 0;

   mtklog(("execFilter %s skipbin=%d", pszInFile ? pszInFile : "", gfilter.bSkipBinaries));

   char  **argv     = gfilter.argv;
   int  iPat        = gfilter.iPat;
   int  nPat        = gfilter.nPat;
   bool  bReWrite   = gfilter.bReWrite;
   bool  bFilenames = gfilter.bFilenames;

   bool bHaveOut = (pszOutFile != 0);
   if (!bHaveOut && pcoi && pcoi->isWriteable())
      pszOutFile = pcoi->name();

   // in case that -unique is used:
   if (!gfilter.bGlobalUnique)
      glblFilterDups.reset(); // reset per file
   glblFilterDups.setcase(cs.usecase);

   // INPUT FILE CLOSES AUTOMATICALLY.
   FileCloser fcin(pcoi); // does nothing if pcoi == NULL

   if (pszGlblSaveTo) bReWrite = 1;

   if (pcoi) 
   {
      if (gfilter.bSkipBinaries && pcoi->isBinaryFile()) 
      {
         cs.binariesSkipped++;
         if (cs.verbose) {
            setTextColor(nGlblWarnColor);
            oprintf("skipping binary file: %s\n", pcoi->name());
            setTextColor(-1);
         }
         return 0;
      }
      if (gfilter.bReWrite) {
         num nFileSize = pcoi->getSize();
         if (nFileSize > nGlblMemLimit)
            return 9+perr("input file too large: %s (adjust -memlimit)\n", pcoi->name());
         if (!pcoi->isWriteable())
            return 9+perr("readonly file, cannot overwrite: %s\n", pcoi->name());
      }
      if (pcoi->open("rb"))
         return 9+perr("cannot read file: %s%s\n", pcoi->name(),pcoi->lasterr());
      if (cs.verbose) {
         info.setStatus("scan", pcoi->name(), 0);
      }
   } else {
      if (bReWrite)
         return 9+perr("-write requires a filename.\n");
   }
 
   StringTable oOut; // in case bReWrite is used
   SFKMD5 md5in;
   SFKMD5 md5out;

   int nMaxLineLen = sizeof(szLineBuf)-10;
   int nLine = 0, nCnt = 1;
   int nMatchingLines = 0;
   int nReplaced = 0;
   bool bUseColor = bGlblUseColor;
   bool bDumpedFileName = 0;
   bool bCollectedFileName = 0;   
   bool bSave = 0;
   bool bSaveChainOut = 0;
   int lRC = 0;
   bool bSnapFile = 0;
   bool bGrabSubFileName = 0;
   int nSubFiles = 0;
   num  nInputBytes = 0;
   int ncheckcnt = 0;
   int ninccnt  = 0;  // block include counter
   int nexcnt   = 0;  // block exclude counter
   int nexstate = 0;  // block exclude state flags
   int nPostConCnt = 0; // post context down counter

   char abLFBuf[5];
   abLFBuf[0] = '\n';
   abLFBuf[1] = '\0';

   char szSnapPre[50];  // snapfile prefix
   char szSubFile[300]; // current subfile
   strcpy(szSnapPre, ":file:"); // default
   szSubFile[0] = '\0';

   myfgets_init();
   while (1)
   {
      // always provide an attrib buf in the same length
      // of input text, to allow replacements, highlight etc.
      // including the attribs.
      memset(szAttrBuf, ' ', MAX_LINE_LEN-10);
      szAttrBuf[MAX_LINE_LEN-10] = '\0';

      int nRead = 0;

      if (pInData) {
         // take line from stringpipe
         if (pInData->eod()) {
            mtklog(("filt: indata.eod"));
            break;
         }
         char *pattr = 0;
         char *psz = pInData->read(&pattr);
         // mtklog(("filt: indata.read \"%.100s\"", psz));
         mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
         strcat(szLineBuf, "\n"); // force LF
         int nlen = strlen(szLineBuf);
         if (pattr) {
            mystrcopy(szAttrBuf, pattr, MAX_LINE_LEN);
            // attrib lines are guaranteed to be as int as text
            if ((int)strlen(szAttrBuf) < nlen-1) {
               memset(szAttrBuf, ' ', nlen);
               szAttrBuf[nlen] = '\0';
            }
         }
         nRead = nlen;
         // nRead includes LF
      } else if (pcoi) { // native or virtual file
         nRead = pcoi->readLine(szLineBuf, nMaxLineLen);
         // nRead includes CRLF
      } else if (fin)  { // probably stdin
         nRead = myfgets(szLineBuf, nMaxLineLen, fin, 0, szAttrBuf);
         // nRead includes CRLF
      }
      if (!nRead) {
         mtklog(("filt: nread=0 EOD"));
         break; // EOD
      }

      // allow interrupt while processing very large files:
      if ((++ncheckcnt > 100000) && ((ncheckcnt & 65535)==0))
         if (userInterrupt())   // costs a bit of time
            {  lRC=9; break;  } // stop by escape

      nInputBytes += nRead;

      szLineBuf[nRead] = '\0';
      szAttrBuf[nRead] = '\0';
      nLine++;
      removeCRLF(szLineBuf);

      if (cs.usesnap && (nLine == 1)) {
         // identify snapfile by header line.
         if (strBegins(szLineBuf, ":snapfile sfk,")) {
            bSnapFile = 1;
            char *pszpre = strstr(szLineBuf, "lprefix=");
            if (pszpre) {
               pszpre += strlen("lprefix=");
               strcopy(szSnapPre, pszpre);
            }
            continue; // don't filter the header line
         }
      }
      if (cs.usesnap && bSnapFile) {
         // indentify subfile headers within a snapfile.
         if (bGrabSubFileName) {
            bGrabSubFileName = 0;
            strcopy(szSubFile, szLineBuf);
            pszInFile = szSubFile;
            bDumpedFileName = 0; // dump this name on first match
            nSubFiles++;
            if (cs.verbose) {
               int nMB = (int)(nInputBytes / 1000000);
               info.setAddInfo("%d mb, %d subfiles", nMB, nSubFiles);
               info.setStatus("scan", szSubFile, 0, eKeepAdd);
            }
            if (!cs.usesnapfiltname)
               continue;
         }
         else
         if (strBegins(szLineBuf, szSnapPre)) {
            bGrabSubFileName = 1;
            continue; // don't filter prefix itself
         }
      }

      int nLineLen = strlen(szLineBuf);
      if (!nLineLen)
         md5in.update((uchar*)abLFBuf, 1); // include empty lines
      else
         md5in.update((uchar*)szLineBuf, nLineLen);

      bool bVerb = 0;
      if (cs.verbose > 1 && nLine == 2) {
         // issue verbose infos on 2nd line, 1st is for syntax checks.
         bVerb = 1;
         if (pszInFile)
            fprintf(stderr, "[read file %s, find:", pszInFile);
         else
            fprintf(stderr, "[read stdin, find:");
      }

      int noldinc = ninccnt;
      int noldex  = nexcnt;

      int nsc = selectTextLine(argv, iPat, nPat, bVerb,
         ninccnt, nexcnt, nexstate,
         pszInFile ? pszInFile : (char*)"", nLine);
      if (nsc > 1) { lRC = nsc; break; }

      // append extra line after block inclusion?
      char *paddmark = 0;
      if (gfilter.pBlockMark) {
         // end of included block?
         if (noldinc && !ninccnt)
            paddmark = gfilter.pBlockMark;
         // end of excluded block?
         if (noldex && !nexcnt && nsc==1) {
            // create pseudo match line,
            // but do NOT set paddmark.
            nsc = 0;
            strcopy(szLineBuf, gfilter.pBlockMark);
            int nlen = strlen(szLineBuf);
            memset(szAttrBuf, 'i', nlen);
            szAttrBuf[nlen] = '\0';
         }
      }

      if (nsc == 0 || nPostConCnt > 0) // if match
      {
         // text line is selected within stream.

         // this means there is a matching file.
         if (gfilter.bPassHitFiles && chain.colfiles && !bCollectedFileName)
         {
            bCollectedFileName = 1;
            // chain mode: collect filenames with hits
            if (!pszInFile) {
                perr("wrong chaining mode: filter collects text but not filenames.\n");
                pinf("try to insert +ttf or +texttofilenames.\n");
                return 9;
            }
            // just scan for word hits: return on first hit
            if (!bReWrite) {
               if (!pcoi) return 9+perr("int. #141271849");
               chain.addFile(*pcoi);
               break;
            }
            // replace and save: do name chaining later
            bSaveChainOut = 1; // later masked by bSave
         }

         nMatchingLines++;

         // print the filename?
         if (   pszInFile && !bReWrite
             && !gfilter.bSingleFile && bFilenames
             && !cs.nonames && !bDumpedFileName
            )
         {
            bDumpedFileName = 1;
            if (!strncmp(pszInFile, glblDotSlash, 2))
               pszInFile += 2;
            if (chain.coldata) {
               sprintf(szLineBuf2, ":file %s", pszInFile);
               // note: +view scans extended end of attribute line
               //       to identify 'f'ile header lines, therefore +2:
               setattr(szAttrBuf2, 'f', strlen(szLineBuf2)+2, MAX_LINE_LEN);
               chain.addLine(szLineBuf2, szAttrBuf2);
            }
            else
            if (chain.colfiles) { } // done above
            else {
               setTextColor(nGlblFileColor);
               info.print("%s :\n", pszInFile);
               setTextColor(-1);
            }
         }

         // dump pre context lines, if any
         if (gfilter.nprecon) 
         {
            bool bcached = 0;

            if (gfilter.pPreConMark && !nPostConCnt) 
            {
               bcached = 1;
               strcpy(gfiltPreContext.szClLineTmp, szLineBuf);
               strcpy(gfiltPreContext.szClAttrTmp, szAttrBuf);
               strcopy(szLineBuf, gfilter.pPreConMark);
               mirrorAttrBuf(' ');
               if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, 0, abLFBuf, bDumpedFileName))
                  return 9;
            }

            for (int i=gfilter.nprecon; i>=1; i--) 
            {
               char *pszPreLine = gfiltPreContext.getLine(i);
               if (!pszPreLine) continue;

               // dump current pre context line. this requires
               // to place it temporarily into szLine/AttrBuf.
               if (!bcached) {
                  bcached = 1;
                  strcpy(gfiltPreContext.szClLineTmp, szLineBuf);
                  strcpy(gfiltPreContext.szClAttrTmp, szAttrBuf);
               }

               // prepare a precontext line
               strcpy(szLineBuf, pszPreLine);
               mirrorAttrBuf(gfilter.cprecolor);

               // post-process the precontext line (replace, highlight etc.)
               if (processTextLine(argv, iPat, nPat, nReplaced, bUseColor, nLine, nCnt))
                  return 9;

               // dump the precontext line
               if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, 0, abLFBuf, bDumpedFileName))
                  return 9;
            }

            if (bcached) {
               strcpy(szLineBuf, gfiltPreContext.szClLineTmp);
               strcpy(szAttrBuf, gfiltPreContext.szClAttrTmp);
            }
         }

         // handle post context lines
         bool bPostConElapsed = 0;
         if (gfilter.npostcon > 0) 
         {
            // why was the current line selected?
            if (!nsc) {
               // if was a true content match: reset postcnt
               // to make sure following context is dumped
               nPostConCnt = gfilter.npostcon;
            } else {
               // it was part of post context.
               mirrorAttrBuf(gfilter.cpostcolor);
               if (nPostConCnt > 0)
                  if (--nPostConCnt == 0)
                     bPostConElapsed = 1;
            }
         }

         // post-process the selected line (replace, highlight etc.)
         if (processTextLine(argv, iPat, nPat, nReplaced, bUseColor, nLine, nCnt))
            return 9;

         // dump current szLineBuf/szAttrBuf to output.
         if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, paddmark, abLFBuf, bDumpedFileName))
            return 9;

         // do we want to save the file content?
         // - if anything replaced
         // - or if found filter matches, and -force specified
         if (cs.writeall || nReplaced || (cs.force && nMatchingLines))
            bSave = 1;

         // if pre context is selected, reset cached precontext.
         gfiltPreContext.reset();

         // if post content was completed, show a marker?
         if (bPostConElapsed && gfilter.pPostConMark) 
         {
            strcopy(szLineBuf, gfilter.pPostConMark);
            mirrorAttrBuf(' ');
            if (dumpFilterLine(bReWrite, md5out, oOut, nLine, nCnt, 0, abLFBuf, bDumpedFileName))
               return 9;
         }
      }
      else
      {
         // no match, text line is removed from stream.
         nReplaced++;
         bSave = 1;

         // if pre context is selected, remember dropped line.
         if (gfilter.nprecon)
            gfiltPreContext.putLine(szLineBuf);
      }

      if (nMaxLines > -1 && nLine >= nMaxLines)
         break;

   }  // endwhile myfgets

   char *pszChainOutFile = pszInFile;

   // since 161: check for empty text caused by
   // -cut from * to a pattern, without pattern.
   if (nexstate == 1 && cs.nocheck == 0)
   {
      // -cut from * to pat: pat was not found
      bSave = 0; // do NOT rewrite empty file
      if (bReWrite) {
         // -write: simply don't change the file, tell an info.
         if (!cs.noinfo) {
            pwarn("filter -cut from * end marker not found, will not rewrite.\n");
            pinf("add -noinfo to hide this message.\n");
         }
      } else {
         // chain text processing: cannot repair, must stop.
         perr("filter -cut from * end marker not found, stopped processing.");
         pinf("add -nocheck to continue with empty text.\n");
         return 99; // stop all processing
      }
   }

   if (bReWrite && bSave)
   {
      uchar *pmd5in  = md5in.digest();
      uchar *pmd5out = md5out.digest();

      // save only on changes, or if -writeall selected
      if (cs.writeall || memcmp(pmd5in, pmd5out, 16))
      {
         if (cs.sim) {
            // simulating write
            info.setStatus("write", pszOutFile);
            info.setAddInfo("%5d changes", nReplaced);
            info.printLine(1<<2);
         } else {
            // if different output is specified, create directory structure.
            if (bHaveOut)
               if (createOutDirTree(pszOutFile))
                  return 9;
            info.setStatus("write", pszOutFile);
            info.setAddInfo("%5d changes", nReplaced);
            info.printLine(1<<2);
   
            FILE *fout = fopen(pszOutFile, "w");
            if (!fout) return 9+perr("failed to write to: %s\n", pszOutFile);
   
            int nLines = oOut.numberOfEntries();
            for (int i=0; i<nLines; i++)
               fprintf(fout, "%s\n", oOut.getEntry(i, __LINE__));
            fclose(fout);
         }
         gfilter.nTotalRC = 1;
         // use save filename as chain out
         pszChainOutFile = pszOutFile;
      }
   } else {
      if (nMatchingLines > 0)
         gfilter.nTotalRC = 1;
   }

   if (!cs.nocheck) {
      if (ninccnt > 0) {
         perr("%d filter -inc block(s) open at end of: %s", ninccnt, pszInFile ? pszInFile : "");
         pinf("one or more blocks starts were not followed by a block end.\n");
         pinf("add option -nocheck to ignore missing block endings.\n");
         lRC = 5;
      }
      if (nexcnt > 0) {
         perr("%d filter -cut block(s) open at end of: %s", nexcnt, pszInFile ? pszInFile : "");
         pinf("one or more block starts were not followed by a block end\n");
         pinf("add option -nocheck to ignore missing block endings.\n");
         lRC = 5;
      }
   }

   if (bSaveChainOut && bSave) {
      Coi ocoi(pszChainOutFile, 0);
      chain.addFile(ocoi); // is copied
   }

   return lRC;
}

int execCsvConv(bool bToCsv, Coi *pcoi, FILE *fin, StringPipe *pInData, int nMaxLines, char *pszOutFile)
{
   FILE *fout = 0;

   // INPUT FILE CLOSES AUTOMATICALLY.
   FileCloser fcin(pcoi); // does nothing if pcoi == NULL

   if (pcoi)
   {
      if (pcoi->open("rb"))
         return 9+perr("cannot read: %s %s\n", pcoi->name(),pcoi->lasterr());
   }

   if (pszOutFile)
      if (!(fout = fopen(pszOutFile, "w")))
         return 10+perr("cannot write: %s\n", pszOutFile);

   int nMaxLineLen = sizeof(szLineBuf)-10;
   int ncheckcnt   = 0;
   int lRC         = 0;
   int nLine       = 0;

   myfgets_init();
   while (1)
   {
      // --- get next line to linebuf ---

      memset(szAttrBuf, ' ', MAX_LINE_LEN-10);
      szAttrBuf[MAX_LINE_LEN-10] = '\0';

      int nRead = 0;

      if (pInData) {
         if (pInData->eod())
            break;
         char *pattr = 0;
         char *psz = pInData->read(&pattr);
         mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
         strcat(szLineBuf, "\n"); // force LF
         int nlen = strlen(szLineBuf);
         if (pattr) {
            mystrcopy(szAttrBuf, pattr, MAX_LINE_LEN);
            if ((int)strlen(szAttrBuf) < nlen-1) {
               memset(szAttrBuf, ' ', nlen);
               szAttrBuf[nlen] = '\0';
            }
         }
         nRead = nlen;
      } else if (pcoi) { // native or virtual file
         nRead = pcoi->readLine(szLineBuf, nMaxLineLen);
      } else if (fin)  { // probably stdin
         nRead = myfgets(szLineBuf, nMaxLineLen, fin, 0, szAttrBuf);
      }
      if (!nRead)
         break; // EOD

      if ((++ncheckcnt > 100000) && ((ncheckcnt & 65535)==0))
         if (userInterrupt())   // costs a bit of time
            {  lRC=9; break;  } // stop by escape

      szLineBuf[nRead] = '\0';
      szAttrBuf[nRead] = '\0';
      nLine++;
      removeCRLF(szLineBuf);

      // --- process line ---
      int isubrc = 0;
      if (bToCsv == 0)
         isubrc = csvToTab(szLineBuf, szLineBuf2, MAX_LINE_LEN);
      else
         isubrc = tabToCsv(szLineBuf, szLineBuf2, MAX_LINE_LEN);
      if (isubrc) {
         if (!cs.nowarn)
            pwarn("input line %d wrong format (%d): %s", nLine, isubrc, szLineBuf);
         snprintf(szLineBuf2, MAX_LINE_LEN, "[warning:%d]\t%s", isubrc, szLineBuf);
      }

      // -- write to output ---
      if (fout)
         fprintf(fout, "%s\n", szLineBuf2);
      else
      if (chain.coldata)
         chain.addLine(szLineBuf2, str(""));
      else
         printf("%s\n", szLineBuf2);
   }

   if (fout)
      fclose(fout);

   return lRC;
}

#ifndef USE_SFK_BASE

num nGlblCheckDiskHits = 0;
num nGlblCDWriteBytes  = 0;
num nGlblCDWriteTime   = 0;
num nGlblCDReadBytes   = 0;
num nGlblCDReadTime    = 0;

int writeDiskSlice(char *pszPath, num nSliceBytes, uchar *pBuf, int nBufSize)
{
   // 1. write slice
   num nTime1 = getCurrentTime();
   FILE *fout = fopen(pszPath, "wb");
   if (!fout) return 9+perr("unable to open test file %s\n", pszPath);
   srand(1);
   num nRemain = nSliceBytes;
   int nBlockSize = nBufSize-10;
   while (nRemain > 0)
   {
      int nWriteSize = nBlockSize;
      if (nWriteSize > nRemain)
          nWriteSize = nRemain;
      for (int i=0; i<nWriteSize; i++)
         pBuf[i] = (uchar)rand();
      int nWriteSize2 = myfwrite(pBuf, nWriteSize, fout);
      if (nWriteSize2 != nWriteSize) {
         fclose(fout);
         return 9+esys("fwrite", "unable to fully write test file %s\n", pszPath);
      }
      nRemain -= nWriteSize;
   }
   fclose(fout);
   num nTime2 = getCurrentTime();

   nGlblCDWriteBytes += nSliceBytes;
   nGlblCDWriteTime  += (nTime2-nTime1);

   return 0;
}

int readDiskSlice(char *pszPath, num nSliceBytes, uchar *pBuf, int nBufSize)
{
   // 2. read and check slice
   num nTime1 = getCurrentTime();
   FILE *fin = fopen(pszPath, "rb");
   if (!fin) return 9+perr("unable to re-read test file %s\n", pszPath);
   srand(1); // reproduce same pseudo-random sequence
   num nRemain = nSliceBytes;
   int nBlockSize = nBufSize-10;
   num nHits = 0;
   while (nRemain > 0) 
   {
      int nReadSize = nBlockSize;
      if (nReadSize > nRemain)
          nReadSize = nRemain;
      int nReadSize2 = fread(pBuf, 1, nReadSize, fin);
      if (nReadSize2 != nReadSize) {
         fclose(fin);
         return 9+perr("unable to re-read test file %s\n", pszPath);
      }
      nRemain -= nReadSize;
      for (int i=0; i<nReadSize; i++)
         if (pBuf[i] != (uchar)rand())
            nHits++;
   }
   fclose(fin);
   num nTime2 = getCurrentTime();

   nGlblCDReadBytes += nSliceBytes;
   nGlblCDReadTime  += (nTime2-nTime1);

   nGlblCheckDiskHits += nHits;

   if (nHits > 0)
      return 1;

   return 0;
}

// uses szLineBuf
int checkDisk(char *pszPath, int nRangeMB)
{__
   num nTotal=0, nFree=0;
   char szFSName[200];
   char szVolID[200];
   uint nVolID=0;

   if (getFileSystemInfo(pszPath, nTotal, nFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10, nVolID))
      return 9;

   num nBrutto = 0;
   num nNetto  = 0;

   if (nRangeMB == -1) {
      nRangeMB = nFree / 1000000;
      nBrutto = (num)nRangeMB * 1000000;
      nNetto  = (num)nBrutto * 9 / 10;
   } else {
      nBrutto = (num)nRangeMB * 1000000;
      nNetto  = nBrutto;
   }

   printf("Testing Volume %s, FileSystem %s, over %u mbytes.\n", szVolID, szFSName, (uint)(nNetto/1000000));

   if (nNetto > nFree)
      return 9+perr("test range too large: volume has only %d free mbytes\n", nFree);

   num nSliceBytes = nNetto / 100;
   printf("Writing 100 temporary files of %s mbytes each. Press ESC to stop.\n", numtoa(nSliceBytes/1000000));

   char abStat[100+10];
   memset(abStat, '.', sizeof(abStat));
   abStat[100] = '\0';

   // for USB stick write performance, we MUST use the largest I/O blocks possible.
   // a large buffer makes I/O about 10 times(!) faster.
   int nWorkBufSize = 1048675 * 50; // yes, 50 megabytes
   uchar *pWorkBuf = new uchar[nWorkBufSize];
   if (!pWorkBuf)
      return 9+perr("out of memory, cannot allocate working buffer.\n");

   memset(pWorkBuf, 0xFF, nWorkBufSize);

   // NO RETURN FROM HERE!

   num nWritten = 0;
   num nTimeW1  = getCurrentTime();
   int i;
   for (i=0; i<100; i++)
   {
      if (userInterrupt())
         break;

      sprintf(szLineBuf, "%s%stmp-test-%02u.dat", pszPath, endsWithPathChar(pszPath)?"":glblPathStr, i);
      int lRC = writeDiskSlice(szLineBuf, nSliceBytes, pWorkBuf, nWorkBufSize);

      if (lRC) abStat[i] = 'E';
      else     abStat[i] = '_';

      if (i < 49) {
         printf("%03u%% > %.50s < \r", i+1, abStat);
         fflush(stdout);
      }
      if (i == 49) {
         printf("%03u%% > %.50s < - 1st half written.\n", i+1, abStat);
      }
      if (i > 49 && i < 99) {
         printf("%03u%% > %.50s < \r", i+1, &abStat[50]);
         fflush(stdout);
      }
      if (i == 99) {
         printf("%03u%% > %.50s < - 2nd half written.\n", i+1, abStat);
      }

      nWritten += nSliceBytes;
   }
   int nCheck  = i;
   num nTimeW2  = getCurrentTime();
   num nWElapse = nTimeW2-nTimeW1;

   uint nkbswrite = (uint)(nWritten / (nWElapse?nWElapse:1));
   printf("Write done at %u kbytes/sec.%.40s\n", nkbswrite, pszGlblBlank);

   memset(pWorkBuf, 0xFF, nWorkBufSize);

   printf("Reading and verifying temporary files.\n");

   memset(abStat, '.', sizeof(abStat));
   abStat[100] = '\0';

   num nFirstHits  = 0;
   num nSecondHits = 0;
   num nReadBytes  = 0;
   num nTimeR1  = getCurrentTime();
   // read and check file system
   for (i=0; i<nCheck; i++)
   {
      // if (userInterrupt())
      //   break;

      sprintf(szLineBuf, "%s%stmp-test-%02u.dat", pszPath, endsWithPathChar(pszPath)?"":glblPathStr, i);
      int lRC = readDiskSlice(szLineBuf, nSliceBytes, pWorkBuf, nWorkBufSize);

      if (lRC) abStat[i] = 'E';
      else     abStat[i] = '_';

      if (i < 49) {
         printf("%03u%% > %.50s < \r", i+1, abStat);
         fflush(stdout);
      }
      if (i == 49) {
         nFirstHits = nGlblCheckDiskHits;
         printf("%03u%% > %.50s < - %s \n", i+1, abStat, nFirstHits ? "1st half contains Errors." : "1st half OK.");
      }
      if (i > 49 && i < 99) {
         printf("%03u%% > %.50s < \r", i+1, &abStat[50]);
         fflush(stdout);
      }
      if (i == 99) {
         nSecondHits = nGlblCheckDiskHits - nFirstHits;
         printf("%03u%% > %.50s < - %s \n", i+1, abStat, nSecondHits ? "2nd half contains Errors." : "2nd half OK.");
      }

      nReadBytes += nSliceBytes;
   }
   num nTimeR2  = getCurrentTime();
   num nRElapse = nTimeR2-nTimeR1;

   uint nkbsread = (uint)(nReadBytes / (nRElapse?nRElapse:1));
   printf("Read done at %u kbytes/sec.%.40s\n", nkbsread, pszGlblBlank);

   // NO RETURN UNTIL HERE.

   delete [] pWorkBuf;
   pWorkBuf = 0;

   // cleanup: delete all files without errors.
   int nKept = 0;
   for (i=0; i<100; i++)
   {
      if (abStat[i] != 'E') {
         sprintf(szLineBuf, "%s%stmp-test-%02u.dat", pszPath, endsWithPathChar(pszPath)?"":glblPathStr, i);
         printf("%02u%% cleanup test files ... \r", i);
         fflush(stdout);
         remove(szLineBuf);
      } else {
         nKept++;
      }
   }

   if (nGlblCheckDiskHits) {
      printf("%s mb of file system checked, errors detected:\n", numtoa(nReadBytes/1000000));
      printf("%s bytes failed to re-read after write.\n", numtoa(nGlblCheckDiskHits));
      printf("%u test files with bad sectors are left over, to cover the bad areas.\n", nKept);
   } else {
      printf("%s mb of file system successfully written and re-read.\n", numtoa(nReadBytes/1000000));
   }

   return 0;
}

#endif // USE_SFK_BASE

#ifdef _WIN32
int putClipboard(char *pszStr)
{__
   if (!OpenClipboard(0)) // GetDesktopWindow()))
      return 9+perr("clipboard #1\n");
   if (!EmptyClipboard())
      return 9+perr("clipboard #2\n");

   int nStrLen = strlen(pszStr);

   HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, nStrLen+10);
   if (hMem == NULL) return 9+perr("clipboard #3\n");

   LPTSTR pCopy = (char*)GlobalLock(hMem);
   if (pCopy)
   {
      memcpy(pCopy, pszStr, nStrLen);
      pCopy[nStrLen] = 0;
   }
   GlobalUnlock(hMem);

   HANDLE hData = SetClipboardData(CF_TEXT, hMem);
   if (hData == NULL)
   {
      CloseClipboard();
      return 9+perr("clipboard #4\n");
   }

   // System is now owner of hMem.

   CloseClipboard();

   return 0;
}
#endif

int getPartExtDigits(char *pszPartExt)
{
   if (strncmp(pszPartExt, ".part", 5))
      return 0;
      
   char *psz = pszPartExt + 5;
   int iDigits = 0;
   char c=0;
   while (c = *psz++)
   {
      if (!isdigit(c))
         return 0+perr("non-digit character '%c' is not allowed\n", c);
      iDigits++;         
   }
   
   return iDigits;
}

int execJoin(char *pszFirstInput, char *pszDst, bool bTest, char *pszMD5Write)
{__
   char szAddInfo[200];

   int nWorkMB = 100;
   num nWorkBufSize = nWorkMB * 1000000;
   uchar *pWorkBuf = new uchar[nWorkBufSize+1000];
   if (!pWorkBuf) return 9+perr("out of memory, cannot allocate working buffer.\n");

   // NO RETURN W/O DELETE FROM HERE

   // x.part1
   strcopy(szLineBuf, pszFirstInput);
   char *pszBaseName = szLineBuf;
   char *pszPartExt  = strrchr(szLineBuf, '.');
   
   int iDigits = getPartExtDigits(pszPartExt);
   if (!pszPartExt || !iDigits) {
      delete [] pWorkBuf;
      return 9+perr("expecting input filename ending like .part1, .part001 etc.\n");
   }

   // check if first input exists
   if (!fileExists(szLineBuf))
      return 9+perr("first input file not found: %s\n", szLineBuf);

   // cut ".part1" in szLineBuf
   *pszPartExt = '\0';

   // and use this as output filename
   if (!pszDst)
      pszDst = szLineBuf;

   FILE *fout = 0;

   if (!bTest)
   {
      if (fileExists(pszDst) && !cs.force && !cs.yes)
         while (1) {
            printf("%s output file exists, overwrite? (y/n) ",pszDst);
            fflush(stdout);
            char nReply = getYNAchar();
            if (nReply == 'y') break;
            if (nReply == 'n') { delete [] pWorkBuf; return 5; }
            // printf("\n");
         }
   
      fout = fopen(pszDst, "wb");
      if (!fout) {
         delete [] pWorkBuf;
         return 9+perr("cannot write output file: %s\n",pszDst);
      }
   }

   num ntotal = 0;
   SFKMD5 md5;

   int nin = 1;
   bool bbail = 0;
   while (!bbail)
   {
      sprintf(szLineBuf2, "%s.part%0*d", pszBaseName, iDigits, nin);
      char *pszSrc = szLineBuf2;
      
      // internal check: first part's name must be the same as input
      if ((nin == 1) && strcmp(pszSrc, pszFirstInput))
         perr("int. error while building name: %s\n", pszSrc);

      FILE *fpart = fopen(pszSrc, "rb");
      if (!fpart)
         break;   // (probably) all done

      if (cs.debug)
         info.print("open.read: %s\n", pszSrc);

      nin++;

      while (!bbail)
      {
         num nTotalMB = ntotal / 1000000;

         if (pszMD5Write) 
         {
            // printf("verifying part %d, %s mb done [Esc to skip] \r", nin-1, numtoa(nTotalMB));
            // fflush(stdout);
            sprintf(szAddInfo, "%s mb [Esc to skip]", numtoa(nTotalMB));
            info.setStatus("verfy", pszSrc, szAddInfo);
            if (userInterrupt(1)) {
               info.print("verify skipped.\n");
               fclose(fpart);
               bbail = 1;
               break;
            }
         } 
         else 
         {
            // printf("reading part %d, %s mb done \r", nin-1, numtoa(nTotalMB));
            // fflush(stdout);
            sprintf(szAddInfo, "%s mb", numtoa(nTotalMB));
            info.setStatus("read ", pszSrc, szAddInfo);
         }

         int nread = myfread(pWorkBuf, nWorkBufSize, fpart);

         if (cs.debug) 
            info.print("read.blck: %d maxbuf=%d\n", nread, (int)nWorkBufSize);

         if (nread <= 0)
            break; // EOD

         if (!bTest)
         {
            int nwrite = myfwrite(pWorkBuf, nread, fout);

            if (cs.debug)
               info.print("writ.blck: %d\n", nwrite);

            if (nwrite != nread) {
               delete [] pWorkBuf;
               fclose(fout); fclose(fpart);
               remove(pszDst); // cleanup incomplete output
               return 9+esys("fwrite", "failed to write %s   \n", pszDst);
            }
         }

         md5.update(pWorkBuf, nread);

         ntotal += nread;
      }

      if (cs.debug)
         info.print("clos.read: %s totalDone=%d\n", pszSrc, (int)ntotal);

      fclose(fpart);
   }
 
   if (!bTest)
      fclose(fout);

   delete [] pWorkBuf;

   // NO RETURN W/O DELETE UNTIL HERE

   info.clear();

   if (bbail)
      return 0;

   if (bTest) {
      if (!pszMD5Write)
         printf("tested join of %d files, %s total bytes.\n", nin-1, numtoa(ntotal));
   } else {
      printf("%s created from %d files, %s total bytes.\n", pszDst, nin-1, numtoa(ntotal));
   }

   char szMD5Read[100];

   uchar *pmd5 = md5.digest();
   for (int i=0; i<16; i++)
      sprintf(&szMD5Read[i*2], "%02x", pmd5[i]);
   printf("md5 = %s   %s ", szMD5Read, pszMD5Write ? "[verify]" : "");

   if (pszMD5Write) {
      if (strcmp(pszMD5Write, szMD5Read)) {
         printf("\n");
         return 9+perr("checksum mismatch - re-read of output files failed.\n");
      }
      else
         printf("- OK\n");
   }
   else
      printf("\n");

   return 0;
}

#define MAX_MOV_CMD 100
#define SFKMOV_KEEP   1
#define SFKMOV_CUT    2

class Media
{
public:
      Media ( );

   void  reset             ( );
   void  closeOutput       ( );
   void  clearCommands     ( );
   void  shutdown          ( );
   int   parseM3UFile      (char *pszFilename);
   int   processMediaFile  (char *pszSrc, char *pszOutFile);
   int   findSeconds       (num nBytePos); // with M3U only
   int   renderTempName    (char *pszFromname);
   int   analyze           (uchar *pbuf, int isize);
   void  setFixParms       (char *psz);

static Media *pClCurrent;
static Media &current ( );

int   aCmd[MAX_MOV_CMD];
num   aBeg[MAX_MOV_CMD];
num   aEnd[MAX_MOV_CMD];
int   aBegSec[MAX_MOV_CMD];
int   aEndSec[MAX_MOV_CMD];
int   iFirstCmd,iCmd;
int   iClInvalidFiles;
int   iClDoneFiles;
int   iClDoneTS;
bool  bClHaveM3UCommands;
bool  bClHaveKeep;
bool  bClKeepAll;
bool  bClJoinOutput;
bool  bClFixOutput;
bool  bClScan;
bool  bClKeepTmp;
bool  bClShowTmp;
num   nClGlobalBytes;

char  szClTmpOutFile[SFK_MAX_PATH+10];
char  szClRecentOutFile[SFK_MAX_PATH+10];
char  szClFinalFile[SFK_MAX_PATH+10];
char  szClFixParms[200];

char  szClMoveSrcOutDir[200];
char  szClMoveSrcOutFile[SFK_MAX_PATH+10];

FILE  *fClOut;
FileStat clOutStat;

char  *pszClM3UText;
char  *pszClM3UFileEntry;  // pointer into M3UText
};

int Media::findSeconds(num n)
{
   for (int i=0; i<iCmd; i++) {
      if (aBeg[i]==n && aBegSec[i]!=-1)
         return aBegSec[i];
      if (aEnd[i]==n && aEndSec[i]!=-1)
         return aEndSec[i];
   }
   return -1;
}

Media *Media::pClCurrent = 0;

Media::Media( ) 
{ 
   memset(this, 0, sizeof(*this)); 
}

void Media::reset( ) 
{
   iClInvalidFiles = 0;
   iClDoneFiles = 0;
   nClGlobalBytes = 0;
   bClHaveKeep = 0;
   bClKeepAll = 0;
   bClJoinOutput = 0;
   bClFixOutput = 0;
   iClDoneTS = 0;
   if (fClOut)
      perr("media: output file open on init\n");
   fClOut = 0;
   mclear(szClTmpOutFile);
   mclear(szClRecentOutFile);
   mclear(szClFinalFile);
   mclear(szClFixParms);
   clearCommands();
}

void Media::setFixParms(char *psz)
{
   if (!strcmp(psz, "pal-dvd") || !strcmp(psz, "dvd-pal"))
      strcopy(szClFixParms, "-target pal-dvd");
   else
   if (!strcmp(psz, "ntsc-dvd") || !strcmp(psz, "dvd-ntsc"))
      strcopy(szClFixParms, "-target ntsc-dvd");
   else
      strcopy(szClFixParms, psz);
}

void Media::closeOutput( )
{
   char szCmd[SFK_MAX_PATH+100];

   if (bClFixOutput)
   {
      snprintf(szCmd, sizeof(szCmd)-10,
         "ffmpeg -y -i \"%s\" %s -codec copy \"%s\"",
         szClTmpOutFile, szClFixParms, szClFinalFile);

      if (cs.sim && (cs.quiet<2))
         printx("$%s\n", szCmd);
      else
      if (!cs.sim && fClOut)
         printx("$%s\n", szCmd);
   }

   if (!fClOut)
      return;

   fclose(fClOut);
   fClOut = 0;
   
   if (bClFixOutput)
   {
      int iSubRC = system(szCmd);

      if (iSubRC > 0) {
         pwarn("ffmpeg possible error, RC=%d\n", iSubRC);
         pinf("use -keeptmp to keep temporary output file.\n");
      }
         
      if (!bClKeepTmp) {
         if (cs.verbose)
            printf("cleaning up temporary: %s\n", szClTmpOutFile);
         remove(szClTmpOutFile);
      }
   }

   if (cs.keeptime)
   {
      // this checks if it was really set
      clOutStat.writeStat(__LINE__);
   }
}

void Media::clearCommands( )
{
   bClHaveM3UCommands=0;
   mclear(aCmd);
   mclear(aBeg);
   mclear(aEnd);
   mclear(aBegSec);
   mclear(aEndSec);
   iFirstCmd=0;
   iCmd=0;
   for (int i=0; i<MAX_MOV_CMD; i++) {
      aBegSec[i]=-1;
      aEndSec[i]=-1;
   }
}

void Media::shutdown( )
{
   if (pszClM3UText) {
      delete [] pszClM3UText;
      pszClM3UText = 0;
   }
   if (!pClCurrent)
      return; // safety
   Media *pThis = pClCurrent;
   pClCurrent = 0;
   delete pThis;
   // no further processing
}

Media &Media::current( ) 
{
   if (!pClCurrent) 
      pClCurrent = new Media();
   return *pClCurrent;
}

int Media::parseM3UFile(char *pszm3u)
{
   bClHaveM3UCommands=1;

   iFirstCmd=0;
   iCmd=0;

   if (pszClM3UText)
      delete [] pszClM3UText;
   if (!(pszClM3UText = loadFile(pszm3u, 0)))
      return 9;
   if (cs.verbose)
      printf("--- Using bookmarks: ---\n");
   /*
      #EXTVLCOPT:bookmarks={name=the.mpg0,bytes=56119296,time=93}
      #EXTVLCOPT:bookmarks={name=the.mpg0,bytes=56119296,time=93},{name=the.mpg1,bytes=1334441410,time=2354},...
      C:\video\the.mpg
   */
   bool  bNextIsFile = 0;
   char *pszMeta = 0;
   char *pszCur  = pszClM3UText;
   char *pszNext = 0;
   char *pszTime = 0;
   int iCurLine=0,iMetaLine=0,iFileLine=0;

   char  szTimeBuf1[100],szTimeBuf2[100],szTimeBuf3[100];

   // find last EXTVLCOPT entry
   while (pszCur && *pszCur) {
      pszNext = strchr(pszCur, '\n');
      if (pszNext)
         *pszNext++ = '\0';
      removeCRLF(pszCur);
      iCurLine++;
      if (strBegins(pszCur, "#EXTVLCOPT:bookmarks=")) {
         pszMeta = pszCur;
         bNextIsFile = 1;
         iMetaLine = iCurLine;
      }
      else
      if (bNextIsFile) {
         bNextIsFile = 0;
         pszClM3UFileEntry = pszCur;
         iFileLine = iCurLine;
      }
      pszCur = pszNext;
   }
   if (!pszMeta)
      return 9+perr("no #EXTVLCOPT:bookmarks= found within %s\n", pszm3u);
   if (!pszClM3UFileEntry || !strlen(pszClM3UFileEntry))
      return 9+perr("no input file filename found within %s\n", pszm3u);
   if (!fileExists(pszClM3UFileEntry)) {
      perr("input file not found: %s\n", pszClM3UFileEntry);
      pinf("from line %03u of M3U: %s\n", iFileLine, pszm3u);
      return 9;
   }
   if (cs.verbose) {
      printf("using: line %u, %.60s ...\n", iMetaLine, pszMeta);
      printf("using: line %u, %s\n", iFileLine, pszClM3UFileEntry);
   }
   
   // parse that entry
   pszCur = pszMeta;
   int istate2 = 0;
   int nTimeSec = 0;
   while (pszCur && *pszCur) {
      // convert bookmarks into keep commands
      if (!(pszNext = strstr(pszCur, "bytes=")))
         break;
      pszNext += 6;
      num nPos = atonum(pszNext);
      if (pszTime = strstr(pszNext, "time="))
         nTimeSec = atoi(pszTime+5);
      if (!(istate2++ & 1)){
         aCmd[iCmd] = SFKMOV_KEEP;
         aBeg[iCmd] = nPos;
         aBegSec[iCmd] = nTimeSec;
      } else {
         aEnd[iCmd] = nPos;
         aEndSec[iCmd] = nTimeSec;
         if (cs.verbose)
            printf("%s : %s-%s (%s-%s)\n", 
               aCmd[iCmd] == SFKMOV_KEEP ? "keep":"skip",
               numtoa(aBeg[iCmd],10,szTimeBuf1), numtoa(aEnd[iCmd],10,szTimeBuf2),
               movtimetoa(aBegSec[iCmd]*100,szTimeBuf3),movtimetoa(aEndSec[iCmd]*100));
         iCmd++;
      }
      pszCur = pszNext;
   }
   
   // plausi check
   if (istate2 & 1)
      return 9+perr("uneven number of boomarks found in %s\n", pszm3u);
   if (cs.verbose) {
      printf("------------------------\n");
   }

   return 0;
}

int Media::analyze(uchar *pbuf, int isize)
{
   return 0;
}

int Media::renderTempName(char *pszFinal)
{
   // from: pszFinal == output.mpg
   // to  : pszFinal == output-tmp.mpg
   //       szClFinalFile  == output.mpg
   strcopy(szClFinalFile, pszFinal);

   char szNameBuf[SFK_MAX_PATH+10];
   strcopy(szNameBuf, pszFinal);

   char *pszBase = szNameBuf;
   char *pszExt  = strrchr(szNameBuf, '.');

   if (!pszExt)
      return 9+perr("missing file extension on output name: %s\n", pszFinal);

   if (SFTmpFile::tmpDirWasSet()) {
      // NO *pszExt del here, using full ".ext"
      SFTmpFile otmp(pszExt, 1);
      char *psz = otmp.name();
      strcopy(szClTmpOutFile, psz);
   } else {
      *pszExt++ = '\0';
      snprintf(szClTmpOutFile, sizeof(szClTmpOutFile)-10,
         "%s-tmp.%s", pszBase, pszExt);
   }

   if (bClShowTmp)
      printf("using temporary: %s\n", szClTmpOutFile);

   return 0;
}

int Media::processMediaFile(char *pszSrc, char *pszOutFile)
{
   if (!bClKeepAll && !iCmd) {
      pwarn("no commands given, skipping: %s\n", pszSrc);
      return 5;
   }

   const char *pszind = bClHaveM3UCommands ? "  ":"";
   if (cs.quiet >= 2) pszind = "";

   printf("input: %s%s\n", pszind, pszSrc);

   if (bClFixOutput) 
   do
   {
      if (bClJoinOutput && szClTmpOutFile[0]) {
         pszOutFile = szClTmpOutFile;
         break; // names already rendered
      }

      if (!pszOutFile)
         return 9+perr("missing output filename");

      if (renderTempName(pszOutFile))
         return 9;
      // szClOut   is now TEMPORARY name
      // szClFinal is the final filename

      pszOutFile = szClTmpOutFile;
   }
   while (0);

   if (pszOutFile)
      strcopy(szClRecentOutFile, pszOutFile);

   if ((cs.quiet<2) && pszOutFile)
      printf("out  : %s%s%s\n", pszind, pszOutFile, bClJoinOutput ? " (joined)":"");

   FileStat ofsSrc;
   if (ofsSrc.readFrom(pszSrc, 0, 1))
      return 9+perr("no such input file: %s", pszSrc);

   num nFileSize = ofsSrc.getSize();

   if (nFileSize <= 0)
      return 9+perr("empty input file: %s", pszSrc);

   if (!cs.sim && !pszOutFile)
      return 9+perr("missing output filename");

   int iRC = 0;

   num nTotalTime = nFileSize;

   FILE *fin = fopen(pszSrc, "rb");
   if (!fin) return 9+perr("unable to open input file: %s\n", pszSrc);

   if (!cs.sim) {
      if (!fClOut) {
         fClOut = fopen(pszOutFile, "wb");
         if (!fClOut) { fclose(fin); return 9+perr("unable to write: %s\n", pszOutFile); }
         clOutStat.copyFrom(ofsSrc);
         clOutStat.setFilename(pszOutFile);
      }
   }

   num nTotalBytes=0;

   // set start state
   int iCopyState = 1; // keep
   if (   aCmd[iFirstCmd] == SFKMOV_KEEP
       && aBeg[iFirstCmd] > 0
      )
       iCopyState = 0; // keep, but not from start
   else
   if (   aCmd[iFirstCmd] == SFKMOV_CUT
       && aBeg[iFirstCmd] == 0
      )
       iCopyState = 0; // cut from start

   // define current switch point
   num nCurBeg = 0;
   num nCurEnd = nTotalTime;
   
   char szBuf1[100],szBuf2[100],szBuf3[100];
   char szInfoBuf[100];
   
   num tLastInfo = 0;

   while (iRC==0 && nCurBeg<nTotalTime)
   {
      // BEGIN state of current cmd was set already.
      // find next switch point.
      int iNextCmd   = -1;
      int bNextIsBeg =  0;
      num iNextTime  = nTotalTime;
      for (int iTmp=iFirstCmd; aCmd[iTmp]; iTmp++)
      {
         num ibeg = aBeg[iTmp];
         num iend = aEnd[iTmp];

         if (ibeg > nCurBeg && ibeg < iNextTime) {
            iNextTime=ibeg; iNextCmd=iTmp; bNextIsBeg=1; 
            // printf("curmin: #%d with beg %s\n", iTmp, numtoa(ibeg, 10));
            continue; 
         }

         if (iend > nCurBeg && iend < iNextTime) {
            iNextTime=iend; iNextCmd=iTmp; bNextIsBeg=0; 
            // printf("curmin: #%d with end %s\n", iTmp, numtoa(iend, 10));
            continue; 
         }
      }

      // calc current range to keep or cut
      if (iNextCmd >= 0)
         nCurEnd = iNextTime;
      else
         nCurEnd = nTotalTime;

      if (!cs.quiet)
      {
         info.clear();

         int iBegSec = findSeconds(nCurBeg);
         int iEndSec = findSeconds(nCurEnd);

         if (iBegSec >= 0 && iEndSec >= 0)
            sprintf(szInfoBuf, "%s-%s (%s-%s)",
               numtoa(nCurBeg, 10, szBuf1), numtoa(nCurEnd, 10, szBuf2),
               movtimetoa(iBegSec*100,szBuf3),movtimetoa(iEndSec*100));
         else
            sprintf(szInfoBuf, "%s-%s", 
               numtoa(nCurBeg, 10, szBuf1), numtoa(nCurEnd, 10, szBuf2));

         if (iCopyState)
            printx("$copy : %s\n", szInfoBuf);
         else
            printx("#skip : %s\n", szInfoBuf);
      }

      // apply current range
      while (1)
      {
         info.setProgress(nTotalTime, nCurBeg, "bytes");
         info.setStatus(iCopyState ? "copy":"skip", pszOutFile ? pszOutFile : pszSrc);

         if (iCopyState)
         {
            // copy part
            int iMaxRead = sizeof(abBuf)-100;
   
            if (nCurEnd < nCurBeg + iMaxRead)
               iMaxRead = (int)(nCurEnd - nCurBeg);
               
            if (iMaxRead <= 0) {
               perr("invalid section length: %d at %s\n", iMaxRead, numtoa(nCurBeg, 10));
               iRC = 9;
               break;
            }
   
            int nread = (cs.sim && !bClScan) ? iMaxRead : fread(abBuf, 1, iMaxRead, fin);
   
            if (nread <= 0) 
            {
               info.print("file end reached.\n");
               iRC = 9;
               break; // EOF on input
            }

            if (bClScan)
               analyze(abBuf, nread);
   
            if (!cs.sim && fClOut) {
               int nwrite = myfwrite(abBuf, nread, fClOut);
               if (nwrite != nread) {
                  esys("fwrite", "error while writing: %s   \n", pszOutFile);
                  iRC = 9;
                  break;
               }
            }

            nTotalBytes += nread;
            nClGlobalBytes += nread;
            nCurBeg += nread;
         }
         else
         {
            // skip part
            if (myfseek(fin, nCurEnd, SEEK_SET)) {
               iRC = 9;
               break;
            }
            nCurBeg = nCurEnd;
         }

         if (nCurBeg >= nCurEnd)
            break;

      }  // endwhile part read loop

      if (iRC > 0)
         break;

      // switch copy state
      if (iNextCmd >= 0)
      {
         if (aCmd[iNextCmd]==SFKMOV_KEEP && bNextIsBeg) {
            iCopyState = 1; // start of keep
            if (cs.verbose > 2)
               info.print("part : kb.KEEP from %s\n", numtoa(nCurBeg, 10));
         }
         else
         if (aCmd[iNextCmd]==SFKMOV_KEEP && !bNextIsBeg) {
            iCopyState = 0; // end of keep
            if (cs.verbose > 2)
               info.print("part : ke.SKIP from %s\n", numtoa(nCurBeg, 10)); 
         }
         else
         if (aCmd[iNextCmd]==SFKMOV_CUT && bNextIsBeg) {
            iCopyState = 0; // start of cut
            if (cs.verbose > 2)
               info.print("part : cb.SKIP from %s\n", numtoa(nCurBeg, 10)); 
         }
         else
         if (aCmd[iNextCmd]==SFKMOV_CUT && !bNextIsBeg) {
            iCopyState = 1; // end of cut
            if (cs.verbose > 2)
               info.print("part : ce.KEEP from %s\n", numtoa(nCurBeg, 10)); 
         }
      }

   }  // endwhile overall I/O loop

   info.clear();

   if (!bClJoinOutput)
      closeOutput();
   // else called later

   fclose(fin);

   if (!iRC && cs.verbose) {
      if (cs.sim) {
         printf("would copy %d mb (%s bytes).\n", 
            (int)(nTotalBytes/1000000), numtoa(nTotalBytes));
      } else {
         printf("copied %s bytes.\n", numtoa(nTotalBytes));
      }
   }

   if (!iRC && szClMoveSrcOutDir[0]) {
      char *pszSrcRelName = strrchr(pszSrc, glblPathChar);
      if (pszSrcRelName)
         pszSrcRelName++;
      else
         pszSrcRelName = pszSrc;
      joinPath(szClMoveSrcOutFile, sizeof(szClMoveSrcOutDir),
               szClMoveSrcOutDir, pszSrcRelName);
      const char *pszInfo = "";
      if (fileExists(szClMoveSrcOutFile)) {
         if (cs.sim) {
            pszInfo = " (output file exists)";
         } else {
            if (cs.force) {
               remove(szClMoveSrcOutFile);
               pszInfo = " (overwritten)";
            } else {
               pszInfo = " "; // dummy for following error
            }
         }
      }
      if (!cs.quiet)
         printx("$move : %s -> %s%s\n", pszSrc, szClMoveSrcOutFile, pszInfo);
      if (!cs.sim) {
         if (rename(pszSrc, szClMoveSrcOutFile)) {
            perr("cannot move %s -> %s\n", pszSrc, szClMoveSrcOutFile);
            static bool btold=0;
            if (!btold) {
               btold=1;
               if (pszInfo[0])
                  pinf("add option -force to overwrite existing output file.\n");
               else
                  pinf("output dir must be on same file system as input file.\n");
            }
         }
      }
   }

   iClDoneFiles++;

   return iRC;
}

int execMedia(char *pszSrc, char *pszOutFile)
{
   Media &m = Media::current();
   
   int iRC = 0;

   if (m.bClHaveM3UCommands) {
      // these are valid per single file only
      m.clearCommands();
   }
   
   if (endsWithExt(pszSrc, str(".m3u"))) {
      if (!m.bClHaveKeep) {
         pwarn("missing \"-keepbook\" command, skipping: %s\n", pszSrc);
         return 5;
      }
      if (cs.quiet<2)
         printf("using: %s\n", pszSrc);
      if (iRC = m.parseM3UFile(pszSrc)) {
         // a single M3U batch is invalid, 
         // but overall processing may keep running
         m.iClInvalidFiles++;
         return iRC;
      }
      if (!(pszSrc = m.pszClM3UFileEntry)) {
         m.iClInvalidFiles++;
         return 9; // safety
      }
   }

   if (iRC = m.processMediaFile(pszSrc, pszOutFile))
      m.iClInvalidFiles++;

   return iRC;
}

bool isHelpOpt(char *psz) {
   if (!strcmp(psz, "-h"))     return 1;
   if (!strcmp(psz, "-help"))  return 1;
   if (!strcmp(psz, "-?"))     return 1;
   if (!strcmp(psz, "/?"))     return 1;
   if (!strcmp(psz, "/help"))  return 1;
   return 0;
}

// process -opt=value AND -opt value
bool haveParmOption(char *argv[], int argc, int &iDir, cchar *pszOptBase, char **pszOutParm)
{
   *pszOutParm = 0;  // if this stays NULL it tells ERROR status.

   // check if format -opt=value is given
   char szEqBuf[100];
   sprintf(szEqBuf, "%s=", pszOptBase);
   char *pszOpt = argv[iDir];
   if (*pszOpt == '+') pszOpt++; // e.g. +md5gento=
   if (!strncmp(pszOpt, szEqBuf, strlen(szEqBuf))) {
      *pszOutParm = pszOpt+strlen(szEqBuf);
      return 1;
   }

   // check if format "-opt value" is given
   if (!strcmp(pszOpt, pszOptBase)) {
      if (iDir >= argc-1) {
         perr("missing parameter after option %s\n", pszOptBase);
         return 0;
      }
      iDir++;  // IDIR INCREMENT IS WRITTEN BACK!
      *pszOutParm = argv[iDir];
      return 1;
   }

   return 0;
}

#ifdef VFILEBASE
void resetLoadCaches(bool bfinal)
{
   glblVCache.reset(bfinal);
   glblConCache.reset();
}
#endif // VFILEBASE

// template,tpl: command option handling loop
/*
   ifcmd (!strcmp(pszCmd, "mycommand"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk cmd ...\n"
             "\n"
             "   summary\n"
             "\n"
             "   $options\n"
             "      -opt1     text1\n"
             "\n"
             "   $pattern support\n"
             "   $command chaining\n"
             "   $see also\n"
             "\n"
             "   $examples\n"
             "      #examp1\n"
             "         explanation1\n"
             );
      ehelp;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-opt1", &pszParm)) {
            if (!pszParm) return 9;
            nValue = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(pszArg, "-opt2")) {
            bFlag = 1;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!strcmp(pszArg, "key1")) {
            if (iDir >= argc-1) return 9+perr("missing parameter after %s\n", pszArg);
            char *pszParm = argv[++iDir];
         }
      }
      
      // ...

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }
*/

StringTable glblSynTests;

void shutdownAllGlobalData()
{__
   // final cleanup of tmp cmd data
   cleanupTmpCmdData();

   if (pGlblDumpBuf) delete [] pGlblDumpBuf;

   #ifdef WITH_BITFILTER
   glblBitFilter.shutdown();
   #endif // WITH_BITFILTER

   // cleanup for all commands
   glblFileSet.shutdown();
   glblCircleMap.reset();

   #ifdef VFILEBASE
   resetLoadCaches(1);
   #endif // VFILEBASE

   if (pGlblFileParms)  delete pGlblFileParms;
   if (apGlblFileParms) delete [] apGlblFileParms;
   if (pszGlblJamRoot)  delete [] pszGlblJamRoot;
   if (pszGlblDstRoot)  delete [] pszGlblDstRoot;
   if (pszGlblSinceDir) delete [] pszGlblSinceDir;
   if (pszGlblDirTimes) delete [] pszGlblDirTimes;

   chain.shutdown();
   gfiltPreContext.shutdown();
   glblSynTests.resetEntries();
   Media::current().shutdown();

   #ifdef SFK_CCDIRTIME
   if (glblCreatedDirs.numberOfEntries() > 0)
      if (cs.verbose >= 1) {
         pwarn("createddirs list has remaining entries:\n");
         glblCreatedDirs.dump();
      }
   glblCreatedDirs.resetEntries();
   #endif

   #ifdef _WIN32
   // used by getFileMD5NoCache, was alloc'ed on demand:
   if (pGlblMD5NoCacheBuf != 0)
      VirtualFree(pGlblMD5NoCacheBuf, nGlblMD5NoCacheBufSize, MEM_DECOMMIT);
   #endif

   #ifndef USE_SFK_BASE
   sfkNetIO.closeAll();
   #endif // USE_SFK_BASE

   #ifdef VFILEBASE
   // in case any tcp was used
   TCPCore::sysCleanup();
   #endif // VFILEBASE

   #if (defined(WITH_TCP) || defined(VFILENET) || defined(DV_TCP))
   shutdownTCP();
   #endif
}

void cleanupTmpCmdData()
{
   glblGrepPat.reset();
   glblIncBin.reset();
   glblSFL.resetEntries();
   glblFileListCache.resetEntries();
   #ifndef USE_SFK_BASE
   glblFTPRemList.resetEntries();
   glblFTPLocList.resetEntries();
   filedb.reset();
   glblVerifier.reset();
   #endif
   glblErrorLog.resetEntries();
   glblStaleLog.resetEntries();
}

// lowest level output for words or full lines
int sfkprintf(const char *pszFormat, ...)
{
   // output to stdout
   va_list argList;
   va_start(argList, pszFormat);
   ::vprintf(pszFormat, argList);
   return 0;
}

#ifndef USE_SFK_BASE

// register syntax test
void subregtest(cchar *pszcmd, cchar *pszTest) {
   // if not running the syntest cmd, do nothing:
   if (strcmp(pszcmd, "syntest"))
      return;
   if (!bGlblSyntaxTest) // avoid recursion
      glblSynTests.addEntry((char*)pszTest);
}

#define regtest(x) subregtest(pszCmd, x)

// run user interface tests, by calling main() again
int runSyntaxTests(char *penv[])
{__
   bGlblSyntaxTest = 1;
   bool bVerbose = (cs.verbose > 0);
   cs.verbose = 0;
   char **myargv = new char*[100];
   char *pszBuf  = new char[MAX_LINE_LEN+10];
   int myargc = 0;
   int lrc=0, npassed=0, nfailed=0;
   for (int i=0; i<glblSynTests.numberOfEntries(); i++) 
   {
      myargc = 0;
      myargv[myargc++] = str("sfk");
      myargv[myargc++] = str("-stest");
      char *psz1 = glblSynTests.getEntry(i, __LINE__);
      if (!psz1) break;
      mystrcopy(pszBuf, psz1, MAX_LINE_LEN);
      // linux syntax fixes
      psz1 = pszBuf;
      while ((psz1 = strchr(psz1, '$')))
         *psz1++ = glblRunChar;
      // process line
      psz1 = pszBuf;
      // sfk -stest md5gento dummy.dat dummydir
      while (*psz1) {
         char *psz2 = strchr(psz1, ' ');
         if (psz2) {
            *psz2++ = '\0';
            myargv[myargc++] = psz1;
            // activate masked blanks (_)
            char *psz3 = psz1;
            while ((psz3 = strchr(psz3, '_')))
               *psz3++ = ' ';
            // continue on next parm
            psz1 = psz2;
         } else {
            if (strlen(psz1))
               myargv[myargc++] = psz1;
            break;
         }
      }
      char *pszCmd = myargv[2];
      int iDir = 3;
      bool bFatal = 0;
      lrc = submain(myargc, myargv, penv, pszCmd, iDir, bFatal);
      if (lrc || bVerbose) {
         printf("rc %d : ", lrc);
         for (int k=0; k<myargc; k++)
            printf("%s ",myargv[k]);
         printf("\n");
      }
      if (lrc) nfailed++;
      else     npassed++;

      // before the next test, reset processing state
      glblFileSet.reset();
      if (pszGlblSinceDir) { delete [] pszGlblSinceDir; pszGlblSinceDir=0; }
      chain.colfiles = 0;
      bGlblStdInAny = 0;
   }
   if (nfailed > 0)
      printf("%d syntax checks failed (%d passed).\n",nfailed,npassed);
   else
      printf(": OK : %d syntax checks passed.\n",npassed);
   delete [] pszBuf;
   delete [] myargv;
   return (nfailed > 0) ? 9 : 0;
}

int blockChain(char *pszCmd)
{
   if (chain.usefiles || chain.usedata || chain.colfiles || chain.coldata)
      return 9+perr("command \"%s\" does not support chaining.\n", pszCmd);
   return 0;
}

int blockChain(char *pszCmd, int iDir, int argc, char *argv[], int nSilent=0)
{
   char *pszNext  = 0;
   bool  bforce   = 0;
   int  bbinary   = 0;
   int nNextType = findNextChainType(iDir, argv, argc, &pszNext, bforce, bbinary);
   if (nNextType == 0)
      return 0;
   if (!(nSilent & 1)) {
      perr("command \"%s\" does not support chaining (+%s).\n", pszCmd, pszNext);
      if (!(nSilent & 2)) {
         pinf("say \"sfk -nochain ...\" if you want to process a file with name \"+%s\"\n", pszNext);
      }
   }
   return 9;
}

class SFKMainStat {
public:
    SFKMainStat (num nStartTime);
   ~SFKMainStat ( );
private:
   num clStartTime;
};

SFKMainStat::SFKMainStat(num nStartTime) { 
   clStartTime = nStartTime; 
}

SFKMainStat::~SFKMainStat( ) {
   if (gs.tellExecTime) {
      printf("done in %s msec. \n", numtoa(getCurrentTime()-clStartTime));
   }
}

// sort and count
int groupChainText(char *pcmd, bool brev, bool bcnt, int ndig)
{__
   // use a KeyMap of Index-Based StringMaps:
   KeyMap omap;
   omap.setcase(cs.usecase);
   omap.setreverse(brev);

   // collect text lines into groups
   for (int i=0; i<chain.indata->numberOfEntries(); i++) {
      char *pattr = str("");
      char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
      num   nidx  = 0;
      AttribStringMap *pgrp = (AttribStringMap*)omap.get(ptext);
      if (!pgrp) {
         // create new string group under search key
         pgrp = new AttribStringMap();
         if (!pgrp) return 9+perr("out of memory");
         mtklog(("pgrp-put %p under \"%s\"", pgrp, ptext));
         if (omap.put(ptext, pgrp))
            return 9+perr("failed to sort, probably out of memory");
      } else {
         // add to existing group, at next index
         nidx = pgrp->size(); // next index == size
      }
      if (!pattr) pattr = str("");
      if (pgrp->put(nidx, ptext, pattr))
         return 9+perr("failed to sort, probably out of memory");
   }

   // in case of group, need this:
   StringMap oout;

   // dump group contents
   for (int i=0; i<omap.size(); i++) 
   {
      char *pgrpkey = 0;
      AttribStringMap *pgrp = (AttribStringMap*)omap.iget(i, &pgrpkey);
      if (!pgrp) return 9+perr("int. #168281033");
      if (bcnt) 
      {
         int nsize = pgrp->size();
         sprintf(szLineBuf, "%0*u\t", (int)ndig, nsize);
         int nlen = strlen(szLineBuf);

         memset(szAttrBuf, 'p', nlen);
         szAttrBuf[nlen] = '\0';

         int nrem = MAX_LINE_LEN - nlen;
         // get first entry of group
         char *pattr = 0, *pkey = 0;
         char *ptext = pgrp->iget(0, &pkey, &pattr);
         if (!ptext) return 9+perr("int. #168281035");

         strncpy(szLineBuf+nlen, ptext, nrem);
         szLineBuf[MAX_LINE_LEN-10] = '\0';

         strncpy(szAttrBuf+nlen, pattr, nrem);
         szAttrBuf[MAX_LINE_LEN-10] = '\0';

         oout.put(szLineBuf, szAttrBuf);

         // if (chain.colany())
         //    chain.addLine(szLineBuf, szAttrBuf);
         // else
         //    printColorText(szLineBuf, szAttrBuf, 1); // with lf
      }
      else
      for (int k=0; k<pgrp->size(); k++) {
         char *pkey = 0, *pattr = 0;
         char *pval = pgrp->iget(k, &pkey, &pattr);
         if (!pval) return 9+perr("int. #168281034");
         if (!pattr) pattr = str("");
         if (chain.colany())
            chain.addLine(pval, pattr);
         else
            printColorText(pval, pattr, 1); // with lf
      }
   }

   if (bcnt) {
      // dump sorted output
      for (int k=0; k<oout.size(); k++) {
         char *pkey=0;
         char *pattr = oout.iget(k, &pkey);
         if (!pkey) return 9+perr("int. #168281039");
         if (!pattr) pattr = str("");
         if (chain.colany())
            chain.addLine(pkey, pattr);
         else
            printColorText(pkey, pattr, 1); // with lf
      }
   }

   // cleanup
   for (int i=0; i<omap.size(); i++) 
   {
      AttribStringMap *pgrp = (AttribStringMap*)omap.iget(i);
      mtklog(("pgrp-del %p", pgrp));
      if (pgrp) delete pgrp;
   }

   return 0;
}

int diffChainText(char *pszRefFile)
{__
   KeyMap omapFile,omapChain,omapMix;
   omapFile.setcase(cs.usecase);
   omapChain.setcase(cs.usecase);
   omapMix.setcase(cs.usecase);

   // read ref data, reducing dub lines
   FILE *fin = fopen(pszRefFile, "r");
   if (!fin)
      return 9+perr("cannot open: %s\n", pszRefFile);
   myfgets_init();
   while (myfgets(szLineBuf, MAX_LINE_LEN, fin)) 
   {
      removeCRLF(szLineBuf);
      omapFile.put(szLineBuf, 0);
      omapMix.put(szLineBuf, 0);
   }
   fclose(fin);
   
   // read chain text, reducing dub lines
   for (int i=0; i<chain.indata->numberOfEntries(); i++) 
   {
      char *pattr = str("");
      char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
      omapChain.put(ptext, 0);
      omapMix.put(ptext, 0);
   }
   
   // list differences
   for (int i=0; i<omapMix.size(); i++)
   {
      char *pszMixLine = 0;
      omapMix.iget(i, &pszMixLine);
      if (!pszMixLine) continue; // safety
      
      bool bChainSet = omapChain.isset(pszMixLine);
      bool bFileSet  = omapFile.isset(pszMixLine);
      
      if (bChainSet && bFileSet)
         chain.print("- : %s\n", pszMixLine);
      else
      if (bChainSet)
         chain.print("> : %s\n", pszMixLine);
      else
         chain.print("< : %s\n", pszMixLine);
   }
   
   return 0;
}

void dospell(char *pszWord, bool bNato)
{
   static const char *apszMixed[26] = 
   {
      "Alpha", "Bravo",  "Charlie", "Delta",  "Echo",  "Foxtrot",  "Golf", "Hotel", 
      "India", "Johnny", "King",    "London", "Mike",  "November", "Oscar", "Peter", 
      "Queen", "Roger",  "Sierra",  "Tango",  "Union", "Victor",   "William", 
      "X-ray", "Yankee", "Zebra"
   };

   static const char *apszNato[26] = 
   {
      "Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", 
      "India", "Juliet", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", 
      "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whisky", 
      "X-ray", "Yankee", "Zulu"
   };

   const char **apsz = bNato ? apszNato : apszMixed;

   char szBuf[20];

   if (pszWord)
   {
      while (*pszWord)
      {
         char c = tolower(*pszWord++);
   
         if (c >= 'a' && c <= 'z') {
            if (chain.coldata)
               chain.addToCurLine((char*)apsz[c - 'a'], str(""));
            else
               printf("%s ", apsz[c - 'a']);
         } else {
            szBuf[0] = c;
            szBuf[1] = '\0';
            if (chain.coldata)
               chain.addToCurLine(szBuf, str(""));
            else
               printf("%s ", szBuf);
         }
         if (chain.coldata)
            chain.addToCurLine(str(" "), str(""));
      }
   }
   else
   for (int i=0; i<26; i++)
   {
      printf("%-10.10s ", apsz[i]);
      if ((i & 7) == 7)
         printf("\n");
   }
}

#ifdef VFILENET
int execWGet(Coi *psrc, char *pDstDir, uint nmode)
{__
   char *pSrcName = psrc->name();

   bool bpath2path = (nmode & 2) ? 1 : 0;
   bool b1outfile  = (nmode & 8) ? 1 : 0;
   
   // default on single output file
   char *pDstName = pDstDir;

   int nMaxDst= 500;
   char szDstBuf[500+10]; mclear(szDstBuf);

   if (!b1outfile && pDstDir) 
   {
      mystrcopy(szDstBuf, pDstDir, nMaxDst);
      strcat(szDstBuf, glblPathStr);
   }

   num nSize = psrc->getSize(); // if any

   if (psrc->open("rb"))
      return 9+perr("cannot read: %s%s\n", psrc->name(),psrc->lasterr());

   char *pctype = psrc->header("content-type");

   // if content is not in memory yet, try to collect,
   // up to a limit of 200 MB
   num    nalloc = 0;
   uchar *pdata  = 0;
   num    nused  = 0;
   bool   btomem = psrc->data().src.data ? 0 : 1;

   // make sure to use the redirected source name
   pSrcName = psrc->name();

   bool bSetDefault = 0;

   if (b1outfile)
   {
      if (cs.verbose)
         printf("write to single output file: %s\n", pDstName);
   }
   else
   {
      // create target filename without output dir

      char *pcat = szDstBuf + strlen(szDstBuf);
      int  nrem = nMaxDst  - strlen(szDstBuf);
   
      if (!flatURLName(pSrcName, pctype, pcat, nrem, nmode, bSetDefault))
         return 9+perr("wrong URL format: %s\n", pSrcName);

      pDstName = szDstBuf;

      if (cs.verbose)
         printf("write to joined output path: %s\n", pDstName);
   }

   if (bSetDefault && !nmode)
      return 9+perr("need -path2name or -fullpath on URLs like : %s\n", pSrcName);

   if (bpath2path)
      if (createOutDirTree(pDstName))
         return 9;

   Coi *pdst = new Coi(pDstName, 0);
   if (!pdst) return 9+perr("out of memory");
   CoiAutoDelete odel2(pdst, 0); // no decref

   num nread    = 0;
   num nWritten = 0;

   // if (!cs.quiet && !cs.nowarn && pdst->existsFile())
   //    pwarn("file exists, overwriting: %s\n", pdst->name());

   if (pdst->open("wb"))
      perr("cannot write: %s%s\n", pdst->name(),pdst->lasterr());
   else
   {
      info.setAction("write", pdst->name(), "");

      while ((nread = psrc->read(abBuf, sizeof(abBuf)-1000)) > 0) 
      {
         if (pdst->write(abBuf, nread) != nread) {
            perr("cannot fully write %s, probably disk full.\n", pdst->name());
            break;
         }

         if (btomem)
         {
            num nrem = nalloc - nused;
            if (nrem < nread + 1000) 
            {
               // expand buffer
               if (!nalloc) nalloc = 10000; // initial

               num nalloc2 = nalloc * 2 + nread;

               if (nalloc2 >= 100 * 1000000) {
                  pinf("download will not be cached (too large).\n");
                  btomem = 0;
                  delete [] pdata;
                  pdata  = 0;
                  nalloc = 0;
               } else {
                  uchar *ptmp = new uchar[nalloc2+100];
                  memcpy(ptmp, pdata, nused);
                  // swap old and new
                  delete [] pdata;
                  pdata  = ptmp;
                  nalloc = nalloc2;
                  nrem   = nalloc - nused;
               }
            }
         }

         if (btomem)
         {
            // add block to memory
            if (nused+nread > nalloc)
               { perr("int. #228290640"); btomem=0; break; }
            memcpy(pdata+nused, abBuf, nread);
            nused += nread;
         }

         nWritten += nread;
         info.setProgress(nSize, nWritten, "bytes");
      }
   }
 
   pdst->close();
   psrc->close();

   if (btomem && pdata && nused)
      psrc->setContent(pdata, nused, 0);

   // NO cleanup of pdata, as it is cached!

   if (cs.quiet < 2)
      info.print("done : %s (%s bytes).\n", pdst->name(), numtoa(nWritten));

   if (chain.colfiles) 
   {
      // use tmp coi to make sure it is copied
      Coi ocoi(pdst->name(), 0);
      chain.addFile(ocoi); // is copied
   }

   return 0;
}
#endif // VFILENET

void reduceToPath(char *psz)
{
   int iLen = strlen(psz);

   if (iLen > 1 && psz[iLen-1] == glblPathChar)
      return; // is a path already

   // FROM F:\\mydir\\zz-index.txt
   // TO   F:\\mydir\\
   // FROM 
   while (iLen > 1 && psz[iLen-1] != glblPathChar) {
      psz[iLen-1] = '\0';
      iLen--;
   }
}

// rc  0: invalid
// rc >0: length of headline
int validIndexFormat(char *pszText, char *pszFilename)
{
   // headline must contain: {TAB}name{TAB}sfk-index-
   char *pszHeadStart = pszText;
   char *pszHeadEnd   = strchr(pszHeadStart, '\n');
   char *pszHeadForm  = strstr(pszHeadStart, "\tname\tsfk-index-");
   if (pszHeadForm==0 || pszHeadEnd==0 || pszHeadForm>pszHeadEnd) {
      pwarn("invalid index format, skipping: %s\n", pszFilename);
      pinf("index files must contain a headline with {tab}name{tab}sfk-index-\n");
      return 0;
   }
   return pszHeadEnd - pszHeadStart;
}

int makeINameResultLine(char *pszText, char *pszAttr, int iMask, bool bTabs, int iDigits)
{
   // from: date{tab}time{tab}size{tab}name
   // to  : date time name
   szLineBuf[0] = '\0';
   szAttrBuf[0] = '\0';

   char *pdstt = szLineBuf;
   char *pdsta = szAttrBuf;
   char *pmaxt = szLineBuf + MAX_LINE_LEN;
   char *pmaxa = szAttrBuf + MAX_LINE_LEN;

   char *pcol  = pszText;
   char *pnex  = 0;
   char  csep  = bTabs ? '\t':' ';
   bool  bname = 0;

   for (int icol=0; *pcol; icol++)
   {
      if (!(pnex = strchr(pcol, '\t'))) {
         pnex = pcol + strlen(pcol);
         bname = 1;
      }

      int ilen = pnex - pcol;

      if (*pnex)
         pnex++;

      if (!bname && !(iMask & (1U << icol))) {
         pcol = pnex;
         continue;
      }

      if (icol==2 && bTabs==0) 
      {
         // reformat size field
         num nSize = atonum(pcol);
         char *psz = numtoa_blank(nSize, iDigits);
         ilen = strlen(psz);
         if (pdstt+ilen > pmaxt) return 12;
         memcpy(pdstt, psz, ilen);
         pdstt += ilen;
         *pdstt++ = csep;
         if (pszAttr) {
            if (pdsta+ilen > pmaxa) return 12;
            memset(pdsta, ' ', ilen+1);
            pdsta += ilen+1;
         }
      }
      else
      {
         // copy all other fields as is
         if (pdstt+ilen > pmaxt)
            return 11; // overflow
   
         memcpy(pdstt, pcol, ilen);
         pdstt += ilen;
         *pdstt++ = csep;
   
         if (pszAttr) {
            if (pdsta+ilen > pmaxa)
               return 11; // overflow
            memcpy(pdsta, pszAttr+(pcol-pszText), ilen);
            pdsta += ilen;
            *pdsta++ = ' ';
         }
      }

      pcol = pnex;
   }

   *pdstt = '\0';
   *pdsta = '\0';
   
   return 0;
}

void printSearchReplaceCommands()
{
printx("   $see also\n"
       "      #sfk find<def>     search  fixed    text in   text/binary files\n"
       "      #sfk ftext<def>    search  fixed    text in   text        files\n"
       "      #sfk hexfind<def>  search  fixed    text in        binary files\n"
       "      #sfk replace<def>  replace fixed    text in   text/binary files\n"
       "      #sfk filter<def>   filter and edit  text with simple wildcards\n"
       "\n");
}

void printSFKMatchHelp(bool bRepHelp, bool bFullHelp=1)
{
printx("   $wildcards and SFK expressions\n"
       "      SFK Expressions are simple patterns containing literal text,\n"
       "      wildcards * and ? and character classes in square brackets [].\n"
       "      basically, the syntax provides extended wilcards but no\n"
       "      further logic and is not related to regular expressions.\n"
       "\n"
       "      search patterns are surrounded by a separator character which\n"
       "      can be anything not contained in the search text, like / or _\n"
       "\n");
if (bRepHelp)
printx("      $within a pattern #/fromtext/totext/<def> $the #fromtext<def> $may contain:\n");
else
printx("      $within a search pattern #/fromtext/<def> $the #fromtext<def> $may contain:\n");
printx("\n"
       "        $*<def>                       - 0 to 4000 characters in the same\n"
       "                                  text line or paragraph, i.e. all\n"
       "                                  bytes not being CR, LF or NULL.\n"
       "                                  4000 is just a default maximum\n"
       "                                  that can be changed by:\n"
       "        $[0.100000 chars]<def>        - 0 to 100000 characters in the same\n"
       "                                  text line or paragraph, i.e. the\n"
       "                                  same as * but with a larger range.\n"
       "        $?<def>                       - one character.\n"
       "        $???\x3f\x3f<def>                   - same as $[5.5 chars]<def> or $[5 chars]<def>\n"
       "        $[bytes]<def>                 - 0 to 4000 bytes (with CR,LF,NULL)\n"
       "                                  i.e. it collects stream text\n"
       "                                  across lines, even in binary data\n"
       "        $**<def>                      - the same as [bytes].\n"
       "        $[0.100 bytes]<def>           - 0 to 100 bytes\n"
       "        $[.100000 bytes]<def>         - up to 100000 bytes\n"
       "        $[1.* bytes]<def>             - 1 to default maximum bytes\n"
       "        $[30 bytes]<def>              - exactly 30 bytes\n"
       "        $[byte of aeiou]<def>         - one vocal (a OR A OR e OR ...),\n"
       "                                  case insensitive by default.\n"
       "                                  \"aeiou\" is a character list.\n"
       "        $[byte of \\\\\\x2f]<def>            - a backslash \\ or forw. slash /\n"
       "        $[bytes of \\r\\n \\t]<def>      - whitespace incl. line ends\n"
       "        $[bytes of (\\r\\n \\t)]<def>    - the same, () are optional\n"
       "        $[bytes not \\r\\n\\0]<def>      - up to 4000 bytes as long as no\n"
       "                                  CR, LF or NULL byte appears\n"
       );
printx("        $[chars]<def>                 - the same as $[bytes not \\r\\n\\0]<def>,\n"
       "                                  i.e. collect text in a line\n"
       "        $[char not ( \\t)]<def>        - same as $[byte not ( \\r\\n\\0\\t)]<def>,\n"
       "                                  everything not blanks and tabs\n"
       "        $[char not )( \\t]<def>        - not brackets, blanks and tabs,\n"
       "                                  same as $not (\\(\\) \\t)<def>\n"
       "        $[chars of a-z0-9]<def>       - means a-zA-Z0-9 as search is\n"
       "                                  case insensitive by default\n"
       "        $[chars of \\x61-\\x7A]<def>    - search a-z but not A-Z, or use\n"
       "                                  option -case for case search\n"
    // "        $[others]<def>                - all chars or bytes NOT searched\n"
    // "                                  by previous part\n"
       "        $[eol]<def>                   - end of line by characters:\n"
       "                                  CRLF or LF or CR\n"
    // "        $[start or byte of \\r\\n]<def> - start of file or CR or LF.\n"
    // "        $[end or byte of \\r\\n]<def>   - end of file or CR or LF.\n"
       "\n"
       );
printx("        $[white]<def>     = chars of (\\t )     - 0 or more whitespaces\n"
       "        $[xwhite]<def>    = bytes of (\\t \\r\\n) - same but across lines\n"
       "        $[1 white]<def>   = byte  of (\\t )     - 1 whitespace\n"
       "        $[digit]<def>     = byte  of (0-9)     - 1 digit\n"
       "        $[digits]<def>    = bytes of (0-9)     - 0 or more digits\n"
       "        $[hexdigit]<def>  = byte  of (0-9a-f)  - 1 hexadecimal digit\n"
       "        $[hexdigits]<def> = bytes of (0-9a-f)  - 0 or more hex digits\n"
       "\n"
       );
printx("        anchors that have no length of their own:\n"
       "        $[start]<def>  - start of file\n"
       "        $[end]<def>    - end of file\n"
       "        $[lstart]<def> - line start, i.e. start or CRLF or CR or LF\n"
       "        $[lend]<def>   - logical line end, i.e. eol or end of file\n"
       "\n"
       );
printx("        $how to search or replace special characters:\n"
       "        - to search or replace text containing the literal characters\n"
       "          $* ? \\ [ ]<def> then these must be escaped like #\\\\* \\? \\\\ \\[ \\]<def>\n"
       "        - $( )<def> are escaped only within character lists, like #\\( \\)<def>\n"
       "        - to search or replace the $forward slash '/'<def> type $\\x2f<def> or use\n"
       "          another char around from/to text, e.g. #_fromtext_totext_<def>\n"
       "        - parameters with #blanks and non trivial characters<def> need double\n"
       "          quotes \"\", see also \"about Shell Command Characters\" below.\n"
       "\n"
       );
printx("        $expansion priorities:<def> (highest first)\n"
       "        if two search parts are side by side, and the same input\n"
       "        character matches both, then these priorities apply:\n"
       "\n"
       "          5: start, end, lstart, lend\n"
       "          4: literal text, eol\n"
       "          3: whitelist classes: byte of, bytes of\n"
       "          2: blacklist classes: chars not, bytes not\n"
       "          1: plain wildcards: ?, *, **, byte, bytes, chars\n"
       "\n"
       "        this means in \"/[bytes]foo/\" the [bytes] will stop to collect\n"
       "        characters as soon as \"foo\" is found, as \"foo\" is a literal.\n"
       "        on same or higher priority the right side stops the left side.\n"
       "\n"
       );
if (bRepHelp)
printx("      $the #totext<def> $may contain:\n"
       "\n"
       "        $[part 1]<def>          - use first text part of the fromtext.\n"
       "                            e.g. the fromtext #/*foo[.100 chars]bar*/<def>\n"
       "                            contains parts    # 1 2         3    4 5\n"
       "        $[part1]<def>           - the same (blank is optional).\n"
       "        $[parts 1,2,3]<def>     - use parts 1, 2 and 3.\n"
       "        $[parts 1-10]<def>      - use parts 1 to 10.\n"
       "        $[strip(part1,\\0)]<def> - use part 1 but remove zero bytes.\n"
       "                            only zero bytes \"\\0\" can be removed.\n"
       "        $[file.name]<def>       - full input filename with path\n"
       "        $[file.relname]<def>    - input filename without path\n"
       "        $[file.path]<def>       - input file's path\n"
       "        $[file.base]<def>       - relname without last .extension\n"
       "        $[file.ext]<def>        - input filename extension\n"
       "        $[all]<def>             - use all parts from fromtext.\n"
       "\n"
       "        although anchors like lstart, lend count as a separate part\n"
       "        they need NOT be specified in the totext. this means that\n"
       "        /[lstart]foo[lend]/bar/ just changes the word \"foo\".\n"
       "\n"
       );
printx("   $supported slash patterns\n"
       "      $\\t<def>    = TAB\n"
       "      $\\r<def>    = CR\n"
       "      $\\n<def>    = LF\n"
       "      $\\x00<def>  = one byte with code 00 hexadecimal\n"
       "      $\\0<def>    = short form for \\x00\n"
       "      $\\q<def>    = a double quote \"\n"
       "      $\\\\ <def>   = the backslash character \\ itself\n"
       "      $\\[<def>    = the bracket open character [\n"
       "      $\\]<def>    = the bracket close character ]\n"
       "      $\\\\*<def>    = the literal star character *\n"
       "      $\\?<def>    = the literal question mark  ?\n"
       "      $\\-<def>    = to use literal \"-\" in a command\n"
       "      Within multi line -bylist files:\n"
       "      $\\ <def>    = slash+blank is changed to a single blank\n"
       "      Only within \"char of\" or \"byte not\" lists:\n"
       "      $\\(<def>    = to use literal character \"(\"\n"
       "      $\\)<def>    = to use literal character \")\"\n"
       "\n"
       );
printx("   $SFK expression options\n"
       "      -showpart(s) print /from/ part numbers, range statistics\n"
       "                   and expansion priority points per part.\n"
       "                   done automatically if a required /to/ text\n"
       "                   is not given with a command.\n"
       "      -showbest    if a /from/ pattern finds nothing, use this to\n"
       "                   see how many parts would match so far, and with\n"
       "                   up to how many bytes per part. anchors like [lstart]\n"
       "                   may show a non zero length when matching (CR)LF.\n"
       "      -showlist    with -bylist, show the internal joined list if\n"
       "                   commands are spread across multiple lines.\n"
       "      -showall     show all of the above.\n"
       "      -xmaxlen=n   set default maximum length for chars or bytes commands,\n"
       "                   e.g. -maxlen=10000 means /foo*bar/ matches with up to\n"
       "                   10000 characters between foo and bar. the default max\n"
       "                   length without this option is 4000 characters.\n"
       "\n"
       );
printx("   $performance notes\n"
       "    - always use a string literal, or single byte or char, at the start\n"
       "      of your search expressions, like in $/foo*bar/ starting with 'f'.\n"
       "      #Do not use a wildcard like * at the start like in #/*foobar/<def>\n"
       "      when searching huge input data, as your search will #slow down by\n"
       "      #factor 256.<def> Use $/[lstart]*foobar/<def> instead.\n"
       "    - the system may cache output file(s), writing to disk in background\n"
       "      after sfk has finished. subsequent batch commands may execute slower.\n"
       "\n"
       );
}

void printAboutBracketExamples()
{
printx("   $about example numbers with [brackets]\n"
       "      if you see [1] type \"sfk cmd 1\" for whole command in one line.\n"
       "\n");
}

void printXRepExamples(char *pszCmd, bool bFind, bool bRep)
{
printAboutBracketExamples();
printx("   $bad examples with corrections\n"
       "      #if input text contains:\n"
       "         bool bClFoo;\n"
       "         bool bClBar   ;\n"
       "      #sfk xfind in.txt \"/bool[xwhite]bCl*[xwhite];/\"\n"
       "         does NOT match \"bool bClFoo;\" because * eats the\n"
       "         whole input line including \";\" so no input is left\n"
       "         for \"[xwhite];\" and the whole expression fails.\n"
       "      #sfk xfind in.txt \"/bool[xwhite]bCl[* not ;][xwhite];/\"\n"
       "         does both match \"bool bClFoo;\" and \"bool bClBar   ;\".\n"
       "         this means whenever your search fails to work write\n"
       "         in detail which characters (not) to collect where.\n"
       "\n"
       );

printx("   $working examples\n");

if (bRep)
{
printx("      #sfk xrep -text \"/class*CFoo/\"\n"
       "         an incomplete command (missing \"to\" part in pattern),\n"
       "         just to get a help text listing part numbers.\n"
       "      #sfk xrep -text \"/class*CFoo/[part1] [part2]/\" -dump -dir mydir -file .hpp\n"
       "         search all .hpp files within mydir, and replace for example\n"
       "         \"class IMPORT CFoo\" by \"class CFoo\". as long as -dump is given\n"
       "         it lists the found hits.\n"
       "      #sfk xrep -pat \"/[byte not \\n][end]/[part1]\\n/\" -dir mydir -file .cpp .hpp\n"
       "         find all .cpp or .hpp files in mydir not ending with a line\n"
       "         ended by linefeed, and add the linefeed.\n"
       "      #sfk xrep -dir . -file .hpp -enddir -text \"/[byte not \\n][end]/[part1]\\n/\"\n"
       "         similar to the above but with dir parameters first.\n"
       "      #sfk xrep io.txt \"/[lstart][20 chars]*/[part3]/\"\n"
       "         cut first 20 characters in every line of io.txt.\n"
       );
printx("      #sfk xrep io.txt \"/[lstart][9 bytes]1001*/[part2]9009[part4]/\"\n"
       "         in fixed position text file data like:\n"
       "            rec. 001:5318 aef3 2751 1001\n"
       "            rec. 002:1001 aef5 275a 1001\n"
       "            rec. 003:ef49 aef7 2763 1001\n"
       "         replace \"1001\" where it appears in columns 10 to 13,\n"
       "         in this example only the first \"1001\" in record 2.\n");
printx("      #sfk xrep in.dat \"/\\xFF\\xFE[1 byte]\\x80\\x81/\\xFF\\xFE\\x00\\x80\\x81/\"\n"
       "         replace byte sequences (not ASCII text strings) in binary data.\n"
       "         searches byte groups starting with values 0xFF 0xFE, then any\n"
       "         single byte, then 0x80 0x81, and replaces the variable byte\n"
       "         by always a binary 0x00 value.\n"
       );
}
if (bFind)
{
printx("      #sfk xfind -text \"/class [bytes]{[bytes]}/[all]\\n\\n/\"\n"
       "       #-dir mydir -file .hpp +tofile out.txt\n"
       "         collect class definitions from mydir and write output\n"
       "         indirectly (via command chaining) to out.txt [13]\n");
printx("      #sfk %s in.txt -text \"/foo*bar/\"\n"
       "         search in.txt for patterns starting with foo and ending\n"
       "         with bar, in the same line, with up to 4000 characters inbetween.\n"
       "      #sfk xhex -text \"/foo[0.100000 bytes]bar/\" -dir mydir\n"
       "         search all text and binary files of mydir for patterns of\n"
       "         foo and bar with 0 to 100000 bytes (including NULL, CR\n"
       "         and LF) inbetween and print output as hex dump.\n"
       "      #sfk %s -text \"/printf(**);/\" -dir mydir -file .cpp\n"
       "         find all printf statements in source code, including statements\n"
       "         across multiple lines.\n"
       , pszCmd, pszCmd
       );
}
}

// for filter
void printBewareWide( )
{
   printx("   $beware of Shell Command Characters.\n" // filter, wide
          "      to find or replace text containing #spaces<def> or special characters like #<>|!&?*<def>\n"
          "      you #must add quotes \"\" around parameters or the shell will #destroy your command<def>.\n"
          "      it splits the command into parts and gives SFK only one part, causing errors.\n"
          "      therefore #-replace _ _&nbsp;_<def> must be written like: #-replace \"_ _&nbsp;_\"\n"
          #ifdef _WIN32
          "      within a $.bat or .cmd file<def> the #percent %%<def> must be escaped like #%%%%<def> even\n"
          "      within quoted strings: #sfk echo -spat \"percent %%%% is a percent \\x25\"<def>\n"
          #else
          "      within a $bash batch file the #dollar $$ must<def> be escaped like #\\$$<def> even\n"
          "      within quoted strings: #sfk echo -spat \"dollar \\$$ is a dollar \\x24\"<def>\n"
          #endif
          "\n"
          );
}

// for replace, xed
void printBewareLean( )
{
   printx("   $beware of Shell Command Characters.\n" // replace, lean
          "      to find or replace text patterns containing #spaces<def> or special\n"
          "      characters like #<>|!&?*<def> you #must add quotes \"\"<def> around parameters\n"
          "      or the shell environment will #destroy your command<def>. for example,\n"
          "      #-text / /&nbsp;/<def> must be written like: #-text \"/ /&nbsp;/\"\n"
          #ifdef _WIN32
          "      within a $.bat or .cmd file<def> the #percent %%<def> must be escaped like #%%%%<def>\n"
          "      even within quotes: #sfk echo -spat \"percent %%%% is a percent \\x25\"<def>\n"
          #else
          "      within a $bash batch file the #dollar $$ must<def> be escaped like #\\$$<def> even\n"
          "      within quoted strings: #sfk echo -spat \"dollar \\$$ is a dollar \\x24\"<def>\n"
          #endif
          "\n"
          );
}

static const char *aWebRef[] =
{
   "sfk", "detab", "stat", "twinscan", "filefind", "env", "bintosrc", 
   "sleep", "sample", "script", "partcopy", "patch", "rep", "run", 
   "pathfind", "ftpserv", "httpserv", "filetrans", "ftp", "remcrlf", 
   "joinlines", "find", "filter", "snapto", "winshell", "vmftp", "md5list", 
   "clip", "hexdump", "charset", "split", "list", "sincedir", "alias", "tcpdump", 
   "echo", "runloop", "hsel", "hopt", "hchain", "hpat", "deblank", "tail", 
   "hextobin", "fview", "del", "findclass", "inst", "reflist", "deplist", 
   "netlog", "copy", "space", "filetime", "touch", "media", "version", "license", 
   "index", "iname", "xtext", "xex", "ftext", "hexfind", "xfind", "xhexfind", 
   "extract", "xrep", "xed", "csvtotab", "tabtocsv", 
   0
};

void arcinf(int iind)
{
}

void webref(char *pszIn)
{
   char *psz = 0;

   for (int i=0; aWebRef[i]; i++) {
      if (strBegins(pszIn, aWebRef[i])) {
         psz = str(aWebRef[i]);
         break;
      }
   }

   if (!psz)
      return;

   printx("   $web reference:\n"
          "      #stahlworks.com/sfk-%s\n"
          "\n", psz);
}

bool isrs(char c, bool &rTabFlag)
{
   if (c == ' ')
      return 1;
   if (c == '\t')
      rTabFlag=1;
   return 0;
}

char *loadRepList(char *pszRepFile)
{
   char *pszRepList = 0;

   num nRawSize = 0;

   if (!(pszRepList = (char*)loadBinaryFile(pszRepFile, nRawSize)))
      return 0;

   bool bIsFreeFormat=0;

   int  iRecCur = 0;
   int  iRecMax = 0;

   if (cs.fixedbylist==0 && nRawSize>0)
   {
      char *ptmp=0;

      for (int ipass=0; ipass<2; ipass++)
      {
         if (ipass) 
         {
            // this is reached only with multi line format
            iRecMax = iRecCur;
            iRecCur = 0;
            // each record is prefixed by 8 bytes
            // ":123456 "
            //  12345678
            int iHeadBytes = iRecMax * 10;
            nRawSize += iHeadBytes;
            if (!(ptmp = new char[nRawSize+100]))
               { perr("out of memory"); return 0; }
            memset(ptmp, 0, nRawSize+100);
         }

         char *pSrcCur = pszRepList;
         char *pSrcMax = pszRepList+nRawSize;
         char *pDstCur = ptmp;
         char *pDstMax = ptmp+nRawSize;
         char *pLineEnd = 0, *pNetEnd = 0;
         int istate=0,netlen=0,brutlen=0;
         int isep=0,iline=0,ipastsep=0;
         char csep=0,bcr=0,blf=0;

         while (pSrcCur<pSrcMax && *pSrcCur!=0) 
         {
            pLineEnd = pSrcCur;
            while (*pLineEnd && !iseol(*pLineEnd))
               pLineEnd++;
            pNetEnd = pLineEnd;
            netlen = pNetEnd-pSrcCur;
            // skip single EOL
            bcr=0; blf=0;
            if (*pLineEnd=='\r') { bcr=1; pLineEnd++; }
            if (*pLineEnd=='\n') { blf=1; pLineEnd++; }
            brutlen = pLineEnd-pSrcCur;
            iline++;

            // printf("LINE.1=%02d l=%02d st=%d sep=%c: %s\n",iline,brutlen,istate,csep,dataAsTrace(pSrcCur,brutlen+5));
            // printf("p=%d sep=%c state=%d: %s\n",ipass,csep,istate,dataAsTrace(pSrcCur,brutlen));

            // compact format always stays in state 0
            if (istate == 0) 
            {
               // strip empty lines
               if (netlen < 1) {
                  pSrcCur = pLineEnd;
                  continue;
               }
               // strip whitespace lines incl. tab
               int icheck=0;
               for (; icheck<brutlen; icheck++)
                  if (iseol(*pSrcCur)==0 && isws(*pSrcCur!=' ')==0)
                     break;
               if (icheck>=brutlen) {
                  pSrcCur = pLineEnd;
                  continue;
               }
               // no matter what format, insert prefix now
               if (ipass) {
                  if (pDstCur+9 >= pDstMax)
                     { perr("buffer overflow lrep.9"); return 0; }
                  sprintf(pDstCur, ":@%06u ", iline % 1000000);
                  pDstCur += 9;
               }
               // keep :commands and :# as is
               if (*pSrcCur==':')
               {
                  if (ipass) {
                     if (pDstCur+brutlen >= pDstMax)
                        { perr("buffer overflow lrep.1"); return 0; }
                     memcpy(pDstCur, pSrcCur, brutlen);
                     pDstCur += brutlen;
                  } else {
                     iRecCur++;
                  }
                  pSrcCur  = pLineEnd;
                  continue;
               }
               // a block start was found
               csep = *pSrcCur;
               // scan current line
               isep = 0;
               for (int i=0; i<brutlen; i++)
                  if (pSrcCur[i]==csep)
                     isep++;
               // if it's compact format, keep as is
               if (isep>=3) {
                  if (ipass) {
                     if (pDstCur+brutlen >= pDstMax)
                        { perr("buffer overflow lrep.2"); return 0; }
                     memcpy(pDstCur, pSrcCur, brutlen);
                     pDstCur += brutlen;
                  } else {
                     iRecCur++;
                  }
                  pSrcCur = pLineEnd;
                  continue;
               }
               // start free format block
               if (ipass==0) {
                  bIsFreeFormat=1;
               }
               // printf("p=%d sep=%c state=%d: %s\n",ipass,csep,istate,dataAsTrace(pSrcCur,brutlen));
               // state will be switched below
            }

            bool bTabFlag=0;

            // within free format: check plausi
            if (iseol(*pSrcCur)) {
               perr("line %d empty line not allowed within a command:", iline);
               printf("%.60s\n", pSrcCur);
               if (csep)
                  pinf("check if the previous command was completed correctly.\n");
               return 0;
            }
            if (*pSrcCur!=csep && isrs(*pSrcCur,bTabFlag)==0) {
               perr("line %d missing \"%c\" or blank at start:", iline, csep);
               printf("%.60s\n", pSrcCur);
               if (bTabFlag)
                  pinf("tab character is not allowed, use space instead.\n");
               if (csep)
                  pinf("check if the previous command was completed correctly.\n");
               return 0;
            }

            bool bWhiteStart = isrs(*pSrcCur,bTabFlag);
            char *pLineStart = pSrcCur;

            // trim left and right whitespaces
            while (isrs(*pSrcCur,bTabFlag))
               pSrcCur++;
            while (pNetEnd>pSrcCur && isrs(pNetEnd[-1],bTabFlag)!=0) 
               pNetEnd--;
            netlen = pNetEnd-pSrcCur;

            // strict format check
            if (bTabFlag) {
               perr("line %d: TAB character(s) are not allowed, use space instead:", iline);
               printf("%.60s\n", pLineStart);
               return 0;
            }
            if (bWhiteStart!=0 && *pSrcCur==csep) {
               perr("line %d: separator \"%c\" must be placed at line start or end:", iline, csep);
               printf("%.60s\n", pLineStart);
               pinf("use a different separator character if '%c' should be searched.\n", csep);
               return 0;
            }

            bool bEOC = 0;
            for (int i=0; i<brutlen; i++) {
               if (pLineStart[i]==csep) {
                  istate++;
                  if (pLineStart[i+1]=='.')
                     bEOC=1;
               }
            }

            // invalid no. of separators
            if (istate>3) {
               perr("line %d: wrong total number of \"%c\" separators:", iline, csep);
               printf("%.60s\n", pLineStart);
               pinf("a %cfromtext%ctotext%c pattern requires \"%c\" 3 times,\n", csep, csep, csep, csep);
               pinf("and search-only terms must end with %c[all]\\n%c as totext.\n", csep, csep);
               pinf("if you have only search terms you may use -bylinelist\n");
               pinf("which allows one %cfromtext%c per line without any totext.\n", csep, csep);
               pinf("use a different separator character if '%c' should be searched.\n", csep);
               return 0;
            }

            // check context
            if (istate==3) {
               if (bEOC==0) {
                  perr("line %d: missing dot '.' at end of multi line command \"%c.\":", iline, csep);
                  printf("%.60s\n", pLineStart);
                  return 0;
               }
               netlen--;
            }

            if (ipass) {
               if (pDstCur+netlen >= pDstMax)
                  { perr("buffer overflow lrep.3"); return 0; }
               memcpy(pDstCur, pSrcCur, netlen);
               pDstCur += netlen;
            }
            pSrcCur  = pLineEnd;

            // end of block
            if (istate==3) {
               if (ipass) {
                  if (pDstCur+2 >= pDstMax)
                     { perr("buffer overflow lrep.4"); return 0; }
                  if (bcr) *pDstCur++ = '\r';
                  if (blf) *pDstCur++ = '\n';
               } else {
                  iRecCur++;
               }
               istate=0;
            }

         }  // endwhile data

         if (istate)
            perr("missing separator(s), use -showlist to see joined text: %s", pszRepFile);

         if (ipass) {
            *pDstCur = '\0';
            delete [] pszRepList;
            pszRepList = ptmp;
         }

         if (!bIsFreeFormat)
            break;

      }  // endfor pass
   }

   if (cs.showlist)
   {
      if (bIsFreeFormat)
         printx("$----- -bylist commands were joined to: -----\n");
      else
         printx("$----- -bylist was kept unchanged: -----\n");
      int ilen = strlen(pszRepList);
      if (cs.debug) {
         printf("%s\n", dataAsTrace(pszRepList, ilen));
      } else {
         myfwrite((uchar*)pszRepList, ilen, stdout);
         if (ilen<1 || pszRepList[ilen-1]!='\n')
            printf("\n");
      }
      printx("$-------------------------------------------\n");
   }

   return pszRepList;
}

class CharAutoRestore {
public:
      CharAutoRestore (char **pp) {
         pClPPtr   = pp;
         pClOldVal = *pClPPtr;
      }
     ~CharAutoRestore ( ) { 
         *pClPPtr  = pClOldVal;
      }
private:
      char **pClPPtr;
      char *pClOldVal;
};

void dumpConsoleHelp(bool bMin)
{
   if (!bMin)
   printx("$Swiss File Knife is a program for the command line.<def>\n"
          "It cannot be used by double clicking on the 'sfk' icon.\n"
          "\n"
          );

   #ifdef _WIN32

   TCHAR szOwnPath[_MAX_PATH + 10];
   mclear(szOwnPath);
   ::GetModuleFileName(NULL, szOwnPath, _MAX_PATH + 2);

   printx("- create a folder like C:\\tools\n"
          "\n"
          "- copy sfk.exe from it's current location\n"
          "  %s\n"
          "  to C:\\tools\n"
          "\n"
          "- search for the \"cmd\" application to open a shell (command line) window.\n"
          "  With Windows 7 just select \"run\" at the left bottom and type \"cmd\".\n"
          "\n"
          "- then type: c:\\tools\\sfk\n"
          "  and read the help text shown.\n"
          "\n"
          "- to use sfk just by typing 'sfk', extend the PATH like:\n"
          "  SET PATH=%cPATH%c;c:\\tools\n"
          "\n"
          "- for your first steps, use CMD but not the PowerShell.\n"
          "  within PowerShell you may have to type .\\sfk instead of sfk\n"
          "\n"
          , szOwnPath
          , '%', '%'
          );

   if (!bMin)
   printx("Press Enter to close this window now.\n");

   #else

   // not used so far
   printx("- create a simple folder with a short path\n"
          "  that is easy to locate, for example\n"
          "     /home/youruser/tools\n"
          "- store sfk.exe into that folder\n"
          "- open a shell (command prompt window)\n"
          "- then type:\n"
          "  cd /home/youruser/tools\n"
          "  ./sfk\n"
          "- then continue reading the help text shown.\n"
          "  for example, typing\n"
          "     ./sfk stat /\n"
          "  will list folder tree sizes.\n"
          "\n"
          );
   printx("Press Enter to continue.\n");

   #endif

   // wait for user input:
   getchar(); // requires enter
}

static const char *szGlblData =
{
"#:sfk-phrase-db:100:\n"
"# content is converted as:\n"
"# ,  -> random selection\n"
"# \\, -> tab\n"
"# ;  -> ,\n"
"# \\; -> ;\n"
"# \\+ -> nothing\n"
"# \\n -> linefeed\n"
"# $1sym -> remember a random index in slot 1\n"
"#          for later repeat as $1sym\n"
"\n"
"$company: $namecom\\,$stradr\\,$city $statecode $zip\n"
"$person: $nameper\\,$stradr\\,$city $statecode $zip\n"
"$nameper: $name1 $name2\n"
"$name1: $preperm,$preperf\n"
"$preperm: Arthur,Alexander,Brian,Colin,Donald,Edward,Henry,\n"
"          Jack,James,Larry,Neil,Richard\n"
"$preperf: Alice,Brenda,Dora,Ellen,Grace,Helena,Ilona,Laura,\n"
"          Lena,Sandra,Susan\n"
"$name2: Smith,Jones,Harris,Young,Scott,Cole,Ellis,Porter,\n"
"          Anderson,Johnson,Peterson,Miller\n"
"$namecom: $comsyl1$comsyl2 $combra $comtype\n"
"$comsyl1: Wel,Gen,Fram,Nap,Ken,Can,New,Al,Be,Dan,El\n"
"$comsyl2: ton,mond,dale,ney,kin,port,tree,way,nex,car,dyne\n"
"$cnsyl1: Che,Wo,Fi,Gu,Kan,Sel,Ben,Chong,Ching,Wing,Fon,Bun\n"
"$cnsyl2: che,wo,fi,gu,kan,sel,ben,chong,ching,wing,fon,bun\n"
"$combra: Machinery,Printing,Design,Furniture,Computers\n"
"$comtype: Inc,Ltd\n"
"$stradr: $num3 $namestr $strtype\n"
"$num9: $dig1$dig$dig$dig$dig$dig$dig$dig$dig\n"
"$num8: $dig1$dig$dig$dig$dig$dig$dig$dig\n"
"$num7: $dig1$dig$dig$dig$dig$dig$dig\n"
"$num6: $dig1$dig$dig$dig$dig$dig\n"
"$num5: $dig1$dig$dig$dig$dig\n"
"$num4: $dig1$dig$dig$dig\n"
"$num3: $dig1$dig$dig\n"
"$dig1: 1,2,3,4,5,6,7,8,9\n"
"$dig: 0,1,2,3,4,5,6,7,8,9\n"
"$namestr: $comsyl1$comsyl2\n"
"$strtype: Dr,Rd\n"
"$zip: $num5\n"
"$city: London,Melville,Hertford,Denton,Framingham,Orlando,Irvine,\n"
"       Seattle,Toronto,Victoria,Portland,Wellington\n"
"$statecode: AL,MT,AK,NE,AZ,NV,AR,NH,CA,NJ,CO,NM,CT,NY,DE,NC,FL,\n"
"            ND,GA,OH,HI,OK,ID,OR,IL,PA,IN,RI,IA,SC,KS,SD,KY,TN,\n"
"            LA,TX,ME,UT,MD,VT,MA,VA,MI,WA,MN,WV,MS,WI,MO,WY\n"
"$char1: A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z\n"
"$country: USA,England,Australia,Canada,Argentina,Chile,China,\n"
"          France,Germany,Greece,Japan,Spain,Taiwan\n"
"$countrycode: US,EN,AU,CA,AR,CL,CN,\n"
"          FR,DE,GR,JP,ES,TW\n"
"\n"
"$ip4: $ip4part.$ip4part.$ip4part.$ip4part\n"
"$ip4part: 1$dig$dig\n"
"\n"
"$news: $1preperm $name2 created a new product; the $2verb $3sub with $social connectivity.\\n\n"
"       It allows to $4get $images from all $5friend\\+s around your $area live on $your $watch.\\n\n"
"       \"Everyone needs a $2verb $3sub\"; $1preperm says; \"it's the smart and social way to $4get $5friend\\+s\".\n"
"$verb: flying, rolling, jumping\n"
"$sub: watch, saucer, robot, rubber duck, camera\n"
"$get: keep track of, share, post\n"
"$images: images, sounds, videos\n"
"$your: your, a friends\n"
"$watch: watch, tv, smartphone, tablet\n"
"$friend: friend, dog, cat, squirrel, turtle\n"
"$area: area, house, couch, toilet, fridge\n"
"$social: facebook, twitter, google, tumblr, whats app\n"
};

static const char *szGlblBookSamp =
{
"[101]"
   "sfk csvtotab in.csv +xed \"/[start]*[eol]//\" \"/</&lt;/\" \"/>/&gt;/\""
   " +xex \"_[lstart]*\\t*\\t*_<record>\\n <id>[part2]</id>\\n"
   " <name>[part4]</name>\\n <city>[part6]</city>\\n</record>\\n_\"\n"
"[102]"
   "sfk xed in.xml \"/\\q/\\x27/\" +xex \"_<record>**"
   "<id>*</id>**<name>*</name>**<city>*</city>**"
   "</record>_\" -showparts\n"
"[103]"
   "sfk xed in.xml \"/\\q/\\x27/\" +xex \"_<record>**"
   "<id>*</id>**<name>*</name>**<city>*</city>**"
   "</record>_\\q[part4]\\q,\\q[part8]\\q,\\q[part12]\\q\\n_/\"\n"
"[104]"
   "sfk xed messages.txt"
   " \"/+message*[eol]-de*[eol]=en*[eol]=it*[eol]"
   "/[parts 1-3]-en[parts 8,9]=de[parts 5,6,10-12]/\""
   " \"/+message*[eol]-de*[eol]=it*[eol]=en*[eol]"
   "/[parts 1-3]-en[parts 11,12]=de[parts 5,6,7-9]/\"\n"
"[105]"
   "sfk xex in.txt \"/[1.100 white][2 chars of a-z][1.100 chars of ( \\t\\r\\n)]/[part2],/\"\n"
"[106]"
   "sfk csvtotab in.csv +xed \"/*\\t*\\t*\\t*\\t*\\t*/\"\n"
"[107]"
   "sfk csvtotab in.csv +xed \"/*\\t*\\t*\\t*\\t*\\t*/"
   "[part9]\\t[part11]\\t[parts 1-3]/\" +sort\n"
};

// block all trivial signals like SIGPIPE.

#ifndef SIGPIPE
 #define SIGPIPE  13  // Broken pipe (POSIX).
#endif

#ifndef SIGCONT
 #define SIGCONT  18  // Continue (POSIX).
#endif

#ifndef SIGWINCH
 #define SIGWINCH 28  // Window size change (4.3 BSD, Sun).
#endif

#ifndef SIGTRAP
 #define SIGTRAP   5  // Trace trap (POSIX).
#endif

void sfkSignalHandler(int nsig)
{
   const char *psig = "";
   switch (nsig) {
      case SIGPIPE : psig = "SIGPIPE"; break;
      case SIGCONT : psig = "SIGCONT"; break;
      case SIGWINCH: psig = "SIGWINCH"; break;
      case SIGTRAP : psig = "SIGTRAP"; break;
   }
   if (nsig != SIGWINCH)
      pinf("signal %u (%s) caught and ignored.\n", nsig, psig);
}

void initSignalHandlers()
{
   #ifndef _WIN32
   signal(SIGPIPE , sfkSignalHandler);
   signal(SIGCONT , sfkSignalHandler);
   signal(SIGWINCH, sfkSignalHandler);
   signal(SIGTRAP , sfkSignalHandler);
   #endif
}

int main(int argc, char *argv[], char *penv[])
{
   // remember original argument list
   gs.argc = argc;
   gs.argv = argv;

   // catch all help requests
   if (argc == 2) 
   {
      char *pfirst = argv[1];
      if (   !strcmp(pfirst, "-h") || !strcmp(pfirst, "-help")
          || !strcmp(pfirst, "-?") || !strcmp(pfirst, "/?")
          || !strcmp(pfirst, "/h") || !strcmp(pfirst, "/help")
         )
      {
         printf("To get help, type the command without any parameter.\n");
         printf("For example: \"sfk\", \"sfk list\", \"sfk run\".\n");
         return 9;
      }
   }

   // block trivial signals
   initSignalHandlers();

   #ifdef WITH_TRACING
   
   // debug compile with mtktrace: 
   // dump mtk ring buffer on crash
   initCrashHandler(0);
   
   #else
   
   // production: if this is set,
   // a crashlog will be written to that filename.
   char *pszCrashLog = getenv("SFK_CRASH_LOG");
   if (pszCrashLog)
      initCrashHandler(pszCrashLog);
      
   #endif

   #ifdef SFINT
   bool bSkipCNA = 0;
   #endif

   // fundamental inits
   static bool bFirstCall = 1;
   if (bFirstCall)
   {
      bFirstCall = 0;

      szGlblOpenWriteName[0] = 0;
      mclear(szOutNameRecent);
   
      initWildCards();
      initConsole();
      chain.init();

      char *pszCfg = getenv("SFK_CONFIG");
      if (pszCfg) 
      {
         char *aSubOpt[2];
         int   iSubOpt = 0;

         char *pszParm = strstr(pszCfg, "active-file-age:");
         if (pszParm)
            nGlblActiveFileAgeLimit = atol(pszParm+16);
         if (strstr(pszCfg, "skip-hour-jump"))
            bGlblIgnore3600 = 1;
         #ifdef SFINT
         if (strstr(pszCfg, "ignore-exec-name"))
            bSkipCNA = 1;
         #endif
         #ifdef VFILEBASE
         if (strstr(pszCfg, "xdemo"))
            gs.xelike = cs.xelike = 1;
         #endif // VFILEBASE
         #ifdef VFILENET
         // if (strstr(pszCfg, "nocache"))
         //    setDiskCacheActive(0);
         #endif // VFILENET
         if (pszParm = strstr(pszCfg, "memlimit:")) {
            int nMBytes = atol(pszParm+strlen("memlimit:"));
            setMemoryLimit(nMBytes);
         }
         if (pszParm = strstr(pszCfg, "tmpdir:")) {
            pszParm += strlen("tmpdir:");
            char *pszEnd = pszParm;
            while (*pszEnd != 0 && *pszEnd != ',')
               pszEnd++;
            int iLen = pszEnd-pszParm;
            memcpy(szLineBuf, pszParm, iLen);
            szLineBuf[iLen] = '\0';
            SFTmpFile::setTmpDir(szLineBuf);
         }
         if (strstr(pszCfg, "echoonstart")) {
            fprintf(stderr, "[cmd]: ");
            for (int i=0; i<argc; i++)
               fprintf(stderr, "%s ", argv[i]);
            fprintf(stderr, "\n");
         }
         if (strstr(pszCfg, "echoonerr")) {
            gs.echoonerr = cs.echoonerr = 1;
         }
         if (strBegins(pszCfg, "xchars") || strstr(pszCfg, ",xchars")) {
            aSubOpt[0] = str("-xchars"); setGeneralOption(aSubOpt, 0, iSubOpt, 1);
         }
         if (strBegins(pszCfg, "noacc") || strstr(pszCfg, ",noacc")) {
            aSubOpt[0] = str("-noacc"); setGeneralOption(aSubOpt, 0, iSubOpt, 1);
         }
         if (strBegins(pszCfg, "fixedbylist") || strstr(pszCfg, ",fixedbylist")) {
            gs.fixedbylist = cs.fixedbylist = 1;
         }
      }
   }

   #ifdef SFINT
   // command name aliasing: if our executable is not sfk.exe
   char **paliasv = 0;
   int    naliasc = 0;
   if (!bSkipCNA && !mystrstri(argv[0], "sfk")) {
      // then rebuild parameter set, autoselecting the command
      paliasv = new char*[argc+10];
      naliasc = argc+1;
      for (int i=0; i<argc; i++)
        paliasv[i+1] = argv[i];
      paliasv[0] = "sfk";
      // remap parameter set
      argc = naliasc;
      argv = paliasv;
      // special option for cn-aliases: if first parm is "-version"
      // sfk list -version
      if (argc >= 3 && !strcmp(argv[2], "-version")) {
         // then run version command instead
         argv[1] = "version";
         argc = 2;
      }
   }
   #endif

   // parse and remove general prefix options, e.g. -nocol
   int iDirPre = 1;
   while ((iDirPre < argc) && setGeneralOption(argv, argc, iDirPre, 1)) // 1: global
      iDirPre++;
   memcpy(&cs, &gs, sizeof(cs)); // copy global, permanent options
   argc -= (iDirPre-1);
   argv += (iDirPre-1);

   char *pszCmd = str("?");
   int   iDir   = 0;

   if (argc < 2) {
      // no parms: show help
      if (bGlblStartedInEmptyConsole) {
         dumpConsoleHelp(0);
         return 9;
      } else {
         pszCmd = str("dump-main-help");
      }
      // and fall through
   } else {
      pszCmd = argv[1];
      iDir   = 2;
   }

   nGlblStartTime = getCurrentTime();

   SFKMainStat mainStat(nGlblStartTime);

   // see also end of main, loop processing
   bool  bFatal = 0;
   int  lRC    = 0;

   // special case like "sfk +toterm":
   if (argc == 2 && pszCmd[0] == '+')
      pszCmd++; // user wants help for chain-only command

   // sfk cmd parm
   // => nparm == 1 (one parm remaining for this command)
   // => iDir  == 2 (on the parameter, not on the command)

   // command chaining support: from list to +run etc.
   #define STEP_CHAIN(iDirNext,bMod)          \
      if (iDirNext)                           \
      {                                       \
         if (cs.memcheck) sfkmem_checklist("command"); \
         pszCmd = argv[iDirNext];             \
         if (pszCmd[0] == '+')                \
            pszCmd++;                         \
         iDir   = iDirNext+1;                 \
         nparm  = argc-iDir;                  \
         bChainCycle = 1;                     \
         if (!bMod) {                         \
            chain.colfiles = 0;               \
            chain.coldata  = 0;               \
         } else {                             \
          if (chain.moveOutToIn(pszCmd)) {    \
            bDone = 1;                        \
            break;                            \
          }                                   \
         }                                    \
         resetStats();                        \
         if (lRC >= 9) {                      \
            pinf("chaining stops before %s, rc=%d\n", pszCmd, lRC); \
            bDone = 1;                        \
            break;                            \
         } else {                             \
            continue;                         \
         }                                    \
      }

   lRC = submain(argc, argv, penv, pszCmd, iDir, bFatal);

   // print overall informal messages
   if (!gs.nonotes) {
      if (gs.utf16read)
         printx("<time>%d utf-16 file(s) decoded%s.<def>\n", gs.utf16read, gs.verbose ? "":" (-verbose for more)");
      else
      if (gs.utf16found && gs.verbose)
         printx("<time>%d utf-16 file(s) found. (see \"sfk help utf\")<def>\n", gs.utf16found);
   }

   #ifdef VFILEBASE
   if (gs.cachestat) {
      num nmax  = glblVCache.bytesMax();
      num ndrop = glblVCache.filesDropped();
      printx(
         "<time>peak cache usage = %d mb. "
         "the memlimit was %sreached (%d drops).<def>\n",
         (int)(nmax / 1000000),
         (ndrop > 0) ? "":"not ",
         (int)ndrop
         );
   }
   #endif // VFILEBASE

   // print error and warning stats
   if (nGlblErrors) {
      setTextColor(nGlblErrColor);
      printf("%d errors", nGlblErrors);
      if (nGlblWarnings) {
         setTextColor(nGlblWarnColor);
         printf(", %d warnings", nGlblWarnings);
         setTextColor(nGlblErrColor);
      }
      if (bGlblSysErrOccured && !bGlblSysErrDetail) {
         printf(" occurred. ");
         setTextColor(nGlblTimeColor, 1);
         printf("add -exterr after sfk for more.\n");
      } else {
         printf(" occurred.\n");
      }
      setTextColor(-1);
   }
   else
   if (nGlblWarnings) {
      setTextColor(nGlblWarnColor);
      printf("%d warnings occurred.\n", nGlblWarnings);
      setTextColor(-1);
   }

   num nStart = getCurrentTime();

   shutdownAllGlobalData();

   #ifdef SFINT
   if (paliasv)
      delete [] paliasv;
   #endif

   #ifdef _MSC_VER
    #ifdef SFK_MEMTRACE
    if (!bFatal && !nGlblError && !nGlblErrors && !bGlblEscape && !bGlblNoMemCheck)
       listMemoryLeaks(); // if any
    #endif
   #endif

   checkFileWrite();

   if (cs.perf)
      printf("%d msec for cleanup\n", (int)(getCurrentTime()-nStart));

   // if any error occurred during file tree processing,
   // build highest error code as application return code.
   if (nGlblShellRC > lRC)
      lRC = nGlblShellRC;

   if (gs.showrc)
      printf("sfk rc: %d\n", lRC);

   if (bGlblPauseOnEnd) {
      printf("Press ENTER to continue.\n");
      while (getchar() != '\n');
   }

   return lRC;
}

cchar *askBlackList[] = {
   "how","do","i","in","for","the","a","to",
   "use","using","of","by","many","every",
   "only","part","bytes","within","all",
   "from","into","cmd","command",
   "calculate","calc","using","with",
   "on","2g","one","two","three",
   "and","can","out","you","some","is",
   "an","computer","example","cr",
   "specific","given",
   0 // EOD
};

cchar *askReduxList[] = {
   "1bigger", "1directory", "3converting", "4splitting",
   "4comparison", "2converter", "4conversion",
   "2colored", "7tabulation", "2sorted",
   0 // EOD
};

cchar *askSynList[][2] = {
   { "search", "find" },
   { "determine", "find" },
   { "check", "find" },
   { "show", "find" },
   { "string", "word" }, { "phrase", "word" },
   { "txt", "text" },
   { ".txt", "text" },
   { ".bin"," binary" },
   { "filename", "file" },
   { "change", "replace" },
   { "generate", "create" },
   { "shortname", "alias" },
   { "hexadecimal", "hex" },
   { "coloured", "colored" },
   { "linefeed", "lf" },
   { "cr-lf", "crlf" },
   { "execute", "run" },
   { "duplicated", "duplicate" },
   { "executable", "exe" },
   { "colour", "color" },
   { "ls", "list" },
   { "rejoin", "join" },
   { "subfolder", "dir" },
   { "multiple", "many" },
   { "communication", "connection" },
   { "unix", "linux" },
   { ".exe", "exe" },
   { 0, 0 } // EOD
};

// returns a ptr into szLineBuf or NULL
char *filterAskPattern(char *prawpat, char *ppre1, char *ppre2)
{__
   // strip all 1-char words
   if (strlen(prawpat) < 2) return 0;

   int i=0;

   strcopy(szLineBuf, prawpat);
   for (i=0; askBlackList[i]; i++)
      if (!mystricmp(szLineBuf, askBlackList[i]))
         return 0;

   // word reduction:
   char *p   = szLineBuf;
   int nlen = strlen(p);

   // force all lowercase
   for (i=0; i<nlen; i++)
      p[i] = tolower(p[i]);

   // director ies -> director
   if (nlen > 7 && strEnds(p, "ies")) p[nlen-3] = '\0';
   else // file s -> file
   if (nlen > 3 && p[nlen-1] == 's')  p[nlen-1] = '\0';
   else // list ing -> list
   if (nlen > 6 && strEnds(p, "ing")) {
      p[nlen-3] = '\0';
      // split ting -> split by dub consonants
      if (p[nlen-4] == p[nlen-5])
         p[nlen-4] = '\0';
   }

   // reduce by list
   for (i=0; askReduxList[i]; i++) {
      cchar *ppat = askReduxList[i];
      int   nred = (*ppat++) - '0';
      if (!mystricmp(szLineBuf, ppat)) {
         int ncpy = strlen(ppat)-nred;
         memcpy(szLineBuf, ppat, ncpy);
         szLineBuf[ncpy] = '\0';
         break;
      }
   }

   // reduce synonyms
   for (i=0; askSynList[i][0]; i++) {
      cchar *pfrom = askSynList[i][0];
      cchar *pto   = askSynList[i][1];
      if (!mystricmp(p, pfrom))
      {  strcpy(p, pto); break; }
   }
   if (strBegins(p, "folder") || strBegins(p, "director")) strcpy(p, "dir");

   // reduce three word phrases
   #define ifpair(s1,s2) if (!strcmp(ppre2,s1) && !strcmp(ppre1,s2))
   if (ppre2 && ppre1) {
      ifpair ("in","a")
         if (!strcmp(p, "dir")) return 0; // "in a dir"
      ifpair ("of","a")
         if (!strcmp(p, "dir")) return 0; // "of a dir"
   }

   // reduce two word phrases
   if (ppre1) {
      if (strBegins(ppre1, "dir") && !strcmp(p, "tree"))
         return 0; // any command uses a "dir tree"
      if (!strcmp(ppre1, "in") || !strcmp(ppre1, "of") || !strcmp(ppre1, "all")) {
         if (!strcmp(p, "dir"))  return 0; // "in dir", "of dir"
         if (!strcmp(p, "tree")) return 0; // "in tree", "of tree"
      }
      if (!strcmp(ppre1, "file") && strBegins(p, "name"))
         strcpy(p, "file"); // "file name" -> "file"
      if (!mystricmp(ppre1, "cr") && !mystricmp(p, "lf"))
         strcpy(p, "crlf"); // "cr lf" -> "crlf"
   }

   // reduce number strings
   for (i=0; i<nlen; i++)
      if (!isdigit(p[i])) break;
   if (i >= nlen) return 0;

   return szLineBuf;
}

int submain(int argc, char *argv[], char *penv[], char *pszCmd, int iDir, bool &bFatal) // sfk
{__
   int   nparm  = argc - iDir; // number of parameters (after command name)
   bool  bDone  = 0;
   int  lRC    = 0;
   bool  btest  = bGlblSyntaxTest;

   // help text collection support:
   bool  bhelp  = 0;
   bool  bexec  = 0;

   #define ifcmd(xcond) \
      if (bhelp || (xcond))

   #define ifhelp(xcond) \
      if (bhelp || (xcond)) {

   #define ehelp \
      if (!bhelp) return 9; printx("\n"); } bexec=1; } \
      if (!bhelp && bexec) { bexec=0

   // if the very first command starts with +
   if (*pszCmd == '+')
      pszCmd++; // then skip this char

   // for +loop: restart point
   char *pszCmdStart = pszCmd;
   int   iDirStart   = iDir;

 bool bChainCycle = 0;
 do
 {
   cs.curcmd = pszCmd;
   cs.argc   = argc;
   cs.argv   = argv;

   if (bChainCycle && cs.verbose) {
      printf("[chain process index %d, \"%s\", cmd=%s, nparm=%d, \"%s\" uf=%d %d ud=%d %d cf %d cd %d]\n",
         iDir,argv[iDir-1],pszCmd,nparm,(iDir<argc)?argv[iDir]:"[eod]",
         chain.usefiles, chain.usefiles ? chain.numberOfInFiles() : 0,
         chain.usedata , chain.usedata  ? chain.indata->numberOfEntries() : 0,
         chain.colfiles, chain.coldata
         );
      if (cs.verbose > 1)
         if (chain.usedata)
            chain.indata->dump("chain.indata");
   }

   bChainCycle = 0;
   bexec       = 0;

   int lFiles=0, lDirs=0; // deprecated stats
   num  nBytes=0;          // deprecated stats

   if (!strcmp(pszCmd, "dumphelp") || !strcmp(pszCmd, "ask"))
   {
      if (!strcmp(pszCmd, "ask") && (nparm < 1)) {
      printx("<help>$sfk ask word1 [word2 word3 ...]\n"
             "\n"
             "   search the help text of all sfk commands for lines containing\n"
             "   all given words. keep your query short and up to the point,\n"
             "   listing only the most important words.\n"
             "\n"
             "   if your query produces no results, rephrase it:\n"
             "   - use singular instead of plural: directory vs. directories,\n"
             "     file vs. files\n"
             "   - use synonyms: directory vs. folder, list file vs. find file,\n"
             "     old file vs. most recent files\n"
             "\n"
             "   $no option processing by default:\n"
             "      by default, \"sfk ask\" does NOT process any options itself,\n"
             "      but treats them as text to search for. if you want to set any\n"
             "      options although, say \"sfk ask word1 word2 ... -opt -youropt\"\n"
             "\n"
             "   $no output chaining support:\n"
             "      output of sfk ask can NOT be post-processed in a command chain.\n"
             "      instead, words starting with \"+\" are searched for as well:\n"
             "         #sfk ask +filter\n"
             "            searches for help text lines containing \"+filter\".\n"
             "      if you really need to post-process output from sfk ask, pipe it\n"
             "      to another sfk process like \"sfk ask foo | sfk filter -+bar\".\n"
             "\n"
             "   $examples\n"
             "      #sfk ask walk subfolders\n"
             "      #sfk ask find oldest files\n"
             "      #sfk ask replace binary\n"
             "         search for the given words.\n"
             "      #sfk ask -nocol\n"
             "         search where the word \"-nocol\" appears.\n"
             "      #sfk ask -nocol -opt -nocol\n"
             "         the same, but also use -nocol to switch off color output.\n"
             );
         return 9;
      }

      // activate help text collection mode
      bGlblCheckPrintX = 1;
      bhelp = bGlblCollectHelp = 1;
      bDone = 1;
      // fall through
   }

   ifcmd (!strcmp(pszCmd, "cmd"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk cmd commandnumber\n"
             "\n"
             #ifdef _WIN32
             "   extract an example command from the help text, print it\n"
             "   as one long text line and put it into the clipboard.\n"
             #else
             "   extract an example command from the help text\n"
             "   and print it as one long text line.\n"
             #endif
             "\n"
             "   $options\n"
             "     -run        execute the command\n"
             "     -tofile x   write to an output file x\n"
             "     -force      overwrite existing output file\n"
             );
      ehelp;

      mclear(szGlblHelpCmdPat);
      mclear(szGlblHelpCmdText);

      // do NOT step iDir here! just peek the parameter

      int iDir2 = iDir;

      for (; iDir2<argc; iDir2++)
      {
         char *pszArg = argv[iDir2];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-tofile", &pszParm)) {
            if (!pszParm) return 9;
            continue;
         }
         else
         if (!strcmp(pszArg, "-run")) {
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir2))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         // process non-option keywords

         if (szGlblHelpCmdPat[0])
           return 9+perr("supply only a single command number");

         if (atoi(pszArg) < 1)
           return 9+perr("not a command number: %s", pszArg);

         snprintf(szGlblHelpCmdPat, sizeof(szGlblHelpCmdPat)-4, "[%s]", pszArg);
      }

      // check if it's an sfkbook example
      char *pszbook = (char*)strstr(szGlblBookSamp, szGlblHelpCmdPat);
      if (pszbook)
      {
         // if so fall through without collecting
      }
      else
      {
         // activate help text collection mode
         bhelp = bGlblCollectHelp = iGlblCollectCmd = 1;
         bDone = 1;
         // fall through
      }
   }

   regtest("list -zip -time -since 5d -size xdir .dat");
   regtest("list -late -since 2006-01-01_12:01:01 -dir xdir -file .dat");
   regtest("list -old -stat -since today .");
   regtest("list -big -withdirs -since 20060101 .");
   regtest("list -small -hidden -quot .");
   regtest("list -late=20 -pure .");
   regtest("list -late=all -notime -nosize");
   regtest("list -late -sincedir rdir xdir");
   regtest("list -sincedif rdir -relnames .");

   ifcmd (   !strcmp(pszCmd, "list") || !strncmp(pszCmd, "sel", 3) // +chaining
          || !strcmp(pszCmd, "dir")  || !strcmp(pszCmd, "larc")
          || !strcmp(pszCmd, "late")
         )
   {
      ifhelp ((iDir < 3) && !chain.usefiles && (nparm < 1))
      printx("<help>$sfk list [-time] [-size|-size=digits] [...] dir [mask]\n"
             "$sfk sel[ect] -dir dir1 dir2 -file .ext1 .ext2 !.ext3 [...]\n"
             "\n"
             "   list all or just selected files from a directory tree.\n"
             "   select is the same, but it ignores command chaining input.\n"
             "\n"
             "   $options:\n"
             "      -time      show date and modification time\n"
             "      -flattime  show date and time in a more compact format\n"
             "      -tab       separate columns by tab characters, not blanks\n"
             "      -size[=n]  show size of files [n characters wide]\n"
             "      -kbytes    or -kb lists sizes in kbytes instead of bytes\n"
             "      -mbytes    or -gbytes lists sizes in mbytes or gbytes\n"
             "      -kbpure    list without \"kb\" postfix\n"
             "      -stat      show statistics (number of files, dirs, bytes)\n"
             #ifdef _WIN32
             "                 and tell if hidden files or dirs were skipped.\n"
             #endif
             #if (!defined(_WIN32) && !defined(SFK_LIB5))
             "      -nofollow  or -nofo does not follow symbolic directory links.\n"
             "                 use this if list runs in an endless recursion.\n"
             #endif
             "      -withdirs  list also directories\n"
             "      -justdirs  list just directories\n"
             #ifdef _WIN32     
             "      -hidden    list also hidden or system files\n"
             #endif
             #ifndef _WIN32
             "      -verbose   list also non-regular files\n"
             "      -showskip  tell whenever dir contents are skipped to avoid\n"
             "                 double processing caused by symbolic links.\n"
             "      -allowdups disable detection of duplicate dir contents.\n"
             #endif
             "      -arc       list contents of .zip .jar .ear etc. archives\n"
             "      -sort[=n]  sort by name, list all or last n files\n"
             "      -sortrev   sort by name, in reverse order\n"
             "      -late[=n]  sort by time, list latest   [n] files last\n"
             "      -old[=n]   sort by time, list oldest   [n] files last\n"
             "      -big[=n]   sort by size, list biggest  [n] files last\n"
             "      -small[=n] sort by size, list smallest [n] files last\n"
             );
      printx("      -minsize=s list only files >= size, like 10b or 100k\n"
             "      -maxsize=s list only files <= size, like 10m or 4g\n"
             "                 b=bytes k=kbytes m=megabytes g=gigabytes\n"
             "      -late=all  sort by time, list all files\n"
             "      -notime    don't list time, after -late or -old\n"
             "      -nosize    don't list size, after -big  or -small\n"
             "      -pure      pure list of filenames, leave out time, size,\n"
             "                 headline or statistics.\n"
             "      -quot      surround filenames by double quotes. needed when\n"
             "                 post-processing filename lists containing blanks.\n"
             "      -quiet     do not show the \"scan\" progress information\n"
             );
      printx("      -since     list only files since this timestamp, e.g.\n"
             "                    \"2006-01-31 12:15:59\" or 20060131121559\n"
             "                    2006-01-31 or 20060131\n"
             "                    today : files changed since midnight of today\n"
             "                    1d    : changed since 1 day, i.e. not counting\n"
             "                            from midnight, but 24 hours into the past\n" 
             "                    5h, 30m, 10s : 5 hours, 30 minutes, 10 seconds.\n"
             "      -before    select files modified before that timestamp.\n"
             "      -today     short replacement for \"-since today\".\n"
             "      -usectime  use or list creation time instead of modification time.\n"
             "                 may not be available on some filesystems.\n"
             "      -utc       or -gmt lists UTC/GMT time instead of local time.\n"
             "      -sincedir  compare against another directory, list files that\n"
             "       or -sd    have been added, have different time, or content.\n"
             "                 does not list files which have been removed.\n"
             "      -sinceadd  like -sincedir, list only added files.\n"
             "      -sincedif  like -sincedir, list only changed files.\n"
             "                 does not list files with diff. time but same content.\n"
             "                 does not list added files.\n"
             "      -sincechg  list files with different content, and added files.\n"
             "       or -sc    does not list files with diff. time but same content.\n"
      //     "      -incref    include names listed after -dir in sincedir references.\n"
      //     "      -verbose   lists non-existing reference directory names.\n"
             "      -relnames  list filenames relative to specified directory(s),\n"
             "                 i.e. strip root directory names at the beginning.\n"
             "      -tofile x  write all names directly to file x (using less memory\n"
             "                 than the chain command +tofile x).\n"
             "      -maxfiles=n      list a maximum of n files only.\n"
             "      -fileoff[set]=n  from all selected files, list only a subset,\n"
             "                 starting at index n. first file has index 0.\n"
             "\n"
             "   $important details of file name / extension selection:\n"
             "      - when specifying a filename pattern beginning with a dot \".\"\n"
             "        and no wildcard, only files with this extension will be selected.\n"
             "      - otherwise the pattern is searched anywhere within the filename.\n"
             "        to force a filename start comparison, say <sla>pattern (with a slash).\n"
             "      - filename means the relative filename, not directory or path name.\n"
             );
      printx("\n"
             "   $command chaining difference between list and select:\n"
             "      +list accepts files from previous commands. +select ignores them,\n"
             "      allowing scripts to run many independent selects in one chain.\n"
             );
             #ifdef VFILEBASE
      if (cs.xelike)
      printx("\n"
             "   $no default archive content processing:\n"
             "      .zip .jar .tar .tgz .bz2 archive contents are NOT listed by default,\n"
             "      as this is not desirable if you just want a quick dir tree overview.\n"
             "      specify -arc or -qarc to activate archive content listing.\n"
             "      type \"sfk help opt\" to list all supported archive extensions.\n");
             #endif // VFILEBASE
      printx("\n"
             "   $aliases:\n"
             "      #sfk dir<def>         same as \"sfk list -stat\".\n"
             "      #sfk select<def>      same as list, but ignoring chain input.\n"
             "      #sfk larc<def>        same as \"sfk list -arc\".\n"
             "      #sfk late<def>        same as \"sfk list -late\".\n"
             );
      printx("\n"
             "   $see also:\n"
             "      #sfk help select<def> the sfk file selection syntax.\n"
             "      #sfk help opt<def>    for further general options.\n"
             "      #sfk stat<def>        to list directory tree sizes.\n"
             "      #sfk filetime<def>    list all times of a file.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "      #sfk list .\n"
             "         list all files of current directory and all subdirectories.\n"
             "      #sfk list mydir <not>.bak <not>.tmp.txt\n"
             "         list all files within mydir, except .bak and .tmp.txt files.\n"
             "      #sfk list -dir . -file foo .htm .java\\%c\n"
             "         this will find and list the following sample filenames:\n"
             "            thefoobar.dat     - matches anywhere-pattern \"foo\"\n"
             "            biginfo.htm       - matches exact extension  \".htm\"\n"
             "            test.java.9.15    - matches anywhere-pattern \".java\\%c\"\n"
             "         the command will NOT list the following sample filenames:\n"
             "            foosys\\thebar.dat - pattern must match filename, not path.\n"
             "            biginfo.html      - does not match extension \".htm\"\n"
             "      #sfk list -dir mydir <not>tmp <not><sla>save<sla> -file .txt\n"
             "         list all .txt files within mydir, excluding all sub folders\n"
             "         having \"tmp\" in their name, or called exactly \"save\".\n"
             ,glblWildChar,glblWildChar
             );
      printx("      #sfk alias list = sfk list -noop\n"
             "         after this, just typing \"list\" lists the current directory.\n"
             "      #sfk list -dir src1 -file .cpp -dir src2 -file .hpp\n"
             "         list .cpp files from src1, .hpp files from src2.\n"
             "      #sfk list -dir src \"*examples*\"\n"
             "         list contents of all directories having a name with \"examples\",\n"
             "         located somewhere below src. note that \"*examples*\" defines a\n"
             "         path mask, whereas \"examples\" would be another root directory.\n"
             "         under linux, patterns with a * wildcard MUST have quotes \"\".\n"
             "      #sfk list -late -dir . -sub foo -file .jsp .java\n"
             "         list the most recent .jsp and .java files, in all dirs below\n"
             "         the current one (.) having \"foo\" in their pathname.\n"
             "      #sfk list -late -dir . <wild>foo -file .jsp .java\n"
             "         the same, only shorter to type.\n"
             "      #sfk list -justdirs -dir . <wild>foo<wild> -file .jsp .java\n"
             "         list all folders having \"foo\" in their pathname\n"
             "         and which contain any .jsp or .java files.\n"
             "      #sfk list -sincedir src5 src1 .cpp\n"
             "         provided that directory src5 is an older copy of src1, list the\n"
             "         .cpp files that have been added/changed since src5 was created.\n"
             "      #sfk list -pure -late=30 -quot | zip ..\\update.zip -@\n"
             "         collect the latest 30 files from current dir into a zip file,\n"
             "         using InfoZIP's option \"-@\" to use a filename list from stdin.\n"
             "      #sfk sel src .bak +del\n"
             "         select all .bak files in src, then delete them.\n"
             "      #sfk list -nosub -late mydir +sleep 5000 +loop\n"
             "         list most recent files of mydir every 5 seconds,\n"
             "         excluding all sub folder contents.\n"
             "      #sfk list . .jpg +count\n"
             "         tell the number of .jpg files in current directory tree.\n"
             "      #sfk list -nosub -flattime -tabs . .jpg +filter -stabform\n"
             "         #\"ren <run>qcol3 \\q<run>col1<run>col2-<run>col3\\q\" +run \"<run>text\"\n"
             "         rename all .jpg files in current folder to be prefixed by\n"
             "         their modification time (type whole command in one line).\n"
             #ifdef VFILEBASE
             "      #sfk larc src.zip +view\n"
             "         show content listing of zip file src.zip in Depeche View,\n"
             "         to search filenames interactively (\"sfk view\" for details).\n"
             #endif // VFILEBASE
             "      #sfk list <nofo>. >lslr\n"
             "         list files of the current directory and all subdirectories into\n"
             "         an index text file \"lslr\" (named after the unix command \"ls -lR\").\n"
             "         doing this in a root directory may take some while, but afterwards\n"
             "         you will find the location of every file in realtime, by simply\n"
             "         typing \"sfk find lslr your_filename_pattern\".\n"
             "      #sfk list <nofo>-qarc -tofile lslrx .\n"
             "         same as above, but including hidden and system files, as well as\n"
             "         the first content level of every .zip and .jar file. using -tofile\n"
             "         instead of \">lslrx\" redirection allows you to see a progress info.\n"
             "         doing this in a root dir like C:\\ may produce a filename listing\n"
             "         of several hundred MB in size.\n"
             );
      ehelp;

      CommandScope ocmd("List");

      // the "dir" command is more verbose
      bool bStat = !strcmp(pszCmd, "dir") ? 1 : 0;

      // larc is the same as list -arc
      if (!strcmp(pszCmd, "larc")) {
         cs.travelzips = 1;
         #ifdef VFILEBASE
         cs.xelike     = 1;  // process zips as deep as possible
         #endif // VFILEBASE
      }

      nGlblListMode = 2;
      cs.listByTime = 0;
      cs.listBySize = 0;
      cs.listByName = 0;

      #ifdef VFILEBASE
      // list is the only command where traveling
      // of text content links is allowed.
      cs.travelHttp = 1;
      #endif // VFILEBASE

      // in case of multiple select in a chain, reset fileset:
      glblFileSet.reset();

      // the "select" command always ignores chain input:
      bool bselect = strBegins(pszCmd, "sel");
      if (bselect) chain.reset();

      bool bTime=0, bSize=0, bPure=0;

      char *toFileName = 0;

      // late is the same as list -late
      if (!strcmp(pszCmd, "late")) {
         pszCmd = str("list");
         cs.listByTime = 50;
         cs.listForm = ((cs.listForm << 8) | 0x02);
         bTime = 1;
      }

      #define SFK_ADD_SIZE { if (!bSize) { bSize=1; cs.listForm = ((cs.listForm << 8) | 0x01); } }

      for (; iDir < argc; iDir++) 
      {
         char *pszParm = 0;
         #ifdef VFILEBASE
         if (!strcmp(argv[iDir], "-qarc")) {
            cs.travelzips  = 1;
            cs.xelike      = 1;
            cs.shallowzips = 1;  // toplevel only
         }
         else
         #endif // VFILEBASE
         if (!strcmp(argv[iDir], "-qarc")) {
            cs.travelzips  = 1;
         }
         else
         if (!strcmp(argv[iDir], "-twinscan")) {
            return 9+perr("-twinscan was replaced by sfk dupfind.\n");
         }
         else
         if (!strcmp(argv[iDir], "-size")) {
            // do not just remember the flag, but also option sequence.
            if (!bSize) {
               cs.listForm = ((cs.listForm << 8) | 0x01);
               bSize = 1;
            }
         }
         else if (strBegins(argv[iDir], "-kbpure"))   { cs.listunit = 'K'; nGlblListDigits =  9; SFK_ADD_SIZE; continue; }
         else if (strBegins(argv[iDir], "-mbpure"))   { cs.listunit = 'M'; nGlblListDigits =  6; SFK_ADD_SIZE; continue; }
         else if (strBegins(argv[iDir], "-gbpure"))   { cs.listunit = 'G'; nGlblListDigits =  3; SFK_ADD_SIZE; continue; }
         else if (strBegins(argv[iDir], "-kb"))       { cs.listunit = 'k'; nGlblListDigits = 12; SFK_ADD_SIZE; continue; }
         else if (strBegins(argv[iDir], "-mb"))       { cs.listunit = 'm'; nGlblListDigits =  9; SFK_ADD_SIZE; continue; }
         else if (strBegins(argv[iDir], "-gb"))       { cs.listunit = 'g'; nGlblListDigits =  6; SFK_ADD_SIZE; continue; }
         else
         if (!strncmp(argv[iDir], "-size=", strlen("-size="))) {
            // size format with digits specified
            if (!bSize) {
               cs.listForm = ((cs.listForm << 8) | 0x01);
               bSize = 1;
            }
            char *psz1 = argv[iDir] + strlen("-size=");
            nGlblListDigits = atol(psz1);
         }
         else
         if (!strncmp(argv[iDir], "-small", 6)) {
            // list sorted by size, show smallest 50 by default
            cs.listBySize = -50;
            if (!bSize && !bPure) {
               cs.listForm = ((cs.listForm << 8) | 0x01);
               bSize = 1;
            }
            if (!strncmp(argv[iDir], "-small=", strlen("-small="))) {
               char *psz1 = argv[iDir] + strlen("-small=");
               if (!strcmp(psz1, "all")) {
                  cs.listBySize    = 0 - 1; // sort direction
                  cs.listBySizeAll = 1;
               } else {
                  cs.listBySize = 0 - atol(psz1);
               }
            }
         }
         else
         if (!strncmp(argv[iDir], "-big", 4)) {
            // list sorted by size, show biggest 50 by default
            cs.listBySize = 50;
            if (!bSize && !bPure) {
               cs.listForm = ((cs.listForm << 8) | 0x01);
               bSize = 1;
            }
            if (!strncmp(argv[iDir], "-big=", strlen("-big="))) {
               char *psz1 = argv[iDir] + strlen("-big=");
               if (!strcmp(psz1, "all")) {
                  cs.listBySize    = 0 + 1; // sort direction
                  cs.listBySizeAll = 1;
               } else {
                  cs.listBySize = atol(psz1);
               }
            }
         }
         else
         if (!strncmp(argv[iDir], "-sort", 5))
         {
            // list sorted by name, ALL by default
            cs.listByName    = 0 + 1;
            cs.listByNameAll = 1;
            if (!strncmp(argv[iDir], "-sort=", 6)) 
            {
               char *psz1 = argv[iDir] + 6;
               if (!strcmp(psz1, "all")) {
                  // all is default
               } else {
                  cs.listByName    = atol(psz1);
                  cs.listByNameAll = 0;
               }
            }
            if (!strncmp(argv[iDir], "-sortr", 6)) 
            {
               cs.listByName = 0 - 1;
               if (!strncmp(argv[iDir], "-sortrev=", 9)) 
               {
                  char *psz1 = argv[iDir] + 9;
                  if (!strcmp(psz1, "all")) {
                     // all is default
                  } else {
                     cs.listByName    = 0 - atol(psz1);
                     cs.listByNameAll = 0;
                  }
               }
            }
         }
         else
         if (!strcmp(argv[iDir], "-nosize")) {
            // reverse implicite size listing by "-big"
            if ((cs.listForm & 0xFF) == 0x01) {
               cs.listForm >>= 8;
               bSize = 0;
            }
         }
         else
         if (!strcmp(argv[iDir], "-time")) {
            // do not just remember the flag, but also option sequence.
            if (!bTime) {
               cs.listForm = ((cs.listForm << 8) | 0x02);
               bTime = 1;
            }
         }
         else
         if (!strcmp(argv[iDir], "-flattime")) {
            if (!bTime) {
               cs.listForm = ((cs.listForm << 8) | 0x02);
               bTime = 1;
            }
            cs.flatTime = 1;
         }
         else
         if (!strcmp(argv[iDir], "-stat")) {
            bStat = 1;
         }
         else
         if (!strncmp(argv[iDir], "-old", 4)) {
            // list sorted by time, show oldest 50 by default
            cs.listByTime = -50;
            if (!bTime && !bPure) {
               cs.listForm = ((cs.listForm << 8) | 0x02);
               bTime = 1;
            }
            if (!strncmp(argv[iDir], "-old=", strlen("-old="))) {
               char *psz1 = argv[iDir] + strlen("-old=");
               if (!strcmp(psz1, "all")) {
                  cs.listByTime    = 0 - 1; // sort direction
                  cs.listByTimeAll = 1;
               } else {
                  cs.listByTime = 0 - atol(psz1);
               }
            }
         }
         else
         if (!strncmp(argv[iDir], "-late", 5)) {
            // list sorted by time, show latest 50 by default
            cs.listByTime = 50;
            if (!bTime && !bPure) {
               cs.listForm = ((cs.listForm << 8) | 0x02);
               bTime = 1;
            }
            if (!strncmp(argv[iDir], "-late=", strlen("-late="))) {
               char *psz1 = argv[iDir] + strlen("-late=");
               if (!strcmp(psz1, "all")) {
                  cs.listByTime    = 0 + 1; // sort direction
                  cs.listByTimeAll = 1;
               } else {
                  cs.listByTime = atol(psz1);
               }
            }
         }
         else
         if (haveParmOption(argv, argc, iDir, "-sort", &pszParm)) {
            if (!pszParm) return 9;
            if (!strncmp(pszParm, "late", 4)) {
               cs.listByTime    = 0 + 1; // sort direction
               cs.listByTimeAll = 1;
            }
            if (!strncmp(pszParm, "old", 3)) {
               cs.listByTime    = 0 - 1; // sort direction
               cs.listByTimeAll = 1;
            }
            if (!strncmp(pszParm, "big", 3)) {
               cs.listBySize    = 0 + 1; // sort direction
               cs.listBySizeAll = 1;
            }
            if (!strncmp(pszParm, "small", 5)) {
               cs.listBySize    = 0 - 1; // sort direction
               cs.listBySizeAll = 1;
            }
         }
         else
         if (!strcmp(argv[iDir], "-notime")) {
            // reverse implicite time listing by "-late"
            if ((cs.listForm & 0xFF) == 0x02) {
               cs.listForm >>= 8;
               bTime = 0;
            }
         }
         else
         if (!strcmp(argv[iDir], "-pure")) {
            cs.pure = 1;
            cs.listForm = 0;
            bTime = 0;
            bSize = 0;
            cs.quiet = 1;
            cs.nohead  = 1;
            bPure = 1;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-tofile", &pszParm)) {
            if (!pszParm) return 9;
            toFileName = pszParm;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-tab")) {
            cs.listTabs = 1;
            nGlblListDigits = 1; // FIX: 1674
         }
         else
         if (strBegins(argv[iDir], "-nofile")) {
            perr("-nofile cannot be used here\n");
            pinf("use it on a following command, e.g. +filefilter -nofile\n");
            return 9;
         }
         else
         if (   strBegins(argv[iDir],"-fileoffset")
             || strBegins(argv[iDir],"-fileoff")
            )
         {
            char *psz2 = strchr(argv[iDir], '=');
            if (!psz2) {
               perr("wrong syntax: %s", argv[iDir]);
               pinf("use -fileoffset=n or -fileoff=n to set first file to process\n");
               return 9;
            }
            cs.selfileoff = atoi(psz2+1);
         }
         else
         if (strBegins(argv[iDir],"-maxfiles")) 
         {
            char *psz2 = strchr(argv[iDir], '=');
            if (!psz2) {
               perr("wrong syntax: %s", argv[iDir]);
               pinf("use -maxfiles=n to set max. number of files to process\n");
               return 9;
            }
            cs.selfilerange = atoi(psz2+1);
         }
         else {
            char *pszOpt = argv[iDir];
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir)) {
               if (!strcmp(pszOpt, "-since")) {
                  // selecting -since activates time listing by default
                  if (!bPure && !bTime) {
                     cs.listForm = ((cs.listForm << 8) | 0x02);
                     bTime = 1;
                  }
               }
            }
            else
               break;
         }
      }

      int nsort=0, msort=0;
      if (cs.listByTime) { nsort++; msort |= 1; }
      if (cs.listBySize) { nsort++; msort |= 2; }
      if (cs.listByName) { nsort++; msort |= 4; }
      if (nsort > 1) {
         szLineBuf[0] = '\0';
         if (msort & 1) strcat(szLineBuf, "time");
         if (msort & 2) { if (szLineBuf[0]) strcat(szLineBuf, " AND "); strcat(szLineBuf, "size"); }
         if (msort & 4) { if (szLineBuf[0]) strcat(szLineBuf, " AND "); strcat(szLineBuf, "name"); }
         return 9+perr("cannot sort by %s\n", szLineBuf);
      }

      int iDirNext = 0;
      bool bAnyDirParms = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext, &bAnyDirParms))) return lRC;
      if (btest) return 0;

      // plausi checks
      if (chain.useany() && bAnyDirParms) {
         perr("%s got filenames from command chain AND as parameters", pszCmd);
         pinf("say \"+select\" instead of \"+%s\" to ignore chain input\n", pszCmd,pszCmd);
         return 9;
      }
      if (bselect && !bAnyDirParms) {
         if (chain.useany()) {
            perr("%s requires dir- or filename parameters, chain input is ignored.", pszCmd);
            pinf("say \"+list\" instead of \"+%s\" to use chained input filenames.\n", pszCmd);
            return 9;
         }
         // "sfk ... +sel" without any dir parms
         perr("%s requires dir- or filename parameters.", pszCmd);
         return 9;
      }

      if (chain.colany())
         cs.nohead = 1;

      // prepare listing to file
      cs.outfile = 0;
      if (toFileName) {
         if (chain.colany())
            return 9+perr("-tofile excludes any further chain processing.");
         if (!(cs.outfile = fopen(toFileName, "w")))
            return 9+perr("cannot open for writing: %s", toFileName);
      }

      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);

      // end listing to file
      if (cs.outfile) { fclose(cs.outfile); cs.outfile = 0; }

      info.clear();

      if (cs.listBySize) {
         int nCnt  = glblFileListCache.numberOfEntries();
         int iFrom = 0;
         if (!cs.listBySizeAll && (nCnt > abs(cs.listBySize))) {
            iFrom = nCnt - abs(cs.listBySize);
            if (!cs.nohead)
                printx("<file>[listing %d of %d files by size:]<def>\n", (int)(abs(cs.listBySize)), nCnt);
         }
         for (int i=iFrom; i<nCnt; i++) {
            Coi *pcoi = glblFileListCache.getEntry(i, __LINE__);
            // get text line prefixed by metatext length
            char *pszFull = pcoi->getExtStr();
            if (!pszFull) return 9+perr("internal 141271931\n");
            int nMetaLen = atol(pszFull);
            if (nMetaLen > (int)strlen(pszFull)) return 9+perr("internal 61212\n");
            if (strlen(pszFull) < 6) return 9+perr("internal 61213\n");
            char *pszText = pszFull+6;
            if (chain.colfiles)
               chain.addFile(*pcoi);
            else
            if (chain.coldata)
               chain.addLine(pszText, str(""));
            else
            {
               if (nMetaLen) {
                  setTextColor(nGlblFileColor);
                  printf("%.*s", nMetaLen, pszText);
                  setTextColor(-1);
               }
               oprintf("%s\n", pszText+nMetaLen);
            }
         }
      }

      if (cs.listByTime) {
         int nCnt  = glblFileListCache.numberOfEntries();
         int iFrom = 0;
         if (!cs.listByTimeAll && (nCnt > abs(cs.listByTime))) {
            iFrom = nCnt - abs(cs.listByTime);
            if (!cs.nohead)
                printx("<file>[listing %d of %d files by date:]<def>\n", (int)(abs(cs.listByTime)), nCnt);
         }
         int noldday = -1;
         int i=iFrom;
         if (i > 0) i--; // one precycle to find previous entry's day
         for (; i<nCnt; i++) {
            Coi *pcoi = glblFileListCache.getEntry(i, __LINE__);
            num nTime = pcoi->getTime();
            struct tm *pLocTime = 0;
            mytime_t nTime2 = (mytime_t)nTime;
            #ifdef SFK_W64
            pLocTime = _localtime64(&nTime2);   // may be NULL
            #else
            pLocTime = localtime(&nTime2);      // may be NULL
            #endif
            int nday = pLocTime->tm_yday;      // 0..365
            if (i < iFrom) {
               noldday = nday;
               continue; // empty precycle
            }
            // get text line prefixed by metatext length
            char *pszFull = pcoi->getExtStr();
            if (!pszFull) return 9+perr("internal 141271933\n");
            int nMetaLen = atol(pszFull);
            if (nMetaLen > (int)strlen(pszFull)) return 9+perr("internal 61211\n");
            if (strlen(pszFull) < 6) return 9+perr("internal 61214\n");
            char *pszText = pszFull+6;
            if (chain.colfiles)
               chain.addFile(*pcoi);
            else
            if (chain.coldata)
               chain.addLine(pszText, str(""));
            else
            {
               if (nMetaLen) {
                  if (nday != noldday) {
                     noldday = nday;
                     setTextColor(nGlblFileColor);
                  } else {
                     // setTextColor(nGlblPreColor);
                  }
                  printf("%.*s", nMetaLen, pszText);
                  setTextColor(-1);
               }
               oprintf("%s\n", pszText+nMetaLen);
            }
         }
      }

      if (cs.listByName) {
         int nCnt  = glblFileListCache.numberOfEntries();
         int iFrom = 0;
         if (!cs.listByNameAll && (nCnt > abs(cs.listByName))) {
            iFrom = nCnt - abs(cs.listByName);
            if (!cs.nohead)
                printx("<file>[listing %d of %d files by name:]<def>\n", (int)(abs(cs.listByName)), nCnt);
         }
         for (int i=iFrom; i<nCnt; i++) {
            Coi *pcoi = glblFileListCache.getEntry(i, __LINE__);
            // get text line prefixed by metatext length
            char *pszFull = pcoi->getExtStr();
            if (!pszFull) return 9+perr("internal 141271934\n");
            int nMetaLen = atol(pszFull);
            if (nMetaLen > (int)strlen(pszFull)) return 9+perr("internal 61220\n");
            if (strlen(pszFull) < 6) return 9+perr("internal 61221\n");
            char *pszText = pszFull+6;
            if (chain.colfiles)
               chain.addFile(*pcoi);
            else
            if (chain.coldata)
               chain.addLine(pszText, str(""));
            else
            {
               if (nMetaLen) {
                  setTextColor(nGlblFileColor);
                  printf("%.*s", nMetaLen, pszText);
                  setTextColor(-1);
               }
               oprintf("%s\n", pszText+nMetaLen);
            }
         }
      }

      if (bStat) // FIX 153R3: do not also check quiet, nohead
      {
         num   nbytes = nGlblBytes;
         cchar *punit  = "bytes";
         num   ndiv   = 1;

         if (nbytes > 1000000)
            {  ndiv   = 1000000; punit = "mb"; }
         else
         if (nbytes > 1000)
            {  ndiv   = 1000; punit = "kb"; }

         char nbuf1[50], nbuf2[50];

         if (ndiv > 1)
            printf("%d files, %d dirs, %s %s, %s bytes",cs.files,cs.dirs,numtoa(nbytes/ndiv,1,nbuf1),punit,numtoa(nbytes,1,nbuf2));
         else
            printf("%d files, %d dirs, %s bytes",cs.files,cs.dirs,numtoa(nbytes,1,nbuf1));

         if (cs.numHiddenFiles || cs.numHiddenDirs) {
            printf(", ");
            setTextColor(nGlblWarnColor, 1);
            printf("%d hidden files, %d dirs.\n", cs.numHiddenFiles, cs.numHiddenDirs);
            setTextColor(-1);
         }
         else
         if (cs.numHiddenFilesSkipped || cs.numHiddenDirsSkipped) {
            printf(".\n");
            setTextColor(nGlblWarnColor, 1);
            printf("skipped %d hidden files, %d hidden dirs.\n", cs.numHiddenFilesSkipped, cs.numHiddenDirsSkipped);
            setTextColor(-1);
         }
         else {
            printf(".\n");
         }
      }

      // diverse convience stuff, reminders etc.
      if (!cs.nohead && !cs.quiet) {
         bool btold = 0;
         if (cs.addedFilesSkipped > 0) {
            setTextColor(nGlblTimeColor, 1);
            printf("skipped %d added files. ", cs.addedFilesSkipped);
            btold = 1;
         }
         if (cs.sincetime)
            if (cs.maxFileTime < cs.sincetime) {
               // user specified -since, but no files matched:
               num nnow = 0;
               tryGetRelTime("now", nnow);
               num nsec  = nnow - cs.maxFileTime;
               num nhrs  = nsec / 3600;
               num ndays = nhrs / 24;
               setTextColor(nGlblHeadColor, 1);
               if (ndays <= 0)
                  printf("most recent file is %s hours old.", numtoa(nhrs));
               else
                  printf("most recent file is %s days old.", numtoa(ndays));
               btold = 1;
            }
         if (btold) {
            setTextColor(-1);
            printf("\n");
         }
      }

      // detect -sincedir user errors
      if (!cs.quiet && pszGlblSinceDir && (nGlblMissingRefDirs > 0)) {
         if (nGlblMissingRefDirs > nGlblMatchingRefDirs)
            setTextColor(nGlblWarnColor, 1);
         else
            setTextColor(nGlblTimeColor, 1);
         printf("found %d matching and %d missing reference dirs (try -incref or -verbose)\n",nGlblMatchingRefDirs,nGlblMissingRefDirs);
         setTextColor(-1);
      }

      if (!cs.quiet) {
         if (cs.noFiles)
            printf("%u non-regular files skipped.\n", cs.noFiles);
      }

      // step to next chain command (if any),
      // and copy filenames from chainfiles2 to chainfiles.
      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "gindex")  || !strcmp(pszCmd, "gindex2")
          || !strcmp(pszCmd, "lindex")  || !strcmp(pszCmd, "index")
         )
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk gindex[2] [opts] -dir rootDir [rootDir2] ...\n"
             "<help>$sfk lindex [opts] -dir localDir ...\n"
             "\n"
             "   create index file(s) containing file names with time\n"
             "   and size info, for later realtime filename lookup,\n"
             "   or just to archive folder meta data.\n"
             "\n"
             "   $creating index files for use with sfk iname<def>\n"
             "\n"
             "    to create a $local index of the current directory tree<def>, use\n"
             "      #sfk lindex .\n"
             "         which writes a local file $zz-index.txt<def>\n"
             "\n"
             "    to create a $global index of the current machine<def>, use\n"
             "      #sfk gindex -dir C:\\ D:\\\n"
             "         which stores a base index file in your user folder:\n"
             "         %s<sla>data<sla>zz-index.txt\n"
             "\n"
             "    to create an $extended global index<def> of network drives, use\n"
             "      #sfk gindex2 -dir T:\\ P:\\ V:\\\n"
             "         if drives T, P, V are network drives. this will write\n"
             "         an extended index file in a user local folder:\n"
             "         %s<sla>data<sla>zz-index-ext.txt\n"
             , sfkhome.szClDir
             , sfkhome.szClDir
             );
      printx("\n"
             "    in other words:\n"
             "\n"
             "      $sfk lindex<def> writes an index locally onto the disk\n"
             "         where you are standing, $visible for all users<def>.\n"
             "         this is useful 1. under linux in the root dir \"/\"\n"
             "         to make an index of all files available for all users\n"
             "         2. on external media like USB hard drives, where an\n"
             "         index in the drive root can be used on any machine.\n"
             "\n"
             "      $sfk gindex<def> is your $personal global index<def> of whatever\n"
             "         disk contents are important for you, $not for use<def>\n"
             "         $by other users<def>, and maintained only by yourself.\n"
             );
      printx("\n"
             "   $creating special purpose meta data archives<def>\n"
             "\n"
             "    to create a $local index of a sub folder \"mydir\"<def>, use\n"
             "      #sfk lindex mydir\n"
             "         which writes a file $zz-index-mydir.txt<def>. this file\n"
             "         can $NOT<def> be used with $sfk iname<def>. it's just an archive\n"
             "         of file meta informations for that sub folder.\n"
             );
      printx("\n"
             "   $using indexes for fast name lookup\n"
             "\n"
             "       #sfk iname word [word2] [word3] [...]\n"
             "         will use local index files:\n"
             "            - in the current folder\n"
             "            - in the parent folder\n"
             "            - and so on, until the root folder \"<sla>\"\n"
             "            - and also the global Base Index file\n"
             "         and then lists all file names from those indexes\n"
             "         having the given words in their name or path.\n"
             "\n"
             "       #sfk iname2 word [word2] [word3] [...]\n"
             "         does the same as iname, but also includes\n"
             "         the global Extended Index file.\n"
             "\n"
             "   $sfk index options\n"
             "      -tofile f  write output into a file f instead of the\n"
             "                 default index file. can be used then with\n"
             "                 \"sfk iname -from f ...\"\n"
             #if (!defined(_WIN32) && !defined(SFK_LIB5))
             "      -follow    follows symbolic directory links. this is\n"
             "                 no default as it may cause endless recursion.\n"
             #endif
             #ifdef _WIN32     
             "      -hidden    list also hidden or system files\n"
             #endif
             #ifndef _WIN32
             "      -verbose   show names of skipped non-regular files\n"
             "      -showskip  tell whenever dir contents are skipped to avoid\n"
             "                 double processing caused by symbolic links.\n"
             "      -allowdups disable detection of duplicate dir contents.\n"
             #endif
             "      -arc       include contents of .zip .jar .ear etc. archives\n"
             "\n"
             "   $see also\n"
             "      #sfk iname<def>       lookup files in local and Base Indexes\n"
             "      #sfk iname2<def>      lookup in local, Base and Extended Index\n"
             "      #sfk help select<def> the sfk file selection syntax.\n"
             "      #sfk help opt<def>    for further general options.\n"
             "      #sfk dir<def>         list contents of a directory.\n"   
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             #ifdef _WIN32
             "      #sfk gindex C:\\\n"
             "          create a global Base Index containing all file names\n"
             "          from drive C: using a short syntax.\n"
             "      #sfk gindex C:\\ <not>.tmp <not>.bak\n"
             "          the same, but excluding all .tmp and .bak files.\n"
             "          to include another drive letter in the index,\n"
             "          the long syntax must be used:\n"
             "      #sfk gindex -dir C:\\ D:\\ -subdir !tmp -file !.bak\n"
             "          create Base Index of C: and D: without any sub\n"
             "          dirs having tmp in their name, and w/o .bak files.\n"
             "      #sfk gindex2 -dir P:\\ W:\\\n"
             "          if P: and W: are network drives, this creates\n"
             "          an Extended Index file with their contents.\n"
             #else
             "      #sfk gindex /\n"
             "          create a base index containing all file names\n"
             "          from the machine.\n"
             "      #sfk gindex -dir / -subdir :tmp -file :.bak\n"
             "          create an index of / without any sub dirs\n"
             "          having tmp in their name, and without .bak files.\n"
             #endif
             "      #sfk lindex .\n"
             "          if standing in the root dir of an exernal hard drive,\n"
             "          this will write a local index file for that drive,\n"
             "          which can later be used on another machine by typing\n"
             "          $sfk iname<def> while working on that drive.\n"
             , sfkhome.szClDir
             );
      ehelp;

      if (!strcmp(pszCmd, "index"))
         return 0;

      cs.travelzips = 0;
      nGlblListMode = 2;
      cs.listByTime = 0;
      cs.listBySize = 0;
      cs.listByName = 0;
      cs.listForm   = 0;
      cs.listTabs   = 1;
      nGlblListDigits = 1;
      bool bGlobal  = (pszCmd[0] == 'g') ? 1 : 0;

      glblFileSet.reset();

      bool bExt = !strcmp(pszCmd, "gindex2") ? 1 : 0;
      bool bTime=1, bSize=0, bPure=0;
      char *toFileName = 0;

      // at least list time and size
      cs.listForm = ((cs.listForm << 8) | 0x02);
      cs.listForm = ((cs.listForm << 8) | 0x01);

      // linux: don't follow symlinks
      cs.skipLinks = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszArg = argv[iDir];
         if (!strcmp(pszArg, "-ext")) {
            bExt = 1;
            continue;
         }
         else if (!strcmp(pszArg, "-follow")) {
            cs.skipLinks = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-size=", strlen("-size="))) {
            char *psz1 = argv[iDir] + strlen("-size=");
            nGlblListDigits = atol(psz1);
         }
         else
         #ifdef VFILEBASE
         if (!strcmp(argv[iDir], "-qarc")) {
            cs.travelzips  = 1;
            cs.xelike      = 1;
            cs.shallowzips = 1;  // toplevel only
         }
         else
         #endif // VFILEBASE
         if (!strcmp(argv[iDir], "-qarc")) {
            cs.travelzips  = 1;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // assume dir name
      }

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC;
      if (btest) return 0;

      char szRelName[SFK_MAX_PATH+10];

      if (bGlobal) {
         sprintf(szRelName, "data%czz-index%s.txt", glblPathChar, bExt ? "-ext" : "");
         toFileName = sfkhome.makePath(szRelName);
      }
      else if (cs.tomaskfile) {
         toFileName = cs.tomask;
      }
      else {
         if (!glblFileSet.hasRoot(0))
            return 9+perr("missing -dir parameter");
         char *pszFirstRoot = glblFileSet.setCurrentRoot(0);
         if (   !strcmp(pszFirstRoot, glblPathStr)
             || !strcmp(pszFirstRoot, ".")
            )
         {
            toFileName = str("zz-index.txt");
         }
         else {
            if (strchr(pszFirstRoot, glblPathChar)) {
               perr("cannot lindex nested directory names.", glblPathChar);
               pinf("use only plain dir names of the current folder.\n");
               return 9;
            }
            snprintf(szRelName, sizeof(szRelName)-10,
               "zz-index-%s.txt", pszFirstRoot);
               toFileName = szRelName;
         }
      }

      if (!cs.quiet && !cs.tomaskfile)
         printx("$making<def> %s\n", toFileName);

      if (!(cs.outfile = fopen(toFileName, "w")))
         return 9+perr("cannot open index file for writing: %s", toFileName);

      fprintf(cs.outfile, "date\ttime\tsize\tname\tsfk-index-v100\n");

      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);

      if (cs.outfile) { fclose(cs.outfile); cs.outfile = 0; }

      info.clear();

      if (!cs.quiet) 
      {
         printf("%d files indexed",cs.files);

         if (cs.numHiddenFiles) {
            printf(", ");
            setTextColor(nGlblWarnColor, 1);
            printf("including %d hidden files.\n", cs.numHiddenFiles);
            setTextColor(-1);
         }
         else
         if (cs.numHiddenFilesSkipped || cs.numHiddenDirsSkipped) {
            printf(".\n");
            setTextColor(nGlblWarnColor, 1);
            printf("skipped %d hidden files, %d hidden dirs.\n", cs.numHiddenFilesSkipped, cs.numHiddenDirsSkipped);
            setTextColor(-1);
         }
         else {
            printf(".\n");
         }

         if (cs.noFiles)
            printf("%u non-regular files skipped. (add -verbose to show)\n", cs.noFiles);
      }

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   regtest("md5gento x.dat xdir");
   regtest("md5gento=x.dat -quiet xdir");
   regtest("md5gento x.dat -rel -dir xdir");
   regtest("list xdir +md5gento xfile.md5");

   ifcmd (!strncmp(pszCmd, "md5gento", 8))   // +chaining
   {
      ifhelp (!strcmp(pszCmd, "md5gento") && (nparm < 2))
      printx("<help>$sfk md5gento[=]outputfile [-rel[names]]]] dirname [-quiet]\n"
             "\n"
             "   create list of md5 checksums over all selected files.\n"
             "\n"
             "   $options:\n"
             "      -rel    create a list with relative filenames, i.e. strip\n"
             "              the supplied dirname from the beginning of each name.\n"
             "      -quiet  do not print progress output while reading files.\n"
          // "      -arc    XE: create checksums of .zip file contents (deepest)\n"
          // "      -qarc   XE: create checksums of top level archive content\n"
             "\n"
             "   #sfk md5gento contents.md5 .\n"
             "      create checksum of all files in current dir and subdirs,\n"
             "      and store them in contents.md5.\n"
             "\n"
             "   #sfk select -dir prod -file !.tmp +md5gento=checksums.md5\n"
             "      first select all files from prod, excluding .tmp files,\n"
             "      then create an md5 list to checksums.md5\n"
            );
      ehelp;

      pszGlblOutFile = 0;

      iDir--;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "md5gento", &pszParm)) {
            if (!pszParm) return 9;
            pszGlblOutFile = pszParm;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-rel", 4)) {
            bGlblMD5RelNames = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // fall through to short dir format
         break;
      }

      if (!pszGlblOutFile)
         return 9+perr("missing output filename\n");

      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3))) return lRC;
      if (btest) return 0;

      #ifndef SFKPRO
      // must block this to avoid checksums over truncated demo extracts
      if (cs.travelzips)
         return 9+perr("md5gento with -(q)arc requires SFK XE.");
      #endif

      fGlblOut = fopen(pszGlblOutFile, "w");
      if (!fGlblOut) return 9+perr("cannot write %s\n", pszGlblOutFile);

      lRC = walkAllTrees(eFunc_MD5Write, lFiles, lDirs, nBytes);

      fclose(fGlblOut);

      info.print("%u files hashed into %s. %u kb/sec\n", glblFileCount.value(), pszGlblOutFile, currentKBPerSec());
      bDone = 1;
   }

   regtest("md5check x.dat");
   regtest("md5check=x.dat -quiet -skip=2");
   regtest("md5check x.dat -rel xdir -skip 10");

   ifcmd (!strncmp(pszCmd, "md5check", 8))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (!strcmp(pszCmd, "md5check") && !chain.usefiles && (nparm < 1))
      printx("<help>$sfk md5check[=]inputfile [-rel[ativeto]] dirname] [-quiet]\n"
             "\n"
             "   verify list of md5 checksums.\n"
             "\n"
             "   $options:\n"
             "\n"
             "      -rel     if dirname is supplied, treat filenames from list\n"
             "               as being relative to dirname. in this case, run the\n"
             "               command from dirname's parent directory.\n"
             "\n"
             "      -quiet   do not print progress output while checking files,\n"
             "               and do not list kb/sec speed stats.\n"
             "\n"
             "      -skip=n  do not check all files, perform just spot checking\n"
             "               by skipping n files after every checked file.\n"
             "\n"
             "   $return codes for batch files\n"
             "      0   normal execution, all checksums matched.\n"
             "      1   normal execution, checksum(s) mismatched.\n"
             "      2   some files were missing, all other checksums matched.\n"
             "      3   some files were missing, and some checksums mismatched.\n"
             "    >=9   severe error occurred, e.g. wrong checksum file format.\n"
             #ifdef _WIN32
             "\n"
             "         #@rem windows batchfile example\n"
             "         @echo off\n"
             "         sfk md5check mysums.txt -quiet >nul 2>nul\n"
             "         IF ERRORLEVEL 1 GOTO mdfailed\n"
             "         sfk echo \"[[green]]all ok[[def]]\"\n"
             "         GOTO mddone\n"
             "         :mdfailed\n"
             "         sfk echo \"[[red]]verification failed[[def]]\"\n"
             "         :mddone\n"
             #endif
            );
      ehelp;

      char *pszInFile = 0;
      char *pszRefDir = 0;

      iDir--;
      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "md5check", &pszParm)) {
            if (!pszParm) return 9;
            pszInFile = pszParm;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-rel", 4)) {
            iDir++;
            if (iDir >= argc) return 9+perr("missing dirname after -rel\n");
            pszRefDir = argv[iDir];
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-skip", &pszParm)) {
            if (!pszParm) return 9;
            nGlblMD5Skip = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // non-option parameter:
         if (!pszInFile)
            pszInFile = argv[iDir];
         else
            return 9+perr("unexpected parameter: \"%s\" (2)\n", argv[iDir]);
      }

      if (!pszInFile)
         return 9+perr("missing input filename\n");

      if (btest) return 0;

      char *pInFile = loadFile(pszInFile);
      if (!pInFile) return 9;

      lRC = execMD5check(pInFile, pszRefDir);

      delete [] pInFile;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   /*
   if (!strncmp(pszCmd, "metagen", 7))
   {
      if (argc < 3) {
      printx("<help>$sfk metagen[to][=]dbfile [-rel[names]]]] fileselection\n"
             "\n"
             "   create or update database with file meta informations.\n"
             "   this stores time, attribute, path and a content checksum\n"
             "   of all selected files.\n"
             "\n"
             "   $options:\n"
             "      -rel   create a list with relative filenames, i.e. strip\n"
             "             the supplied dirname from the beginning of each name.\n"
            );
      return 9;
      }

      char *pszDBFile = 0;

      iDir = 1;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "metagento", &pszParm)) {
            if (!pszParm) return 9;
            pszDBFile = pszParm;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "metagen", &pszParm)) {
            if (!pszParm) return 9;
            pszDBFile = pszParm;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-rel", 4)) {
            bGlblMD5RelNames = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // fall through to short dir format
         break;
      }

      if (!pszDBFile)
         return 9+perr("missing output filename\n");

      // always create new db:
      remove(pszDBFile);

      if (filedb.openUpdate(pszDBFile))
         return 9+perr("cannot open file meta db: %s\n", pszDBFile);

      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3)) return lRC;
      lRC = walkAllTrees(eFunc_MetaUpd, lFiles, lDirs, nBytes);

      int nSignsWritten = 0;
      if (filedb.canUpdate())
         if (filedb.save(nSignsWritten))
            return 9;

      info.print("%u file infos saved into %s. %u kb/sec\n", nSignsWritten, pszDBFile, currentKBPerSec());
      bDone = 1;
   }

   if (!strcmp(pszCmd, "metacheck"))
   {
      if (argc < 3) {
      printx("<help>$sfk metacheck dbfile [-rel[names]]]] fileselection\n"
             "\n"
             "   compare selected files against file meta db, and list those\n"
             "   which have different time or content.\n"
             "\n"
             "   $options:\n"
             "      -rel   use relative filenames.\n"
            );
      return 9;
      }

      char *pszDBFile = 0;

      iDir = 1;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "metacheck", &pszParm)) {
            if (!pszParm) return 9;
            pszDBFile = pszParm;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-rel", 4)) {
            bGlblMD5RelNames = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // fall through to short dir format
         break;
      }

      if (!pszDBFile)
         return 9+perr("missing output filename\n");

      if (filedb.openRead(pszDBFile))
         return 9+perr("cannot open file meta db: %s\n", pszDBFile);

      if (lRC = processDirParms(pszCmd, argc, argv, iDir, 3)) return lRC;
      lRC = walkAllTrees(eFunc_MetaCheck, lFiles, lDirs, nBytes);

      info.print("%u files compared.\n", cs.files);
      bDone = 1;
   }
   */

   regtest("md5 xfile1");
   regtest("md5 -quiet -verify bfb9acc99d1811730687f49a09318e8f xfile1");

   ifcmd (!strcmp(pszCmd, "md5"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk md5 [-quiet] [-verify md5sum] file1 [file2 file3 ...]\n"
             "\n"
             "   calculate md5 hash of one or more files, and optionally compare the results.\n"
             "   if md5 sums are compared, a message is shown, and the shell return code\n"
             "   is set to 0 (all equal), or 1 (not equal), or >1 (any other error).\n"
             "\n"
             "   $options\n"
             "      -nonames   do not echo filename(s), show only the md5 sum.\n"
             "      -verify    or -ver, or -v verifies the given filename(s) against\n"
             "                 the given checksum.\n"
             "      -nocomp    if multiple filenames are given, do not compare.\n"
             "\n"
             "      #sfk md5 test01.dat\n"
             "         tell md5 sum of test01.dat\n"
             "\n"
             "      #sfk md5 test01.dat test02.dat\n"
             "         compare both files, if content is the same.\n"
             "\n"
             #ifdef _WIN32
             "      #sfk md5 -quiet -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat\n"
             "         check if test01.dat has an md5 matching the one specified.\n"
             "         issues no output, returns just a shell return code.\n"
             "         within a windows .bat file, check the RC this way:\n"
             "\n"
             "         @echo off\n"
             "         sfk md5 -quiet -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat\n"
             "         if errorlevel 1 goto mismatch\n"
             "         echo \"file checked, all ok\"\n"
             "         goto done\n"
             "         :mismatch\n"
             "         echo \"file content mismatch\"\n"
             "         :done\n"
             #else
             "      #sfk md5 -verify 14da96b20e45fd84c46c5b7aef641cb3 test01.dat\n"
             "         check if test01.dat has an md5 matching the one specified.\n"
             #endif
             );
      ehelp;

      bool bMismatch  = 0;
      bool bNames     = 1;
      bool bComp      = 1;
      char *pszVerify = 0;
      int  iFile      = -1;
      int  iFileMax   = argc; // exclusive

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (   haveParmOption(argv, argc, iDir, "-verify", &pszParm)
             || haveParmOption(argv, argc, iDir, "-ver", &pszParm)
             || haveParmOption(argv, argc, iDir, "-v", &pszParm)
            ) 
         {
            if (!pszParm) return 9;
            pszVerify = pszParm;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-noname")) {
            bNames = 0;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-nocomp")) {
            bComp = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext)) {
            iFileMax = iChainNext;
            break;
         }
         // process non-option keywords:
         if (iFile < 0) iFile = iDir;
         // else step through supplied filenames
      }

      if (iFile < 0) return 9+perr("supply filename(s) for reading\n");
      if (btest) return 0;

      num nstart = getCurrentTime();

      // read file(s), dump md5s underneath
      szLineBuf2[0] = '\0';
      int nFiles = 0;
      for (; iFile < iFileMax; iFile++)
      {
         nFiles++;

         {
            SFKMD5 md5;
            char *pszFile = argv[iFile];
            // special case: -verify checksum *filename
            // -> skip * before filename
            if (pszVerify && pszFile[0] == '*')
               pszFile++;
            if (getFileMD5(pszFile, md5))
               return 9;
            unsigned char *pmd5 = md5.digest();
            for (int i=0; i<16; i++)
               sprintf(&szLineBuf[i*2], "%02x", pmd5[i]);
            if (!cs.quiet) {
               if (chain.colany()) {
                  if (bNames)
                     chain.print("%s\t%s", szLineBuf, pszFile);
                  else
                     chain.print("%s", szLineBuf);
               } else {
                  if (bNames)
                     oprintf("%s\t%s\n", szLineBuf, pszFile);
                  else
                     printf("%s\n", szLineBuf);
               }
            }
            if (szLineBuf2[0] && strcmp(szLineBuf, szLineBuf2))
               bMismatch = 1;
            if (pszVerify && strcmp(pszVerify, szLineBuf))
               bMismatch = 1;
            strcpy(szLineBuf2, szLineBuf);
         }
      }

      lRC = bMismatch ? 1 : 0;

      if (((nFiles > 1 && bComp) || pszVerify != 0) && !cs.quiet) {
         if (chain.colany()) {
            if (bMismatch)
               chain.print("rc1 mismatch");
            else
               chain.print("rc0 equal");
         } else {
            if (bMismatch)
               printf("content mismatch (RC==1)\n");
            else
               printf("content is equal (RC==0)\n");
         }
      }

      if (cs.verbose)
         printf("done in %d msec\n", (int)(getCurrentTime() - nstart));

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }
   
   if (!strcmp(pszCmd, "makepw") || !strcmp(pszCmd, "randhex"))
   {
      // todo: join with make-random-file
      int iFormat = 1;
      if (!strcmp(pszCmd, "randhex"))
          iFormat = 2;
      
      const char *pszChars = aenc64;
      int iMaxChars = strlen(pszChars) - 2; // w/o "+/"   

      char szBuf[100];
      szBuf[0] = '\0';

      uchar abBuf[100];
      mclear(abBuf);

      initRandom(penv);

      int i=0;

      switch (iFormat)
      {
         case 1:
            for (; i<10; i++)
               szBuf[i] = pszChars[((uint32_t)rand()) % iMaxChars];
            szBuf[i] = '\0';
            break;
            
         case 2:
            for (; i<4; i++)
               abBuf[i] = (uchar)rand();
            sprintf(szBuf, "%02x%02x%02x%02x", abBuf[0],abBuf[1],abBuf[2],abBuf[3]);
            break;
      }

      chain.print("%s", szBuf);
            
      bDone = 1;
   }   

   ifcmd (!strcmp(pszCmd, "license"))
   {
      ifhelp (nparm < 1)
      #ifndef SFKPRO
      printx(
         "Copyright (c) 2014 by Stahlworks Technologies, www.stahlworks.com.\n"
         "All rights reserved.\n"
         "\n"
         "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n"
         "\n"
         "    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n"
         "    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer "
         "in the documentation and/or other materials provided with the distribution.\n"
         "\n"
         "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, "
         "INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. "
         "IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, "
         "OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; "
         "OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, "
         "OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
         );
      #endif
      ehelp;
      
      bDone = 1;
   }

   if (!strcmp(pszCmd, "testchar"))
   {
      int irc1 = sfkisalpha('a');
      int irc2 = sfkisalpha((uchar)0xFF);
      printf("%d %d\n", irc1, irc2);
      return 0;
   }

   #ifdef SFK_MEMTRACE
   if (!strcmp(pszCmd, "testmemerror"))
   {
      printf("forcing error for test\n");   

      char *pszDummy = new char[10];

      memset(pszDummy, 0, 10);

      pszDummy[10] = 'a'; // invalid
      
      // should produce memory leak notice.
      // with option -memcheck, should tell
      // about overwrite at program end.
      
      bDone = 1;
   }
   #endif
   
   if (!strcmp(pszCmd, "test"))
   {
      if (argc < 3) {
      printx("<help>$sfk test mode dbfile tctitle infile\n"
             "\n"
             "   record/compare automated test results on a database.\n"
             "\n"
             "      mode:\n"
             "         rec   record checksum of infile\n"
             "         upd   record only if not yet contained in db\n"
             "         cmp   compare checksum against db entry\n"
             "      dbfile : a database file, created by sfk in mode -rec\n"
             "      tctitle: name of the testcase, e.g. T01.1.mytest\n"
             "      infile : an output file resulting from a testcase\n"
             "\n"
             "   the sequence of text lines within the infile is ignored.\n"
             "   this may lead to a checksum of \"0000\" if the input file\n"
             "   contains the same content twice.\n"
             "\n"
             "   $example:\n"
             "      #sfk test rec mycrc.db T01.1.encoding out1.dat\n"
             "      -> creates checksum of out1.dat, writes to mycrc.db\n"
             "         under the title T01.1.encoding\n"
             "      #sfk test cmp mycrc.db T01.1.encoding out1.dat\n"
             "      -> creates checksum of out1.dat, reads 2nd checksum\n"
             "         from mycrc.db, and compares both.\n"
             );
         return 9;
      }

      if (argc >= 3 && !strcmp(argv[2], "workdir"))
      {
         szLineBuf[0] = '\0';
         if (getcwd(szLineBuf,sizeof(szLineBuf)-10)) { }
         char *psz = strrchr(szLineBuf, glblPathChar);
         if (!psz) return 9;
         psz++;
         char *pszRelWorkDir = psz;
         if (argc == 4) {
            if (!strcmp(argv[3], pszRelWorkDir))
               return 0;
            else {
               if (cs.verbose)
                  printf("\"%s\" != \"%s\"\n",pszRelWorkDir,argv[3]);
               return 9;
            }
         } else {
            printf("%s\n", pszRelWorkDir);
         }
         return 0;
      }

      if (argc < 6) return 9+perr("missing arguments. type \"sfk test\" for help.\n");

      char *pszMode   = argv[2];
      char *pszDBFile = argv[3];
      char *pszTitle  = argv[4];
      char *pszInFile = argv[5];

      // create checksum of infile in szLineBuf.
      if (getFuzzyTextSum(pszInFile, abBuf))
         return 9;
      for (int i=0; i<16; i++)
         sprintf(&szLineBuf2[i*2], "%02x", abBuf[i]);

    {
      TestDB tdb(pszDBFile);

      // select command
      if (!strcmp(pszMode, "rec")) {
         tdb.load(1); // silent: ignore rc, create on 1st use
         // write unconditional, overwrite existing vals
         if (tdb.update(pszTitle, szLineBuf2)) return 9;
         if (tdb.write()) return 9;
         int tlen = strlen(pszTitle);
         if (tlen > 15) tlen = 15;
         printf(":REC : %s%.*s %s\n", pszTitle, (int)(15-tlen), pszGlblBlank, szLineBuf2);
      }
      else
      if (!strcmp(pszMode, "upd")) {
         tdb.load(1); // silent: ignore rc, create on 1st use
         // write only if not yet contained
         if (!tdb.getValue(pszTitle)) {
            if (tdb.update(pszTitle, szLineBuf2)) return 9;
            if (tdb.write()) return 9;
            int tlen = strlen(pszTitle);
            if (tlen > 15) tlen = 15;
            printf(":ADD : %s%.*s %s\n", pszTitle, (int)(15-tlen), pszGlblBlank, szLineBuf2);
         }
      }
      else
      if (!strcmp(pszMode, "cmp")) {
         if (tdb.load(0)) return 9;
         char *pszVal = tdb.getValue(pszTitle);
         if (!pszVal) return 9+perr("no such entry: %s\n", pszTitle);
         if (!strcmp(pszVal, szLineBuf2)) {
            // match
            printf(": OK : %s\n", pszTitle);
         } else {
            // mismatch
            printf(":FAIL: %s   - mismatch of %s\n", pszTitle, pszInFile);
            lRC = 9;
         }
      }
      else
         return 9+perr("unknown test mode: %s\n", pszMode);
    }

      bDone = 1;
   }

   // internal
   if (!strcmp(pszCmd, "proctest"))
   {
      if (nparm < 1) 
      {
      printx("<help>$sfk proctest script.txt [startid]\n"
             "\n"
             "   test text processing by running testcases\n"
             "   from a script. per testcase,\n"
             "\n"
             "   - an input file tmpin.txt is written\n"
             "   - another file tmpout.txt is written\n"
             "     with same content as tmpin.txt,\n"
             "     to allow direct replace in tmpout.txt\n"
             "   - a command from the script is executed\n"
             "   - output file tmpout.txt is compared\n"
             "     against the output template data in the script.\n"
             "\n"
             "   $script syntax\n"
             "      :test name of test case 1\n"
             "      :from\n"
             "      ... [any text data] ...\n"
             "      :command\n"
             "      ... [single line command] ...\n"
             "      :to\n"
             "      ... [any text data] ...\n"
             "      :done\n"
             "\n"
             "      :test name of test case 2\n"
             "      ...\n"
             "\n"
             "   $script example\n"
             "      :test 01 replace foo\n"
             "      :from\n"
             "      the foo and the bar\n"
             "      :command\n"
             "      sfk rep tmpout.txt -text \"/foo/bar/\" -yes\n"
             "      :to\n"
             "      the bar and the bar\n"
             "      :done\n"
             "\n"
             "   $options\n"
             "      -quiet    redirect terminal output to >nul\n"
             "      -cmd=x    replace $cmd at line starts by x\n"
             "\n"
             "   $examples\n"
             "      #sfk proctest myscript.txt\n"
             "         runs script myscript.txt\n"
             );
      return 9;
      }

      char *pszScript = 0;
      char *pszStart = 0;
      char *pszCmd = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-cmd", &pszParm)) {
            if (!pszParm) return 9;
            pszCmd = pszParm;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszScript) {
            pszScript = pszArg;
            continue;
         }
         if (!pszStart) {
            pszStart = pszArg;
            continue;
         }
         return 9+perr("unexpected parameter: %s", pszArg);
      }

      if (!pszScript)
         return 9+perr("missing script filename\n");

      char *pScript = loadFile(pszScript);
      if (!pScript)
         return 9+perr("cannot load script");

      char *pTestName,*pFromStart,*pFromEnd;
      char *pCommand,*pToStart,*pToEnd;

      char *pCur = pScript;
      while (pCur && *pCur)
      {
         if (strBegins(pCur, ":done")) {
            if (nextLine(&pCur)) break;
            continue;
         }
         skipOver(&pCur, " \r\n");
         if (!*pCur) break;
         if (!strBegins(pCur, ":test "))
            { perr("missing :test"); break; }
         pTestName = pCur+6;
         if (nextLine(&pCur)) break;
         if (!strBegins(pCur, ":from"))
            { perr("missing :from after :test"); break; }
         if (nextLine(&pCur)) break;
         pFromStart = pCur;
         pFromEnd = strstr(pCur, "\n:command");
         if (!pFromEnd)
            { perr("missing :command after :from"); break; }
         pFromEnd++;
         pCommand = pFromEnd;
         if (nextLine(&pCommand)) break;
         while (*pCommand == '#')
            nextLine(&pCommand);
         // auto convert ./sfk to target system
         if (pCommand[0]=='.' && pCommand[1]==glblWrongPChar)
            pCommand[1]=glblPathChar;
         pToStart = pCommand;
         if (nextLine(&pToStart)) break;
         if (!strBegins(pToStart, ":to"))
            { perr("missing :to after :command"); break; }
         if (nextLine(&pToStart)) break;
         pToEnd = strstr(pToStart, "\n:done");
         if (!pToEnd)
            { perr("missing :test or :done after :to"); break; }
         pToEnd++;
         pCur = pToEnd;
         // execute single test case
         if (pszStart!=0 && !strstr(pTestName,pszStart))
            { }
         else
         {
            printx("#TEST: ===== %s =====\n", pTestName);
            if (!cs.quiet)
               printf("FROM: %s\n", dataAsTrace(pFromStart, pFromEnd-pFromStart));
            if (saveFile(str("tmpin.txt"), (uchar*)pFromStart, pFromEnd-pFromStart))
               break;
            if (saveFile(str("tmpout.txt"), (uchar*)pFromStart, pFromEnd-pFromStart))
               break;
            // replace $cmd by -cmd parameter
            if (strBegins(pCommand, "$cmd ")) {
               if (!pszCmd)
                  return 9+perr("missing -cmd for $cmd entries in test script");
               snprintf(szLineBuf2, MAX_LINE_LEN, "%s %s", pszCmd, pCommand+5);
               pCommand = szLineBuf2;
            }
            if (!cs.quiet)
               printf("CMD : %s\n", pCommand);
            if (cs.quiet && !strstr(pCommand, " >")) {
               snprintf(szLineBuf, MAX_LINE_LEN, "%s >nul 2>&1", pCommand);
               if (system(szLineBuf)) { }
            } else {
               if (system(pCommand)) { }
            }
            if (!cs.quiet)
               printf("NEED: %s\n", dataAsTrace(pToStart, pToEnd-pToStart));
            num nOutSize=0;
            uchar *pOut = loadBinaryFile(str("tmpout.txt"), nOutSize);
            if (!pOut)
               { perr("missing output file tmpout.txt"); break; }
            if (!cs.quiet)
               printf("GOT : %s\n", dataAsTrace(pOut, nOutSize));
            #ifdef _WIN32
            if (nOutSize != pToEnd-pToStart) {
               delete [] pOut;
               perr("... output size differs (%d/%d)",(int)nOutSize,(int)(pToEnd-pToStart));
               break;
            }
            if (memcmp(pOut,pToStart,nOutSize)) {
               delete [] pOut;
               perr("... output differs.");
               break;
            }
            #else
            uchar abSum1[20];
            uchar abSum2[20];
            getFuzzyTextSum((char*)pToStart, (int)(pToEnd-pToStart), abSum1);
            getFuzzyTextSum((char*)pOut, (int)nOutSize, abSum2);
            if (memcmp(abSum1,abSum2,16)) {
               delete [] pOut;
               perr("... output differs (fuzzy).");
               break;
            }
            #endif
            delete [] pOut;
         }
      }

      delete [] pScript;

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "snapto")) 
   {
      ifhelp (1)
      printx("$sfk snapto=outfile [-pure] [-nosub] -dir mydir1 -file .ext1 .ext2\n"
             "\n"
             "   Collect many text files into one large text file, specifying\n"
             "   what sub folders and file (extensions) to include or exclude.\n"
             "   The resulting file can be loaded directly by Depeche View,\n"
             "   allowing interactive search and filtering of the content.\n"
             "\n"
             "   $options\n"
             "      -fileset x  instead of specifying long lists of -dir / -file\n"
             "                  statements on the command line, you may write them\n"
             "                  all into a text file, then use that. for more infos,\n"
             "                  type \"sfk help fileset\".\n"
             );
      arcinf(8); // snapto
             #ifdef _WIN32
      printx("      -hidden     include hidden and system files (not default).\n");
             #endif
      printx("      -allbin     include binary files as text extract (not default).\n"
             "      -pure       don't insert filenames.\n"
             "      -prefix=x   insert x before every file.\n"
             "      -nometa     by default, sfk adds the file system's time and size\n"
             "                  info to each :file: header. can be disabled here.\n"
             "                  note that size= may not reflect the actual bytes used\n"
             "                  within the snapfile, due to line ending conversions.\n"
         //  "      -raw        add text file content 1:1 without CRLF conversions\n"
         //  "                  and skip binary files completely. assures that the\n"
         //  "                  size= header field reflects the true content size.\n"
         //  "      -rawest     like -raw but does not even convert unexpected null\n"
         //  "                  or EOF (0x1A) characters within text data.\n"
             "      -nosub      or -norec does not include subdirectories (subfolders).\n"
             "      -wrap[=n]   auto-wrap long lines [near column n], e.g. -wrap=80.\n" 
             "      -stat       show time stats at end.\n"
             ,glblPathChar);
      printx("\n"
             "   $see also\n"
             "      #sfk view<def>    a GUI tool that can load and view sfk snap files\n"
             "                  directly and search them at high speed.\n"
             "      #sfk getdv<def>   instant download of Depeche View Lite (portable,\n"
             "                  no installation) to browse snap file contents.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk snapto=all-src.cpp . .cpp .hpp .dll <not>tmp\n"
             "         includes .cpp, .hpp and even .dll text extracts, excludes all\n"
             "         files with \"tmp\" in their name, e.g. tmp10.cpp\n"
             "\n"
             "      #sfk snapto=all-src.cpp -dir src2 <not>src2<sla>old -file -all .doc\n"
             "         includes all text files, and .doc binary extracts.\n"
             "\n"
             "      #sfk snapto=all-src.cpp -fileset zz-myset.txt\n"
             "         includes whatever dirs and files are specified in the\n"
             "         fileset definition \"zz-myset.txt\" (sfk help fileset).\n"
             "\n"
             "      #sfk select src5 .txt .exe +snapto=all.txt\n"
             "         filenames provided by command chaining are always included,\n"
             "         no matter if binary or not. in this case, extracts from .exe\n"
             "         binary files are also placed into the output.\n"
             "\n"
             "      #sfk select -text mydir <not>.bak +snapto=all.txt\n"
             "         select all text files from mydir, excluding .bak files.\n"
             );
      ehelp;
      // no real action here
      return 9;
   }

   regtest("snapto=xfile.txt xdir .cpp .hpp -wrap");
   regtest("snapto=xfile.txt -pure -prefix=foo -dir xdir1 xdir2 -file .cpp");
   regtest("list xdir +snapto=xfile.txt");

   if (!strncmp(pszCmd, "snapto=", strlen("snapto=")))   // +chaining
   {
      pszGlblOutFile = pszCmd+strlen("snapto=");

      bool bstat     = 0;
      cs.addsnapmeta = 0xFFFFUL; // add as much infos as possible
      cs.addsnaplf   = "\n";     // by default converted by fprintf etc.

      #ifdef VFILEBASE
      cs.precachezip = 1;
      #endif // VFILEBASE

      const char *poutmode = "w";

      for (; iDir < argc; iDir++) {
         if (!strncmp(argv[iDir],"-prefix=",strlen("-prefix="))) {
            char *psz = argv[iDir]+strlen("-prefix=");
            if (strlen(psz) > 40)
               return 9+perr("prefix too long, only up to 40 characters are allowed."); 
            pszGlblJamPrefix = psz;
         }
         else
         if (!strcmp(argv[iDir],"-pure"))
            bGlblJamPure = 1;
         else
         if (!strcmp(argv[iDir],"-stat"))
            bstat = 1;
         else
         if (!strcmp(argv[iDir],"-nometa"))
            cs.addsnapmeta = 0;
         else
         if (!strcmp(argv[iDir],"-raw")) {
            cs.addsnapraw = 1;
            // write snapfile in binary mode,
            // to avoid any conversions by fwrite
            poutmode = "wb";
            // therefore we need to specify exact
            // line endings used for header lines
            cs.addsnaplf  = glblLineEnd;
         }
         else
         if (!strcmp(argv[iDir],"-rawest")) {
            cs.addsnapraw = 2;
            poutmode = "wb";
         }
         else
         if (isDirParm(argv[iDir]))
            break; // fall through
         else
         if (!setGeneralOption(argv, argc, iDir))
            break;
      }

      // collect dir and mask parms
      bGlblAllowAllPlusPosFile = 1;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3))) return lRC;
      if (btest) return 0;

      fGlblOut = fopen(pszGlblOutFile, poutmode);
      if (!fGlblOut) return 9+perr("cannot write %s\n", pszGlblOutFile);

      // write global file header
      fprintf(fGlblOut, ":snapfile sfk,1.1,%slprefix=%s",
         cs.addsnapraw ? "raw,":"", pszGlblJamPrefix);
      if (cs.wrapcol > 0)
         fprintf(fGlblOut, ",wrap=%u", cs.wrapcol);
      fprintf(fGlblOut,"%s%s",cs.addsnaplf,cs.addsnaplf);
      // we will scan the input if we see this content, and exclude it

      // reset stats in case of input chaining
      glblFileCount.reset();
      cs.lines   = 0;
      nGlblBytes = 0;

      lRC = walkAllTrees(eFunc_JamFile, lFiles, lDirs, nBytes);

      fclose(fGlblOut);

      uint nmbytes = (uint)(nGlblBytes/1000000UL);
      uint nkbytes = (uint)(nGlblBytes/1000UL);
      uint nkbsec  = currentKBPerSec();
      uint nmbsec  = nkbsec / 1000UL;
      uint nmsec   = (uint)(getCurrentTime() - nGlblStartTime);
      uint nsec    = nmsec / 1000UL;

      info.clear();

      if (bstat)
      printf("%u files collected into %s, %d lines, %u %s, %u %s, %u %s/sec\n",
         glblFileCount.value(), pszGlblOutFile, cs.lines,
         (nmbytes>0)?nmbytes:nkbytes, (nmbytes>0)?"mb":"kb",
         (nsec>=10)?nsec:nmsec, (nsec>=10)?"sec":"msec",
         (nmbsec>=10)?nmbsec:nkbsec, (nmbsec>=10)?"mb":"kb");
      else
      printf("%u files collected into %s, %d lines, %u %s\n",
         glblFileCount.value(), pszGlblOutFile, cs.lines,
         (nmbytes>0)?nmbytes:nkbytes, (nmbytes>0)?"mb":"kb");

      bDone = 1;
   }

   regtest("text-join-lines xinfile xoutfile");

   ifcmd (!strcmp(pszCmd, "joinlines") || !strcmp(pszCmd, "text-join-lines"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 2)
      printx("<help>$sfk joinlines infile outfile\n"
             "\n"
             "   join text lines from text split by email reformatting.\n"
            );
      ehelp;

      for (; iDir < argc; iDir++)
         if (!setGeneralOption(argv, argc, iDir))
            break;

      if (iDir >= argc-1) return 9+perr("missing arguments\n");

      char *pszInFile  = argv[iDir+0];
      for (int k=iDir+1; k<argc; k++)
         if (isChainStart(pszCmd, argv, argc, k, 0))
            return 9+perr("%s does not support chaining (%s).\n",pszCmd,argv[k]);
      char *pszOutFile = argv[iDir+1];

      if (btest) return 0;

      char *pInFile = loadFile(pszInFile);
      if (!pInFile) return 9;

      fGlblOut = fopen(pszOutFile, "w");
      if (!fGlblOut) {
         perr("cannot write %s\n", pszOutFile);
         delete [] pInFile;
         return 9; 
      }

      lRC = execTextJoinLines(pInFile);

      fclose(fGlblOut);
      delete [] pInFile;

      bDone = 1;
   }

   if (!strcmp(pszCmd, "scantab2")) 
   {
      cs.scanTabs = 1;
      if ((lRC = processDirParms(pszCmd, argc, argv, 2, 3))) return lRC;
      lRC = walkAllTrees(eFunc_Detab, lFiles, lDirs, nBytes);
      printf("%d files of %d contain tabs.\n", cs.tabFiles, cs.files);
      bDone = 1;
   }

   regtest("scantab -dir xsrc1 xsrc2 -file .cpp .hpp .txt");
   regtest("scantab -quiet -pure . .cpp .hpp");
   regtest("list xdir .txt +scantab");

   ifcmd (!strcmp(pszCmd, "scantab"))  // +chaining
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk scantab [-quiet] dir [mask] [-pure]\n"
             "\n"
             "   list files containing tabs.\n"
             "\n"
             "   $options\n"
             "      -quiet   do not list filenames, show only statistics.\n"
             "      -pure    list only filenames, but no statistics.\n"
             "\n"
             "   $return codes for batch files\n"
             "      0 = no tabs, 1 = tabs found, >1 = error occurred.\n"
      //     "   -ind[ent]  collect also indentation statistics\n"
      //     "   -indsel=4  list only files with indentation 4\n"
      //     "   -verbose   list estimated indendation per file\n"
            );
      ehelp;

      // allow option -pure to be used anywhere:
      bGlblAllowGeneralPure = 1;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-indsel", &pszParm)) {
            if (!pszParm) return 9;
            cs.indentFilt = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-ind", 4)) {
            cs.scanIndent = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-pure")) {
            cs.pure = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         break;
      }

      memset(aGlblIndentStats, 0, sizeof(aGlblIndentStats));
      cs.scanTabs = 1;
      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC;
      if (btest) return 0;

      lRC = walkAllTrees(eFunc_Scantab, lFiles, lDirs, nBytes);
      if (!lRC && (cs.tabFiles > 0)) lRC = 1; // found files with tabs

      if (!cs.indentFilt && !cs.pure)
         printf("%d files of %d contain tabs.", cs.tabFiles, cs.files);

      bool bTold=0;
      if (cs.scanIndent) 
      {
         // create sorted indent stats
         int i,k;
         int asize[20], acnt[20];
         memset(asize, 0, sizeof(asize));
         memset(acnt , 0, sizeof(acnt));
         // transform
         for (i=0; i<=8; i++) {
            int nsize = i;
            int ncnt  = aGlblIndentStats[i];
            asize[i] = nsize;
            acnt[i]  = ncnt;
         }
         // sort
         for (i=0; i<10; i++)
            for (k=i+1; k<10; k++)
               if (acnt[k] > acnt[i] || (asize[i] == 0)) {
                  int n   = acnt[i];
                  acnt[i]  = acnt[k];
                  acnt[k]  = n;
                       n   = asize[i];
                  asize[i] = asize[k];
                  asize[k] = n;
               }
         // dump sorted stats
         for (i=0; i<=10; i++) {
            if (acnt[i] > 0) {
               if (!bTold) {
                  printf(" %d files have indent %d", acnt[i], asize[i]);
                  bTold = 1;
               }
               else
               if (asize[i] > 0) {
                  printf(", %d/%d", acnt[i], asize[i]);
                  bTold = 1;
               }
               else
               if (bTold) // list unknowns only if others listed before
                  printf(", %d/unknown", acnt[i]);
            }
         }
      }

      if (bTold)
         printf(".\n");
      else
      if (!cs.indentFilt && !cs.pure)
         printf("\n");

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   regtest("detab=3 xfile");
   regtest("detab=3 xsrc .cpp .hpp");
   regtest("list xdir .txt +detab=3");

   ifcmd (!strncmp(pszCmd, "detab", 5))  // +chaining (alpha)
   {
      ifhelp(   strncmp(pszCmd, "detab=", 6)
             || (!chain.useany() && (nparm < 1)) 
            )
      printx("<help>$sfk detab=tabsize dir ext1 [ext2 ...] [-to outmask]\n"
             "\n"
             "   replace tabs by spaces within file(s) or text stream.\n"
             "\n"
             "   $options\n"
             "      -to outmask   do not overwrite original files, but write\n"
             "                    to output files according to outmask, e.g.\n"
             "                    #-to tmp<sla><run>path<sla><run>base.<run>ext<def> or #-to tmp<sla><run>file\n"
             "      -yes          if files are selected, really (re)write them.\n"
             "                    without -yes, detab is only simulated.\n"
             "      -memlimit=n   process files with up to n mbytes (default=300).\n"
             "      -nowarn       do not tell about skipped or unreadable files.\n"
             "\n"
             "   $see also\n"
             "      #sfk scantab<def>   list files containing TAB characters.\n"
             "      #sfk help opt<def>  how to change the memlimit permanently.\n"
             #ifdef _WIN32
             "      #sfk view<def>      a text file viewer that can show all TAB\n"
             "                    characters in blue by pressing CTRL+T.\n"
             #endif
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk detab=3 sources .cpp .hpp\n"
             "         replace tabs by up to 3 blanks, within all .cpp and .hpp\n"
             "         files of directory tree \"sources\".\n"
             "\n"
             "      #sfk select -dir src -file .java +detab=4 -to tmp<sla><run>file\n"
             "         list all .java files of src, then detab with tabsize 4,\n"
             "         writing all outputs to directory tree \"tmp\".\n"
             "\n"
             "      #sfk detab=4 src .java -relnames -to tmp<sla><run>file\n"
             "         nearly the same, however stripping the \"src\" input directory\n"
             "         name from output file paths (not possible with \"+detab\" form).\n"
             "\n"
             "      #sfk filter mytext.txt +detab=8\n"
             "         detab content of a single file to the console.\n"
            );
      ehelp;

      char *pszTabSize = pszCmd+strlen("detab=");
      if (!(cs.tabSize = atol(pszTabSize))) return 9+perr("invalid tab size\n");
      
      cs.scanTabs = 0;
      
      // since 161: process only text files. before that,
      // user had to select text files by file extension.
      cs.textfiles = 1;
      
      // since 161: accept generic options
      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // short file parms
      }

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext))) return lRC;
      if (btest) return 0;

      cs.sim = !cs.yes;

      if (chain.usedata) {
         // detab stream line
         for (int i=0; i<chain.indata->numberOfEntries(); i++) {
            szLineBuf[0]  = '\0';
            szLineBuf2[0] = '\0';
            char *psrc = chain.indata->getEntry(i, __LINE__);
            if (psrc) {
               strcopy(szLineBuf, psrc);  
               removeCRLF(szLineBuf);
            }
            detabLine(szLineBuf, szLineBuf2, MAX_LINE_LEN, cs.tabSize);
            if (chain.coldata) {
               chain.addLine(szLineBuf2, str(""));
            } else {
               printf("%s\n", szLineBuf2);
            }
         }
      } else {
         // detab file contents
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         lRC = walkAllTrees(eFunc_Detab, lFiles, lDirs, nBytes);

         const char *sxinfo = cs.sim ? "would be ":"";
         printf("%d files checked, %d %sdetabbed, %d tabs in total.\n", 
            cs.files, cs.tabFiles, sxinfo, cs.tabsDone);
            
         if (cs.anyFileTooLarge)
            pinf("use -memlimit=1000 to process larger files.\n");

         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");
      }

      if (chain.usedata) {
         STEP_CHAIN(iDirNext, 1); // 1: use new data
      } else {
         STEP_CHAIN(iDirNext, 0); // 0: reuse existing filename list
      }

      bDone = 1;
   }

   ifcmd (strBegins(pszCmd, "del") || !strcmp(pszCmd, "rmtree"))  // +chaining
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk delete dir ext1 [ext2 ...] [-yes]\n"
             "$sfk deltree targetdir [-yes]\n"
             "$sfk del -dir dir1 dir2 -file .ext1\n"
             "\n"
             "   delete files or dirs, even if they're write protected.\n"
             "   deltree or rmtree deletes a directory tree with all contents.\n"
             "\n"
             "   $options\n"
             "      -yes         really delete the files. without option -yes,\n"
             "                   del only lists the files that would be deleted.\n"
             "      -withdirs    if you supply a file mask other than \"<wild>\",\n"
             "      or -wdir     and file deletion leads to an empty directory,\n"
             "                   then the directory is removed as well. if you\n"
             "                   supply no file mask (or \"<wild>\"), then every\n"
             "                   empty directory is always deleted. this option\n"
             "                   cannot be used with chaining, as chaining passes\n"
             "                   only filenames, but no processed directory names.\n"
             #ifdef _WIN32
             "      -hidden      include hidden and system files.\n"
             "                   this option is default when using deltree.\n"
             #endif
             "\n"
             "   $lazy confirmation on command chaining\n"
             "      if you selected files in a command chain, then want to add +del\n"
             "      you may type \"+del.\" (with a dot) or \"+del!\" (windows only)\n"
             "      instead of \"+del -yes\" to actually delete the files.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk del -withdirs src .bak\n"
             "         deletes .bak files within src and all subdirs.\n"
             "         if a directory contained only .bak files,\n"
             "         it is deleted as well.\n"
             "\n"
             "      #sfk del -yes -withdirs -hidden tmp\n"
             "         delete tmp with all files, including hidden files.\n"
             "\n"
             "      #sfk deltree. tmp\n"
             "         the same as above, with \".\" as a short for -yes.\n"
             "\n"
             "      #sfk list -dir src -file foo*.hpp +del\n"
             "         first list target files, then add +del\n"
             #ifdef _WIN32
             "\n"
             "      #sfk fromclip +del\n"
             "         take a list of filenames from clipboard and delete them.\n"
             "         see \"sfk help shell\" on how to configure your windows\n"
             "         command prompt, to allow easy copying of filename lists.\n"
             #endif
            );
      ehelp;

      bool bdeltree = 0;

      if (strBegins(pszCmd, "deltree")) {
         bdeltree = cs.hidden = cs.withdirs = 1;
         if (   !strcmp(pszCmd, "deltree.")
             || !strcmp(pszCmd, "deltree!")
            )
            cs.yes = 1;
      }

      if (strBegins(pszCmd, "rmtree")) {
         bdeltree = cs.hidden = cs.withdirs = 1;
         if (   !strcmp(pszCmd, "rmtree.")
             || !strcmp(pszCmd, "rmtree!")
            )
            cs.yes = 1;
      }

      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // process non-option keywords:
         break; // fall through
      }

      // lazy confirmation: accept -del. as -del -yes
      if (!strcmp(pszCmd, "del.") || !strcmp(pszCmd, "del!"))
         cs.yes = 1;

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext))) return lRC;
      if (btest) return 0;

      cs.sim = !cs.yes;

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_Delete, lFiles, lDirs, nBytes);

      info.clear();
      if (cs.quiet < 2) {
         const char *sxinfo = cs.sim ? "would be ":"";
         if (cs.withdirs)
            printf("%d files, %d dirs %sdeleted. ", cs.filesDeleted, cs.dirsDeleted, sxinfo);
         else
            printf("%d files %sdeleted. ", cs.filesDeleted, sxinfo);
         cchar *pcont = "including ";
         if (cs.filesDeletedWP) {
            printx("<time>including %d readonly files<def>", cs.filesDeletedWP);
            pcont = ", ";
         }
         if (cs.dirsDeletedWP)
            printx("<time>%s%d readonly dirs<def>", pcont,cs.dirsDeletedWP);
         printf("\n");
      }

      if (cs.sim && !cs.nohead) {
         #ifdef _WIN32
         printx("$[say -yes, %s. or %s! to execute.]\n",bdeltree ? "deltree":"del",bdeltree ? "deltree":"del");
         #else
         printx("$[say -yes or %s. to execute.]\n",bdeltree ? "deltree":"del");
         #endif
      }

      STEP_CHAIN(iDirNext, 0); // 0: reuse existing filename list

      bDone = 1;
   }

   regtest("entab=3 xfile");
   regtest("list xdir .java +entab=4");

   ifcmd (!strcmp(pszCmd, "entab") || !strncmp(pszCmd, "entab=", 6))  // +chaining (alpha)
   {
      ifhelp (!strcmp(pszCmd, "entab") || (!chain.usefiles && (nparm < 1)))
      printx("<help>$sfk entab=tabsize dir ext1 [ext2 ...]\n"
             "\n"
             "   replace groups of spaces by tabs within file(s).\n"
             "\n"
             "   $options\n"
             "      -to outmask   do not overwrite original files, but write\n"
             "                    to output files according to outmask, e.g.\n"
             "                    #-to tmp<sla><run>path<sla><run>base.<run>ext<def> or #-to tmp<sla><run>file\n"
             "      -yes          if files are selected, really (re)write them.\n"
             "                    without -yes, entab is only simulated.\n"
             "      -memlimit=n   process files with up to n mbytes (default=300).\n"
             "      -nowarn       do not tell about skipped or unreadable files.\n"
             "\n"
             "   $see also\n"
             "      #sfk scantab<def>   list files containing TAB characters.\n"
             "      #sfk help opt<def>  how to change the memlimit permanently.\n"
             #ifdef _WIN32
             "      #sfk view<def>      a text file viewer that can show all TAB\n"
             "                    characters in blue by pressing CTRL+T.\n"
             #endif
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk entab=3 sources .cpp .hpp\n"
             "         replace 3 spaces each by a TAB character in all .cpp\n"
             "         and .hpp files within folder sources.\n"
             "\n"
             "      #sfk entab=3 singleFileName.txt\n"
             "         the same, but only in a single file.\n"
            );
      ehelp;

      if (chain.usedata)
         return 9+perr("entab does not support chain text input.");

      char *pszTabSize = pszCmd+strlen("entab=");
      if (!(cs.tabSize = atol(pszTabSize))) return 9+perr("invalid tab size\n");
      cs.scanTabs = 0;

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext))) return lRC;
      if (btest) return 0;

      cs.sim = !cs.yes;

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_Entab, lFiles, lDirs, nBytes);

      const char *sxinfo = cs.sim ? "would be ":"";
      printf("%d files checked, %d %sentabbed, %d tabs in total.\n", 
         cs.files, cs.tabFiles, sxinfo, cs.tabsDone);

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      STEP_CHAIN(iDirNext, 0);
      bDone = 1;
   }

   regtest("addcr xfile");
   regtest("lf-to-crlf xsrc .cpp .hpp");
   regtest("list xdir .txt +addcr");
   regtest("list -dir xdir1 xdir2 -file .cpp .hpp +lf-to-crlf");

   ifcmd (   !strcmp(pszCmd, "lf-to-crlf")   // +chaining (alpha)
          || !strcmp(pszCmd, "addcr") 
          || !strcmp(pszCmd, "addcrlf")
          || !strcmp(pszCmd, "listle")       // yet internal
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk lf-to-crlf [options] dir .ext1 .ext2 [-to outmask]\n"
             "\n"
             "   convert just-lf (unix) text format to cr+lf (dos/windows).\n"
             "\n"
             "   if only a single filename, or list of filenames, is given\n"
             "   then these are converted immediately.\n"
             "\n"
             "   if a directory parameter is given then the command runs\n"
             "   in simulation mode, requiring option -yes to convert.\n"
             "\n"
             "   $options\n"
             "      -forceend    if a file is changed and rewritten then\n"
             "                   also add a line ending at the last line\n"
             "                   even if there was none in the input file.\n"
             "      -writeall    rewrite all files no matter if changed\n"
             "\n"
             "   $aliases\n"
             "      #sfk addcr<def>    same as sfk lf-to-crlf\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk addcr src .cpp .hpp\n"
             "         add crlf on all .cpp and .hpp files within src.\n"
             "\n"
             "      #sfk select -dir doc -file .txt +addcr -to tmp<sla><run>file\n"
             "         add crlf on all .txt files within doc, saving to tmp.\n"
            );
      ehelp;
 
      int iDirNext = 0;
      bool bshowle = 0;
 
      nGlblConvTarget = eConvFormat_CRLF;

      if (!strcmp(pszCmd, "listle")) {
         nGlblConvTarget = eConvFormat_ShowLE;
         mclear(aGlblConvStat);
         bshowle = 1;
      }

      // SFK 1.7.2: only text files
      cs.textfiles = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         if (strBegins(pszArg, "-forceend")) {
            cs.forcele = 1;
            continue;
         }
         else
         if (strBegins(pszArg, "-writeall")) {
            cs.writeall = 1;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break;
      }

      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext))) return lRC;
      if (btest) return 0;

      if (!bshowle && (!cs.sim || cs.yes))
      {
         // list of filenames: execute immediately
         if (glblSFLNumberOfEntries() > 0)
            cs.yes = 1;
   
         cs.sim = !cs.yes;
      }

      if (!bshowle && cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_FormConv, lFiles, lDirs, nBytes);

      if (!bshowle && cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      if (bshowle) {
         printx("$%d files with CR/LF, %d with LF, %d unterminated, %d with CR.<def>\n",
            aGlblConvStat[0],aGlblConvStat[1],aGlblConvStat[2],aGlblConvStat[3]);
      } else {
         printf("%d files %sconverted.\n", cs.files, cs.sim ? "would be ":"");
      }

      STEP_CHAIN(iDirNext, 0);
      bDone = 1;
   }

   regtest("remcr xfile");
   regtest("crlf-to-lf xsrc .cpp .hpp");
   regtest("list xdir .txt +remcr");
   regtest("list -dir xdir1 xdir2 -file .cpp .hpp +crlf-to-lf");

   ifcmd (   !strcmp(pszCmd, "crlf-to-lf")   // +chaining (alpha)
          || !strcmp(pszCmd, "remcr") 
          || !strcmp(pszCmd, "remcrlf")
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk crlf-to-lf [options] dir .ext1 .ext2 [-to outmask]\n"
             "\n"
             "   convert cr+lf (dos/windows) text format to just-lf (unix).\n"
             "\n"
             "   if only a single filename, or list of filenames, is given\n"
             "   then these are converted immediately.\n"
             "\n"
             "   if a directory parameter is given then the command runs\n"
             "   in simulation mode, requiring option -yes to convert.\n"
             "\n"
             "   $options\n"
             "      -forceend    if a file is changed and rewritten then\n"
             "                   also add a line ending at the last line\n"
             "                   even if there was none in the input file.\n"
             "      -writeall    rewrite all files no matter if changed\n"
             "\n"
             "   $aliases\n"
             "      #sfk remcr<def>    same as sfk crlf-to-lf\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk remcr src .cpp .hpp\n"
             "         reduce crlf to lf on all .cpp and .hpp files within src.\n"
             "\n"
             "      #sfk select -dir doc -file .txt +remcr -to tmp<sla><run>file\n"
             "         change crlf on all .txt files within doc, saving to tmp.\n"
            );
      ehelp;

      int iDirNext = 0;

      nGlblConvTarget = eConvFormat_LF;

      // SFK 1.7.2: only text files
      cs.textfiles = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         if (strBegins(pszArg, "-forceend")) {
            cs.forcele = 1;
            continue;
         }
         else
         if (strBegins(pszArg, "-writeall")) {
            cs.writeall = 1;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break;
      }

      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iDirNext))) return lRC;
      if (btest) return 0;

      if (!cs.sim || cs.yes)
      {
         // list of filenames: execute immediately
         if (glblSFLNumberOfEntries() > 0)
            cs.yes = 1;
   
         cs.sim = !cs.yes;
      }

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      lRC = walkAllTrees(eFunc_FormConv, lFiles, lDirs, nBytes);

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      printf("%d files %sconverted.\n", cs.files, cs.sim ? "would be ":"");

      STEP_CHAIN(iDirNext, 0);
      bDone = 1;
   }

   regtest("stat -minsize=10 .");
   regtest("stat -quiet -i");

   ifcmd (strBegins(pszCmd, "stat") || strBegins(pszCmd, "treesize"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk stat [-minsize=n] dir [-i]\n"
             "$sfk treesize[mb] dir\n"
             "\n"
             "   show directory tree size statistics in mbytes.\n"
             #ifdef _WIN32
             "   hidden and system files are INCLUDED by DEFAULT,\n"
             "   to make sure the real size usage is always shown.\n"
             #endif
             "\n"
             "   $options\n"
             "      -minsize=n   list only dirs and files with a size larger\n"
             "                   or equal to this, e.g. 100 = 100 bytes,\n"
             "                   10k = 10 kbytes, 10m = 10 megabytes.\n"
             "      -i           read list of directories from stdin.\n"
             #ifdef _WIN32
             "      -nohidden    exclude hidden and system files.\n"
             #endif
             "      -nosum       print no summary at end of listing.\n"
             "      -sum         print only the summary.\n"
             "      -kbytes      list all sizes in kbytes.\n"
             "      -bytes       list all sizes in bytes.\n"
             "      -flat        show the no. of files and bytes per folder\n"
             "                   without its subfolders (do not accumulate).\n"
             "\n"
             "   $aliases\n"
             "      #sfk stat10<def>       does the same as #sfk stat -minsize=10m<def>\n"
             "      #sfk treesize100<def>  does the same as #sfk stat -minsize=100m<def>\n"
             #ifdef VFILEBASE
             "\n"
             "   $limitations\n"
             "      this command cannot summarize zip file contents.\n"
             #endif // VFILEBASE
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk stat . -minsize=10m\n"
             "          list sizes of all directories below the current one\n"
             "          having a size of at least 10 mbytes.\n"
             "\n"
             "      #sfk stat50 docs\n"
             "          list all directories and single files under the docs\n"
             "          directory tree having a size of >= 50 mbytes.\n"
             "\n"
             "      #type dirlist.txt | sfk stat -quiet -i\n"
             "          list sizes of dirs listed in dirlist.txt\n"
             );
      ehelp;

      nGlblListMode = 1;
      cs.withdirs   = 1; // always, esp. on receive of dirs by chain
      bool bSummary = 1;
      cs.hidden     = 1; // INCLUDE HIDDEN FILES BY DEFAULT (windows)

      // command aliases: "stat10" == "stat -minsize=10"
      char *pqsize = pszCmd + 4;
      if (strBegins(pszCmd, "treesize"))
            pqsize = pszCmd + 8;
      if (*pqsize) {
         if (!isdigit(*pqsize)) return 9+perr("supply a number after stat, like stat10.\n");
         nGlblListMinSize = atol(pqsize) * 1000000;
      }

      int iChainNext = 0;
      for (; iDir < argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-minsize", &pszParm)) {
            if (!pszParm) return 9;
            nGlblListMinSize = numFromSizeStr(pszParm, "-minsize");
            if (nGlblListMinSize < 0) return 9;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-kb")) {
            cs.listunit = 'k';
            continue;
         }
         else
         if (strBegins(argv[iDir], "-byte")) {
            cs.listunit = 'b';
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-flat")) {
            cs.flatdirstat = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nosum", 6)) {
            bSummary = 0;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-sum")) {
            cs.statonlysum = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // short file set expected
      }

      int nAutoComp = (bGlblStdInAny || chain.usefiles) ? 3 : 1;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, nAutoComp, &iChainNext)))
         return lRC;
      if (btest) return 0;

      // on which level should directory size summaries be highlighted?
      if (glblFileSet.numberOfRootDirs() < 2)
         cs.stathilitelevel = 1; // on 0 (rootdir) and 1 (first below)
      // else >= 2 roots exist, highlight only on that level

      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);

      if (cs.flatdirstat) {
         lFiles = cs.flatfilecnt;
         lDirs  = cs.flatdircnt;
         nBytes = cs.flatbytecnt;
      }

      int lMBytes = (int)(nBytes / 1000000);

      if (!cs.quiet && bSummary) {
         // chained mode: no dir stats, just add filesizes.
         setTextColor(nGlblHeadColor);
         switch (cs.listunit) {
            case 'b':
               printf("%s, %5d files, %d dirs, %s bytes.\n", numtoa_blank(nBytes, 12), lFiles, lDirs, numtoa(nBytes));
               break;
            case 'k':
               printf("%s kb, %5d files, %d dirs, %s bytes.\n", numtoa_blank(nBytes/1000, 10), lFiles, lDirs, numtoa(nBytes));
               break;
            default :
               printf("%5d mb, %5d files, %d dirs, %s bytes.\n", lMBytes, lFiles, lDirs, numtoa(nBytes));
               break;
         }
         setTextColor(-1);
         if (cs.noFiles)
            printf("%u non-regular files skipped.\n", cs.noFiles);
      }

      // chaining: collected text lines
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   regtest("find -norec -text -lnum -nocol xdir xpat1 xpat2");
   regtest("grep -c -names -quiet -pat xpat1 -dir xdir1 xdir2 -file .dat");
   regtest("list xdir +find mypat");
   regtest("list xdir +find -pat mypat");

   bool bIsFText  = 0;

   ifcmd (   !strcmp(pszCmd, "find") || !strcmp(pszCmd, "grep")   // +chaining
          || !strcmp(pszCmd, "ftext")
         )
   {
      bIsFText = strcmp(pszCmd, "ftext") ? 0 : 1;

      ifhelp (nparm < 1)
      if (bIsFText)
      printx("<help>$sfk ftext [opts] singledir word [word2] [word3] ... [-names]\n"
             "\n"
             "   case-insensitive text search for text files only.\n");
      else
      printx("<help>$sfk find [opts] singledir word [word2] [word3] ... [-names]\n"
             "\n"
             "   case-insensitive text search for text and binary files.\n");
      printx("   if multiple words are given then only areas containing\n"
             "   all words are listed. sfk find tries to autodetect if a file\n"
             "   is text or binary, adapting the output text formatting.\n"
             "\n"
             "   $options\n");
      arcinf(7); // find
      printx("      -bin       do not autodetect file content, process all as binary.\n"
             "                 can also be used for floating text files (one linefeed per\n"
             "                 paragraph, not per line). may produce unwanted line breaks\n"
             "                 with short-lined text.\n"
             "      -len=n     increase the line length for text extracted from binary\n"
             "                 to find longer strings. maximum is 600 approx.\n"
             "      -wide      same as -len=300\n"
         //  "      -nojoin    do not auto join records extracted from binary\n"
         //  "                 if result hits are spread across them\n"
             "      -delim=.,; set delimiters to enable soft word wrapping.\n"
             "                 default is to soft wrap only on white space.\n"
         //  "      -noind     with binary data: no not indentate output text.\n"
         //  "      -rtrim[=n] trim results after right side hit, and optionally\n"
         //  "                 keep n characters after that.\n"
             #ifdef _WIN32
             "      -hidden    include hidden and system files.\n"
             #endif
             "      -c         case-sensitive search (not default).\n"
             "      -lnum      list line numbers of hits.\n"
             "      -nocol     disable color highlighting of output (sfk help colors).\n"
             "      -names     list only names of files containing at least one hit.\n"
             "      -count     list no. of matching lines per file. implies -names.\n"
             "                 requires -text option, cannot be used with binary files.\n"
             "      -quiet     do not show \"scan\" progress info.\n"
             "      -pure      do not list filenames, list only text hits without indent.\n"
             "                 default when specifying a single file as first parameter.\n"
             "      -verbose   tells in detail what find is actually searching for.\n"
             #ifdef _WIN32
             "      -nocconv   disable umlaut and accent character conversions during\n"
             "                 output to console. \"sfk help opt\" for details.\n"
             #endif
             "      -firsthit  show only first matching result per file.\n"
             "      -justrc    print nothing to terminal, just set return code.\n"
             );
      printx("\n"
             "   $search limitations within binary data\n"
             "      by default, only lines up to 80 characters are extracted\n"
             "      from binary data, so strings longer than this may not be found.\n"
             "      this can be changed by option -len=n or -wide.\n"
             );
      printx("\n"
             "   $pattern support\n"
             "      no wildcards or slash patterns are supported, with one exception:\n"
             "      if you need to find patterns starting with \"-\" or \"+\", prefix\n"
             "      them with backslash \\ to avoid misinterpretation as options.\n"
             "\n"
             "   $return codes for batch files\n"
             "      0 = no matches, 1 = matches found, >1 = major error occurred.\n"
             "      see also \"sfk help opt\" on how to influence error processing.\n"
             "\n");
      if (!bIsFText)
      printx("   $aliases\n"
             "      #sfk ftext<def>    same as sfk find but reads only text files.\n"
             "\n");
      printSearchReplaceCommands();
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk find . foo bar include\n"
             "         search all files in current dir for the words foo+bar+include.\n"
             "         note that the short form syntax supports one directory name,\n"
             "         and any number of text patterns, but no file name patterns.\n"
             "\n"
             "      #sfk find -pat text1 text2 -dir src1 src2 -file .cpp .hpp\n"
             "         searches within the specified directories and file masks.\n"
             "\n");
      if (!bIsFText)
      printx("      #sfk find -wide -pat http:// .html -dir mydir -file .dat\n"
             "         #+filter -rep \"_*http://_http://_\" -rep \"_.html*_.html_\"\n"
             "         find all http://*.hml references in binary .dat files,\n"
             "         using -wide to find links beyond 80 characters,\n"
             "         then reduce the output to just the link text.\n"
             "\n");
      printx("      #sfk list src +find -verbose \\-pat \\\\-foo \\+list\n" 
             "         find lines containing words \"-pat\", \"\\-foo\" and \"+list\"\n"
             "         in all files of directory src, with verbose search infos.\n"
             #ifdef _WIN32
             "\n"
             "      #sfk find testfiles class +view\n"
             "         search \"class\" within \"testfiles\", and show results\n"
             "         interactively in Depeche View (\"sfk view\" for details).\n"
             #endif
             );
      ehelp;

      bGlblAllowGeneralPure  = 1;
      bGlblBinGrep           = 1;
      bGlblBinGrepAutoDetect = 1;
      bGlblShortSyntax       = 0;

      bool bGotFileDir  = 0;
      bool bcolpat      = 0;  // collecting patterns
      bool bcolpat2     = 0;  // dummy

      // alias presets
      if (!strcmp(pszCmd, "ftext")) {
         bGlblBinGrep = 0;
         bGlblBinGrepAutoDetect = 0;
      }

      #ifdef VFILEBASE
      cs.precachezip = 1;
      #endif // VFILEBASE

      // only enable colorful scan status if console is available
      if (!bGlblConsColumnsSet)
         cs.quiet = true;

      // since 1703: always join extracted records from binary
      cs.joinlines = 1;
      // and set binary wrap as twice of console width, by default 160.
      cs.wrapbincol = autoCalcWrapColumns() * 2;

      int iDirNext=0;

      for (; iDir < argc; iDir++) 
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (!bcolpat2 && haveParmOption(argv, argc, iDir, "-delim", &pszParm)) {
            if (!pszParm) return 9;
            cs.delim = pszParm;
            continue;
         }
         else
         if (    !bcolpat2 
             && (   haveParmOption(argv, argc, iDir, "-len", &pszParm)
                 || haveParmOption(argv, argc, iDir, "-length", &pszParm)
                )
            )
         {
            if (!pszParm) return 9;
            int iWrap = atoi(pszParm);
            if (iWrap < 40) return 9+perr("specify 80 or higher for -len");
            cs.wrapbincol = iWrap * 2;
            continue;
         }
         else
         if (!bcolpat2 && strBegins(argv[iDir], "-rtrim=")) {
            cs.rtrim = atoi(argv[iDir]+7)+1;
            continue;
         }
         else
         if (!bcolpat2 && !strcmp(argv[iDir], "-rtrim")) {
            cs.rtrim = 1;
            continue;
         }
         else
         if (!bcolpat2 && !strcmp(argv[iDir], "-wide")) {
            cs.wrapbincol = 300 * 2;
         }
         else
         if (!bcolpat2 && !strcmp(argv[iDir], "-text")) {
            bGlblBinGrep = 0;
            bGlblBinGrepAutoDetect = 0;
         }
         else
         if (!bcolpat2 && !strncmp(argv[iDir], "-bin", 4)) {
            bGlblBinGrep = 1;
            bGlblBinGrepAutoDetect = 0;
         }
         else
         if (!bcolpat2 && !strcmp(argv[iDir], "-lnum"))
            bGlblGrepLineNum = 1;
         else
         if (!bcolpat2 && !strcmp(argv[iDir], "-nojoin"))
            cs.joinlines = 0;
         else
         if (!bcolpat2 && !strcmp(argv[iDir], "-c"))
            cs.usecase = 1;
         else
         if (!bcolpat2 && !strcmp(argv[iDir], "-count")) {
            if (bGlblBinGrep || bGlblBinGrepAutoDetect) {
               perr("-count cannot be used only with text file search");
               pinf("say -text -count instead of -count\n");
               return 9;
            }
            cs.useJustNames    = 1;
            cs.countMatchLines = 1;
         }
         else
         if (!bcolpat2 && !strcmp(argv[iDir], "-to")) {
            perr("-to is not supported with find.");
            return 9;
         }
         else
         if (!bcolpat2 && !strcmp(argv[iDir], "-tofile")) {
            perr("-tofile is not supported with find.");
            #if defined(SFKXDXE)
            pinf("you may use +tofile or try xfind.\n");
            #else
            pinf("you may use +tofile instead.\n");
            #endif
            return 9;
         }
         else
         if (!bcolpat2 && setGeneralOption(argv, argc, iDir))
            continue;
         else
         if (!bcolpat2 && !strncmp(argv[iDir], "-", 1))
            break; // process int -dir form
         else
         if (!bcolpat && !chain.usefiles && !bGotFileDir) {
            // single dir or file specified.
            bGotFileDir = 1;
            Coi ocoi(argv[iDir], 0);
            if (ocoi.isTravelDir()) {
                if ((lRC = setProcessSingleDir(argv[iDir])))
                   return lRC;
            } else {
                if (!fileExists(argv[iDir]))
                    return 9+perr("no such file or dir: %s\n", argv[iDir]);
                glblSFL.addEntry(ocoi); // is copied
                cs.pure = 1;
            }
            bGlblShortSyntax = 1;
            bcolpat = 1;
            // is -pat following immediately?
            if ((iDir < argc-1) && !strcmp(argv[iDir+1], "-pat"))
               iDir++; // then skip this
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iDirNext)) {
            break; // fall thru, let pdp set iDirNext
         }
         else {
            // search pattern specified.
            bcolpat = 1;
            char *psz = argv[iDir];
            if (psz[0] == '+') {
               perr("unknown chain command: %s\n", psz);
               pinf("to search for this word, say \\%s\n", psz);
               return 9;
            }
            if (!strncmp(psz, "\\\\", 2) || !strncmp(psz, "\\+", 2) || !strncmp(psz, "\\-", 2))
               psz++;
            glblGrepPat.addString(psz);
            // see also: processDirParms, which may also add to glblGrepPat.
         }
      }
      
      if (cs.justrc) {
         cs.nonames = 1;
      }

      if (iDir < argc) {
         if (!bGotFileDir && !iDirNext)
            if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext)))
               return lRC;
      } else {
         if (!chain.usefiles && !bGotFileDir)
            return 9+perr("please specify a directory or file name.\n");
      }

      if (cs.verbose) {
         printf("[searching lines with");
         int nGrepPat = glblGrepPat.numberOfEntries();
         for (int i=0; i<nGrepPat; i++) {
            char *pszPat = glblGrepPat.getString(i);
            if (i==0)
               printf(" \"%s\"", pszPat);
            else
               printf(" AND \"%s\"", pszPat);
         }
         printf("]\n");
      }
      if (!glblGrepPat.numberOfEntries())
         return 9+perr("no search patterns specified.\n");
      if (btest) return 0;

      if (chain.colany())
         cs.quiet = 1;

      lRC = walkAllTrees(eFunc_Find, lFiles, lDirs, nBytes);
      if (!lRC && cs.anymatches) lRC = 1; // found a match
      info.clear(); // in case nothing was found

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "home"))
   {
      ifhelp (    (iDir < argc) 
               && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?"))
             )
      printx("<help>$sfk home\n"
             "\n"
             "   tells the location of the SFK Home folder\n"
             "   for configuration and data storage.\n"
             );
      ehelp;

      printf("%s\n", sfkhome.szClDir);

      bDone = 1;
   }

   ifcmd (   strBegins(pszCmd, "iname")
          || strBegins(pszCmd, "gname")
          || strBegins(pszCmd, "lname")
          || !strcmp(pszCmd, "x")
          || !strcmp(pszCmd, "x2")
         )
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk iname[2] word [word2] [<not>exclude] [.ext]\n"
             "\n"
             "   find filenames as fast as possible by using\n"
             "   index files created by $sfk lindex<def> or $gindex<def>.\n"
             "\n"
             "   $sfk iname word [word2] [word3] [...]\n"
             "     will use local index files $zz-index.txt\n"
             "        - in the current folder\n"
             "        - in the parent folder\n"
             "        - and so on, until the root folder \"<sla>\"\n"
             "     and also the global Base Index file from\n"
             "     %s\n"
             "     and then lists all file names from those indexes\n"
             "     having the given words in their name or path.\n"
             "\n"
             , sfkhome.szClDir
             );
      printx("   $sfk iname2 word [word2] [word3] [...]\n"
             "     does the same as iname, but also includes\n"
             "     the global Extended Index file.\n"
             "\n"
             "   $sfk gname<def> uses only the global index.\n"
             "   $sfk lname<def> uses only local index files.\n"
             "\n"
             "   $pattern syntax\n"
             "    - just type up to 10 words that must be contained\n"
             "      somehere in the file name or it's path. the words\n"
             "      are AND combined. the sequence is ignored.\n"
             #ifdef _WIN32
             "    - words starting with ! or : will exclude any file\n"
             #else
             "    - words starting with <not> will exclude any file\n"
             #endif
             "      having the word in it's name.\n"
             "    - words starting with \".\" are a file extension and\n"
             "      must appear only at the END of a file name, or be\n"
             "      followed in the filename by another \".\"\n"
             "      like \".so\" in foobar.so.1.2.3\n"
             "\n"
             "   $options\n"
             "      -size     include size info in result\n"
             "      -size=n   pad size info to n characters\n"
             "      -tab      create tab separated output\n"
             "\n"
             "   $output sorting\n"
             "      output is always sorted by $file modification time<def>,\n"
             "      listing the $most recent files<def> at the list bottom.\n"
             "\n"
             "   $chaining support\n"
             "      output chaining is supported.\n"
             "\n"
             );
      printx("   $aliases\n"
             "      #sfk x<def>  is the same as $sfk iname<def>\n"
             "      #sfk x2<def> is the same as $sfk iname2<def>\n"
             "\n"
             );
      printx("   $see also\n"
             "      #sfk gindex<def>   - create global index file(s)\n"
             "      #sfk lindex<def>   - create local  index file(s)\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk iname .pdf\n"
             "         lists all PDF files in the Base Index.\n"
             "      #sfk iname part 2391 datasheet .pdf\n"
             "         lists all PDF files in the Base Index having\n"
             "         the words \"part\", \"2391\" and \"datasheet\"\n"
             "         somewhere in their name, for example:\n"
             "            C:\\documentation\\datasheets\\parts\\2391.pdf\n"
             "            C:\\server2391beta\\subparts\\datasheet.pdf\n"
          // "      #sfk x part 2391 datasheet .pdf\n"
          // "         the same as above, but faster to type.\n"
             "      #sfk iname2 part 2391 datasheet .pdf\n"
             "         the same, but may list further results also\n"
             "         from the extended index, for example:\n"
             "            Z:\\public\\docs\\part-2391\\datasheet-03.pdf.old\n"
             );
      printx("      #sfk iname .hpp +find class tree\n"
             "         search all .hpp header files from the index\n"
             "         for the words \"class\" and \"tree\".\n"
             "      #sfk iname tree .hpp +fview\n"
             "         load and view all .hpp files having \"tree\"\n"
             "         in their name or path. (\"sfk view\" for more)\n"
             );
      ehelp;

      bool bExt = 0;
      if (strstr(pszCmd, "name2"))  bExt = 1;
      if (!strcmp(pszCmd, "x2"))    bExt = 1;

      int iStartState=1;
      int iMaxState=3;
      if (strstr(pszCmd, "gname"))  iStartState = 2;
      if (strstr(pszCmd, "lname"))  iMaxState = 2;

      int  iMaxPat=10;
      char aIncPat[10+2][100]; mclear(aIncPat);
      char aExPat[10+2][100];  mclear(aExPat);
      char aExt[10+2][100];    mclear(aExt);
      int iIncPat=0,iExPat=0,iExt=0;
      bool bKeepTabs=0;
      int iOutMask=1+2; // name is always included
      int idig=12;
      char *pszIdxFile1=0, *pszIdxFile2=0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            pszIdxFile1 = pszParm;
            continue;
         }
         else
         if (strBegins(pszArg, "-tab")) {
            bKeepTabs = 1;
            continue;
         }
         else
         if (strBegins(pszArg, "-size=")) {
            iOutMask += 4;
            idig = atoi(pszArg+6);
            continue;
         }
         else
         if (strBegins(pszArg, "-size")) {
            iOutMask += 4;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:
         if (pszArg[0] == '!' || pszArg[0] == glblNotChar)
            { strcopy(aExPat[iExPat], pszArg+1); glblNoCase.setStringToLower(aExPat[iExPat]); iExPat++; }
         else
         if (pszArg[0] == '.')
            { strcopy(aExt[iExt]    , pszArg  ); glblNoCase.setStringToLower(aExt[iExt])    ; iExt++; }
         else
            { strcopy(aIncPat[iIncPat], pszArg); glblNoCase.setStringToLower(aIncPat[iIncPat]); iIncPat++; }

         if (iExPat  >= iMaxPat) return 9+perr("too many %c exclusion patterns\n", pszArg[0]);
         if (iExt    >= iMaxPat) return 9+perr("too many file types\n");
         if (iIncPat >= iMaxPat) return 9+perr("too many patterns\n");
      }
      
      if (!iIncPat && !iExt)
         return 9+perr("missing parameters for x\n");

      StringMap oResults;

      num nStartTime = getCurrentTime();
      int iHits = 0;

      char szPathBuf1[SFK_MAX_PATH+10];
      char szPathBuf2[SFK_MAX_PATH+10];
      char szHeadBuf[1024+100];

      char aInFile[10][SFK_MAX_PATH+10];
      num  aMaxOff[10];
      int  nInFiles=0;
      num  nCurOff=0;
      mclear(aInFile);
      mclear(aMaxOff);

      int bIsDir=0,b2=0,b3=0;
      num nFileSize=0,nFileTime=0;

      // pass 1
      num nTotalSize = 0;
      
      // pass 2
      char *pIndexOrg = 0;
      num nReadCursor = 0;

      // pass 0 finds all base     indexes with their size.
      // pass 1 finds all extended indexes with their size.
      // pass 2 loads all base     indexes.
      // pass 3 loads all extended indexes.
      for (int ipass=0; ipass<4; ipass++)
      {
         if (ipass == 2)
            if (!(pIndexOrg = new char[nTotalSize+100]))
               return 9+perr("out of memory");

         bool bExtPass = (ipass & 1) ? 1 : 0;

         if (bExt == 0 && bExtPass == 1)
            continue;

         if (!getcwd(szPathBuf1,sizeof(szPathBuf1)-10))
            return 9+perr("cannot get work dir.");

         int iState = iStartState;

         while (iState<iMaxState)
         {
            int iLen = strlen(szPathBuf1);
            if (iState==1) {
               const char *psla = (iLen > 0 && szPathBuf1[iLen-1] != glblPathChar) ? glblPathStr : "";
               snprintf(szPathBuf2, sizeof(szPathBuf2)-10,
                  "%s%szz-index%s.txt", szPathBuf1, psla, bExtPass ? "-ext" : "");
            } else if (iState==2) {
               sprintf(szPathBuf1, "data%szz-index%s.txt", glblPathStr, bExtPass ? "-ext" : "");
               char *psz = sfkhome.getPath(szPathBuf1);
               if (!psz) break;
               strcopy(szPathBuf2, psz);
            }

            // check if current filename exists
            if (getFileStat(szPathBuf2, bIsDir,b2,b3, nFileTime,nFileSize))
            {
               if (cs.verbose!=0 && ipass<2)
                  pinf("[nopre] noidx: %s\n", szPathBuf2);
            }
            else
            do
            {
               if (bIsDir)
                  break;
                  
               // check for valid index format
               int iHeadLen = 0;

               // read header
               {
                  FILE *fin = fopen(szPathBuf2, "rb");
                  if (!fin) break;
                  mclear(szHeadBuf);
                  myfread((uchar*)szHeadBuf, sizeof(szHeadBuf)-100, fin);
                  fclose(fin);
                  iHeadLen = validIndexFormat(szHeadBuf, szPathBuf2);
                  if (iHeadLen <= 0)
                     break;
               }

               // found a valid input file
               if (ipass < 2)
               {
                  // remember path and memory offset
                  strcopy(aInFile[nInFiles], szPathBuf2);
                  reduceToPath(aInFile[nInFiles]);
                  aMaxOff[nInFiles] = nCurOff+nFileSize;
                  nCurOff += nFileSize;
                  nInFiles++;

                  // count only sizes
                  nTotalSize += nFileSize;
                  break;
               }

               pinf("[nopre] using: %s\n", szPathBuf2);

               // load/append index
               {
                  FILE *fin = fopen(szPathBuf2, "rb");
                  if (!fin) return 9+perr("cannot open: %s\n", szPathBuf2);
                  myfread((uchar*)pIndexOrg+nReadCursor, nFileSize, fin);
                  fclose(fin);
                  memset(pIndexOrg+nReadCursor, ' ', iHeadLen);
                  nReadCursor += nFileSize;
               }
            }
            while (0);

            if (iState==1) {
               // step to next higher directory
               // /home/
               int iLen = strlen(szPathBuf1);
               int iOldLen = iLen;
               if (iLen > 1 && szPathBuf1[iLen-1] == glblPathChar) {
                  szPathBuf1[iLen-1] = '\0'; // safety
                  iLen--;
               }
               while (iLen > 0 && szPathBuf1[iLen-1] != glblPathChar) {
                  szPathBuf1[iLen-1] = '\0';
                  iLen--;
               }
               // F: or /
               if (iLen == iOldLen || !strchr(szPathBuf1, glblPathChar))
                  iState++;
            } else {
               iState++;
            }
         }  // endwhile state
      }  // endfor pass

      // plausi check: search end marker (in tolerance area)
      strcpy(pIndexOrg+nTotalSize, ":sfk-internal-memory-end-marker:");
      char *psz = strstr(pIndexOrg, ":sfk-internal-memory-end-marker:");
      if (!psz) {
         delete [] pIndexOrg;
         return 9+perr("index data check failed, files may contain zero bytes.");
      }
      pIndexOrg[nTotalSize] = '\0';

      CharAutoDel odel1(pIndexOrg);

      char *pIndexFlat = strdup(pIndexOrg);
      if (!pIndexFlat)
         return 9+perr("out of memory\n");

      CharAutoDel odel2(pIndexFlat);

      glblNoCase.setStringToLower(pIndexFlat);

      char *pszCur = pIndexFlat;
      char *pszMax = pIndexFlat + nTotalSize; // nFileSize1 + nFileSize2;
      while (pszCur < pszMax && *pszCur != 0)
      {
         char *pszRaw = strstr(pszCur, aIncPat[0]);
         if (!pszRaw)
            break;
         char *pszRow = pszRaw;
         while (pszRow > pIndexFlat && pszRow[-1] != '\0' && pszRow[-1] != '\n')
            pszRow--;
         char *pszEnd = pszRaw;
         while (*pszEnd != 0 && *pszEnd != '\r' && *pszEnd != '\n')
            pszEnd++;

         if (*pszEnd == '\r') *pszEnd++ = '\0';
         if (*pszEnd == '\n') *pszEnd++ = '\0';

         // mark primary hit in attribs
         int iRowLen = (int)strlen(pszRow);
         bool buseattr = (iRowLen < MAX_LINE_LEN) ? 1 : 0;
         if (buseattr) 
         {
            memset(szAttrBuf, ' ', iRowLen);
            szAttrBuf[iRowLen] = '\0';
            memset(szAttrBuf+(pszRaw-pszRow), 'g', strlen(aIncPat[0]));
         }

         // now check record for all patterns
         do
         {
            bool bskip=0,bkeep=0;

            // AND further inclusion patterns
            for (int i=1; i<iIncPat; i++) {
               char *phit = strstr(pszRow, aIncPat[i]);
               if (!phit)
                  { bskip=1; break; }
               if (buseattr)
                  memset(szAttrBuf+(phit-pszRow), 'g', strlen(aIncPat[i]));
            }
            if (bskip)
               break;

            // ANY of file extension patterns
            if (iExt==0)
               bkeep=1;
            for (int i=0; i<iExt; i++) {
               char *pext = strstr(pszRow, aExt[i]);
               if (!pext)
                  continue;
               int ilen = strlen(aExt[i]);
               // accept .so and .so.3
               if (pext[ilen]==0 || pext[ilen]=='.') {
                  bkeep=1; 
                  if (buseattr)
                     memset(szAttrBuf+(pext-pszRow), 'g', strlen(aExt[i]));
                  break;
               }
            }
            if (!bkeep)
               break;

            // NOT exclusion patterns
            for (int i=0; i<iExPat; i++)
               if (strstr(pszRow, aExPat[i]))
                  { bskip=1; break; }
            if (bskip)
               break;

            // THEN found a match
            iHits++;
            num nMemOff  = pszRow - pIndexFlat;
            char *pszOrg = nMemOff + pIndexOrg;

            // isolate line in original data
            int ilen = (int)strlen(pszRow);
            pszOrg[ilen] = '\0';

            // isolate result path
            char *pszResPath = strrchr(pszOrg, '\t');
            if (!pszResPath)
               return 9+perr("missing tab format in index file(s)");
            pszResPath++;

            // if it starts absolute
            if (isAbsolutePath(pszResPath))
            {
               // then take as is
               oResults.put(pszOrg, buseattr ? szAttrBuf : 0);
            }
            else
            {
               // build absolute result path

               // find InFile index
               int iInFile=0;
               for (; iInFile<nInFiles; iInFile++)
                  if (nMemOff < aMaxOff[iInFile])
                     break;
               if (iInFile >= nInFiles)
                  return 9+perr("internal #213731");
                  
               // infile : C:\\projects\\zz-index.txt
               // relname: fooproj\\file1.txt
               strcopy(szLineBuf, aInFile[iInFile]);
               reduceToPath(szLineBuf);

               char *pAbsPart = szLineBuf;
               int   iAbsPart = strlen(pAbsPart);
               char *pRelPart = pszResPath;
               int   iRelPart = strlen(pRelPart);
               int   iRelOff  = pszResPath - pszOrg;
               char *pMetaTxt = pszOrg;
               int   iMetaTxt = pszResPath - pszOrg;

               char *pLineMax = szLineBuf2 + MAX_LINE_LEN;

               do
               {
                  // 1. copy meta data part
                  int   iDst = 0;
                  if (szLineBuf2+iDst+iMetaTxt > pLineMax)
                     { pwarn("overflow.1\n"); break; }
                  memcpy(szLineBuf2+iDst, pMetaTxt , iMetaTxt);
                  memcpy(szAttrBuf2+iDst, szAttrBuf, iMetaTxt);
                  iDst += iMetaTxt;
   
                  // 2. copy absolute path part with slash
                  if (szLineBuf2+iDst+iAbsPart > pLineMax)
                     { pwarn("overflow.2\n"); break; }
                  memcpy(szLineBuf2+iDst, pAbsPart , iAbsPart);
                  memset(szAttrBuf2+iDst, ' '      , iAbsPart);
                  iDst += iAbsPart;
   
                  // 3. add relative part without slash
                  if (pRelPart[0]=='.' && pRelPart[1]==glblPathChar) {
                     pRelPart+=2;
                     iRelPart-=2;
                     iRelOff +=2;
                  }
                  else
                  if (*pRelPart == glblPathChar) {
                     pRelPart++;
                     iRelPart--;
                     iRelOff++;
                  }
                  if (szLineBuf2+iDst+iRelPart > pLineMax)
                     { pwarn("overflow.3\n"); break; }
                  if (iRelOff+iRelPart > MAX_LINE_LEN)
                     { pwarn("overflow.4\n"); break; }
                  memcpy(szLineBuf2+iDst, pRelPart, iRelPart);
                  memcpy(szAttrBuf2+iDst, szAttrBuf+iRelOff, iRelPart);
                  iDst += iRelPart;
   
                  szLineBuf2[iDst] = '\0';
                  szAttrBuf2[iDst] = '\0';
   
                  oResults.put(szLineBuf2, szAttrBuf2);
               }
               while (0);
            }
         }
         while (0);

         pszCur = pszEnd;
      }

      odel1.deleteNow();
      odel2.deleteNow();

      for (int i=0; i<oResults.size(); i++)
      {
         char *pszRow  = 0;
         char *pszAttr = 0;
         pszAttr = oResults.iget(i, &pszRow);
         if (!pszRow)
            continue;
         if (pszAttr) {
            if (iChainNext) {
               // 2004-12-21 01:42:30{TAB}12345{TAB}C:\filename.txt
               // 2004-12-21 01:42:30{TAB}12345{TAB}localdir\file1.txt
               // just take rightmost TAB column
               char *pszFile = strrchr(pszRow, '\t');
               if (!pszFile)
                  return 9+perr("index file has wrong format (not tab separated).");
               pszFile++;
               // identify absolute root part
               char szRoot[20];
               // default root: "/"
               strcpy(szRoot, glblPathStr);
               // windows root: "C:\\" etc.
               if (pszFile[1]==':' && pszFile[2]==glblPathChar) {
                  memcpy(szRoot, pszFile, 3);
                  szRoot[3] = '\0';
               }
               Coi ocoi(pszFile, szRoot);
               chain.addFile(ocoi);
            }
            else {
               if (makeINameResultLine(pszRow, pszAttr, iOutMask, bKeepTabs, idig))
                  pwarn("output overflow while processing: %s\n", pszRow);
               else
                  printColorText(szLineBuf, szAttrBuf, 1);
            }
         }
         else {
            if (makeINameResultLine(pszRow, 0, iOutMask, bKeepTabs, idig))
               pwarn("output overflow 2 while processing: %s\n", pszRow);
            else
               chain.print("%s\n", szLineBuf);
         }
      }

      int iElapsed = (int)(getCurrentTime() - nStartTime);
      if (cs.verbose)
         printf("Found %d hits. (%d msec)\n", iHits, iElapsed);

      if (iChainNext) {
         STEP_CHAIN(iChainNext, 1);
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "bin-to-src"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (argc < 5)
      printx("$sfk bin-to-src [...] infile outfile namePrefix\n"
             "\n"
             "   create sourcefile containing a binary data block. the outfile\n"
             "   will contain variable definitions beginning with namePrefix.\n"
             "\n"
             "   $options\n"
             "      -java     create java source code output, default is C.\n"
             "      -class    java: create a fully compilable class with a short\n"
             "                demo source code how to write the data to a file.\n"
             "      -pack     C source: compress data with a simple RLE scheme.\n"
             "      -hex      C source: produce hex numbers instead of decimal.\n"
             "      -append   do not overwrite output, but append to it.\n"
             "\n"
             "      -recsize=n   java: define number of bytes per record used\n"
             "                   within the raw data. default is 500. higher values\n"
             "                   produce less records, which may help if you get\n"
             "                   a \"code too large\" error during java compile.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk bin-to-src myimg.dat imgsrc.cpp img01\n"
             "         create C source code containing content from myimg.dat.\n"
             "\n"
             "      #sfk bin-to-src -java -class myimg.dat imgdata.java imgdata\n"
             "         create a Java class \"imgdata\" with myimg.dat content.\n"
            );
      ehelp;

      bool bPack  = 0;
      bool bHex   = 0;
      bool bJava  = 0;
      bool bClass = 0;
      bool bAppend= 0;
      int nrecsize = 500;

      for (; iDir < argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-recsize", &pszParm)) {
            if (!pszParm) return 9;
            nrecsize = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-pack"))
            bPack = 1;
         else
         if (!strcmp(argv[iDir], "-hex"))
            bHex  = 1;
         else
         if (!strcmp(argv[iDir], "-java"))
            bJava = 1;
         else
         if (!strcmp(argv[iDir], "-class"))
            bClass = 1;
         else
         if (!strcmp(argv[iDir], "-append"))
            bAppend = 1;
         else
         if (!setGeneralOption(argv, argc, iDir))
            break;
      }

      if (iDir+3 > argc) return 9+perr("missing parameters for bin-to-src\n");

      char *pszInFile  = argv[iDir+0];
      char *pszOutFile = argv[iDir+1];
      char *pszPrefix  = argv[iDir+2];

      num   nFileSize = 0;
      uchar *pInFile = loadBinaryFile(pszInFile, nFileSize);
      if (!pInFile) return 9+perr("cannot read %s\n", pszInFile);

      fGlblOut = fopen(pszOutFile, bAppend ? "a":"w");
      if (!fGlblOut) {
         perr("cannot write %s\n", pszOutFile);
         delete [] pInFile;
         return 9; 
      }

      if (bJava)
         lRC = execBinToJava(pInFile, (int)nFileSize, bPack, pszPrefix, bClass, nrecsize);
      else
         lRC = execBinToCpp(pInFile, (int)nFileSize, bPack, pszPrefix, bHex);

      fclose(fGlblOut);
      delete [] pInFile;

      bDone = 1;
   }

   regtest("filter -no-empty-lines -count -lnum -case ++mypat");
   regtest("filter -no-blank-lines");
   regtest("filter -cnt -c -+mypat2 -+mypat3 -rep _foo_bar_");
   #ifdef _WIN32
   regtest("filter -+foo -+!bar -ls+start -le+end -ls!nstart -le!nend");
   regtest("filter -sep \" \" -form $40col1_$-50col2 -join");
   regtest("filter -sep ; -form $col3_$col5 -wrap");
   regtest("filter x.txt -blocksep _ -form $col1 -wrap=80");
   #else
   regtest("filter -+foo -+:bar -ls+start -le+end -ls:nstart -le:nend");
   regtest("filter -sep \" \" -form \"#40col1_#-50col2\" -join");
   regtest("filter -sep ; -form \"#col3_#col5\" -wrap");
   regtest("filter x.txt -blocksep _ -form #col1 -wrap=80");
   #endif

   ifcmd (   !strncmp(pszCmd, "filt", 4) || !strncmp(pszCmd, "ffilt", 5)
          || !strncmp(pszCmd, "filefilt", 8)
         )
   {
      ifhelp (!chain.usedata && !chain.usefiles && (nparm < 1))
      printx("<help>$sfk filter [fileOrDir] -selectoption(s) -processoption(s)\n"
             "$sfk filt -selectoption(s) -processoption(s) -dir mydir -file .ext1 .ext2\n"
             "$sfk filter [-memlimit=n] -write inoutfile -replacepattern(s)\n"
             "\n"
             "   filter and change text lines, from standard input, or from file(s).\n"
             "   input lines may have a maximum length of %u characters.\n",
             (uint)(MAX_LINE_LEN-96)
             );
      printx("\n"
             "   $line selection options\n"
             "      -+pat1 -+pat2 [...]   - include lines containing pat1 OR  pat2\n"
             "      ++pat1 ++pat2 [...]   - include lines containing pat1 AND pat2\n"
             "      -ls+pat1              - include lines starting with pat1\n"
             "      -le+pat1 -le+pat2     - include lines ending   with pat1 OR pat2\n"
             "\n"
             "      -<not>pat1 -<not>pat2         - exclude lines containing pat1 OR  pat2\n"
             "      -ls<not>pat1              - exclude lines starting with pat1\n"
             "      -le<not>pat1 -le<not>pat2     - exclude lines ending with pat1 or pat2\n"
             "      -no-empty-lines       - exclude empty lines\n"
             "      -no-blank-lines       - exclude lines containing just whitespaces\n"
             "      -inc[lude] p1 to p2   - include only lines within blocks surrounded by\n"
             "                              boundary lines containing patterns p1 or p2\n"
             "      -inc-      p1 to p2   - same, but exclude boundary lines on output\n"
             "      -cut[-]    p1 to p2   - remove block of lines from p1 until p2\n"
             "      -inc[-]    \"*\" to p1  - include all from text start until marker\n"
             "      -cut[-]    p1 to \"*\"  - cut all from marker line until end of text\n"
             "      -nocheck     - with inc, cut: ignore block endings without a start\n"
             "      -addmark txt - with inc, cut: insert txt after every processed block\n"
             "      -context=n            - select n lines of context around hit lines\n"
             "      -precon=5:blue        - select context before or after hit lines,\n"
             "      -postcon=5:cyan:---     in blue or cyan, with separator \"---\".\n"
             "      -unique [-case]       - if same line occurs twice, keep only first.\n"
             "                              default is case insensitive text comparison.\n"
             "      -global-unique        - when filtering multiple files in one command,\n"
             "         then -unique applies to lines in the same file, and -global-unique\n"
             "         applies across all files. this will cache the text of all files in\n"
             "         memory and may not be used with very large files.\n"
             "      -keep pattern         - after -unique: make an exception for lines\n"
             "         containing the given pattern, and keep them even if redundant.\n"
             "      -keep-empty, -keep-blank - always keep empty or whitespace lines.\n"
             "\n");
      printx("   $text processing options\n"
             "      applied <err>after<def> line selection options only.\n"
             "      -rep[lace] _src_dest_\n"
             "         replace string src by dest. first character is separator character (e.g. _).\n"
             "         src is case-insensitive. to select case-sensitive search, say -case.\n"
             "      -lsrep[lace], -lerep[lace]\n"
             "         same as -replace, but replaces only once at line start or line end.\n"
             "      -high[light] color pattern : highlight matching parts within lines.\n"
             "         color   : red = dark red, Red = bright red, green, blue,\n"
             "                   yellow, cyan, magenta, default.\n"
             "         pattern : e.g. \"GET * HTTP/\"\n"
             "         type \"sfk help colors\" for more about colors.\n"
             "      -lshigh[light], -lehigh[light]\n"
             "         same as -highlight, but only at line start or line end.\n"
             );
      printx("      -sep[arate] \"; \" -form \"<run>col1 mytext <run>[-0n.nq]col2 ...\"\n"
             "         break every line into columns separated by any character listed after -sep,\n"
             "         then reformat the text according to a user-defined mask similar to printf.\n"
             "         when leaving out -sep, the whole line is packed into column 1. if -spat was\n"
             "         specified, then -form also supports slash patterns like \\t.\n"
             "         google for \"printf syntax\" to get more details. example:\n"
             "      -form \"<run>40col1 <run>-3.5col2 <run>05qline <run>(10.10qcount+1000)\"\n"
             "         reformat column 1 as right-ordered with at least 40 chars, column 2 left-\n"
             "         ordered with at least 3 and a maximum of 5 chars, then add the input line\n"
             "         number, \"q\"uoted, right justified with 5 digits, prefixed by zeros,\n"
             "         then the output line number plus 1000 within quotes. NOTE: some examples\n"
             "         may not work in an sfk script, see section \"common errors\" below.\n"
             "         adding values so far only works with (q)line and (q)count.\n"
             "      -tabform \"<run>col1 mytext ...\"\n"
             "         split and reformat columns of tab separated csv data.\n"
         //  "      -stabform \"<run>col(start:foo)\\t<run>col(start:bar)\"\n"
         //  "         within tab separated data, take columns starting with foo and bar.\n"
             #ifdef _WIN32
             "      -uform \"##40col1 ##-3.5col2 ##05qline\"\n"
             "         the same as -form but using unix style syntax. short for filter -upat.\n"
             #endif
             );
      printx("      -trim  removes blanks and tab characters at line start and end.\n"
             "             use -ltrim or -rtrim to trim line start or end only.\n");
      printx("      -blocksep \" \" = treat blocks of whitespace as single whitespace separator.\n"
             "      -join[lines] join output lines, do not print linefeeds.\n"
             "      -wrap[=n]    wrap output lines near console width [or at column n].\n"
             "                   set SFK_CONFIG=columns:n to define or override the console width.\n"
             "      -toiso[=c]   or just -iso converts UTF-8 text to ISO-8859-1. some chars beyond\n"
             "                   the 8 bit code range will be reduced to something similar, but\n"
             "                   most of them are changed to a dot '.', or character c.\n"
             "      -toutf       converts ISO-8859-1 text to UTF-8. if this is done with UTF-8\n"
             "                   input text then existing UTF-8 sequences will be destroyed!\n"
          // "      -toutfsafe   in mixed ISO/UFT-8 text: keep all valid UTF-8 sequences and\n"
          // "                   convert only remaining ISO characters to UTF-8. conversion may\n"
          // "                   not work if multiple ISO characters (accents) appear grouped.\n"
             "\n");
      printx("   $conditional text processing\n"
             "      -[ls/le]where pattern -replace | -highlight | -sep ... -form\n"
             "          replace, highlight or reformat lines matching the given pattern.\n"
             "          all lines that do not match the pattern stay unchanged.\n"
             "      -within pattern -replace _from_to_\n"
             "          replace text in a part of the line matching the given pattern.\n"
             "          the rest of the line text stays unchanged.\n"
             "\n");
      printx("   $pattern support\n"
             "      wildcards * and ? are active by default. add -lit[eral] to disable.\n"
             "      slash patterns are NOT active by default. add -spat to use \\t \\q etc.\n"
             "      if you need the wildcard * but ALSO want to find/replace '*' characters:\n"
             "      add -spat, then specify \\\\* or \\? to find/replace '*' or '?' characters.\n"
             "      instead of typing \"sfk filter -spat -rep\" all the time, you may use the\n"
             "      short form \"sfk filt -srep\". the same applies for -(s)sep, -(s)form etc.\n"
             #ifndef _WIN32
             "      Linux users: add quotes \"\" around everything that contains * or ?,\n"
             "      otherwise it will be misinterpreted by the linux command shell.\n"
             #endif
             "\n"
             "   $unified syntax\n"
             "      since sfk 1.5.4 you can also use -: -ls: -le: under windows.\n"
             "      filter ... -uform or filter -upat ... -form uses ## instead of $$.\n"
             "\n"
             "   $further options\n");
      arcinf(12); // filt
      printx("      -verbose        show names of all files which are currently scanned.\n"
             "      -write          do not print output to console but overwrite input file(s).\n"
             "                      only files with actual text changes will be rewritten.\n"
             "                      this function may be used only with plain ASCII files, not with\n"
             "                      binaries like .doc, .xls. see also \"sfk replace\".\n"
             "      -write -to msk  do not overwrite input files, but save according to mask msk,\n"
             "                      e.g. tmp<sla><run>file . saves only changed files. say -writeall\n"
             "                      to write all files, including those without changes.\n"
             "      -memlimit=mb    when using -write, output is cached in memory, which is limited\n"
             "                      to 300 mb. use this option to extend, e.g. -memlimit=400\n"
             "      -yes            -write simulates by default. add -yes to really write changes.\n"
             "      -snap           detect snapfiles and list subfile names having text matches.\n"
             "      -snapwithnames  same as -snap, but include subfile names in filtering.\n"
             "      -nofile[names]  do not list filenames, do not indent text lines.\n"
             "      -count, -cnt    preceed all result lines by output line counter\n"
             "      -lnum           preceed all result lines by input  line number\n"
             "      -case           compare case-sensitive (not default)\n"
             "      -lit[eral]      treat wildcards * and ? as normal chars (read more above).\n"
             #ifdef _WIN32
             "      -hidden         include hidden and system files.\n"
             #endif
          // "      -bin[ary]       process also files that look like binaries (replacing\n"
          // "                      characters with code 0x00 and 0x1A by '.')\n"
             "      -noinfo         do not warn on line selection combined with -write.\n"
             "      -noop \\\"        no operation, take the \\\" parameter but do nothing.\n"
             "                      may help if your (windows) shell miscounts quotations.\n"
             "      -hitfiles       if another command follows (e.g. +run or +ffilter),\n"
             "                      pass a list of files containing at least one hit.\n"
             #ifdef _WIN32
             "      -nocconv        disable umlaut and accent character conversions during\n"
             "                      output to console. \"sfk help opt\" for details.\n"
             #endif
             "      -justrc         print no output, just set return code on matching lines.\n"
             "\n"
             );
      printx("   $list of possible input sources\n"
             "      from stdin                : type x.txt | sfk filter -+pattern\n"
             "      from single input file    : sfk filter x.txt -+pattern\n"
             "      text from chained command : sfk list mydir .txt +filter -+pattern\n"
             "      from many files, directly : sfk filter -+pattern -dir mydir -file .txt\n"
             "      from many files, by chain : sfk list mydir .txt +filefilter -+pattern\n"
             "      in general, whenever you need to make sure that file contents (not the\n"
             "      file names) are processed, prefer to say \"filefilter\" or \"ffilt\".\n"
             "\n"
             "   $return codes for batch files\n"
             "      0   normal execution, no matching lines found.\n"
             "      1   normal execution,    matching lines found.\n"
             "          with -write: returns rc 1 only if any changes were written.\n"
             "     >1   major error occurred. see \"sfk help opt\" for error handling options.\n"
             );
      printx("\n"
             "   $common errors\n"
             "      when using filter -form within sfk scripts, expressions like <run>10.10col1\n"
             "      may collide with script parameters <run>1 <run>2 <run>3. to solve this, use brackets\n"
             "      like <run>(10.10col1), or \"sfk label ... -prefix=%%\", or -uform.\n"
             "\n");
      printSearchReplaceCommands();
      printBewareWide();
      webref(pszCmd);
      printx("   $examples\n"
             "      #anyprog | sfk filter -+error: -<not>warning\n"
             "         run command anyprog, filter output for error messages, remove warning messages.\n"
             "      #sfk filter result.txt -rep \"_\\_/_\" -rep \"xC:/xD:/x\"\n"
             "         read result.txt, turn all \\ slashes into /, and C:/ expressions to D:/\n"
             "         the quotes \"\" are optional here, and just added for safety.\n"
             "      #sfk filter index.html -rep \"_<u>_<b>_\" -rep \"_</u>_</b>_\" -write\n"
             "         replace underlining by bold in an HTML text. quotes \"\" are strictly\n"
             "         required here, otherwise the shell environment would split the command\n"
             "         at the < and > characters. add option -yes to really rewrite the file.\n"
             "      #sfk filter export.csv -sep \";\" -format \"title: <run>-40col2 remark: <run>-60col5\"\n"
             "         reformat comma-separated data, exported from spreadsheet, as ascii text.\n"
             "      #sfk stat . +filter -blocksep \" \" -format \"<run>4col1 mb in folder: <run>col5\"\n"
             "         reformats output of the stat command.\n"

             "      #sfk filter mycsv.txt >out.txt -spat -rep _\\\"__ -rep _\\t__ -rep \"_;_\\\"\\t\\\"_\" -form \"<run>qcol1\"\n"
             "         read semicolon-separated spreadsheet data mycsv, strip all double colons\n"
             "         and tab characters from data fields. replace field separator \";\" by TAB,\n"
             "         and surround all fields by double colon. -form without -sep means \"pack the whole\n"
             "         line into <run>col1\", allowing -form to add quotes at start and end of each line.\n"

             "      #sfk filter logs\\access.log \"-+GET * 404\"\n"
             "         list all lines from access.log containing a phrase with GET and 404.\n"

             "      #sfk filter log.txt \"-ls<not>??.??.???? ??:??:?? * *\"\n"
             "         excludes lines from log.txt starting with a date, and having two more words,\n"
             "         like \"20.05.2007 07:23:09 org.whatever.server main\"\n"
             );
      printx("      #%s | sfk run -idirs \"sfk filt tpl.conf >httpd.conf -rep _AbsWorkDir_<run>path_\"\n"
             "         create httpd.conf from tpl.conf, replacing the word \"AbsWorkDir\" by the path\n"
             "         from which the command is run. note we can NOT use -spat in this case, otherwise\n"
             "         a pathname like C:\\temp would produce garbage (contains slash pattern \"\\t\").\n"
             #ifdef _WIN32
             , "cd"
             #else
             , "pwd"
             #endif
             );
      printx("      #sfk filter in.txt -spat -sep \"\\t\" -rep _\\q__ -form \"INSERT INTO MYDOCS (DOC_ID,\n"
             "         #DESCRIPTION) VALUES ('TestDoc<run>03line','<run>col2');\"\n"
             "         this example (typed in one line) creates a list of SQL statements, using tab-\n"
             "         separated, quoted input data, and using the input line number for document ids.\n"
             "         the -rep _\\q__ means the same as -rep _\\\"__ - it strips quotes from the input,\n"
             "         but using \\q is safer then \\\" as it doesn't let the shell miscount quotes.\n"
             );
      printx("      #sfk list documents .txt +filter -+big*foo -+wide*foo\n"
             "         from all .txt files in documents, filter the filenames (NOT the file contents)\n"
             "         for big*foo OR wide*foo.\n"
             );
      printx("      #sfk list documents .txt +filefilter -+big*foo -+wide*foo\n"
             "         from all .txt files in documents, filter the file contents (NOT the names)\n"
             "         for text lines containing big*foo OR wide*foo.\n"
             );
      printx("      #sfk list logfiles .txt +filefilter -global-unique +tofile mixedlog.txt\n"
             "         join all .txt files from logfiles into one output file mixedlog.txt,\n"
             "         dropping all redundant text lines. works only if logfile records are\n"
             "         prefixed by a unique record ID, and if overall text data is less than\n"
             "         available memory, because all data is cached during processing.\n"
             "      #sfk list logfiles .txt +ffilter -global-unique -write -to mytmp<sla><run>file\n"
             "      #sfk snapto=mixedlog.txt mytmp\n"
             "         same as above in two commands, using temporary files to allow more data.\n"
             );
             #ifdef _WIN32
      printx("      #bin\\runserver.bat 2>&1 | sfk filter -+exception\n"
             "         filter standard output AND error stream (\"2>\") for exceptions\n"
             "      #sfk filter result.txt -+error -justrc\n"
             "      #IF %%ERRORLEVEL%%==1 GOTO foundError\n"
             "         in a batchfile: jump to label foundError if text \"error\" was found\n"
             "         within file result.txt. with -justrc no output is printed to terminal.\n"
             );
             #else
      printx("      #./runserver.sh 2>&1 | sfk filter -+exception\n"
             "         filter standard output AND error stream (\"2>\") for exceptions\n"
             "      #sfk filter result.txt -+error -justrc\n"
             "      #iReturnCode=$$?\n"
             "      #if [ $$iReturnCode -eq 1 ]; then\n"
             "         echo \"error occured.\"\n"
             "      #fi\n"
             "         in a bash script: tells if text \"error\" was found within result.txt.\n"
             "         due to option -justrc no output is printed to terminal.\n"
             );
             #endif
      printx("      #sfk filt log.txt -high cyan \"*.*.*(*.java:*)\" -high green \"sql select *\"\n"
             "         dump log.txt, listing java stack traces in cyan, and sql selects in green.\n"
             );
      printx("      #sfk filt x.html -where \"000099\" -rep \"_<font*000099*>_<b>_\" -rep \"_</font>_</b>_\"\n"
             "         replaces html <font> commands by <b>, but only in lines with \"000099\" (=blue).\n"
             );
      printx("      #sfk filt foo.cpp -cut \"ifdef barmode\" to \"endif // barmode\"\n"
             "         strip blocks of lines from foo.cpp, surrounded by the given patterns.\n"
             );
      #ifdef _WIN32
      printx("      #sfk fromclip +filt -srep \"_\\\\_\\\\\\\\_\" -srep \"_\\q_\\\\\\q_\" -sform \"\\q$$col1\\\\n\\q\"\n"
             "         convert text from clipboard to source code, e.g. change\n"
             "            #the \"tab character\" is written like \\t\n"
             "         to a C++ or Java string literal like\n"
             "            #\"the \\\"tab character\\\" is written like \\\\t\\n\"\n");
      #endif
      printx("      #sfk filt csv.txt -spat -within \"\\q*\\q\" -rep _,_\\x01_ -rep _,_\\t_ -rep _\\x01_,_\n"
             "         change separators in comma separated data from comma to tab, also taking\n"
             "         care of quotes, by replacing in-quote commas by a placeholder (\\x01).\n"
             "         if the data contains escaped quotes like \"\" then further prefiltering\n"
             "         can be necessary, like removing those quotes by -sreplace _\\q\\q__\n"
             );
      #ifdef _WIN32
      printx("      #sfk filt mysrc.cpp \"-+fopen(\" -postcontext=3:blue:----- +view\n"
             "         filter source file \"mysrc.cpp\" for fopen calls, and list the following\n"
             "         three lines (post context) of every call, separating outputs by -----\n"
             "         and showing the whole result in Depeche View (\"sfk view\" for more).\n"
             );
      #endif
      ehelp;

      CommandScope ocmd("Filter");

      memset(&gfilter, 0, sizeof(gfilter));
      gfilter.argv    = argv;
      gfilter.iPat    = iDir;
      gfilter.nPat    = argc - iDir; // MAX estimation, must be reduced on chaining
      gfilter.bDumpLF = 1;
      gfilter.bSkipBinaries = 1; // always, this is a text-only filter.
      gfilter.bFilenames = 1;
      gfilter.cprecolor  = ' ';
      gfilter.cpostcolor = ' ';

      #ifdef VFILEBASE
      cs.precachezip = 1;
      #endif // VFILEBASE

      char *pszInPath = 0;

      // if we're a chain receiver
      bool bOldUseFiles = chain.usefiles;
      bool bWalkDirs    = chain.colfiles | chain.usefiles;
      if (chain.usedata) {
         cs.quiet = 1; // no filename listings
      }

      // set options, check syntax
      int iDirNew   = 0;
      int iChainNew = 0;
      if (setFilterParms(
         argv, argc, gfilter.iPat, gfilter.nPat,
         gfilter,
         &pszInPath, &iDirNew, &iChainNew
         ))
         return 9;

      // if -test mode, init test stats
      if (cs.test)
         mclear(ftest);

      // logical autocomplete of options:
      // saying -lnum or -count AND -write always means to write ALL files.
      if ((gfilter.bLNum || gfilter.bCnt) && gfilter.bReWrite)
         cs.writeall = 1;

      // plausbility
      if (gfilter.bReWrite && cs.justrc)
         return 9+perr("-justrc and -write cannot be combined.");

      bool bsid = 0;
      if (pszInPath) {
         // single input file or directory specified?
         bWalkDirs = 1;
         Coi ocoi(pszInPath, 0);
         if ((bsid = ocoi.isTravelDir())) {
            setProcessSingleDir(pszInPath);
            // gfilter.bSkipBinaries = 1;
         } else {
            if (!cs.usesnap)
               gfilter.bSingleFile = 1;
            glblSFL.addEntry(ocoi); // is copied
         }
      }

      int nInputs = 0;
      if (pszInPath)    nInputs++;
      if (iDirNew > 0)  nInputs++;
      if (bOldUseFiles) nInputs++;

      if (nInputs > 1) {
         perr("filter cannot process input files from multiple sources.\n");
         int nsrc = 1;
         setTextColor(nGlblWarnColor);
         if (bOldUseFiles) {
            printf("info : source %d are filenames from previous command.\n", nsrc++);
            printf("tip  : try to select all files within the previous command.\n");
         }
         if (pszInPath)   printf("info : source %d is input %s \"%s\"\n", nsrc++, bsid?"directory":"file", pszInPath);
         if (iDirNew > 0) printf("info : source %d is directory or file parameter \"%s\"\n", nsrc++, argv[iDirNew]);
         setTextColor(-1);
         return 9;
      }

      // if any dir parms found
      if (iDirNew)
      {
         iDir = iDirNew ? iDirNew : iChainNew;
         // gfilter.bSkipBinaries = 1;
         if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iChainNew))) return lRC;
         bWalkDirs = 1;
      }
 
      // snapfile parse does not allow rewrite
      if (cs.usesnap && gfilter.bReWrite)
         return 9+perr("options -snap and -rewrite not allowed together.");

      if (btest) return 0;

      // if collecting filenames for another chained command
      if (chain.colfiles) {
         cs.quiet = 1;
         char *pszChainCmd = iChainNew ? argv[iChainNew] : (char*)"";
         if (!strcmp(pszChainCmd, "+copy")) {
            // copy follows: insist on true input filenames
            gfilter.bPassHitFiles = 1;
         }
      }

      if (bWalkDirs)
      {
         // used in most cases:
         if (gfilter.bReWrite) {
            cs.sim = !cs.yes;
            if (cs.sim && !cs.nohead)
               printx("$[simulating:]\n");
         }
         if (!gfilter.bPassHitFiles && chain.colfiles) {
            // the next chain step (e.g. run) wants us to collect filenames.
            // but we are processing a single input file,
            // therefore auto-reconfig:
            chain.colfiles    = 0;
            chain.coldata     = 1;  // collect text now
            chain.text2files  = 1;  // but let it autoconvert
         }
         lRC = walkAllTrees(eFunc_Filter, lFiles, lDirs, nBytes);
         if (cs.sim && !cs.nohead)
            printx("$[add -yes to really write changes.]\n");
         if (!lRC) lRC = gfilter.nTotalRC;   // info if any matches found
      }
      else 
      {
         // processing stdin or chain data:
         if (gfilter.bReWrite) {
            perr("-write cannot be used this way, as it needs filenames.\n");
            pinf("maybe you want to use filefilter (ffilt) instead of filter?\n");
            return 9;
         }
         if (chain.colfiles) {
            // the next chain step (e.g. run) wants us to collect filenames.
            // but we are processing an input text stream.
            // therefore auto-reconfig:
            chain.colfiles    = 0;
            chain.coldata     = 1;  // collect text now
            chain.text2files  = 1;  // but let it autoconvert
         }
         if (!cs.usesnap)
            gfilter.bSingleFile = 1; // don't dump filename
         if (cs.debug) {
            if (chain.usedata)
               printf("[filter reads from chain data]\n");
            else
               printf("[filter reads from stdin (no chain data)]\n");
         }
         lRC = execFilter(0, stdin, chain.usedata ? chain.indata : 0);
         if (!lRC) lRC = gfilter.nTotalRC;   // info if any matches found
      }

      info.clear(); // for -verbose output

      if (!cs.quiet && cs.binariesSkipped)
         printx("<time>%d binary files skipped%s.<def>\n", cs.binariesSkipped, cs.verbose?"":" (-verbose for more)");

      // command cleanup:
      glblFilterDups.reset(); // after last file

      // analyze -test results
      if (cs.test) {
         lRC = 0;
         for (int i=0; i<FILT_MAXTESTMASKS; i++) {
            // if (ftest.apPosMasks[i])
            //    printf("%d: pos %s %d\n",i,ftest.apPosMasks[i],ftest.anPosHits[i]);
            if (ftest.apPosMasks[i] && !ftest.anPosHits[i]) {  
               // a required phrase was not found
               printx("<err>miss :<def> %s\n", ftest.apPosMasks[i]);
               lRC = 10;
            }
            if (ftest.apNegMasks[i] &&  ftest.anNegHits[i]) {
               // an error phrase was found
               printx("<err>fail :<def> %s\n", ftest.apNegMasks[i]);
               lRC = 11;
            }
         }
      }

      int iDirNext = iChainNew;
      STEP_CHAIN(iDirNext, 1);
 
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "addhead"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("$sfk addhead <in >out [-noblank] string1 string2 ...\n"
             "\n"
             "   insert string(s) at the start of text lines.\n"
             "\n"
             "   $options\n"
             "      -noblank    does not add blank chars between added strings.\n"
             "\n"
             "   $see also\n"
             "      #sfk filter infile.txt -form \"string1<run>col1\"\n"
             "         does the same and is more flexible.\n"
            );
      ehelp;

      bool bblank=1;
      if (!strcmp(argv[iDir], "-noblank") && argc >= 4)
         { bblank=0; iDir++; }

      int nMaxLineLen = sizeof(szLineBuf)-10;
      while (fgets(szLineBuf, nMaxLineLen, stdin))
      {
         removeCRLF(szLineBuf);
         // left: collect all parameters to add as head
         szLineBuf2[0] = '\0';
         for (int i1=iDir; i1<argc; i1++) {
            strcat(szLineBuf2, argv[i1]);
            if (!bblank && (i1 == argc-1))
               continue;
            strcat(szLineBuf2, " "); 
         }
         // add middle
         strcat(szLineBuf2, szLineBuf);
         // no right side
         printf("%s\n", szLineBuf2);
      }
      fflush(stdout);
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "addtail"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("$sfk addtail <in >out [-noblank] string1 string2 ...\n"
             "\n"
             "   add string(s) at the end of text lines.\n"
             "\n"
             "   $options\n"
             "      -noblank    does not add blank chars between added strings.\n"
             "\n"
             "   $see also\n"
             "      #sfk filter infile.txt -form \"<run>col1string1\"\n"
             "         does the same and is more flexible.\n"
            );
      ehelp;

      bool bblank=1;
      if (!strcmp(argv[iDir], "-noblank") && argc >= 4)
         { bblank=0; iDir++; }

      int nMaxLineLen = sizeof(szLineBuf)-10;
      while (fgets(szLineBuf, nMaxLineLen, stdin))
      {
         removeCRLF(szLineBuf);
         // right: collect all parameters
         for (int i1=iDir; i1<argc; i1++) {
            if (!bblank && (i1 == iDir))
               { }
            else
               strcat(szLineBuf, " "); 
            strcat(szLineBuf, argv[i1]);
         }
         printf("%s\n", szLineBuf);
      }
      fflush(stdout);
      bDone = 1;
   }

   #ifndef NO_ZIP_LIST
   // internal, to test zip/jar listing via central dir
   if (!strcmp(pszCmd, "ziplist"))
   {
      if (checkArgCnt(argc, 3)) return 9;

      FileList oFiles;
      getZipList(argv[2], oFiles);

      int nFiles = oFiles.clNames.numberOfEntries();
      for (int i=0; i<nFiles; i++) 
      {
         char *psz = oFiles.clNames.getEntry(i, __LINE__);
         num nSize = oFiles.clSizes.getEntry(i, __LINE__);
         num nTime = oFiles.clTimes.getEntry(i, __LINE__);
         printf("%s %s %s\n", timeAsString(nTime), numtoa(nSize,10), psz);
      }
      bDone = 1;
   }
   #endif

   // internal, to test zip listing as stream
   if (!strcmp(pszCmd, "ziplist2"))
   {
      if (checkArgCnt(argc, 3)) return 9;

      SFKMD5 md5;
      FileList oFiles;
      getZipMD5(argv[2], md5, oFiles, 1);

      int nFiles = oFiles.clNames.numberOfEntries();
      for (int i=0; i<nFiles; i++) 
      {
         char *psz = oFiles.clNames.getEntry(i, __LINE__);
         num nSize = oFiles.clSizes.getEntry(i, __LINE__);
         num nTime = oFiles.clTimes.getEntry(i, __LINE__);
         printf("%s %s %s\n", timeAsString(nTime), numtoa(nSize,10), psz);
      }
      bDone = 1;
   }

   #ifndef USE_SFK_BASE
   ifcmd (!strcmp(pszCmd, "patch"))
   {
      ifhelp (nparm < 1)
      printx(
          "<help>$sfk patch [-revoke|-redo] yourpatchfile.cpp [-sim|-verify]\n"
          "\n"
          "   search text blocks in file(s) and replace them by other text blocks,\n"
          "   including backup creation and optional restore of original files.\n"
          "\n"
          "   -revoke: undo all patches, by replacing the modified targets\n"
          "            by the backup files which sfk stores in save_patch.\n"
          "            the target files are touched afterwards (date/time update)\n"
          "            to enforce proper recompile. use -keep-dates to avoid this.\n"
          "   -redo  : undo all patches and then re-apply patches.\n"
          "            best used whenever you change the patchfile itself,\n"
          "            to have your changes updated in the target files.\n"
          "   -exact-match: by default, leading whitespaces are ignored.\n"
          "                 use this option enforce exact 1:1 line matching.\n"
          "   -keep-dates: by default, revoked files get touched. use this option\n"
          "                to enforce original file dates (yet windows only).\n"
          "   -sim     : simulate what the patch would do, don't change anything.\n"
          "   -qs      : quick summary, just tell a one-line status.\n"
          "   -stats   : show statistics of select-replace usage.\n"
          "   -verify  : check if an applied patch is still intact.\n"
          "   -nopid   : apply irrevocable patch without [patch-id].\n"
          "   -anyroot : ignore the :root dir entry in a patch file.\n"
          "\n"
         );
      printx(
         "   $patchfile rules:\n"
         "   - patches are executed exactly in the order as given in the patchfile.\n"
         "   - each :from/:to statement is executed exactly once.\n"
         "   - if ANY of the :from/:to statements doesn't match the input,\n"
         "     the whole file is NOT patched.\n"
         "   - the first :to block for a new target file must contain the word [patch-id],\n"
         "     by using a comment in the target file's syntax, e.g. in C++: // [patch-id].\n"
         "     this marks the file as being patched -> sfk will not patch it again.\n"
         "\n"
         "   it is recommended that your patchfiles have the ending .cpp (or .java etc.)\n"
         "   to enable syntax highlighting with your favourite text editor.\n"
         "\n"
         );
      printx("   #sfk patch -example\n"
             "      shows a detailed patchfile example.\n"
             "   #sfk patch -template\n"
             "      gives a simple, empty patchfile template.\n"
             );
      ehelp;

      #ifdef SFK_MEMTRACE
      bGlblNoMemCheck = 1;
      sfkmem_nocheck();
      #endif // SFK_MEMTRACE

      lRC = patchMain(argc-1, argv, 1);

      bDone = 1;
   }
   #endif // USE_SFK_BASE

   ifcmd (!strcmp(pszCmd, "if"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk ... +if expression command1 ... +command2\n"
             "\n"
             "   execute command1 if expression is true, then continue to command2.\n"
             "   if expression is not true, skip directly to command2.\n"
             "   can be used only in a command chain, after another command.\n"
             "\n"
             "   $supported expressions\n"
             "      rc=n   return code of previous command equal  to   n\n" 
             "      rc>n   return code of previous command higher than n\n"
             "      rc<n   return code of previous command lower  than n\n"
             "\n"
             "   $see also\n"
             "      sfk call labelname - call sub functions in a script.\n"
             "\n"
             "   $examples\n"
             "      #sfk filter in.txt -+err +if \"rc>0\" run -yes \"x.bat\" +echo done\n"
             "         if file in.txt contains the word \"err\", run x.bat.\n"
             "         the \"echo done\" is always executed.\n"
            );
      ehelp;

      int iChainNext = 0;
      char *pexpr    = 0;
      int iThenCmd   = 0;

      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pexpr)
            { pexpr = argv[iDir]; continue; }
         if (!iThenCmd)
            { iThenCmd = iDir; continue; }
         // ignore all other parms as they probably belong
         // to the thenCmd.
      }

      if (!pexpr)    return 9+perr("need an expression after if.");
      if (!iThenCmd) return 9+perr("need a command after \"if expression\".");

      // evaluate expression
      bool btrue = 0;
      if (strBegins(pexpr, "rc=")) {
         int ncmp = atol(pexpr+3);
         btrue = (lRC == ncmp) ? 1 : 0;
      }
      else
      if (strBegins(pexpr, "rc<")) {
         int ncmp = atol(pexpr+3);
         btrue = (lRC < ncmp) ? 1 : 0;
      }
      else
      if (strBegins(pexpr, "rc>")) {
         int ncmp = atol(pexpr+3);
         btrue = (lRC > ncmp) ? 1 : 0;
      }
      else
         return 9+perr("unsupported expression: %s\n", pexpr);

      if (btrue)
         iChainNext = iThenCmd;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "call"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk ... +call label [parm1 parm2 ...]\n"
             "\n"
             "   call a sub function in the current script,\n"
             "   starting at the given label.\n"
             "\n"
             "   $see also\n"
             "      type \"sfk tail\" for a script example.\n"
            );
      ehelp;

      char *pszLabel     = 0;

      int  iChainNext =  0;
      int  iLocalParm = -1;
      int  nLocalParm =  0;
      int  nState     =  0;
      bool bliteral   =  0;

      for (; iDir<argc; iDir++)
      {
         if (nState < 1 && !strncmp(argv[iDir], "-", 1)) {
            // general options are interpreted only before script name,
            // i.e. as int as nState == 0.
            if (strBegins(argv[iDir], "-lit")) {
               bliteral = 1;
               continue;
            }
            else
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (!bliteral && isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszLabel) {
            pszLabel = argv[iDir];
            nState = 1;
         }
         else
         if (iLocalParm < 0) {
            iLocalParm = iDir;
            nLocalParm = 1;
            nState = 2;
         }
         else
            nLocalParm++;
      }

      if (!pGlblCurrentScript)
         return 9+perr("cannot use call outside a script.");

      // pGlbl is the original script data we're running within.
      // make a copy as this will be stuffed with terminators.
      char *pScript = strdup(pGlblCurrentScript);

      // this copy must then be auto deleted.
      CharAutoDel odel(pScript);

      lRC = 0;

      // create temporary argv[] from script file
      StringTable oDynaStrings;
      char **psubargv = 0;
      int    nsubargc = 0;
      for (int npass=0; npass<2; npass++)
      {
         char *psz1 = pScript;
         char  cold = 0; // old char before current one

         // jump to start label, if any.
         if (pszLabel) {
            sprintf(szLineBuf, "label %s", pszLabel);
            psz1 = strstr(pScript, szLineBuf);
            if (!psz1) {
               perr("label not found: %s\n", pszLabel);
               pinf("use \"sfk label %s +...\" to start with a label.\n", pszLabel);
               pinf("use \"sfk ... +label %s +...\" to insert a label.\n", pszLabel);
               lRC = 9;
               break;
            }
            // do NOT skip anything, let the chain
            // start with the "label" command.
            cold = '\0';
         }

         // main processing, until +end token.
         while (*psz1)
         {
            bool bnewline = 0;
            nextToken(&psz1, cold, bnewline);
            if (*psz1)
            {
               // on next (non-blank) token
               char *ptok = psz1;
               if (bnewline && !strncmp(ptok, "//", 2)) {
                  // skip remark line
                  while (*ptok && *ptok != '\n') ptok++;
                  // do NOT skip lf, set newline on next cycle
                  psz1 = ptok;
                  continue;
               }

               // find end of token
               skipPastToken(&psz1, cold);
               int ntoklen = psz1 ? (psz1-ptok) : 0;

               int nrc = 0;
               if (npass && *psz1) {
                  cold = *psz1;   // e.g. lf will be overwritten
                  *psz1++ = '\0';
                  // post-process token: strip quotes, transform inner quotes,
                  // substitute parameters.
                  // uses: szLineBuf
                  nrc = postProcessToken(&ptok, oDynaStrings, argc, argv, iLocalParm, nLocalParm);
                  if (nrc >= 9) return 9+perr("unexpected format: \"%s\"\n", ptok);
                  // nrc==1 means skip EMPTY token.
               }

               // special first token "-prefix=..." ?
               // printf("tok %d: \"%s\"\n",nsubargc,ptok);
               if (!nrc && nsubargc<3 && strBegins(ptok, "-prefix=")) {
                  // give script input parameters a user-defined name
                  if (npass) { // not in prescan phase
                     strcopy(cs.paramprefix, ptok+8);
                  }
                  continue;
               }

               // count and register token
               if (!nrc) {
                  if (npass)
                     psubargv[nsubargc] = ptok;
                  nsubargc++;
               }

               // reached "+end"?
               if (ntoklen==4 && !strncmp(ptok, "+end", 4))
                  break;

            }  // endif *psz1

         }  // endwhile *psz1

         // at end of first pass, alloc token array
         if (!npass) {
            psubargv = new char*[nsubargc+10];
            nsubargc = 0;
         }

      }  // endfor pass

      if (cs.verbose > 0) {
         printf("loaded %d words from global script:\n", nsubargc);
         for (int i=0; i<nsubargc; i++)
            printf("%s,",psubargv[i]);
         printf("\n");
      }

      if (!lRC)
      {
         char *pszSubCmd = psubargv[0];
         int iSubDir = 1;
         // if chain starts like "sfk ...", skip "sfk":
         if (!strcmp(pszSubCmd, "sfk")) {
            pszSubCmd = psubargv[1];
            iSubDir = 2;
         }
         if (cs.verbose > 0)
            printf("  run from \"%s\" (index %d)\n", pszSubCmd, iSubDir);
         lRC = submain(nsubargc, psubargv, penv, pszSubCmd, iSubDir, bFatal);
      }

      if (psubargv) delete [] psubargv;
      oDynaStrings.resetEntries();

      // pScript is auto deleted.

      if (lRC >= 9) return lRC;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   regtest("run echo_$purefile xdir .cpp .hpp");
   regtest("list xdir +run echo_$pfile");

   ifcmd (!strcmp(pszCmd, "run"))
   {
      ifhelp (!chain.usefiles && !chain.usedata && (nparm < 1))
      printx("<help>$sfk run \"your command <run>file [<run>relfile] [...]\" [-yes] [-nohead] [-quiet] [...]\n"
             "\n"
             "   run a self-defined command on every file- or directory name.\n"
             "   within your command string, you may specify:\n"
             "\n"
             "      $<run>file<def>                     - insert full filename, including path.\n"
             "      $<run>quotfile<def>    or $<run>qfile<def>    - just as <run>file, but with quotes \"\" around.\n"
             "      $<run>relfile<def>     or $<run>qrelfile<def> - insert relative filename, without path.\n"
             "      $<run>base<def>        or $<run>qbase<def>    - the relative base filename, without extension.\n"
             "      $<run>ext<def>         or $<run>qext<def>     - filename extension. foo.bar.txt has extension .txt.\n"
             "      $<run>path<def>        or $<run>qpath<def>    - the path (directory) without filename.\n"
             "      $<run>since<def>       or $<run>qsince<def>   - with option -sincediff: the reference file name.\n"
             "      $<run>text<def>        or $<run>qtext<def>    - one record of input text, similar to <run>file.\n"
             "\n"
             "      always prefer 'q' forms over non-quoted forms: as soon as there is a filename\n"
             "      containing blanks, e.g. X:\\the src files\\test one.txt, you will need quotations,\n"
             "      or you have to manually insert \\\" or \\q escaped quotes (see 3rd example below).\n"
             "      you may also use <run>quotrelfile, <run>quotsince, <run>quottext for greater clarity.\n"
             "      if you supply only <run>path expressions, only directories will be processed.\n"
             "      on single word chain commands like \"+run vi\", \" <run>qfile\" is added automatically.\n"
             "\n"
             "   $further pattern support:\n"
             "      -spat       activates slash patterns like \\t \\q \\xnn etc.\n"
             "\n"
             "   $options\n"
             "      -yes        really execute. default is just to simulate what would be done.\n"
             "      -nohead     does not display the [simulating:] info text.\n"
             "      -noinfo     unless you use <run>text, sfk checks the input filenames\n"
             "                  1. if they contain blanks, but no quotes are given within command.\n"
             "                  2. if they seem to use the wrong path separator character.\n"
             "                  in both cases, a reminder is printed. if you know that your command\n"
             "                  needs no changes, add -noinfo or use <run>text instead of <run>file.\n"
             "      -quiet      does not echo the commands before execution.\n"
             "      -relnames   strips the root directory names from filenames.\n"
             "      -i[files]   process a text or filename list from stdin.\n"
             "      -idirs      process a directory name list from stdin.\n"
             "                  on stdin, '##' remark lines and empty lines are skipped. note:\n"
             "                  \"sfk.exe <list.txt\" supports only 4 KB for list.txt under windows.\n"
             "                  \"type list.txt | sfk.exe\" supports unlimited stream length.\n"
             "      -nofile[names]   with chaining, does not create \":file \" name records.\n"
             "      -printcmd   print the full command which is executed to console.\n"
             "      -stoprc=n   stop processing if a command returns return code >= n.\n"
             "\n");
      printx("   $command string format\n"
             "      with option -spat, slashpatterns like \\t \\q \\xnn are supported.\n"
             "      due to syntax limitations of the command shell, it may help\n"
             "      - to use \\q instead of \\\"   (avoids quote miscounting at shell)\n"
             "      - to use \\x26 instead of &  (if ampersand is behaving unexpected)\n"
             "\n"
             );
      printx("   $temporary or permanent output files\n"
             "      if run output is post-processed by $command chaining<def>, e.g. run ... +filter,\n"
             "      sfk creates temporary files to collect the output. by default, these files\n"
             "      are deleted when run finishes. say \"sfk help options\" for more on this.\n"
             "      specify $-to targetdir<sla><run>file<def> to write command output into a permanent\n"
             "      target fileset. required directories are created automatically.\n"
             "      -to accepts the same mask as run itself, e.g. -to \"mydir<sla><run>path<sla><run>base.tmp\"\n"
             "      by default, standard output AND standard error stream are written to file.\n"
             "      add $2>nul<def> to your command to strip the error stream.\n"
             "\n");
      printx("   $command chaining notes\n"
             "      sfk run \"...<run>path...\" +nextcmd: will pass directories, not filenames.\n"
             "      sfk run ... -to tmp<sla><run>file +nextcmd: will pass output filenames, not input.\n"
             "      sfk run ... +run: will pass unchanged input filename list.\n"
             "\n");
      printx("   $see also\n"
             "      sfk runloop - run commands using a loop counter.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk run \"attrib -R <run>qfile\" -quiet testfiles\\FooBank\\BarDriver -yes\n"
             "         removes readonly attribute on all files within BarDriver\n"
             "      #sfk run \"<img src=<run>quottext>\" -dir . -file .jpg -nohead >index.html\n"
             "         create html-style image list of all jpegs (using just simulation).\n"
             "         note that option -nohead removes the [simulating:] info text lines.\n"
             "      #type dirlist.txt | sfk run -idirs \"xcopy \\\"x:<sla><run>path\\\" \\\"z:<sla><run>path\\\" /I /D\" -yes\n"
             "         update-copy all directories from dirlist.txt from x: to z:\n"
             "      #sfk run \"diff oldsrc<sla><run>file newsrc<sla><run>file\" -relnames -sincediff oldsrc newsrc\n"
             "         compare directories, run \"diff\" on all files with different content.\n"
             "      #sfk run \"diff <run>qsince <run>qfile\" -sincediff oldsrc newsrc\n"
             "         same as above, only shorter and safer (including quotes around filenames).\n"
             "      #sfk run \"zip update.zip <run>qfile\" -since 20070131 . .java .jsp\n"
             "         collect .java and .jsp files added/changed since 31-Jan-2007 into a zip file.\n"
             "      #sfk list testfiles .txt +run vi\n"
             "         open all .txt files in vi. <run>qfile is added automatically.\n"
             "      #sfk sel . .avi +run \"ffmpeg -i <run>file -f image -t .02 thumbs<sla><run>base-%%d.jpg\"\n"
             "         extract first image from all .avi movies, videos using ffmpeg.\n"
             "      #sfk sel -since 30m . .cpp .hpp +run -printcmd \"rm <run>path/<run>base.o\" -yes\n"
             "         delete all object files of source codes changed in the last 30 minutes\n"
             "\n"
             "   Don't try to execute a full run statement in ONE GO. Almost certainly, something\n"
             "   will go wrong (wrong files selected, syntax error in the command itself), and you\n"
             "   end up with many wrong output files. Instead, use THREE STEPS:\n"
             "   \n"
             "   $1. find the correct file set, by some trial and error:\n"
             "         #sfk run \"echo <run>quotfile\" mydir\n"
             "      This will simply show all filenames from \"mydir\". no command is executed\n"
             "      on those files, so nothing bad is happening. almost certainly, you notice\n"
             "      that too many files are included. Maybe you have to add \"-nosub\" to exclude\n"
             "      subfolders, or add more details about your file selection, like:\n"
             "         #sfk run \"echo <run>quotfile\" mydir .jpg .jpeg\n"
             "      which reduces the file set to just .jpg and .jpeg files within \"mydir\".\n"
             "   \n"
             "   $2. Replace \"echo\" by the actual command, still running in simulation mode.\n"
             "         #sfk run \"copy <run>quotfile \\\"d:\\pic\\small_<run>base.jpg\\\"\" mydir .jpg .jpeg\n"
             "      This simulates a copy of all images from mydir to d:\\pic, prefixing their name\n"
             "      by \"small_\", and ensuring that all target file extensions are only \".jpg\".\n"
             "   \n"
             "   $3. When you're satisfied with the simulation output, add \"-yes\".\n"
             "\n"
             );
      ehelp;

      bool bAnyToken  = 0;
      int  iChainNext = 0;

      for (; iDir < argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-stoprc", &pszParm)) {
            if (!pszParm) return 9;
            cs.stoprc = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-i")) {
            bGlblStdInAny   = 1;
            bGlblStdInFiles = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-printcmd")) {
            cs.printcmd = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-ifiles")) {
            if (bGlblStdInDirs) return 9+perr("cannot use -ifiles and -idirs together.\n");
            bGlblStdInFiles = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-idirs"))  {
            if (bGlblStdInFiles) return 9+perr("cannot use -ifiles and -idirs together.\n");
            bGlblStdInDirs = 1;
            cs.justdirs  = 1;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-int")) {
            cs.intrun = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!cs.runCmd[0])
         {
            cs.runCmd  = argv[iDir];
            if (strchr(cs.runCmd, '#')) bAnyToken = 1;
            #ifdef SFK_BOTH_RUNCHARS
            if (strchr(cs.runCmd, '$')) bAnyToken = 1;
            #endif
            // special command: echo WITHOUT any valid token
            if (!strcmp(cs.runCmd, "echo")) {
               cs.runCmd = cs.justdirs ? (char*)"echo $quotpath" : (char*)"echo $quotfile";
               cs.sim = 1;
            }
            continue;
         }
         // further non-option keys:
         // short dir parms IF not reading chain
         if (chain.useany()) {
            perr("conflicting parameter: %s\n", argv[iDir]);
            pinf("run is already receiving chain input, so %s is too much.\n", argv[iDir]);
            return 9;
         }
         break; // fall through
      }
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 1, &iChainNext))) return lRC;

      if (!bAnyToken) {
         if (chain.useany()) {
            perr("detected chain input data, but no token found in run command:\n");
            setTextColor(nGlblWarnColor);
            printf("       %s\n", cs.runCmd);
            setTextColor(-1);
            pinf("you may add %cfile or some other token to the run command.\n", glblRunChar);
            pinf("to drop the chain contents, replace +run by \"+then run\".\n");
            pinf("to print them, insert \"+toterm\" or \"+tofile filename\" before +run.\n");
         // pinf("type \"sfk run\" for help. add -verbose to list the chain input on error.\n");
            if (cs.verbose) chain.dumpContents(); // not sure if this helps
            return 9;
         }
         // no token and no chain input: execute simple command once.
         cs.quiet = 1;
         cs.force = 1;
      }

      if (bGlblStdInDirs)
         if (anyFileInRunCmd(cs.runCmd)) 
            return 9+perr("-idirs only allowed with %cpath, not with file commands.\n", glblRunChar);

      if (chain.usedata)
         chain.convInDataToInFiles();

      // add $qfile implicitely if 1) single word command 2) chain input 3) no -force:
      char *pszDynaRunCmd = 0;
      if (!cs.force && !bAnyToken && chain.usefiles && !strchr(cs.runCmd, ' ')) {
         // in this case, accept trailing "." as a replacement for -yes.
         int nlen = strlen(cs.runCmd);
         if (cs.runCmd[nlen-1] == '.') { cs.yes=1; nlen--; }
         sprintf(szLineBuf, "%.*s \"%cfile\"", (int)nlen, cs.runCmd, glblRunChar);
         cs.runCmd = pszDynaRunCmd = strdup(szLineBuf);
         bAnyToken = 1;
      }
      else
      if (!bAnyToken && !cs.force) {
         if (!cs.runCmd[0])
            perr("empty run command. type \"sfk run\" for help.\n");
         else {
            perr("no valid token in run command: \"%s\". type \"sfk run\" for help.\n", cs.runCmd);
            pinf("you may also add -force to run the command without any tokens.\n");
         }
         return 9;
      }

      // NO RETURN W/O DELETE FROM HERE

      if (btest) { if (pszDynaRunCmd) delete [] pszDynaRunCmd; return 0; }

      cs.sim = !cs.yes;

      if (chain.coldata && cs.sim)
         pwarn("%s will receive no data as long as in simulation.\n", argv[iChainNext]); 

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      if (!bAnyToken) {
         // no tokens at all: run command w/o any file input
         int lFiles=0, lDirs=0; num nBytes=0;
         Coi ocoi((char*)"?", 0); // dummy
         cs.nonames = 1; // do NOT create a ":file ?" line
         lRC = execRunFile(&ocoi, 0, 0, lFiles, lDirs, nBytes); // todo: -to support
      }
      else
      if (bGlblStdInFiles || bGlblStdInDirs) {
         lRC = walkStdInListFlat(eFunc_Run, lFiles, nBytes);
      } else {
         if (!anyFileInRunCmd(cs.runCmd))
            cs.justdirs = true;
         lRC = walkAllTrees(eFunc_Run, lFiles, lDirs, nBytes);
      }

      // comment on user errors
      if (!cs.quiet && !cs.noinfo && !bGlblStdInAny) {
         if (cs.badNameForm & 1)
            pinf("%d input names contain blanks, but no quotes (or %cqfile) found.\n", cs.blankRunFiles, glblRunChar);
         if (cs.badNameForm & 2)
            pinf("%d input names seem to use %c path separator instead of %c\n", cs.wrongpcRunFiles, glblWrongPChar, glblPathChar);
      }

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      // NO RETURN W/O DELETE UNTIL HERE
      if (pszDynaRunCmd) delete [] pszDynaRunCmd;

      if (chain.coldata) {
         STEP_CHAIN(iChainNext, 1);
      } else {
         // pass a newly created filename list
         // - if we did not receive a filename list
         // - or if -to outfiles were defined
         STEP_CHAIN(iChainNext, (!chain.usefiles || cs.tomask) ? 1 : 0);
      }

      bDone = 1;
   }

   regtest("runloop 1 100 copy_xfilesrc_xfiledst$03i.dat");

   ifcmd (!strcmp(pszCmd, "runloop") || !strcmp(pszCmd, "printloop"))
   {
      ifhelp (nparm < 3)
      printx("<help>$sfk runloop ifrom ito \"your command <run>[digits]i\" [-yes] [-nohead] [-quiet]\n"
             "$sfk runloop ifrom -steps=n [-inc=i] \"your command <run>[digits]i\"\n"
             "$sfk printloop ifrom ito \"your text <run>[digits]i\"\n"
             "\n"
             "   run a self-defined command many times, or simply print text to\n"
             "   the console, with a counter starting at ifrom, running until ito,\n"
             "   or running n times if -steps=n is specified.\n"
             "\n"
             "   with runloop, execution of commands is just simulated by default,\n"
             "   so nothing happens. as soon as your command is looking well, add\n"
             "   option \"-yes\" to really execute.\n"
             "\n"
             "   $options\n"
             "      -inc=i    increment step counter by i instead of 1.\n"
             "      -spat     support slashpatterns like \\t \\q \\xnn.\n"
             "      -delay=n  wait n msec after every executed command.\n"
             "      -nohead   does not display the [simulating:] info text.\n"
             "                printloop is the same as runloop -nohead.\n"
             "      -quiet    does not echo the commands before execution.\n"
             "      -quietrc  do not print rc status message per command.\n"
             "\n"
             "   $command string format\n"
             "      the command string may contain <run>i which is replaced by the\n"
             "      loop counter, or slashpatterns if option -spat is given.\n"
             "      due to syntax limitations of the command shell, it may help\n"
             "      - to use \\q instead of \\\"   (avoids quote miscounting at shell)\n"
             "      - to use \\x26 instead of &  (if ampersand is behaving unexpected)\n"
             "      <run>i also supports format parameters before 'i' like:\n"
             "         <run>5i    print 5 digits, right justified, filled with blanks.\n"
             "         <run>05i   print 5 digits, right justified, filled with zeros.\n"
             "         <run>-5i   print 5 digits, left  justified, filled with blanks.\n"
             "      to print the <run> char itself in output use <run><run>\n"
             "\n"
             "   $see also\n"
             "      sfk run - run self-defined command on filenames.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk runloop 1 100 \"copy mytest.dat testfile_<run>03i.dat\" -yes\n"
             "         creates 100 copies of mytest.dat named testfile_001.dat,\n"
             "         testfile_002.dat, testfile_003.dat etc.\n"
             "\n"
             "      #sfk printloop 1 100 -spat \"<a href=\\qhttp://...&page=<run>i\\q><run>i</a>\"\n"
             "         creates html code containing 100 web links. note that \\q was used\n"
             "         instead of \\\", as '&' may create problems when combined with \\\"\n"
             "         (a syntax mess produced by the command shell, not by sfk itself.)\n"
             "         and to enable slash patterns like \\q, -spat had to be added.\n"
             );
      ehelp;

      bool bisprint = !strcmp(pszCmd, "printloop");

      bool bHaveFrom=0, bHaveTo=0, bNoRC=0;
      int nfrom = 0;
      int nto   = 0;
      int ninc  = 1;
      int idelay= 0;
      char *pszRunMask = 0;
      int  iChainNext = 0;

      for (; iDir < argc; iDir++)
      {
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         if (strBegins(argv[iDir], "-steps=")) {
            if (bHaveTo) return 9+perr("too many parameters before %s",argv[iDir]);
            if (!bHaveFrom) return 9+perr("a start value must be specified before %s",argv[iDir]);
            nto = nfrom + atol(argv[iDir]+7) - 1;
            bHaveTo = 1;
            continue;
         }

         if (strBegins(argv[iDir], "-inc=")) {
            ninc = atol(argv[iDir]+5);
            if (ninc <= 0) return 9+perr("-inc value must be > 0");
            continue;
         }

         if (strBegins(argv[iDir], "-int")) {
            cs.intrun = 1;
            continue;
         }

         if (strBegins(argv[iDir], "-quietrc")) {
            bNoRC = 1;
            continue;
         }

         if (strBegins(argv[iDir], "-delay=")) {
            idelay = atol(argv[iDir]+7);
            if (idelay <= 0) return 9+perr("-delay value must be > 0");
            continue;
         }

         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unexpected option: %s\n",argv[iDir]);
         }

         // first non-option parm: from value
         if (!bHaveFrom) {
            nfrom = atol(argv[iDir]);
            bHaveFrom = 1;
            continue;
         }
         
         // 2nd non-option parm: to value
         if (!bHaveTo) {
            nto = atol(argv[iDir]);
            bHaveTo = 1;
            continue;
         }

         // 3rd: the run mask
         if (!pszRunMask) {
            pszRunMask = argv[iDir];
            continue;
         }

         return 9+perr("unexpected parameter: \"%s\" (3)\n", argv[iDir]);
      }

      // do not check for ito >= ifrom, allowing also noop cases.

      if (!bHaveFrom || !bHaveTo || !pszRunMask)
         return 9+perr("missing parameters. type \"sfk runloop\" for help.\n");

      if (btest) return 0;

      char szTokMask[20];

      cs.sim = !cs.yes;
      cs.nohead |= cs.quiet;

      // chaining plausi
      if (chain.colfiles) {
         perr("runloop cannot collect filenames, only text data.\n");
         if (iChainNext)
            pinf("try to insert +texttofilenames or +ttf before %s\n",argv[iChainNext]);
         return 9;
      }
      if (chain.colany())
         cs.nohead = 1;
      if (!cs.sim && chain.colany())
         return 9+perr("output chaining is supported only for simulation output.\n");

      if (!bisprint && cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      copyFormStr(szRunCmdBuf, MAX_LINE_LEN, pszRunMask, strlen(pszRunMask));
      pszRunMask = szRunCmdBuf;

      for (int i=nfrom; i<=nto && !userInterrupt(); i += ninc)
      {
         szLineBuf[0] = '\0';
         char *pszCur = pszRunMask;
         while (1) 
         {
            char *pszTok = strchr(pszCur, glblRunChar);
            if (!pszTok)
               break;
            // copy left part before $
            int nBufLen = strlen(szLineBuf);
            sprintf(&szLineBuf[nBufLen], "%.*s", (int)(pszTok-pszCur), pszCur);
            // special case: $$ means $
            if (pszTok[1] == glblRunChar)
            {
               nBufLen = strlen(szLineBuf);
               szLineBuf[nBufLen+0] = glblRunChar;
               szLineBuf[nBufLen+1] = '\0';
               pszCur = pszTok+2;
               continue;
            }
            // isolate token until 'i'
            char *pszTok2 = pszTok;
            while (*pszTok2 && *pszTok2 != 'i')
               pszTok2++;
            if (*pszTok2 != 'i') return 9+perr("wrong syntax, expected %ci somewhere.\n",glblRunChar);
            strcpy(szTokMask, "%d");
            int nTokExtLen = pszTok2-pszTok-1;
            if (nTokExtLen > 0)
               sprintf(szTokMask, "%%%.*sd",(int)nTokExtLen,pszTok+1);
            // use (formatted) token
            nBufLen = strlen(szLineBuf);
            sprintf(&szLineBuf[nBufLen], szTokMask, i);
            // continue with next part
            pszCur = pszTok2+1;
         }
         if (pszCur)
            strcat(szLineBuf, pszCur);

         // now holding full command in szLineBuf.
         if (!cs.quiet && !cs.sim) {
            printf("%s\n", szLineBuf);
            fflush(stdout); 
         }

         int iRC = 0;
      
         if (bisprint || cs.sim) {
            // special case: just dump resulting command to terminal
            if (chain.coldata)
               chain.addLine(szLineBuf, str(""));
            else
               printf("%s\n", szLineBuf);
         } else {
            if (cs.intrun)
               iRC = runInternal(szLineBuf);
            else
               iRC = system(szLineBuf);
         }
      
         if (!cs.quiet && !bNoRC && !cs.sim) {
            if (iRC) {
               printf("... rc %d\n", iRC);
               fflush(stdout);
            }
         }
         
         if (idelay > 0)
            doSleep(idelay);
      }

      if (!bisprint && cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      if (chain.coldata) {
         STEP_CHAIN(iChainNext, 1);
      }

      bDone = 1;
   }

   #ifdef WITH_FN_INST
   ifcmd (!strcmp(pszCmd, "inst")) // +chaining
   {
      ifhelp (   ( chain.usefiles && (nparm < 2))
              || (!chain.usefiles && (nparm < 3))
             )
      printx("<help>$sfk inst mtkinc mtkmac -dir ... -file ...\n"
             "$sfk inst -revoke[|-redo] [-keep-dates] -dir ... -file ...\n"
             "\n"
             "  instrument c++ sourcecode with calls to sfk micro tracing kernel.\n"
             "\n"
             "  $parameters:\n"
             "    mtkinc         path and name of mtktrace.hpp file\n"
             "    mtkmac         mtk block entry macro name, _mtkb_\n"
             "\n"
             "  $options:\n"
             "    -revoke        undo all changes (copy backups back).\n"
             "                   do not specify mtkinc, mtkmac on -revoke.\n"
             "    -keep-dates    on revoke, also reactivate original file dates\n"
             "    -redo          redo all changes\n"
             "    -witheol       also instrument { at end of line, like in:\n"
             "                   void Foo::bar(int nmode) {\n"
             "\n"
             "       #sfk inst mtk/mtktrace.hpp _mtkb_ -dir testfiles !save_ -file .cpp\n"
             "          instrument the code (saving all in save_inst dirs)\n"
             "\n"
             "       #sfk inst -revoke -keep-dates -dir testfiles !save_ -file .cpp\n"
             "          restore original code (copying back from save-inst dirs),\n"
             "          also restoring the original time stamps.\n"
             "\n"
             "       #sfk sel -dir base ext lib -file .cpp +inst mtk/mtktrace.hpp _mtkb_\n"
             "          select the files of interest, and when done, run +inst on them.\n"
             "\n"
             "    NOTE: is is recommended that you do NOT say \"-dir .\" in your batch files\n"
             "          to ensure that instrumenting is always done on the correct path.\n"
             "\n"
             "    read more about the sfk micro tracing kernel in the mtk/ dir.\n"
            );
      ehelp;

      #ifdef SFK_MEMTRACE
      bGlblNoMemCheck = 1;
      sfkmem_nocheck();
      #endif // SFK_MEMTRACE

      for (; (iDir < argc) && !strncmp(argv[iDir], "-", 1); iDir++)
      {
         // inst-specific prefix options
         if (!strcmp(argv[iDir], "-revoke")) {
            bGlblInstRevoke = 1;
         }
         else
         if (!strcmp(argv[iDir], "-redo")) {
            bGlblInstRevoke = 1;
            bGlblInstRedo   = 1;
         }
         else
         if (!strcmp(argv[iDir], "-keep-dates")) {
            bGlblTouchOnRevoke = 0;
         }
         else
         if (!strcmp(argv[iDir], "-witheol")) {
            bGlblInstEol   = 1;
         }
         else
         if (isDirParm(argv[iDir]))
            break; // fall through
         else
         if (!setGeneralOption(argv, argc, iDir))
            break; // other option, fall through
      }
      if (!bGlblInstRevoke || bGlblInstRedo) {
         // no revoke: expect further parms
         if (iDir >= argc-1) { fprintf(stderr, "error  : inst: missing parms. supply include and macro.\n"); return 9; }
         pszGlblInstInc = argv[iDir++];
         pszGlblInstMac = argv[iDir++];
      }
      int iDirNext=0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC;

      lRC = walkAllTrees(eFunc_Inst, lFiles, lDirs, nBytes);

      STEP_CHAIN(iDirNext, 0);

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "strings"))
   {
      // extract strings from single binary file
      ifhelp (nparm < 1)
      printx("$sfk strings [-umlauts] [-wrapbin=n] filename\n"
             "\n"
             "   extract strings from a binary file. resulting text lines are split\n"
             "   at column 80 by default, which can be changed by -wrapbin or -wrap.\n"
             #ifdef _WIN32
             "\n"
             "   $see also\n"
             "   -  #sfk hexfind<def> to search strings in files with hexdump output.\n"
             "   -  the text research tool #Depeche View<def> can also load binary files\n"
             "      and display extracted text contents. For example, #dview foo.exe<def>\n"
             "      will show strings from a single file, and #dview -allbin mydir<def>\n"
             "      loads all text and binary files from mydir. \"sfk view\" for more.\n"
             #endif
             "\n"
             "   $examples\n"
             "      #sfk strings test.exe +filter -+VersionInfo\n"
             );
      ehelp;

      char *pszFile = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszFile)
            pszFile = argv[iDir];
         else
            return 9+perr("unexpected parameter: %s", argv[iDir]);
      }

      // just for chaining:
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 0, &iChainNext))) return lRC;
 
      if (!pszFile) return 9+perr("missing filename");

      Coi ocoi(pszFile, 0);
      if (ocoi.open("rb"))
         return 9+perr("cannot read: %s\n", pszFile);

      BinTexter bt(&ocoi);
      bt.process(BinTexter::eBT_Print);

      ocoi.close();

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "pathfind") || !strcmp(pszCmd, "where"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      // find out exact location of a command in the path
      ifhelp (nparm < 1)
      printx("<help>$sfk pathfind mycmd\n"
             "$sfk where mycmd\n"
             "\n"
             #ifdef _WIN32
             "   search the current directory and the PATH for the location\n"
             "   of a command mycmd. \"where\" is the same as \"pathfind\".\n"
             "\n"
             "   if mycmd does not contain a dot '.', sfk searches for all\n"
             "   extensions listed in PATHEXT, e.g. mycmd.bat, mycmd.exe etc.\n"
             #else
             "   search the PATH for the location of a command mycmd.\n"
             #endif
            );
      ehelp;

      char *pszCmd2 = 0;

      for (; iDir < argc; iDir++) {
         if (strncmp(argv[iDir], "-", 1))
            pszCmd2 = argv[iDir];
         else
         if (!setGeneralOption(argv, argc, iDir))
            break;
      }
      if (!pszCmd2) return 9+perr("supply a command name to search within PATH.\n");

      #ifdef _WIN32
      if (!strchr(pszCmd2, '.'))
      {
         // user did NOT supply .bat etc: search for every possible extension
         int nhits = listPathAny(pszCmd2, 0); // 0: not silent
         if (!nhits) {
            if (!cs.quiet) {
               printf("nothing like %s found within PATH and current dir.\n", pszCmd2);
            }
            return 1;
         }
         // results were dumped already
         return 0;
      }
      else
      {
      #else
      {
      #endif
         char *pszAbs = findPathLocation(pszCmd2);
         if (!pszAbs) {
            if (!cs.quiet) {
               #ifdef _WIN32
               printf("%s not found within PATH and current dir.\n", pszCmd2);
               printf("... try also .exe, .bat, .cmd extensions.\n");
               #else
               printf("%s not found anywhere within PATH.\n", pszCmd2);
               #endif
            }
            return 1;
         } else {
            if (!cs.quiet) {
               printf("%s\n", pszAbs);
            }
            return 0;
         }
      }
   }

   regtest("deblank xdir .cpp .hpp");
   regtest("list xdir +deblank -dir xdir");

   ifcmd (!strcmp(pszCmd, "deblank")) // +chaining
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk deblank dirname [.ext1] [.ext2] [...]\n"
             "\n"
             "   remove blanks from filenames and directory names.\n"
             "   simulates by default. add -yes to apply changes.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "\n"
             "      #sfk deblank docs\n"
             "         lists all directories and files within docs having\n"
             "         blanks in their names, previewing changes.\n"
             "\n"
             "      #sfk select docs +deblank\n"
             "         deblanks only the names of files, not of directories.\n"
             "\n"
             "      #sfk select -withdirs docs +deblank\n"
             "         deblanks filenames and directories.\n"
            );
      ehelp;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-packalnum")) {
            cs.packalnum = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break; // fall through
      }

      // sfk deblank -yes
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 1))) return lRC;
      if (btest) return 0;

      if (!cs.yes) printx("$[simulating:]\n");
      lRC = walkAllTrees(eFunc_Deblank, lFiles, lDirs, nBytes);
      if (!cs.yes) printx("$[add -yes to execute.]\n");

      bDone = 1;
   }

   regtest("reflist -dir xdir1 xdir2");

   ifcmd (!strcmp(pszCmd, "reflist") || !strcmp(pszCmd, "deplist"))
   {
      cs.deplist = !strcmp(pszCmd, "deplist");

      ifhelp (nparm < 2) 

      // if dumping all help text, run two passes
      for (int i=0; i<2; i++) {

      if (!cs.deplist)
      printx("<help>$sfk reflist [-path] [-wide] -dir sdir -file .text -dir tdir -file .sext\n"
             "$sfk reflist -dir sourcedir -dir targetdir1 [targetdir2 targetdir3] [...]\n"
             "\n"
             "   list possible dependencies between files through (fuzzy) content analysis.\n"
             "   find out which target files are referenced by any of the source files.\n");
      else
      printx("<help>$sfk deplist [-flat] -dir srcdir [-file ...] -dir targdir [-file ...]\n"
             "$sfk deplist [-flat] singleSourceFile -dir targdir [tdir2 tdir3] [-file ...]\n"
             "\n"
             "   list possible dependencies between files through (fuzzy) string analysis.\n"
             "   find out on which target files the specified source files depend.\n");

      printx("\n"
             "   a list of target files is created from directory targdir. then all source\n"
             "   files are loaded from srcdir, and scanned if the names of the targets appear\n");

      if (!cs.deplist)
      printx("   within their content. if so, the targets are listed, with the number of\n"
             "   referring source files, and a list (of the first 10) of these files.\n"
             "\n"
             "   NOTE that sfk reflist DOES NOT GUARANTEE that files are (not) referenced.\n"
             "   This way of reference detection is just a FUZZY INDICATOR, so keep thinking\n"
             "   and make backups before you massively cleanup files without references!\n"
             "\n");
      else
      printx("   within their content. if so, the sources are listed with their dependencies.\n"
             "\n"
             "   by default, deplist also checks which targdir files depend on other targdir\n"
             "   files (recursive dependencies), resulting in more complete listings.\n"
             "   specify -flat to disable recursive checks.\n"
             "\n"
             "   if you specify just a singleSourceFile name, the source name is NOT included\n"
             "   in the output (unless -incsrc specified), and the filename list can be used\n"
             "   by subsequent (chained) commands.\n"
             "\n");

      printx("   NOTE: you may specify any number of target directories. if your list of\n"
             "   target directories is incomplete, files from there will NOT be found.\n"
             "\n");

      printx("   by default, only relative target filenames are searched, without path,\n"
             "   but including the file name extension.\n"
             "\n"
             "                  e.g. the target file: #the/path/foosys.dll\n"
             "                     runs a search for: #foosys.dll\n"
             "                   in the source files.\n"
             "\n"
             "   $options\n"
             "      -path     : search target filenames including path information.\n"
             "                  e.g. the target file: #the/path/foosys.dll\n"
             "                     runs a search for: #the/path/foosys.dll\n"
             "\n"
             "      -noext    : strip .extensions from filenames, compare only basename.\n"
             "                  e.g. the target file: #the/path/foosys.dll\n"
             "                     runs a search for: #foosys\n"
             "                  which may lead to ambiguities, listing too many hits.\n"
             "                  -noext can also be combined with -path.\n"
             "\n");

      if (!cs.deplist)
      printx("      -wide[=n] : list references in an extended format, with a list of\n"
             "                  (up to to n) source files per target file, telling in\n"
             "                  detail which text patterns were found.\n"
             "\n");
      printx("      -case     : force case sensitive string comparison (not default).\n"
             "      -quiet    : do not print the number of source and target files.\n"
             "      -relnames : if using -path, strip targdir name from target paths\n"
             "                  for comparison.\n"
             "      -flat     : do not check if target files depend on other target files.\n"
             "                  set this to improve speed, if you know that such dependen-\n"
             "                  cies cannot exist, e.g. if the targets are .wav files.\n"
             "      -memlimit=n : load and analyze only files with a size up to n mbytes.\n"
             "                    the default load limit is 300 mbytes.\n"
             "\n");
      if (!cs.deplist)
      printx("   $see also\n"
             "      sfk deplist - list file dependencies.\n");
      else
      printx("   $see also\n"
             "      sfk reflist - list file references.\n");
      printx("\n");
      webref(pszCmd);
      printx("   $examples\n");

      if (!cs.deplist)
      printx("      #sfk reflist -dir mysrcdir mytargdir\n"
             "         check every file in mytargdir if it is referenced\n"
             "         by any file within mysrcdir.\n"
             "\n"
             "      #sfk reflist -dir movie -file .ppt -dir pic -file .png\n"
             "         find out which .png files within pic are referenced\n"
             "         by .ppt files within movie.\n"
             "\n"
             "      #sfk reflist -wide=100 -dir bin -file .exe -dir bin -file .dll\n"
             "         find out which .dlls are directly referenced by .exe files\n"
             "         within directory bin, listing up to 100 references per target.\n"
             "\n"
             "      #sfk reflist -dir . -file .flp -dir . -file .wav\n"
             "         within a FruityLoops project directory lists which .wav files\n"
             "         are referenced by which .flp project files of that directory.\n"
             "\n"
             "      #sfk reflist -dir film -file .ppj -dir audio frames clips\n"
             "         tell which audio, image and movie clip files (e.g. .wav .bmp .avi)\n"
             "         are used by which Adobe Premiere project files (.ppj) within the\n"
             "         film directory. if image sequences are used, only the first image\n"
             "         of such sequences will be found, e.g. foobar00001.bmp\n"
            );
      else
      printx(
             "      #sfk deplist -dir bin -file .exe -dir lib1 lib2 lib3 -file .dll\n"
             "         create a list of all .exe files in bin, and the dlls they depend on,\n"
             "         searching for dlls in lib1, lib2 and lib3 directories.\n"
             "\n"
             "      #sfk deplist bin\\diff.exe -dir bin -file .dll +run \"copy <run>file tmp\"\n"
             "         find out which .dlls are used by diff.exe, and copy them to tmp.\n"
             "\n"
             "      #sfk deplist -relnames -case -path -noext -dir classes -dir classes\n"
             "         find dependencies between java .class files. -path uses path infos,\n"
             "         -noext strips \".class\", -case keeps the capital letters within names.\n"
             "         -relnames strips \"classes/\" from target names for comparison.\n"
             "\n"
             "      #sfk deplist -flat -dir . -file .flp -dir . -file .wav\n"
             "         within a FruityLoops project directory lists which .flp project\n"
             "         files are using which .wav files of that directory. note that\n"
             "         .wav files cannot \"use\" other .wav files, therefore -flat was set\n"
             "         to avoid recursive target checks, speeding up the search.\n"
            );

      if (bhelp) { cs.deplist = cs.deplist ? 0 : 1; printx("\n"); } else break; }
      // end of two passes if dumping all help text

      ehelp;

      bool bIncDstAsSrc  = 0;
      char *pszSingleSrc = 0;
      bool bIncSrc       = 0;
      bool bAutoMax      = 0;

      memset(abGlblRefChars, 0, sizeof(abGlblRefChars));

      if (cs.deplist) {
         bGlblRefWideInfo  = 1;
         bAutoMax          = 1;  // will auto-adapt RefMaxSrc
         bIncDstAsSrc      = 1;
      }

      int iChainNext = 0;
      for (; iDir < argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-wide=", 6)) {
            // user-selected list truncation
            bGlblRefWideInfo = 1;
            nGlblRefMaxSrc   = atol(argv[iDir]+6);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-wide")) {
            bGlblRefWideInfo = 1;
            bAutoMax         = 1;  // will auto-adapt RefMaxSrc
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-path") || !strcmp(argv[iDir], "-abs")) {
            bGlblRefRelCmp = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-noext") || !strcmp(argv[iDir], "-base")) {
            bGlblRefBaseCmp = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-incsrc")) {
            bIncSrc = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-flat")) {
            bIncDstAsSrc = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-fast", 5)) {
            // yet experimental: strip chars from sources input.
            // do not strip all printable chars, except if fast2.
            if (strcmp(argv[iDir], "-fast2"))
               for (uint uc=0; uc<256; uc++)
                  if (isprint((char)uc))
                     abGlblRefChars[uc] = 1;
            cs.refstripsrc = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option parameter:
         if (!cs.deplist)
            return 9+perr("unexpected: %s\n", argv[iDir]);
         // expect single source file name
         if (pszSingleSrc)
            return 9+perr("only one source file name supported, %s is unexpected.\n",argv[iDir]);
         pszSingleSrc = argv[iDir];
         if (!fileExists(pszSingleSrc))
            return 9+perr("no such file: %s\n", pszSingleSrc);
         cs.depsingle = 1;
      }
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iChainNext))) return lRC;

      // check input: only two dir roots allowed
      if (!pszSingleSrc && glblFileSet.numberOfRootDirs() < 2)
         return 9+perr("need at least two root dirs, for sources and targets.\n");

      if (chain.colfiles) {
         if (cs.depsingle) {
            cs.quiet = 1;
         } else {
            perr("filename chaining is not supported this way.\n");
            if (cs.deplist) {
               pinf("try specifying a single source filename.\n");
            }
            return 9;
         }
      }

      if (btest) return 0;

      // tree layer 0: targets
      // tree layer 1: sources
      int rlFiles=0, rlDirs=0;
      FileList oDirFiles;
      num  rlBytes = 0, nLocalMaxTime = 0, nTreeMaxTime  = 0;

      // ===== collect list of sources to determine nGlblRefMaxSrc =====
      int isrcroot = 0;
      int idstroot = 1;
      nGlblFunc = eFunc_RefColSrc;
      if (pszSingleSrc) {
         if (execRefColSrc(pszSingleSrc))
            return 9;
         idstroot = 0;
      } else {
         char *pszTree = glblFileSet.setCurrentRoot(isrcroot);
         if (cs.debug) info.print("] src: %s\n", pszTree);
         if (!isDir(pszTree)) return 9+perr("no such directory: %s\n", pszTree);
         Coi *pcoi = new Coi(pszTree, 0); // no relroot, is absolute
         int nrc = walkFiles(pcoi, 0, rlFiles, oDirFiles, rlDirs, rlBytes, nLocalMaxTime, nTreeMaxTime);
         if (!pcoi->refcnt()) delete pcoi;
         if (nrc) return 9;
      }
      int nSrcToList = glblRefSrc.numberOfEntries();
      if (bIncDstAsSrc) {
         // deplist: auto-include destinations as sources.
         // nSrcToList tells how many sources will be listed in output.
         cs.coldstnames = 1;
         for (int iroot=idstroot; iroot<glblFileSet.numberOfRootDirs(); iroot++) {
            char *pszTree = glblFileSet.setCurrentRoot(iroot);
            if (cs.debug) info.print("] dst: %s [included as src]\n", pszTree);
            if (!isDir(pszTree)) return 9+perr("no such directory: %s\n", pszTree);
            Coi *pcoi = new Coi(pszTree, 0); // no relroot, is absolute
            int nrc = walkFiles(pcoi, 0, rlFiles, oDirFiles, rlDirs, rlBytes, nLocalMaxTime, nTreeMaxTime);
            if (!pcoi->refcnt()) delete pcoi;
            if (nrc) return 9;
         }
      }
      if (!cs.quiet) {
         if (bIncDstAsSrc)
            info.print("%05u source files (%u internal sources)\n", nSrcToList, cs.refsrccnt);
         else
            info.print("%05u source files\n", cs.refsrccnt);
      }

      // auto-adapt nGlblRefMaxSrc
      if (bAutoMax && (cs.refsrccnt + 10 > nGlblRefMaxSrc))
         nGlblRefMaxSrc = cs.refsrccnt + 10;

      // setup reference table
      glblRefDst.addRow(__LINE__); // for dst file names
      glblRefDst.addRow(__LINE__); // for dst ref counts
      int i=0;
      for (i=0; i<nGlblRefMaxSrc; i++) {
         glblRefDst.addRow(__LINE__); // for source infos
      }

      // ===== collect list of targets (execRefColDst) =====
      nGlblFunc = eFunc_RefColDst;
      if (bIncDstAsSrc) {
         // have scanned dest. files already, reuse memory list.
         for (i=0; i<glblRefDstNames.numberOfEntries(); i++) {
            char *pszFile = glblRefDstNames.getEntry(i, __LINE__);
            Coi ocoi(pszFile, 0);
            if (execRefColDst(&ocoi))
               return 9;
         }
      } else {
         // have not scanned dest. yet, scan now.
         for (int iroot=idstroot; iroot<glblFileSet.numberOfRootDirs(); iroot++) {
            char *pszTree = glblFileSet.setCurrentRoot(iroot);
            if (cs.debug) info.print("] dst: %s\n", pszTree);
            if (!isDir(pszTree)) return 9+perr("no such directory: %s\n", pszTree);
            Coi *pcoi = new Coi(pszTree, 0); // no relroot, is absolute
            int nrc = walkFiles(pcoi, 0, rlFiles, oDirFiles, rlDirs, rlBytes, nLocalMaxTime, nTreeMaxTime);
            if (!pcoi->refcnt()) delete pcoi;
            if (nrc) return 9;
         }
      }
      if (!cs.quiet)
         info.print("%05u target files\n", glblRefDst.numberOfEntries(0));

      // ===== process potential sources (execRefProcSrc) =====
      /*
      fprintf(stderr, "excluded char map dump:\n");
      for (uint i=65; i<155; i++)
         if (!abGlblRefChars[i])
            fprintf(stderr, "%c", (char)i);
      fprintf(stderr, "\n");
      */
      for (i=0; i<cs.refsrccnt; i++) {
         char *pszsrc = glblRefSrc.getEntry(i, __LINE__);
         if (execRefProcSrc(pszsrc, 0, i, cs.refsrccnt))
            return 9;
      }
      info.clear();

      if (!bGlblEscape)
      if (cs.deplist) {
         // dump dependency list
         for (int isrc=0; isrc<nSrcToList; isrc++)
         {
            char *pszSrc = glblRefSrc.getEntry(isrc, __LINE__);
            StringTable asrc;
            bool bprinted = 0;
            if (bIncSrc || !pszSingleSrc) bprinted = 2; // dump a tab
            listDependencies(asrc, pszSrc, 0, bIncSrc || (pszSingleSrc ? 0 : 1), bprinted);
            chain.print(' ', 1, ""); // 1: with post-lf
         }
      } else {
         // dump reference list
         for (int idst=0; idst<glblRefDst.numberOfEntries(0); idst++)
         {
            char *pszDst  = glblRefDst.getString(0, idst);
            int  nRefCnt = glblRefDst.getLong(1, idst, __LINE__);
            if (nRefCnt > 0) {
               chain.print('i', 0, "%05u %s       ", (unsigned int)nRefCnt, pszDst);
               if ((nRefCnt > 0) && bGlblRefWideInfo) {
                  chain.print(' ', 2, "      :ref:\t"); // 2: with pre-lf (newline)
               } else {
                  chain.print(' ', 0, "<- "); // within same line
               }
               int nDump = nRefCnt;
               if (nDump > nGlblRefMaxSrc)
                  nDump = nGlblRefMaxSrc;
               for (i=0; i<nDump; i++) 
               {
                  char *pszSrc  = glblRefDst.getString(2+i, idst);
                  chain.print(' ', 0, "%s ", pszSrc); // within same line
                  if (bGlblRefWideInfo && (i<nDump-1)) {
                     chain.print(' ', 2, "      :ref:\t"); // 2: with pre-lf
                  }
               }
               chain.print(' ', 1, ""); // 1: with post-lf
            } else {
               chain.print(' ', 0, "%05u %s", (unsigned int)nRefCnt, pszDst); // with lf
               chain.print(' ', 1, ""); // 1: with post-lf
            }
         }
      }

      // if reflists are incomplete, warn about it
      if (bGlblRefLimitReached) {
         printx("<warn>lists of source files have been truncated at the %dth entry.<def>\n",nGlblRefMaxSrc);
         printx("<time>use option -wide[=n] to list more source files per target.<def>\n");
      }

      // cleanup
      info.setStatus("wait", "cleaning up memory");
      glblRefDst.reset();
      glblRefSrc.resetEntries();
      glblRefDstNames.resetEntries();
      info.clear();

      // pass created text to next chain command, if any
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "echo"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk echo [-spat] string [string2] [string3] [...]\n"
             "\n"
             "   prints the supplied string to terminal, which may contain color patterns:\n"
             "\n"
             "       [Red][[Red]][def],[Green][[Green]][def],[Blue][[Blue]][def],"
                    "[Yellow][[Yellow]][def],[Cyan][[Cyan]][def],[Magenta][[Magenta]][def]   (bright)\n"
             "       [red][[red]][def],[green][[green]][def],[blue][[blue]][def],"
                    "[yellow][[yellow]][def],[cyan][[cyan]][def],[magenta][[magenta]][def]   (dark)\n"
             "         print the following text in the selected color.\n"
             "\n"
             "       $[[def]]<def>\n"
             "         switch back to default color.\n"
             "\n"
             "       $[[[[<def> print the '[[' character, no not interpret the following word.\n"
             "       $]]]]<def> print the ']]' character, do not interpret it.\n"
             "\n"
             "   $further pattern support:\n"
             "      -spat     activates slash patterns: \\t=TAB \\q=\" \\r=CR \\n=LF\n"
             "                \\xnn = any code with hex value nn.\n"
             "      -literal  or -lit disables everything, even color patterns. set this\n"
             "                always if you need to process filenames in batch files,\n"
             "                using echo to feed a command chain:\n"
             "                   #sfk echo -lit %%1 +filter -rep _/_\\_ ...\n"
             "\n"
             "   $options:\n"
             "      -noline   stay in the same line, print no linefeed.\n"
             "                if your string ends with \\r, -noline is assumed.\n"
             "      -noblank  if multiple strings are given, do not insert blanks\n"
             "                between them.\n"
             "\n"
             "   $see also:<def> sfk help colors\n"
             "\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "      #sfk echo \"[[Red]]error:[[def]] missing filename.\"\n"
             "         prints \"[Red]error:[def] missing filename.\" onto terminal.\n"
             "\n"
             "      #sfk echo [[Cyan]]NOTE:[[def]] type the word [[[[red]]]] with brakets!\n"
             "         prints \"[Cyan]NOTE:[def] type the word [[red]] with brakets!\" onto terminal.\n"
             "\n"
             "      #sfk echo \"[[Green]]mytext contains:[[def]]\" +then filter mytext.txt\n"
             "         $+then<def> forces echo $not<def> to pass its text to filter, but to\n"
             "         print it immediately. filter then prints the content of mytext.\n"
             );
      ehelp;

      bool bNoLine = 0;
      abBuf[0] = '\0';
      int iChainNext = 0;
      bool bfirst = 1;
      bool bNoBlank = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-noline")) {
            bNoLine = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-noblank")) {
            bNoBlank = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) 
         {
            // any indicator that this is not an option?
            char *psz = argv[iDir]+1;
            bool baca = *psz ? 1 : 0; // all chars alphabetic
            for (; *psz; psz++)
               if (!isalpha(*psz))
                  { baca = 0; break; }

            if (!baca)  // e.g. ---===---
               { }      // fall through, take as text
            else
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:

         // if multiple strings are supplied, insert blanks:
         if (!bfirst && !bNoBlank)
            strcat((char*)abBuf, " ");
         bfirst = 0;

         // append another echo string, converting \t etc.
         char *pszsrc  = argv[iDir];
         int  nsrclen = strlen(pszsrc);
         char *pszdst  = (char*)abBuf + strlen((char*)abBuf);
         int  nmaxdst = MAX_ABBUF_SIZE - strlen((char*)abBuf);
         copyFormStr(pszdst, nmaxdst, pszsrc, nsrclen);
      }

      // if constructed string ends with \r, imply -noline
      int nlen = strlen((char*)abBuf);
      if (nlen > 0 && abBuf[nlen-1] == '\r')
         bNoLine = 1;

      if (!cs.wpat) {
         // do not interpret any [red] etc. commands
         if (chain.coldata) {
            if (bNoLine)
               chain.addToCurLine((char*)abBuf, str(""), 0);
            else
               chain.addLine((char*)abBuf, str(""), 2); // splitbylf, also on termlf
         } else {
            printf("%s%s",(char*)abBuf,bNoLine?"":"\n");
         }
      } else {
         // default: support [red] etc.
         printEcho(bNoLine, "%s", (char*)abBuf);
      }

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "time") || !strcmp(pszCmd, "unixtime"))
   {
      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      printx("<help>$sfk time [format]\n"
             "\n"
             "   prints the current date and time.\n"
             "\n"
             "   $format:\n"
             "      Y = year\n"
             "      M = month\n"
             "      D = day\n"
             "      h = hour\n"
             "      m = minute\n"
             "      s = second\n"
             "      any other char is passed through.\n"
             "      default format is YMDhms.\n"
             "\n"
             "   $options:\n"
             "      -spat  support slash patterns \\t etc.\n"
             "\n"
             "   $see also:\n"
             "      #sfk unixtime<def>   prints the unix timestamp\n"
             "\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "      #sfk time -spat \"Y-M-D\\th:m:s\" +filt -tabform \"<run>col2 <run>col1\"\n"
             "         prints 2011-06-16 06:17:31 to terminal,\n"
             "         with a tab character between date and time,\n"
             "         post processing the output by sfk filter.\n"
             );
      ehelp;

      bool bUnixTime = strcmp(pszCmd, "unixtime") ? 0 : 1;

      int iChainNext = 0;
      char *pszFormatMask = 0;

      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1))
         {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:
         if (!pszFormatMask)
            pszFormatMask = argv[iDir];
         else
            return 9+perr("unexpected parameter: \"%s\" (15)\n",argv[iDir]);
      }

      num nTime = time(NULL);

      if (bUnixTime)
      {
         numtoa(nTime, 10, szLineBuf2);
      }
      else
      {
         if (!pszFormatMask)
            pszFormatMask = str("YMDhms");
   
         // get current time
         struct tm *pLocTime = 0;
         mytime_t nTime2 = (mytime_t)nTime;
      
         #ifdef SFK_W64
         pLocTime = _localtime64(&nTime2);   // may be NULL
         #else
         pLocTime = localtime(&nTime2);      // may be NULL
         #endif
      
         struct tm oNullTime;
         mclear(oNullTime);
      
         if (!pLocTime)
            pLocTime = &oNullTime;
   
         // apply slash patterns
         if (cs.spat) {
            copyFormStr(szLineBuf3, MAX_LINE_LEN, pszFormatMask, strlen(pszFormatMask), 0);
            pszFormatMask = szLineBuf3;
         }
   
         // format according to mask
         char *psz1 = pszFormatMask;
         char *psz2 = szLineBuf;
         
         for (;*psz1;psz1++)
         switch (*psz1)
         {
            case 'Y': *psz2++ = '%'; *psz2++ = 'Y'; break;
            case 'M': *psz2++ = '%'; *psz2++ = 'm'; break;
            case 'D': *psz2++ = '%'; *psz2++ = 'd'; break;
            case 'h': *psz2++ = '%'; *psz2++ = 'H'; break;
            case 'm': *psz2++ = '%'; *psz2++ = 'M'; break;
            case 's': *psz2++ = '%'; *psz2++ = 'S'; break;
            default : *psz2++ = *psz1;
         }
         *psz2 = '\0';
         strftime(szLineBuf2, MAX_LINE_LEN, szLineBuf, pLocTime);
      }
      
      // dump to terminal or command chain
      if (chain.coldata) {
         chain.addLine(szLineBuf2, str(""));
      } else {
         printf("%s\n",szLineBuf2);
      }

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "make-random-file"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 2)
      printx("<help>$sfk make-random-file outfilename size [-text] [-seed=n]\n"
             "\n"
             "   creates a file full of random binary data for testing.\n"
             "   size parameters like 5m, 100k, 9000b are supported.\n"
             "   type \"sfk dupfind\" for details on size parameters.\n"
             "\n"
             "   $options\n"
             "      -text     create text data instead of binary.\n"
             "      -seed=n   specify randomizer seed. default is\n"
             "                to use a time based seed.\n"
             "\n"
             "   $example\n"
             "      #sfk make-random-file tmp1.dat 1m -seed=1234\n"
             "         produce a file tmp1.dat with 1 mbyte of size.\n"
            );
      ehelp;

      char *pszFile = argv[2];
      char *pszSize = argv[3];
      num nSize = numFromSizeStr(pszSize, "size");
      if (nSize < 0) return 9;
      bool bText = 0;
      unsigned nSeed = (unsigned)time(NULL);

      iDir = 4;
      for (; iDir < argc; iDir++) {
         if (!strncmp(argv[iDir], "-seed=", strlen("-seed="))) {
            nSeed = (unsigned)atol(argv[iDir]+strlen("-seed="));
         }
         else
         if (!strcmp(argv[iDir], "-text")) {
            bText = 1;
         }
         else
            return 9+perr("unknown option: %s\n", argv[iDir]);
      }

      FILE *fout = 0;
      if (bText) fout = fopen(pszFile, "w");
      else       fout = fopen(pszFile, "wb");
      if (!fout)
         return 9+esys("fopenw", "unable to write %s\n", pszFile);

      info.setAction("write", pszFile, "");

      srand(nSeed);

      num nRemain  = nSize;
      num nWritten = 0;
      int nBlockSize = sizeof(abBuf)-10;
      int i=0;
      while (nRemain > 0) {
         if (bText) {
            int ibreak = 40 + rand() % 80;
            for (i=0; i<nBlockSize; i++) 
            {
               abBuf[i] = (uchar)(rand()%26+'a');
               // add line breaks near 80 chars
               if ((i % ibreak) == ibreak-2)
                  { abBuf[i] = '\r'; }
               if ((i % ibreak) == ibreak-1) {
                  abBuf[i] = '\n';
                  ibreak = 40 + rand() % 80;
               }
            }
         } else {
            for (i=0; i<nBlockSize; i++)
               abBuf[i] = (uchar)rand();
         }
         int nWriteSize = nBlockSize;
         if (nWriteSize > nRemain)
             nWriteSize = nRemain;
         num nWrite = myfwrite(abBuf, nWriteSize, fout);
         if (nWrite != nWriteSize) {
            esys("fwrite", "unable to write after %s bytes.\n", numtoa(nWritten));
            lRC = 9;
            break;
         }
         nRemain  -= nWriteSize;
         nWritten += nWriteSize;
         info.setProgress(nSize, nWritten, "bytes");
      }

      fclose(fout);

      info.print("written %s (%s bytes).\n", pszFile, numtoa(nWritten));

      bDone = 1;
   }

   // internal
   if (!strcmp(pszCmd, "testfwrite"))
   {
      if (blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      if (nparm < 2) { 
         printx("<help>$sfk testfwrite outfile blocksize\n");
         return 9;
      }
      char *pszFile = argv[iDir++];
      char *pszSize = argv[iDir++];
      num nSize = numFromSizeStr(pszSize, "size");

      testfwrite(pszFile, nSize);
     
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "color"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("<help>$sfk color colorname\n"
             "\n"
             "   switches the text color of terminal (command line).\n"
             "   supported color names are:\n"
             "\n"
            );
      if (bhelp) {
      printx("   white,grey,red,green,blue,yellow,cyan,magenta,black\n");
      } else {
         setTextColor(15); printf("      white  \n");
         setTextColor(14); printf("      grey   \n");
         setTextColor( 3); printf("      red    \n");
         setTextColor( 5); printf("      green  \n");
         setTextColor( 9); printf("      blue   \n");
         setTextColor( 7); printf("      yellow \n");
         setTextColor(13); printf("      cyan   \n");
         setTextColor(11); printf("      magenta\n");
         setTextColor( 0); printf("      black  \n");
         setTextColor(-1);
      }
      ehelp;

      char *pszCol = argv[2];
      if (!strcmp(pszCol, "white" ))  { setTextColor(15); return 0; }
      if (!strcmp(pszCol, "grey"  ))  { setTextColor(14); return 0; }
      if (!strcmp(pszCol, "red"   ))  { setTextColor( 3); return 0; }
      if (!strcmp(pszCol, "green" ))  { setTextColor( 5); return 0; }
      if (!strcmp(pszCol, "blue"  ))  { setTextColor( 9); return 0; }
      if (!strcmp(pszCol, "yellow"))  { setTextColor( 7); return 0; }
      if (!strcmp(pszCol, "cyan"))    { setTextColor(13); return 0; }
      if (!strcmp(pszCol, "magenta")) { setTextColor(11); return 0; }
      if (!strcmp(pszCol, "black" ))  { setTextColor( 0); return 0; }
      printf("unsupported color: %s\n", pszCol);
      return 1;
   }

   ifcmd (!strcmp(pszCmd, "colortest"))
   {
      ifhelp (0)
      printx("<help>$sfk colortest\n"
             "\n"
             "   test all current logical colors.\n"
             "\n"
            );
      ehelp;

      printf("\n"
             "=== List of current logical SFK colors. ===\n"
             "=== If text is not colored type \"sfk help color\" for more. ===\n"
             "\n"
             );
      printf("Now follows the list of logical colors:\n"
             #ifndef _WIN32
             "default, "
             #endif
             "head, example, file, link, hit, replace,\n"
             "error, warning, pre, info, traceinc, traceex\n"
             "\n"
             );
      #ifndef _WIN32
      setTextColor(nGlblDefColor);      printf("default  color, for the linux shell\n");
      #endif
      setTextColor(nGlblHeadColor);     printf("head     color, for help text headers\n");
      setTextColor(nGlblExampColor);    printf("example  color, for help text examples\n");
      setTextColor(nGlblFileColor);     printf("file     color, for file names\n");
      setTextColor(nGlblLinkColor);     printf("link     color, for symbolic link files\n");
      setTextColor(nGlblHitColor);      printf("hit      color, for search result hits\n");
      setTextColor(nGlblRepColor);      printf("replace  color, to highlight replaced text\n");
      setTextColor(nGlblErrColor);      printf("error    color, for error messages\n");
      setTextColor(nGlblWarnColor);     printf("warning  color, for warning messages\n");
      setTextColor(nGlblPreColor);      printf("pre      color, for previous line hits\n");
      setTextColor(nGlblTimeColor);     printf("info     color, for many info messages\n");
      setTextColor(nGlblTraceIncColor); printf("traceinc color, for -tracesel included files\n");
      setTextColor(nGlblTraceExcColor); printf("traceex  color, for -tracesel excluded files\n");
      setTextColor(-1);
      return 0;
   }

   ifcmd (!strncmp(pszCmd, "ver", 3) && strncmp(pszCmd, "veri",4))
   {
      if (chain.useany()) {
         perr("sfk ver does not support input chaining.");
         pinf("you may use \"+then ver filename\" instead.\n");
         return 9;
      }

      ifhelp (nparm < 1 && strcmp(pszCmd, "ver."))
      printx(
         "<help>$sfk version filename\n"
         "$sfk ver -own\n"
         "\n"
         "   print version of a binary file, or of sfk itself.\n"
         "   the provided file is searched for a string with format:\n"
         "\n"
         "      #$$%s:name=sfk,type=base,os=windows,vernum=1.5.1,fix=0,\n"
         "      #title=Swiss File Knife,date=Aug  2 2008,info=major rework$$\\0\n"
         "\n"
         "   $%s string fields:\n"
         "    [2] *name    short name, usually similar to the executable name\n"
         "    [3]  type    the type of edition, e.g. base or extended\n"
         "    [4] *os      operating system, e.g. windows, linux-lib6, linux-lib5\n"
         "    [5] *vernum  version number, any number of values separated by dots\n"
         "    [6]  fix     fix level, e.g. a revision or service pack number\n"
         "    [7] *title   long, descriptive name, as printed in a help text\n" 
         "    [8] *date    release or compile date\n"
         "    [9]  info    additional infos or remarks, free text string\n"
         "\n"
         "   fields marked with \"*\" are mandatory for a valid version string.\n"
         "   the other fields can be left out, or be empty like \",fix=,\".\n"
         "   if found, contents are printed TAB-separated, #after the filename<def>,\n"
         "   therefore the #[]<def> numbers given above are #output column numbers<def>,\n"
         "   not the location in the input string (which is random anyway).\n"
         "\n"
         "   $options\n"
         "      -num[ber]  just print the full version number, combining\n"
         "                 vernum and fix to a dotted string.\n"
         "                 cannot be used with -own.\n"
         "      -verbose   tells a warning if file(s) contain no version.\n"
         "\n"
         "   $see also\n"
         "      #sfk require<def> - check if a required version is used.\n"
         "\n"
         ,"version","version"
         );
      webref(pszCmd);
      printx("   $examples\n"
         "      #sfk ver dview.exe\n"
         "         print the version of a Depeche View executable.\n"
         "      #sfk ver -own\n"
         "         print sfk's version.\n"
         "      #sfk ver -nosub . .exe +filt -ssep \"\\t\" -sform \"$$-20.20col1\\t$$col5\"\n"
         "         search all .exe files of the current dir for versions,\n"
         "         reformatting the output, with a 20 chars filename limit.\n"
         "\n"
         );
      ehelp;
      
      if (   (nparm==1 && !strcmp(argv[iDir+0], "-own"))
          || !strcmp(pszCmd, "ver.")
         )
      {
         // tell own version
         // 1.1.7.2 -> 1172 decimal. 1.1.7 -> 1170 decimal.
         // $version:vernum,shortid,full name,type$\0"
         // 0123456789
         StringMap omap;
         if (parseVersion((char*)pszGlblVersion, strlen(pszGlblVersion), omap))
            return -1;

         char *pnam = omap.get(str("name"  ), str(""));
         char *ptyp = omap.get(str("type"  ), str(""));
         char *pos  = omap.get(str("os"    ), str(""));
         char *pnum = omap.get(str("vernum"), str(""));
         char *pfix = omap.get(str("fix"   ), str(""));
         char *ptit = omap.get(str("title" ), str(""));
         char *pdat = omap.get(str("date"  ), str(""));
         char *pinf = omap.get(str("info"  ), str(""));

         // create integer from version string
         char *psz1 = pnum;
         int nVer = 0;
         int nDot = 3;
         while (*psz1) {
            char c = *psz1++;
            if (c == '.')
               { nVer = nVer * 10; nDot--; }
            else
               nVer = nVer + (c - '0');
         }
         while (nDot-- > 0)
            nVer = nVer * 10;
   
         printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", argv[0],
            pnam,ptyp,pos,pnum,pfix,ptit,pdat,pinf);

         // return version to shell, for further processing
         return nVer;
      }

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (strBegins(argv[iDir], "-num")) {
            cs.justvernum = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         break;
      }

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC;
      if (btest) return 0;

      lRC = walkAllTrees(eFunc_Version, lFiles, lDirs, nBytes);

      info.clear();

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }
   
   ifcmd (!strcmp(pszCmd, "require"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk require inputVersion requiredVersion\n"
             "$sfk require -own requiredVersion\n"
             "\n"
             "   check a version text against a required version,\n"
             "   or check SFK's version itself.\n"
             "\n"
             "   produces shell return code 0 if input version\n"
             "   is greater or equal to required version.\n"
             "\n"
             "   $options\n"
             "      -name=x   if input version is too old, SFK prints\n"
             "                an error message containing x.\n"
             "      -own      check SFK's own version.\n"
             "      -quiet    do not print info message\n"
             "                in case of failure.\n"
             "\n"
             "   $windows .bat file example\n"
             "      @echo off\n"
             "      sfk require -own 1.6.1.2\n"
             "      IF %%ERRORLEVEL%%==0 GOTO sfkok\n"
             "      echo \"wrong SFK version, stopping.\"\n"
             "      exit /B\n"
             "      :sfkok\n"
             "\n"
             "   $linux bash example\n"
             "      sfk require -own 1.6.1.2\n"
             "      iReturnCode=$$?\n"
             "      if [ ! $$iReturnCode -eq 0 ]; then\n"
             "         echo \"wrong SFK version, stopping.\"\n"
             "         exit\n"
             "      fi\n"
             "\n"
             "   $further examples\n"
             "      #sfk ver -number dview.exe +require -name=dview 1.4.8\n"
             "         check if dview.exe is 1.4.8.0 or higher.\n"
             );
      ehelp;
      
      char *pszReqVersion = 0;
      char *pszSubject = 0;
      bool bOwn = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-name", &pszParm)) {
            if (!pszParm) return 9;
            pszSubject = pszParm;
            continue;
         }
         else      
         if (!strcmp(argv[iDir], "-own")) {
            bOwn = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
            
         // process non-option keywords:
         if (!pszReqVersion) {
            pszReqVersion = argv[iDir];
            continue;
         }

         return 9+perr("unexpected parameter: %s\n", argv[iDir]);
      }
      
      if (!pszReqVersion)
         if (bOwn)
            return 9+perr("supply required version, e.g. 1.6.1");
         else
            return 9+perr("supply a filename and required version, e.g. myfile 1.6.1");
      
      const char *pszBaseVersion = SFK_VERSION;
      const char *pszFixPack     = SFK_FIXPACK;

      char szOwnVersion[50];
      
      if (chain.usedata) 
      {
         char *psz = chain.indata->getEntry(0, __LINE__);
         if (!psz) return 9+perr("int. #2118201");
         strcopy(szOwnVersion, psz);
         // enforce quadruple format
         psz = szOwnVersion;
         int iparts = 0;
         while (psz) {
            if (*psz) iparts++;
            if (!(psz = strchr(psz, '.')))
               break;
            psz++;
         }
         for (; iparts<4; iparts++) {
            int ilen = strlen(szOwnVersion);
            if (ilen > 0 && szOwnVersion[ilen-1] == '.')
               strcat(szOwnVersion, "0");
            else
               strcat(szOwnVersion, ".0");
         }
         if (cs.verbose)
            printf("using: %s\n", szOwnVersion);
      }
      else
      {
         if (!bOwn)
            return 9+perr("missing -own parameter.\n");
            
         snprintf(szOwnVersion, sizeof(szOwnVersion)-10,
            "%s%s%s"
            , pszBaseVersion
            , pszFixPack[0] ? ".":""
            , pszFixPack
            );
      }
      
      lRC = 0;
      
      // compare version parts
      char *pszOwn = szOwnVersion;
      char *pszReq = pszReqVersion;
      while (1)
      {
         int iOwnPart = atoi(pszOwn);
         int iReqPart = atoi(pszReq);
         
         if (iOwnPart < iReqPart)
            { lRC = 10; break; }
            
         if (iOwnPart > iReqPart)
            break;

         pszOwn = strchr(pszOwn, '.');
         if (!pszOwn) break; // end of own quad version
         pszOwn++;

         pszReq = strchr(pszReq, '.');
         if (!pszReq) break; // end of triple or quad req
         pszReq++;
      }
      
      if (lRC && !cs.quiet) 
      {
         if (bOwn)
         {
            char *pszOwnPath = findPathLocation(argv[0]);
            if (!pszOwnPath) pszOwnPath = str("sfk");
            perr("script requires Swiss File Knife (sfk) version: %s", pszReqVersion);
            pinf("current binary %s has version %s\n", pszOwnPath, szOwnVersion);
         }
         else
         {
            if (pszSubject)
               perr("script requires %s version %s (current=%s)",
                  pszSubject, pszReqVersion, szOwnVersion);
         }
      }

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "messagebox"))
   {
      if (argc < 4) return 9+perr("missing parameters, specify title and text\n");
      char *pszTitle = argv[2];
      char *pszText  = argv[3];
      MessageBox(0, pszText, pszTitle, MB_OK);
      return 0;
   }
   #endif

   #ifdef WITH_TCP
   ifcmd (strBegins(pszCmd, "httpserv") || strBegins(pszCmd, "webserv"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      printx(
         "<help>$sfk httpserv [-h[elp]]]] [-port=nport] [-rw]\n"
         "\n"
         "   The SFK Instant HTTP Server for easy file transfer.\n"
         "\n"
         "   $default behaviour:\n"
         "   * the CURRENT DIRECTORY is made accessible, without subdirs.\n"
         "   * any kind of directory traversal (.., / etc.) is blocked.\n"
         "   * just ONE CLIENT (browser etc.) can connect at a time.\n"
         "\n"
         "   $options:\n"
         "     -port=n     use other port than default, e.g. -port=81.\n"
         "     -port2=n    alternative port, used if first port fails.\n"
         "                 use -port2=0 to disable alternative port.\n"
         "     -rw         allow write access. displays a single file\n"
         "                 upload form when accessing \"/\".\n"
         "     -nolist     do not provide a content listing, but change\n"
         "                 any access to \"/\" into \"index.html\".\n"
         "     -deep       allow reading of files in sub directories.\n"
         "                 only for use with -nolist, as it does not\n"
         "                 provide sub directory listings.\n"
         "\n"
         "   NOTE: be aware that ANYONE may connect to your server.\n"
         "         this is a primitive, low-performance http server\n"
         "         made for easy transfer of a few files.\n"
         "         if you need more power and configurable security,\n"
         "         download and install a real http server like apache.\n"
         "\n"
         "   $see also:\n"
         "     #sfk ftpserv -h<def>    the SFK Instant FTP server.\n"
         #ifdef VFILENET
         "     #sfk wget<def>          a web file download command.\n"
         #endif // VFILENET
         "\n");
      webref(pszCmd);
      ehelp;

      cs.timeOutMSec = 30000;

      int   iDir    =     2;
      int  iChainNext =   0;
      uint nPort    =    80;
      uint nPort2   =  8080;
      char *pszPath =     0;
      bool  bSub    =     0;
      bool  bDeep   =     0;
      bool  bNoList =     0;
      bool  bRW     =     0;
      bool  bUseDirParms = 0;

      // no verbose progress indicator at server side.
      cs.noprog = 1;

      for (; iDir < argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-port", &pszParm)) {
            if (!pszParm) return 9;
            nPort  = atol(pszParm);
            nPort2 = 0;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-port2", &pszParm)) {
            if (!pszParm) return 9;
            nPort2 = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-deep")) {
            bDeep = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-nolist")) {
            bNoList = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-rw")) {
            bRW = 1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-timeout", &pszParm)) {
            if (!pszParm) return 9;
            cs.timeOutMSec = atol(pszParm) * 1000;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir])) {
               bUseDirParms = 1;
               break; // fall through
            }               
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszPath)
            pszPath = argv[iDir];
         else
            return 9+perr("unexpected parameter: %s\n", argv[iDir]);
      }
      
      if (bUseDirParms) 
      {
         // read multiple dirs
         if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 1)))
            return lRC;
      } 
      else 
      {
         // default: single folder only            
         if (!pszPath) pszPath = str(".");
         if (glblFileSet.beginLayer(false, __LINE__)) return 9;
         glblFileSet.addRootDir(pszPath, __LINE__, false);
         glblFileSet.autoCompleteFileMasks(3);
         glblFileSet.setBaseLayer();
      }
      
      cs.subdirs = bSub; // in case of list command

      if (btest) return 0;

      httpServ(nPort, nPort2, bDeep, bNoList, bRW);

      bDone = 1;
   }

   ifcmd (strBegins(pszCmd, "ftpserv") || strBegins(pszCmd, "sftserv"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      printx(
         "<help>$sfk ftpserv [-h[elp]]]] [-port=nport] [-rw] [workdir]\n"
         "\n"
         "   The SFK Instant FTP Server for easy file transfer.\n"
         "\n"
         "   $default behaviour since SFK 1.6.7.2:\n"
         "   * the CURRENT DIRECTORY is made accessible, WITH subdirs.\n"
         "   * any kind of directory traversal (.., / etc.) is blocked.\n"
         "   * just ONE CLIENT (browser etc.) can connect at a time.\n"
         "     if another client connects, the first is auto closed.\n"
         "   * after 60 seconds of inactivity, the connection is closed.\n"
         "   * filenames with accents are sent as is (no UTF8 support).\n"
         "   * with -rw, files of any size can be written (no size limit).\n"
         "   * with -rw, #existing files are overwritten without asking.\n"
         "\n"
         "   $options:\n"
         "     -port=n     use other port than default, e.g. -port=10000.\n"
         "     -port2=n    alternative port, used if first port fails.\n"
         "                 use -port2=0 to disable alternative port.\n"
         "     -pw=x       require primitive authentication, i.e. client\n"
         "                 must provide password x to login. you may also\n"
         "                 set an environment variable like:\n"
         #ifdef _WIN32
         "                    SET SFK_FTP_PW=mypassword\n"
         #else
         "                    export SFK_FTP_PW=mypassword\n"
         #endif
         "     -user=x     require this username. if not specified then\n"
         "                 any username can be used. can also be given\n"
         "                 by environment variable SFK_FTP_USER.\n"
         "     -timeout=n  set timeout to n seconds. default is 60.\n"
         "     -rw         allow read+write access. default is readonly.\n"
         "     -maxsize=n  set size limit per file write to this, e.g.\n"
         "                 10m = 10 mbytes. default is no size limit.\n"
         "     -minspace=n set required free disk space for file writing,\n"
         "                 e.g. -minspace=200m requires 200 megabytes.\n"
         "     -noclone    do not try to replicate time stamps on a file\n"
         "                 transmission from an sfk ftp client.\n"
         "     -verbose    list the transmitted ftp commands.\n"
         "                 helpful to get more infos in case of errors.\n"
         "     -quiet[=2]  print less or no status informations.\n"
         "     -nosub      block sub directory access, e.g. the client\n"
         "                 may NOT say \"put the/sub/dir/document.txt\".\n"
         "     -run        allow client to execute system commands.\n"
         "                 requires -pw option being set as well.\n"
         "                 requires an sfk ftp client to run commands.\n"
         "     -runpw=x    require authentication only for run commands.\n"
         "                 can also be set via the environment:\n"
         #ifdef _WIN32
         "                    SET SFK_FTP_RUNPW=mypassword\n"
         #else
         "                    export SFK_FTP_RUNPW=mypassword\n"
         #endif
         "     -ownip=x    if client sends PASV command, by default the\n"
         "     -ownip x    server replies with the first network interface\n"
         "                 IP found. if this is the wrong one, you may\n"
         "                 supply a different IP here (as n.n.n.n).\n"
         "     -noclose    do not auto close first client connection\n"
         "                 if another client tries to connect.\n"
         );
  printx("\n"
         "   $specific single work dir:\n"
         "      instead of making the current directory accessible\n"
         "      you may set a folder name like #sfk ftpserv mydir<def>\n"
         "      to allow access to these contents only.\n"
         "\n"
         "   $multi directory mappings:\n"
         "      instead of making the current directory accessible,\n"
         "      you may specify folders (with virtual names) like:\n"
         "         #-usedir C:\\audiofiles D:\\images=pic\n"
         );
  printx("\n"
         "   NOTE: be aware that ANYONE may connect to your server.\n"
         "         with -rw specified, ANYONE may also write large files.\n"
         "         if this is a problem, do NOT use sfk ftpserv, but download\n"
         "         and install a full-scale ftp server like filezilla.\n"
         "\n"
         "   $aliases:\n"
         "      sfk sftserv ...  = the same as sfk ftpserv, but using port 2121.\n"
         "\n"
         "   $file attributes\n"
         "      since SFK 1.6.7, if an SFK server speaks with SFK client,\n"
         "      linux file attributes are sent and written at the receiver,\n"
         "      except for file owner 'rw' flags which are set by default\n"
         "      to allow rewrite in future transfers. when sending from linux\n"
         "      to windows attributes like 'x' get lost.\n"
         "\n"
         );
  printx("   $problems and solutions:\n"
         "   if you try to login to the server using a regular ftp client, but\n"
         "   you cannot connect and/or transfer files, then usually there is a\n"
         "   firewall or network configuration incompatible to normal FTP.\n"
         "   - if your ftp client provides a command \"passive\", then type that,\n"
         "     press enter, and then try the usual commands like dir, get or put.\n"
         "   - whenever possible, use the SFK FTP client to connect to an SFK FTP\n"
         "     server. client and server will then use a different protocol (SFT)\n"
         "     with which you often can transfer files even if normal FTP fails.\n"
         "   - Windows Vista, Windows 7: the firewall may stop sfk to sfk file\n"
         "     transfer on the default port 21, with error ECONNRESET, probably\n"
         "     because sfk uses a different protocol. You then have to use a\n"
         "     different port, e.g. -port=5000 or use Windows' \"ftp\" command.\n"
         "   - Windows 7 Starter: you may have to open the firewall settings\n"
         "     and enable incoming connections for application \"sfk\" manually.\n"
         "   - Windows: whenever running sfk.exe in an ununsual user context,\n"
         "     e.g. from a mounted virtual drive, or a non-admin shell, this\n"
         "     may cause the system to block incoming connections.\n"
         "   - some FTP clients must be configured not to use multiple transfer\n"
         "     connections in parallel (FileZilla: edit/settings/transfers)\n"
         "   - virtual machines: when using NAT network adapter mode you may\n"
         "     not connect from the host into the guest but only vice versa.\n"
         "     you may configure port forwards in the VM's adapter settings,\n"
         "     then connect to 127.0.0.1:portnumber but not to the IP shown\n"
         "     in the guest. also read the VM's help on adapter modes.\n"
         "\n"
         );
  printx("   $known compatible ftp clients:\n"
         "     WinSCP (in FTP mode), WS_FTP95, FileZilla, command line ftp\n"
         "\n"
         "   $known incompatible ftp clients:\n"
         "     Windows Explorer FTP (requires unsupported multi connections)\n"
         "\n"
         );
  printx("   $see also:\n"
         "     -  type \"#sfk ftp<def>\" for the SFK FTP client. when it connects to an\n"
         "        SFK FTP server, you get easier connectivity and more features.\n"
         "     -  type \"#sfk httpserv -h<def>\" for the SFK Instant HTTP Server.\n"
         "\n");
      webref(pszCmd);
      printx("   $examples\n"
         "\n"
         "   - to run sfk as a 'real' ftp server for non sfk clients:\n"
         "     (uses port 21. sfk ftp clients may also connect,\n"
         "      but see possible problems listed above.)\n"
         "\n"
         "     #sfk ftpserv -user=foo -pw=bar mydir\n"
         "       require the given user/pw and allow read only access to mydir\n"
         "       and all subdirectories of mydir.\n"
         "\n"
         "     #sfk ftpserv -rw -usedir website/images=pic /Musik/audio=audio\n"
         "       allow read/write access to website/images with virtual folder\n"
         "       name \"pic\" and to /Musik/audio as just \"audio\".\n"
         "\n"
         "   - if you just want quick and simplest file transfer between two\n"
         "     machines both having sfk, use this:\n"
         "\n"
         "     #sfk sftserv -rw\n"
         "       run an sfk simple file transfer server, using port 2121,\n"
         "       allowing read/write access to current dir and all sub dirs.\n"
         "       then use \"sfk sft\" at the client side. should no connection\n"
         "       be possible run the server and/or client with admin rights\n"
         "       and check the firewall settings.\n"
         );
      ehelp;

      DisableCtrlCProcessExit(); // ftpserv

      cs.timeOutMSec = 60000;

      int   iDir    =     2;
      uint nPort    =  strBegins(pszCmd, "sftserv") ? 2121 : 21;
      uint nPort2   =  2121;
      bool  bRW     =     0;
      bool  bRun    =     0;
      bool  bDeep   =     1; // default since SFK 167
      cs.preserve     = 0;
      char *pszDirMap = 0;
      cs.autoclose  = 1;

      nGlblTCPMaxSizeMB = 0; // default since SFK 167

      // no verbose progress indicator at server side.
      cs.noprog = 1;

      int istate = 0;

      FTPServer oserv;

      for (; iDir < argc; iDir++) 
      {
         char *pszArg = argv[iDir];

         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-port", &pszParm)) {
            if (!pszParm) return 9;
            nPort  = atol(pszParm);
            nPort2 = 0;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-port2", &pszParm)) {
            if (!pszParm) return 9;
            nPort2 = atol(pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-ownip", &pszParm)) {
            if (!pszParm) return 9;
            strcopy(cs.szownip, pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-minspace", &pszParm)) {
            if (!pszParm) return 9;
            cs.diskspace = numFromSizeStr(pszParm, "-minspace");
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-user", &pszParm)) {
            if (!pszParm) return 9+perr("-user requires a parameter.\n");
            strcopy(oserv.szClAuthUser, pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-pw", &pszParm)) {
            if (!pszParm) return 9+perr("-pw requires a parameter.\n");
            strcopy(oserv.szClAuthPW, pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-runpw", &pszParm)) {
            if (!pszParm) return 9+perr("-runpw requires a parameter.\n");
            strcopy(oserv.szClRunPW, pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-maxsize", &pszParm)) {
            if (!pszParm) return 9;
            if (!(nGlblTCPMaxSizeMB = numFromSizeStr(pszParm) / 1000000))
               return 9+perr("-maxsize must be at least \"1m\" for one megabyte");
            continue;
         }
         else
         if (!strcmp(pszArg, "-anysize")) { // deprecated since 167
            nGlblTCPMaxSizeMB = 0;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-timeout", &pszParm)) {
            if (!pszParm) return 9;
            cs.timeOutMSec = atol(pszParm) * 1000;
            continue;
         }
         else
         if (!strcmp(pszArg, "-rw")) {
            bRW = 1;
            continue;
         }
         else
         if (   strBegins(pszArg, "-wany")  // deprecated since 167
             || strBegins(pszArg, "-rwany") // deprecated since 167
            )
         {
            bRW = 1;
            nGlblTCPMaxSizeMB = 0;
            bDeep = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-run")) {
            bRun = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-deep")) { // deprecated since 167
            bDeep = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-nosub")) { // since 167
            bDeep = 0;
            continue;
         }
         else
         if (!strcmp(pszArg, "-withsub")) { // deprecated since 167
            continue;
         }
         else
         if (!strcmp(pszArg, "-noclone")) {
            cs.noclone = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-noclose")) {
            cs.autoclose = 0;
            continue;
         }
         else
         if (strBegins(pszArg, "-usedir")) {
            istate = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }

         // non option parms
         switch (istate) {
            case 0: 
               if (oserv.setFixDir(pszArg))
                  return 9;
               istate=2; 
               break;
            case 1:
               if (oserv.addUseDir(pszArg))
                  return 9;
               break;
            default:
               return 9+perr("unexpected parameter: %s\n", pszArg);
         }
      }

      if (bRun && !oserv.szClAuthPW[0] && !oserv.szClRunPW[0])
         return 9+perr("-run requires -pw or -runpw being set.\n");

      // walk file set is set up per command
      glblFileSet.reset();

      if (btest) return 0;

      oserv.run(nPort, bRW, bRun, bDeep, nPort2);

      bDone = 1;
   }

   regtest("ftp 127.0.0.1:5000");
   regtest("ftp 127.0.0.1:5000 get xfile");

   ifcmd (!strcmp(pszCmd, "ftp") || !strcmp(pszCmd, "sft"))
   {
      ifhelp (nparm < 1)
      printx(
         "<help>$sfk ftp host[:port] [options] [command [parms]]\n"
         "\n"
         "   The SFK Simple FTP Client.\n"
         "\n"
         "   $commands\n"
         "      put x     send a single file with name x\n"
         "      get x     receive a single file with name x\n"
         "      mput x    send multiple files of the current directory\n"
         "                having x in their filename\n"
         "      mput .ext send multiple files ending with .ext\n"
         "      mget x    receive multiple files from the ftp server\n"
         "                having x in their filename\n"
         "      mget .ext receive multiple files ending with .ext\n"
         "      dir       list the remote directory\n"
         "      cd x      change into remote directory x\n"
         "      lcd x     change into local  directory x\n"
      // "      ccd x     change remote and local dir in parallel\n"
      // "                if x exists on both sides.\n"
         "      !mycmd    execute local command mycmd\n"
         "      run cmd   run remote command (only with sfk ftp server)\n"
         "      bye       exit\n"
         "\n"
         "   $options\n"
         "      -force    continue transfer after errors.\n"
         "      -verbose  list the transmitted ftp commands.\n"
         "                helpful to get more infos in case of errors.\n"
         "      -quiet    disable progress indicator and other output.\n"
         "      -nohead   do not show message \"using SFK_FTP_USER ...\"\n"
         "      -noprog   no progress indicator during transfers.\n"
         "      -update   or -up transmits only changed files. this option\n"
         "                is experimental and may or may not work, depending\n"
         "                on the server software, server settings (UTC vs.\n"
         "                local time) and time zone.\n"
         "      -new      the same as -update.\n"
         "      -user=x   or -user x sends username x instead of anonymous.\n"
         "                you may also set an environment variable like:\n"
         #ifdef _WIN32
         "                   SET SFK_FTP_USER=myuser\n"
         #else
         "                   export SFK_FTP_USER=myuser\n"
         #endif
         "      -pw=x     or -pw x sends an authentication password x.\n"
         "                you may also set an environment variable like:\n"
         #ifdef _WIN32
         "                   SET SFK_FTP_PW=mypassword\n"
         #else
         "                   export SFK_FTP_PW=mypassword\n"
         #endif
         "     -noclone   do not try to replicate time stamps on a file\n"
         "                transmission from an sfk ftp server.\n"
         "     -pres      always preserve full file attributes, including\n"
         "                readonly modes. default is to keep file writeable\n"
         "                by file owner and to apply umask under linux.\n"
         "     -verify    extra verify by re-reading files after transfer\n"
         "                and comparing against a transmitted md5 checksum.\n"
         "\n"
         "   $aliases\n"
         "      sfk sft ...   = the same as sfk ftp, but using port 2121.\n"
         "      cput          = same as \"mput -update\" (multi put changed).\n"
         "      cget          = same as \"mget -update\" (multi get changed).\n"
         "                      cget, cput have same experimental status\n"
         "                      as described under the -update option.\n"
         "\n"
         "   $automatic IP expansion\n"
         "      if you are in the same subnet as the target host,\n"
         "      you may supply only the IP number's last part, e.g.:\n"
         "         sfk ftp 23 ... == sfk ftp 192.168.1.23 ...\n"
         "      this feature may or may not work, depending on your\n"
         "      operating system and number of network interfaces.\n"
         "      add option -showip to see what the expanded IP is.\n"
         "\n"
         "   $file attributes\n"
         "      since SFK 1.6.7, if an SFK server speaks with SFK client,\n"
         "      some linux file attributes are sent and written at the\n"
         "      receiver. by default, rw for owner is always set, and the\n"
         "      target system umask is applied. use option -pres(erve)\n"
         "      to transfer attributes as is. when sending from linux\n"
         "      to windows attributes like 'x' get lost.\n"
         "\n"
         "   $examples\n"
         "      #sfk ftp farpc put test.zip\n"
         "         send test.zip to farpc\n"
         "      #sfk ftp -user=foo -pw=bar farpc put test.zip\n"
         "         the same but with authentication\n"
         "      #sfk ftp 192.168.1.99:30199 get test.zip\n"
         "         receive test.zip from 192.168.1.99 port 30199\n"
         "      #sfk ftp farpc mput .cpp\n"
         "         send all .cpp files of the local dir to farpc.\n"
         "         subfolder contents are NOT included.\n"
         #ifdef _WIN32
         "      #sfk ftp farpc mget %c\n"
         #else
         "      #sfk ftp farpc mget \"%c\"\n"
         #endif
         "         receive all files from farpc's directory,\n"
         "         overwriting everything in the local directory.\n"
         "      #sfk ftp hostname\n"
         "         enter interactive mode, in which you can type\n"
         "         the above commands directly. for example,\n"
         #ifdef _WIN32
         "            !dir runs the command \"dir\" locally.\n"
         #else
         "            !ls runs the command \"ls\" locally.\n"
         #endif
         ,glblWildChar);
    printx(
         "      #sfk sel -today mydir .css .php +ftp farpc mput\n"
         "         upload all .css and .php files changed today\n"
         "         within the mydir folder to FTP server farpc.\n"
         "         before doing so, make sure that farpc has the\n"
         "         same folder structure (mydir at top level).\n"
         "\n");
    printx(
         "   $IF connected with an sfk sft server:\n"
         "\n"
         "      best practice is to run an sft (simple file transfer)\n"
         "      server on the other PC or VM like:\n"
         "\n"
         "      #sfk sftserv -rw\n"
         "\n"
         "      this will use port 2121, avoiding firewall and other\n"
         "      restrictions that usually block use of ftp port 21.\n"
         "      then the following can be used by an sfk client:\n"
         "\n"
         "      #sfk sft farpc get myfile.txt\n"
         "         download myfile.txt instantly. if a local file\n"
         "         exists with the same name then it is overwritten.\n"
         "\n"
         "      #sfk sft farpc mget myfile\n"
         "         download all files having \"myfile\" in their name.\n"
         "         sfk will show a \"simulating\" preview first.\n"
         "         add -yes to really download the files.\n"
         "\n"
         "      #sfk sft farpc mput myfile\n"
         "         send all files having \"myfile\" in their name.\n"
         "         if files with same name exist at server then\n"
         "         they are overwritten.\n"
         "\n"
         "      #sfk sft farpc get the\\sub\\dir\\doc.txt\n"
         "         by default, sfk sftserv allows deep direct access\n"
         "         to files within folders. all required output dirs\n"
         "         are created automatically. this deep access cannot\n"
         "         be used with mget, mput and dir.\n"
         "\n"
         );
  printx("      #sfk sel mydir .txt +sft farpc cput\n"
         "         send all .txt files within mydir that changed since\n"
         "         the last transmission to farpc.\n"
         "\n"
         "      #sfk filter filelist.txt +sft farpc mget mydir\n"
         "         create a list with filenames, download the files listed\n"
         "         therein from server farpc into a folder \"mydir\".\n"
         "\n"
         "      #sfk sft 192.168.1.100 cput .txt\n"
         "         connect to server .100 and send all .txt files\n"
         "         which are newer or were added in the local folder.\n"
         "\n"
         "      #sfk sft 192.168.1.100 cget .txt\n"
         "         connect to server .100 and download all .txt files\n"
         "         which are newer or were added in the remote folder.\n"
         "\n"
         "      #sfk sft farpc -pw mypw run \"sh myscript.sh >tmp1.txt 2>&1\"\n"
         "         execute a command on the remote server, redirecting all\n"
         "         output into a file tmp1.txt. requires an sfk sft server\n"
         "         with option -run, AND -pw authentication on both sides.\n"
         "\n"
         "   $problems and solutions:\n"
         "   - if running the ftp server just like \"sfk ftpserv\" then\n"
         "     on Windows Vista, Windows 7 the firewall may stop sfk to sfk\n"
         "     file transfer on port 21 with ECONNRESET or ECONNABORTED.\n"
         "     therefore use a different port, like -port=2121 which is\n"
         "     default with sftserv. read more under: sfk ftpserv -help\n"
         "\n"
         "   $see also:\n"
         "      #sfk ftpserv -help\n"
         "\n");
  webref(pszCmd);
  printx("NOTE: existing files are overwritten <err>without asking back<def>.\n"
         "      Make sure that ftp server and client are running\n"
         "      in the correct directories, especially before mput/mget.\n"
         );
      ehelp;

      // collect instant command here
      szLineBuf2[0]   = '\0';
      nGlblTCPMaxSizeMB = 0; // no size limit
      uint nPort      = !strcmp(pszCmd, "sft") ? 2121 : 21;
      cs.subdirs      = 0; // in case of mput
      char *pszHost   = 0;
      int nstate      = 1;
      char *pszUser   = 0;
      char *pszAuthPW = 0;
      cs.preserve     = 0;
      
      // since SFT 103, default is not to use verify, for faster transfer.
      cs.verify = 0;

      bool bChained = chain.usefiles || chain.usedata;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-pw", &pszParm)) {
            if (!pszParm) return 9+perr("-pw requires a parameter.\n");
            pszAuthPW = pszParm;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-user", &pszParm)) {
            if (!pszParm) return 9+perr("-user requires a parameter.\n");
            pszUser = pszParm;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-up") || !strcmp(argv[iDir], "-new"))
         {
            cs.ftpupdate = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-all")) {
            cs.ftpall = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-noclone")) {
            cs.noclone = 1;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-pres")) {
            cs.preserve = 1;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-ver")) {
            cs.verify = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         char *pparm = argv[iDir];
         switch (nstate++) {
            case 1: {
               // first parm must be host:port
               pszHost = strdup(pparm);
               char *psz = strchr(pszHost, ':');
               if (psz) {
                  *psz++ = '\0';
                  nPort = atol(psz);
               }
               // ftp client may act on current dir only.
               if (glblFileSet.beginLayer(false, __LINE__)) return 9;
               glblFileSet.addRootDir(str("."), __LINE__, false);
               glblFileSet.autoCompleteFileMasks(3);
               glblFileSet.setBaseLayer();
               continue;
            }
            default: {
               // continue to collect instant command
               if (szLineBuf2[0]) strcat(szLineBuf2, " ");
               strcat(szLineBuf2, pparm);
            }
         }
      }
      
      if (!pszHost)
         return 9+perr("missing target host.\n");

      bool bTellEnv = 0;
      if (!pszUser && getenv("SFK_FTP_USER")) {
         pszUser = getenv("SFK_FTP_USER");
         bTellEnv = (cs.quiet || cs.nohead) ? 0 : 1;
      }
      if (!pszUser)
         pszUser = str("anonymous");
      if (!pszAuthPW && getenv("SFK_FTP_PW")) {
         pszAuthPW = getenv("SFK_FTP_PW");
         bTellEnv = (cs.quiet || cs.nohead) ? 0 : 1;
      }
      if (bTellEnv)
         printf("[using SFK_FTP_USER/PW for authentication]\n");

      if (btest) {
         if (pszHost) delete [] pszHost;
         return 0;
      }

      // run in interactive or direct mode
      if (szLineBuf2[0]) {
         // direct mode
         ftpClient(pszHost, nPort, szLineBuf2, pszUser, pszAuthPW, bChained);
      } else {
         // interactive mode
         ftpClient(pszHost, nPort, 0, pszUser, pszAuthPW, bChained);
      }

      // cleanup
      if (pszHost) delete [] pszHost;

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }
   #endif // WITH_TCP

   // internal, experimental
   if (!strcmp(pszCmd, "checkdisk"))
   {
      if (argc < 4) { 
         printx("<help>$sfk checkdisk volumepath rangesizemb|all\n"
                "\n"
                "   test the disk or stick specified by volumepath if it is reliable. sfk will write\n"
                "   100 test files, filling up rangesize mbytes, re-read them, and check for errors.\n"
                "   after that, test files without errors are removed, but those with errors are kept,\n"
                "   to block damaged parts of the media from being reused.\n"
                "\n"
                "   NOTE: detection of errors does NOT always mean that the MEDIA itself is corrupted.\n"
                "         the reason may as well lie within the USB electronic of your PC, or within\n"
                "         the disk drive controller. for USB sticks, always test them at least with\n"
                "         two different PCs.\n"
                "\n"
                "      #sfk checkdisk E:\\ all\n"
                "         checks all space available on drive E:\\, e.g. USB-stick.\n"
                "      #sfk checkdisk G:\\ 1950\n"
                "         checks 1950 mb on drive G:\\\n"
               );
         return 0;
      }
      char *pszVolPath = argv[2];
      char *pszRngSize = argv[3];

      int nRangeMB = -1;
      if (strcmp(pszRngSize, "all"))
         if (!(nRangeMB = atol(pszRngSize)))
            return 9+perr("supply no. of mbytes to check, or \"all\".\n");

      lRC = checkDisk(pszVolPath, nRangeMB);

      bDone = 1;
   }

   regtest("hexdump -showle -wide -nohead xdir .dat1 .dat2");
   regtest("hexdump -lean -pure -dir xdir -file .dat");
   regtest("hexdump -hexsrc xfile1");
   regtest("hexdump -decsrc xfile1 xfile2");
   regtest("hexdump -flat xfile1");
   regtest("tcpdump 5000 -forward xhost:xport -timeout 20000");

   bool btcpdump = 0;
   bool budpdump = 0;
   bool bnetdump = 0;

   ifcmd (   strBegins(pszCmd, "hexdump")
          || strBegins(pszCmd, "tcpdump")
          || strBegins(pszCmd, "udpdump")
          || strBegins(pszCmd, "postdump")
          || strBegins(pszCmd, "mindump")
          || strBegins(pszCmd, "knxdump")
          || !strcmp(pszCmd, "hexle")
         )
   {
      bool btcp = btcpdump = strBegins(pszCmd, "tcpdump");
      bool budp = budpdump = strBegins(pszCmd, "udpdump");
      bool bknx = strBegins(pszCmd, "knxdump");
      if (bknx) { budp=1; budpdump=1; cs.knx=2; }
      bool bnet = bnetdump = btcp || budp;

      ifhelp (    (argc >= 3 && isHelpOpt(argv[2]))
              || (!bknx && (argc < 3) && (bnet || !chain.usefiles))
             )

      // if dumping all help text, run three passes
      for (int ihelp=0; ihelp<3; ihelp++) {

      // create different help pages for sfk ask:
      if (bhelp)
         switch (ihelp) {
            case 0 : btcp=0; budp=0; bnet=0; break; // hexdump help
            case 1 : btcp=1; budp=0; bnet=1; break; // tcpdump help
            case 2 : btcp=0; budp=1; bnet=1; break; // udpdump help
         }

      if (!bnet)
      printx("<help>$sfk hexdump [-showle] [-wide] [...] dir .ext1 .ext2 .ext3\n"
             "\n"
             "   create human-readable hexdump of binary file(s).\n"
            );
      else
      if (budp)
      printx("<help>$sfk udpdump [options] [group] port\n"
             "\n"
             "   create human-readable hexdump of UDP socket input,\n"
             "   for debugging of UDP network applications.\n"
            );
      else
      printx("<help>$sfk tcpdump [-showle] [...] port [-forward host:port] [...]\n"
             "\n"
             "   create human-readable hexdump of tcp socket input, and optionally\n"
             "   dump a tcp conversation, for debugging of web applications.\n"
            );

      printx("\n"
             "   $options:\n");
      if (bknx)
      printx("      -full   print knx messages with full details.\n"
             );
      else
      printx("      -showle  highlights line ending characters CR and LF.\n"
             "               you may also add \"le\" to the command name.\n"
             "      -wide    dumps 32 input bytes per line.\n"
             "      -lean    dumps 16 input bytes per line.\n"
             "      -post    reduced format e.g. for forum posts\n"
             "      -min     minimal format with alnum only text\n"
             );
      if (bnet) {
      if (bknx)
         { }
      else
      if (budp)
      printx("      -echo    echo received packets back to sender.\n"
             "      -stop    or stop=n stops after n received packages.\n"
             "               with command chaining, default is -stop=1.\n"
             "      -sep[arator] prints detailed separator between packages\n"
             "               with message number, source IP and time.\n"
            );
      else
      printx("      -forward specifies a host and port to which to forward\n"
             "               incoming requests, to dump a tcp conversation.\n"
             "      -timeout number of milliseconds to wait after last transfer\n"
             "               until connections are closed. default is 60000,\n"
             "               or 10000 if http is detected.\n");
      } else {
      printx("      -nofile  or -nofilenames does not list the filename(s).\n"
             "      -rawname prints filename without :file prefix\n");
      // arcinf(5); // hexdump
      }

      if (!bknx)
      printx("      -pure    lists flat hex characters:\n"
             "               #53464B2D544553540D0A\n"
             "      -hexsrc  lists hex comma separated values:\n"
             "               #0x53,0x46,0x4B,0x2D,0x54,0x45,0x53,0x54,0x0D,0x0A,\n"
             "      -decsrc  lists decimal comma separated values:\n"
             "               #83,70,75,45,84,69,83,84,13,10,\n"
             );
      if (!bnet)
      printx("      -off[set] n1    dump from offset n1 to file end.\n"
             "                      n1 can be negative, for example\n"
             "                      -off=-100 dumps last 100 bytes of file.\n"
             "      -last n1        same as -offset -n1\n"
             "      -offlen n1 n2   dump from offset n1 only n2 bytes.\n"
             "      -notrail     no trailing comma \",\" at end of hex/dec src\n"
             "      -norectrail  no trailing comma at end of every src record\n"
             "      -recsize n   only with -hex/decsrc, -pure or -flat:\n"
             "               change no. of input bytes dumped per record.\n"
             "               with default output format, use -wide instead.\n"
             );

      if (bnet && !bknx)
      printx("      -maxdump=n   dump only first n bytes of incoming data.\n"
             "      -flat        no hexdump, print characters as they come.\n");

      if (budp && !bknx)
      printx("      -nohead      does not show the \"received n bytes\" message.\n"
             "      -tofile x    write output to file x.\n");
      if (budp)
      printx("\n"
             "   $message filtering\n"
             "      show only messages ...\n"
             "      -from s       from IP's containing text s\n"
             "      -size n       with this size\n"
             "      -minsize n    larger  or equal to n\n"
             "      -maxsize n    smaller or equal to n\n"
             "      -data foo     containing text \"foo\"\n"
             "      -data 0xa0a1  containing binary data 0xa0a1\n"
             "\n"
             "   $experimental multicast receive\n"
             "     if a multicast group IP address is given, like\n"
             "        #sfk udpdump 224.0.0.123 5000\n"
             "     then udpdump tries to print incoming multicast messages.\n"
             "     this $may or may not work<def> depending on the OS, network\n"
             "     interface, router and firewall settings, user rights and\n"
             "     other programs running in parallel.\n"
             "\n"
             "   $special protocol support\n"
             "     #sfk udpdump -bon<def>   - print bonjour messages\n"
             "     #sfk udpdump -knx<def>   - print knx messages (sfk help knx)\n"
             );

      if (btcp) {
      printx("\n"
             "   $see also:\n"
             "     #sfk udpdump<def> - dump incoming UDP packets.\n"
             "     #sfk hexdump<def> - for further format options.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "     #sfk tcpdump 9000 -showle -forward www.google.com:80 -timeout 2000\n"
             "        then connect with your browser to localhost:9000 and see\n"
             "        the http requests and replies which are passing through.\n"
             "        small timeouts are recommended to trace http communication,\n"
             "        as the web browser may wait until the connection is closed.\n"
             "\n"
             "     #sfk tcpdump 5000 -flat -timeout 2000 -forward myproxy:8000\n"
             "        show plaintext communication to anywhere via a proxy server.\n"
             "        to connect this way, you MUST connect to sfk as a proxy:\n"
             "        in Firefox, open tools/options/advanced/network/settings, set\n"
             "        manual proxy configuration, http proxy \"localhost\" port 5000.\n"
             "        then type some external servername, e.g. \"http://google.com\"\n"
             "        in your browser. In this example, is expected that a proxy\n"
             "        machine \"myproxy\" exists within your local network.\n"
             "        After the test, disable the proxy setting in your browser.\n"
             );
      }
      else
      if (budp) {
      printx("\n"
             "   $see also:\n"
             "     #sfk udpsend<def>  - send UDP packets.\n"
             "     #sfk hexdump<def>  - for further format options.\n");
      if (bknx)
      printx("     #sfk help knx<def> - for knx examples.\n");
      printx("\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "     #sfk udpdump 5000\n"
             "        waits on port 5000 for incoming udp packages.\n"
             );
      }
      else {
      printx("\n"
             "  $aliases:\n"
             "    #sfk hexdumple<def> - same as \"sfk hexdump -showle\" for text\n"
             "    #sfk postdump<def>  - same as \"sfk hexdump -post\" for forums\n"
             "\n"
             "  $see also:\n"
             "    #sfk hextobin<def>  - convert hex dump back to original data.\n"
             "\n");
      webref(pszCmd);
      printx("  $examples:\n"
             "    #sfk hexdump -offlen 4221566976 96 part1.avi\n"
             "        dumps 96 bytes from offset 4221566976 within part1.avi\n"
             "\n"
             "    #sfk hexdump -offlen 0xFBA00000 0x60 part1.avi\n"
             "        the same as above, but using hexadecimal numbers\n"
             #ifdef _WIN32
             "\n"
             "    #sfk postdump test.dat +toclip\n"
             "        put test.dat contents into clipboard for posting\n"
             #endif
             );
      }

      if (bhelp) { printx("\n"); } else break; }
      // end of three passes if dumping all help text

      ehelp;

      uchar abMsg[2000+100];
      int   nMsg = 0;
      int   nMsgMax = sizeof(abMsg)-100;
      mclear(abMsg);

      if (strBegins(pszCmd, "postdump")) {
         nGlblHexDumpForm=5; cs.bytesperline=16;
      }
      if (strBegins(pszCmd, "mindump")) {
         nGlblHexDumpForm=6; cs.bytesperline=16;
      }

      // internal: hexdumple as alias for hexdump -showle
      if (strstr(pszCmd, "le"))
         cs.leattr = 'e';

      // autoselect hex dump width by console width
      if (bGlblConsColumnsSet && (nGlblConsColumns >= 120))
         bGlblHexDumpWide = 1;

      if (cs.knx)
         cs.separator = 1;

      cs.timeOutMSec = 60000;
      cs.timeOutAutoSelect = 1;

      int   nPort       = -1;
      char *pszForward  = 0;
      int   nForward    = 0;
      int   iChainNext  = 0;
      bool  bEcho       = 0;
      char *pszGroup    = 0;
      char *pszFromMask = 0;
      int   iMinSize    =-1;
      int   iMaxSize    =-1;
      bool  bCollectData= 0;
      uint  nFlags      = 0;

      for (; iDir < argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (   !strcmp(argv[iDir], "-show-line-endings")
             || !strcmp(argv[iDir], "-showle")
            )
         {
            cs.leattr = 'e';
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-wide")) {
            bGlblHexDumpWide = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-lean") || !strcmp(argv[iDir], "-narrow"))
         {
            bGlblHexDumpWide = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-pure"))   { nGlblHexDumpForm=1; continue; }
         else
         if (!strcmp(argv[iDir], "-hexsrc")) { nGlblHexDumpForm=2; continue; }
         else
         if (!strcmp(argv[iDir], "-decsrc")) { nGlblHexDumpForm=3; continue; }
         else
         if (strBegins(argv[iDir], "-notrail")) { cs.dumptrail=1; continue; }
         else
         if (strBegins(argv[iDir], "-norectrail")) { cs.dumptrail=2; continue; }
         else
         if (!strcmp(argv[iDir], "-flat")) { nGlblHexDumpForm=4; continue; }
         else
         if (!strcmp(argv[iDir], "-post")) { nGlblHexDumpForm=5; cs.bytesperline=16; continue; }
         else
         if (!strcmp(argv[iDir], "-min"))  { nGlblHexDumpForm=6; cs.bytesperline=16; continue; }
         else
         if (strBegins(argv[iDir], "-sep")) { cs.separator=1; continue; }
         else
         if (strBegins(argv[iDir], "-nosep")) { cs.separator=0; continue; }
         else
         if (!strcmp(argv[iDir], "-nolf")) { cs.nolf=1; continue; }
         else
         if (strBegins(argv[iDir], "-bon")) 
            { pszGroup = str("224.0.0.251"); nPort = 5353; continue; }
         else
         if (strBegins(pszArg, "-knx")) {
            cs.knx=2;
            if (!strcmp(pszArg, "-knxfull"))
               cs.knx=1;
            cs.separator=1;
            continue; 
         }
         else
         if (cs.knx && !strcmp(pszArg, "-full")) {
            cs.knx=1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-text", &pszParm)) {
            if (!pszParm) return 9;
            if (cs.knx)
               cs.knxtext = pszParm;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-recsize", &pszParm)) {
            if (!pszParm) return 9;
            cs.bytesperline = atoi(pszParm);
            int iMaxBytes = (MAX_LINE_LEN / 5) - 10; // "0x00,"
            if (cs.bytesperline < 1 || cs.bytesperline > iMaxBytes)
               return 9+perr("-recsize must be 1 ... %d\n", iMaxBytes);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-forward", &pszParm)) {
            if (!pszParm) return 9;
            strcopy(szLineBuf, pszParm);
            pszForward = szLineBuf;
            char *psz = strrchr(pszForward, ':');
            if (!psz) return 9+perr("missing port, specify -forward host:port\n");
            *psz++ = '\0';
            nForward = atol(psz);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-timeout", &pszParm)) {
            if (!pszParm) return 9;
            cs.timeOutMSec = atol(pszParm);
            cs.timeOutAutoSelect = 0;
            if (cs.timeOutMSec < 200) {
               printx("<warn>note: timeout set to %d milliseconds (%u.%03u seconds).<def>\n", cs.timeOutMSec, cs.timeOutMSec/1000, cs.timeOutMSec%1000);
            }
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-offlen", &pszParm))
         {
            if (!pszParm) return 9;

            num nval = 0;
            bool bneg = 0;
            if (pszParm[0]=='-')
               bneg = 1;
            nval = numFromSizeStr(pszParm+bneg,"-offlen offset");
            if (nval < 0) return 9;
            nGlblHexDumpOff = bneg ? (0-nval) : nval;

            if (iDir >= argc) return 9+perr("supply values like -offlen 10000 100");
            char *pszlen = argv[++iDir];
            nGlblHexDumpLen = numFromSizeStr(pszlen,"-offlen length");
            if (nGlblHexDumpLen < 0) return 9;

            continue;
         }
         else
         if (   haveParmOption(argv, argc, iDir, "-off"   , &pszParm)
             || haveParmOption(argv, argc, iDir, "-offset", &pszParm)
            )
         {
            if (!pszParm) return 9;

            num nval = 0;
            bool bneg = 0;
            if (pszParm[0]=='-')
               bneg = 1;
            nval = numFromSizeStr(pszParm+bneg,"-offset");
            if (nval < 0) return 9;
            nGlblHexDumpOff = bneg ? (0-nval) : nval;

            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-last", &pszParm))
         {
            if (!pszParm) return 9;

            num nval = numFromSizeStr(pszParm,"-last");
            if (nval < 0) return 9;
            nGlblHexDumpOff = 0-nval;

            continue;
         }
         else
         if (!strcmp(argv[iDir], "-echo")) {
            bEcho = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-rawname")) {
            cs.rawfilename = 1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-maxdump", &pszParm)) {
            if (!pszParm) return 9;
            cs.maxdump = atoi(pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-stop", &pszParm)) {
            cs.stopcnt = pszParm ? atoi(pszParm) : 1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            pszFromMask = pszParm;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-size", &pszParm)) {
            if (!pszParm) return 9;
            iMinSize = atoi(pszParm);
            iMaxSize = iMinSize;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-minsize", &pszParm)) {
            if (!pszParm) return 9;
            iMinSize = atoi(pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-maxsize", &pszParm)) {
            if (!pszParm) return 9;
            iMaxSize = atoi(pszParm);
            continue;
         }
         else
         if (   haveParmOption(argv, argc, iDir, "-data", &pszParm)
             || haveParmOption(argv, argc, iDir, "-show", &pszParm)
            )
         {
            if (!pszParm) return 9;
            const char *pszWhat = "-data";
            if (!strcmp(pszArg, "-show")) {
               pszWhat = "-show";
               nFlags |= 1;
            }
            if (nMsg) return 9+perr("only one -%s is allowed", pszWhat);
            char szBuf[20];
            char *ppart = pszParm;
            if (strBegins(ppart, "0x")) {
               char *pszHex = ppart+2;
               int iLen = strlen(pszHex);
               bool bSkipFirst = (iLen & 1) ? 1 : 0;
               szBuf[0] = '0';
               while (*pszHex) {
                  if (bSkipFirst)
                     bSkipFirst = 0;
                  else
                     szBuf[0] = *pszHex++;
                  if (!*pszHex) return 9+perr("wrong hex format: %s\n",ppart);
                  szBuf[1] = *pszHex++;
                  if (!isxdigit(szBuf[0])) return 9+perr("wrong hex format: %s\n",ppart);
                  if (!isxdigit(szBuf[1])) return 9+perr("wrong hex format: %s\n",ppart);
                  abMsg[nMsg++] = (uchar)strtol(szBuf, 0, 0x10);
                  if (nMsg > nMsgMax) return 9+perr("%s too long", pszWhat); 
               }
            } else {
               int nlen = strlen(ppart);
               if (nMsg+nlen > nMsgMax) return 9+perr("%s too long", pszWhat); 
               memcpy(abMsg+nMsg, ppart, nlen);
               nMsg += nlen;
            }
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         if (bnetdump) 
         {
            // non-option parameter: can be port or 224.0.0.x group
            if (!pszGroup && strchr(argv[iDir], '.')) {
               pszGroup = argv[iDir];
               continue;
            }
            else
            if (nPort == -1) {
               nPort = atol(argv[iDir]);
               continue;
            }
         }

         break; // fall through to non-option processing
      }
      
      if (cs.knx) {
         if (!pszGroup) pszGroup = str("224.0.23.12");
         if (nPort < 0) nPort = 3671;
      }

      if (cs.bytesperline && !nGlblHexDumpForm) {
         perr("-recsize requires -hex/decsrc, -flat or -pure format.\n");
         pinf("use -wide to print 32 bytes per line in default format.\n");
         return 9;
      }

      if (btcpdump) {
         if (nPort == -1)
            return 9+perr("specify port number to listen on.\n");
         if (btest) return 0;
         // get pszForward out of szLineBuf
         if (pszForward)
            pszForward = strdup(pszForward);
         tcpAnyServ(nPort, pszForward, nForward);
         if (pszForward)
            delete [] pszForward;
      }
      else
      if (budpdump) {
         if (nPort == -1)
            return 9+perr("specify port number to listen on.\n");
         if (btest) return 0;
         // get pszForward out of szLineBuf
         if (pszForward)
            pszForward = strdup(pszForward);
         udpAnyServ(nPort, pszForward, nForward, pszGroup, bEcho, pszFromMask, iMinSize, iMaxSize, abMsg, nMsg, nFlags);
         if (pszForward)
            delete [] pszForward;
      } else {
         if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iChainNext))) return lRC;
         if (btest) return 0;
         lRC = walkAllTrees(eFunc_Hexdump, lFiles, lDirs, nBytes);
      }

      if (chain.coldata) {
         STEP_CHAIN(iChainNext, 1);
      } else {
         STEP_CHAIN(iChainNext, 0);
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "fromnet"))
   {
      ifhelp ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
      printx("<help>$sfk fromnet [port] [options]<def>\n"
             "\n"
             "   receive network text sent by sfk tolog or tonetlog.\n"
             "\n"
             "   if a port number is given, it is used to receive text\n"
             "   instead of the default UDP port 21323.\n"
          // "   if a group like 224.0.0.123 is given then text is received\n"
          // "   by UDP multicast.\n"
             "\n"
             "   $options\n"
             "      -nocache  do not cache text lines without linefeed\n"
             "                but print them to terminal immediately.\n"
             "                default is to wait for a linefeed, to join\n"
             "                large lines split across multiple messages.\n"
             "\n"
             "   $see also\n"
             "      sfk netlog   - how to send SFK network text\n"
             "\n"
             "      A recommended #GUI tool<def> to view and filter network text\n"
             "      is #Depeche View<def>. Type #sfk getdv<def> to download, then run\n"
             #ifdef _WIN32
             "      the tool by #dview -net<def> for instant net text display.\n"
             "      It runs with Windows, and on Linux/Mac using WINE.\n"
             #else
             "      the tool by #wine ./dview -net &<def>\n"
             #endif
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk fromnet\n"
             "        wait for incoming text and print it to terminal.\n"
             "\n"
             "      #sfk fromnet +filter -high red error +loop\n"
             "        highlight errors in red in the incoming text.\n" 
             "\n"
            );
      ehelp;

      int iPort = 21323;
      int details = 1;
      bool bNoCache = 0;
      char *pszGroup = 0;
      bool bPortGiven = 0;

      int iChainNext = 0;

      for (; iDir<argc; iDir++) 
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-port", &pszParm)) {
            if (!pszParm) return 9;
            iPort = atoi(pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-group", &pszParm)) {
            if (!pszParm) return 9;
            pszGroup = pszParm;
            continue;
         }
         else
         if (!strcmp(pszArg, "-nocache")) {
            bNoCache = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // non-option parameter: can be port or 224.0.0.x group
         if (!pszGroup && strchr(argv[iDir], '.')) {
            pszGroup = argv[iDir];
            continue;
         }
         else
         if (!bPortGiven) {
            bPortGiven = 1;
            iPort = atoi(argv[iDir]);
            continue;
         }

         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (btest) return 0;

      static bool bInitDone = 0;

      if (!bInitDone)
      {
         bInitDone = 1;

         prepareTCP();
   
         uint uiFlags = 2; // reuse
         if (pszGroup)
              uiFlags |= 1; // multicast
   
         if (sfkNetSrc.initSendReceive("netlog", iPort, 0,pszGroup,uiFlags))
            return 9+perr("cannot receive on port %d\n", iPort);
      }

      while (!userInterrupt())
      {
         int iSubRC = sfkNetSrc.receiveText();
         if (iSubRC > 1)
            { perr("wrong input, rc=%d\n", iSubRC); break; }

         char *pszText=0, *pszCmd=0;

         while (pszCmd = sfkNetSrc.getNextCommand()) {
            // if (!strcmp(pszCmd, "clear"))
            //    clearText();
         }

         struct sockaddr_in oInAddr;
         char szSenderInfo[200];
   
         char *pAttr = 0;
         while (pszText = sfkNetSrc.getNextInput(&pAttr, &oInAddr, bNoCache))
         {
            szSenderInfo[0] = '\0';
            switch (details)
            {
               case 1:
                  ipAsString(&oInAddr, szSenderInfo, sizeof(szSenderInfo)-10, 1);
                  strcat(szSenderInfo, "> ");
                  break;
                  
               case 2:
               {
                  ipAsString(&oInAddr, szSenderInfo+20, sizeof(szSenderInfo)-30, 3);
                  // 192.168.1.229:65300
                  char *psz1 = strrchr(szSenderInfo+20, '.');
                  if (psz1) {
                     psz1++;
                     char *psz2 = strchr(psz1, ':');
                     if (psz2)
                        snprintf(szSenderInfo, 20, "%.*s> ", (int)(psz2-psz1), psz1);
                  }
                  break;
               }
            }
   
            // netColorToDViewColor(pAttr);

            if (chain.coldata) {
               chain.addLine(pszText, pAttr, 1);   // 1: splitByLF
            } else {
               printColorText(pszText, pAttr, 0);
               fflush(stdout);
            }
         }

         if (iChainNext > 0)
            break;
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "sendudp") 
          || !strcmp(pszCmd, "udpsend") 
          || !strcmp(pszCmd, "sendcast")
          || !strcmp(pszCmd, "tcpsend")
          || !strcmp(pszCmd, "sendtcp")
          || !strcmp(pszCmd, "knxsend")
         )
   {
      bool bknx = !strcmp(pszCmd, "knxsend");
      ifhelp (nparm < 1)
      printx("<help>$sfk udpsend host port [options] data [data2] [...]\n"
             "\n"
             "   send a UDP message, and optionally receive replies.\n"
             "\n"
             "   $options:\n"
             "      -listen        wait for a single reply, and dump it.\n"
             "      -listen=n      wait for so many replies and dump them.\n"
             "      -listenall     receive endless.\n"
             "      -timeout=n     wait up to n msec for replies.\n"
             "      -wide, -lean   etc. change hex dump output format.\n"
             "                     for details, type \"sfk hexdump\"\n"
             "      -flat          print messages as plain text.\n"
         //  "      -multi, -mcast send as multicast. requires that \"host\"\n"
         //  "                     is a multicast address like 224.0.0.x.\n"
             "\n"
             "   $input data format:\n"
             "      0x123456       a hex string which is converted to binary\n"
             "      foo            any other plain text is sent as is, but\n"
             "                     zero termination is NOT done automatically.\n"
             "\n"
             "      all given data fragments are joined into one large block.\n"
             "      how long the block can be is system dependent, but it must\n" 
             "      always stay below 2000 bytes.\n"
             "\n"
             "   $experimental multicast send\n"
             "      if option -mcast and a multicast group is given, like\n"
             "         #sfk udpsend -mcast 224.0.0.123 5000 testtext\n"
             "      then udpsend tries to send a multicast message.\n"
             "      this $may or may not work<def> depending on the OS, network\n"
             "      interface, router and firewall settings, user rights and\n"
             "      other programs running in parallel.\n"
             "\n");
      if (bknx)
      printx("   $see also:\n"
             "     #sfk help knx<def>    for knx examples.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk udpsend localhost 12345 -listen hello 0x00\n"
             "         send \"hello\" followed by a zero byte to localhost\n"
             "         on port 12345, then receive a single reply.\n"
             "\n"
             );
      ehelp;

      int   ndstport = -1;
      int   nownport = -1;
      int   nlisten = 0;
      char  szDstIP[200+10];
      uchar abMsg[2000+100];
      int   nMsg = 0;
      int   nMsgMax = sizeof(abMsg)-100;
      char  szBuf[10];
      num   nTimeout = 0;
      bool  bTCP = strcmp(pszCmd, "tcpsend") ? 0 : 1;
      bool  bknx = strcmp(pszCmd, "knxsend") ? 0 : 1;

      mclear(szDstIP);
      mclear(abMsg);
      mclear(szBuf);

      if (bknx) {
         cs.multicast=1; 
         if (!szDstIP[0]) strcpy(szDstIP, "224.0.23.12");
         if (ndstport<0)  ndstport=3671;
         cs.knx=1;
      }

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-replyport", &pszParm)) {
            if (!pszParm) return 9;
            nownport = atol(pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-timeout", &pszParm)) {
            if (!pszParm) return 9;
            nTimeout = atol(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-listen")) {
            nlisten = 1;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-listen=")) {
            nlisten = atol(argv[iDir]+8);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-listenall")) {
            nlisten = -1;
            continue;
         }
         else
         if (   !strcmp(argv[iDir], "-show-line-endings")
             || !strcmp(argv[iDir], "-showle")
            )
         {
            cs.leattr = 'e';
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-wide")) {
            bGlblHexDumpWide = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-lean") || !strcmp(argv[iDir], "-narrow"))
         {
            bGlblHexDumpWide = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-pure"))   { nGlblHexDumpForm=1; continue; }
         else
         if (!strcmp(argv[iDir], "-hexsrc")) { nGlblHexDumpForm=2; continue; }
         else
         if (!strcmp(argv[iDir], "-decsrc")) { nGlblHexDumpForm=3; continue; }
         else
         if (!strcmp(argv[iDir], "-flat")) { nGlblHexDumpForm=4; continue; }
         else
         if (strBegins(argv[iDir], "-multi")) { cs.multicast=1; continue; }
         else
         if (!strcmp(argv[iDir], "-mcast")) { cs.multicast=1; continue; }
         else
         if (!strcmp(argv[iDir], "-knx")) { 
            cs.multicast=1; 
            if (!szDstIP[0]) strcpy(szDstIP, "224.0.23.12");
            if (ndstport<0)  ndstport=3671;
            cs.knx=1;
            continue; 
         }
         else
         if (!strcmp(argv[iDir], "-ntp")) {
            nlisten = 1;
            if (ndstport < 0) ndstport = 123;
            if (!nMsg) { memset(abMsg, 0, 48); abMsg[0]=27; nMsg=48; }
            cs.ntp=1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:
         if (!szDstIP[0])
            { strcopy(szDstIP, argv[iDir]); continue; }
         if (ndstport < 0)
            { ndstport = atol(argv[iDir]); continue; }
         if (cs.knx) {
            int iLen = parseKnxReq(abMsg, argv[iDir]);
            if (iLen < 0)
               return 9;
            nMsg += iLen;
            continue;
         }

         // join data parts
         char *ppart = argv[iDir];
         if (strBegins(ppart, "0x")) {
            char *pszHex = ppart+2;
            int iLen = strlen(pszHex);
            bool bSkipFirst = (iLen & 1) ? 1 : 0;
            szBuf[0] = '0';
            while (*pszHex) {
               if (bSkipFirst)
                  bSkipFirst = 0;
               else
                  szBuf[0] = *pszHex++;
               if (!*pszHex) return 9+perr("wrong hex format: %s\n",ppart);
               szBuf[1] = *pszHex++;
               if (!isxdigit(szBuf[0])) return 9+perr("wrong hex format: %s\n",ppart);
               if (!isxdigit(szBuf[1])) return 9+perr("wrong hex format: %s\n",ppart);
               abMsg[nMsg++] = (uchar)strtol(szBuf, 0, 0x10);
               if (nMsg > nMsgMax) return 9+perr("data too long"); 
            }
         } else {
            int nlen = strlen(ppart);
            if (nMsg+nlen > nMsgMax) return 9+perr("data too long"); 
            memcpy(abMsg+nMsg, ppart, nlen);
            nMsg += nlen;
         }
      }

      if (cs.knx && !bTCP && !nMsg)
         return 9+perr("missing data to send. type \"sfk help knx\" for examples.");

      if (bTCP)
         tcpClient(szDstIP, ndstport, nlisten, nownport, abMsg, nMsg, nTimeout);
      else
         udpSend(szDstIP, ndstport, nlisten, nownport, abMsg, nMsg, nTimeout, 0);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "tolog") || !strcmp(pszCmd, "netlog") || !strcmp(pszCmd, "tonetlog"))
   {
      ifhelp (   !strcmp(pszCmd, "netlog") 
              || ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
             )
      bool bFullHelp = ((iDir < argc) && (!strcmp(argv[iDir], "-full")));
      printx("<help>$sfk tolog [-help]\n"
             "$sfk tonetlog [server[:port]]]]|[port]\n"
             "\n"
             "   Send text output of a command to terminal, and/or append\n"
             "   it to a log file, and/or send it to a network text viewer.\n"
             "   The log target(s) can be specified in the following ways:\n"
             "\n"
             "   1. by defining an environment variable:\n"
             "\n"
             "      #<exp> SFK_LOGTO=net[:hostname[:port][,raw]]\n"
             "      #<exp> SFK_LOGTO=file:mylog.txt\n"
             "      #<exp> SFK_LOGTO=term\n"
             "\n"
             "      where targets can be combined like:\n"
             "\n"
             "      #<exp> SFK_LOGTO=term,file:log.txt,net,duplex\n"
             "\n"
             "   2. by using #tonetlog<def> to force sending by network.\n"
             "      in that case, a hostname and port can be specified\n"
             "      as parameters. the default is to send to localhost.\n"
             "\n"
             "   If no log target is specified all text goes to terminal.\n"
             "\n"
             "   A recommended #GUI tool<def> to view and filter network text\n"
             "   is #Depeche View<def>. Type #sfk getdv<def> to download, then run\n"
             #ifdef _WIN32
             "   the tool by #dview -net<def> for instant net text display.\n"
             "   It runs with Windows, and on Linux/Mac using WINE.\n"
             #else
             "   the tool by #wine ./dview -net &<def>\n"
             #endif
             "\n"
             "   $parameters<def>   (with tonetlog only)\n"
             "      server    IP or name of target machine to send text to.\n"
             "      port      target port, default is 21323 (SFK UDP Text).\n"
             "                you may also type a port without \"server:\".\n"
             "\n"
             "   $options\n"
             "      -h[elp]   print this help text (same as \"sfk netlog\").\n"
             "      -duplex   request a reply for each message sent.\n"
             "                much slower, but it is made sure that the\n"
             "                receiver actually receives all text, which\n"
             "                is not sure without -duplex.\n"
             "      -timeout=n with -duplex: time to wait for a reply.\n"
             "                default is 1000 msec.\n"
             "      -delay=n  if not using -duplex then wait so many msec\n"
             "                after each message sent (default is 10).\n"
             "                delay is required with longer text as\n"
             "                receiver may fail to cache all messages.\n"
             "      -raw      send raw UDP text without sfktxt header.\n"
             "                cannot be combined with -duplex.\n"
             "      -toiso[=c] or just -iso converts utf8 to iso-8859-1\n"
             "                with default character c for non-8bit codes.\n"
             "      -nolf     do not append LF after single line text.\n"
             "      -usecr    append CR instead of LF after single line text.\n"
             "      -clear    clear target log. cannot be used with -raw.\n"
             "      -verbose  tell log target if taken from environment.\n"
             "      -recsize=n UDP max message size, default is 1000 bytes.\n"
             "\n"
             "   $SFK_LOGTO accepted fields<def>\n"
             "      term,file,net,raw,duplex,timeout,delay,toiso,nolf\n"
             "\n"
             );
      printx("   $Send And Forget versus Duplex Transfer\n"
             "      By default, SFK netlog sends text #without checking\n"
             "      #if it arrives at receiver<def>. This is the way that\n"
             "      plain UDP works, and it makes sense for scripts\n"
             "      that shall #NOT slow down or even stop<def> just because\n"
             "      the receiver is too slow, or not present at all.\n"
             "      However, #it is NOT guaranteed that all text arrives\n"
             "      #in complete, or in the same order as sent<def>.\n"
             "      If text is lost you may increment the -delay, or use\n"
             "      the #-duplex<def> option. With duplex, however,\n"
             "      #non listening or slow receivers<def> will cause #delays<def>\n"
             "      and #error messages<def> and may #stop command execution<def>.\n"
             "\n");
      printx("   $Working process example: remote compile scripts\n");
      if (!bFullHelp)
      printx("      Type \"sfk netlog -full\" for example scripts how to run\n"
             "      batch files on remote machines and view their output.\n"
             "\n");
      else
      printx("\n"
             "   Cross platform software development often means to edit\n"
             "   under Windows, and to compile on a remote Linux build server.\n"
             "   Terminal output of a command line compiler should be sent\n"
             "   back to the Windows machine for display. This can be done like:\n"
             "\n"
             "   --- Example Windows batch file for upload: ---\n"
             "   set FTPOPT=-nohead -quiet -noprog 192.168.1.200\n"
             "   set NETLOG=sfk filter \"-! files of*sent\" +tonetlog\n"
             "   sfk echo \"build on remote server\" +tonetlog\n"
             "   sfk sel myproject .cpp .hpp +sft %%FTPOPT%% cput -yes | %%NETLOG%%\n"
             "   sfk sft -pw=foo %%FTPOPT%% run \"./rcomp.sh\" | %%NETLOG%%\n"
             "\n"
             "   --- Example Linux rcomp.sh for compile: ---\n"
             "   export SFK_LOGTO=net:192.168.1.100\n"
             "   sfk echo -spat \"[[green]compiling on build server\" +tolog\n"
             "   bash compile.sh 2>&1 | sfk filter -high Red error +tolog\n"
             "\n"
             "   This will upload changed files from a Windows machine .100\n"
             "   to a Linux machine .200, with the upload status sent directly\n"
             "   to the netlog on the same (Windows) machine. It is assumed that\n"
             "   sfk sftserv -run -runpw=foo is running on the Linux server.\n"
             "\n"
             "   Then, a Linux batch \"rcomp.sh\" is executed under Linux,\n"
             "   which again calls the actual build script \"compile.sh\".\n"
             "   All status and error text is sent to the netlog viewer, usually\n"
             "   Depeche View running on the Windows machine. With DView Pro this\n"
             "   tool is also the text editor, and the Windows upload batch can\n"
             "   be run directly by a hotkey or extended mouse button from within\n"
             "   DView via config file commands.\n"
             "\n");
      printx("   $see also\n"
             "      sfk fromnet -help   - print incoming network text\n"
             "      sfk udpsend         - send UDP text and binary messages\n"
             "      sfk udpdump         - print incoming raw UDP messages\n"
             "      sfk append          - append text output to a file\n"
             "      sfk echo            - for the list of possible colors\n"
             "      sfk view            - more about the text viewer program\n"
             "      sfk samp cppnetlog  - sample C++  code for sending text\n"
             "      sfk samp javanetlog - sample Java code for sending text\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk echo \"[[Red]]foo[[def]] and [[Blue]]bar[[def]]\" +tonetlog\n"
             "        sends colored text to a viewer on the same machine.\n"
             "        Red with big 'R' sends bright color, 'r'ed sends dark.\n"
             #ifdef _WIN32
             "        Type #sfk getdv<def> then #dview -net<def> to download\n"
             "        and run the Depeche View network text viewer tool.\n"
             #else
             "        Type #sfk getdv<def> then #./dview -net &<def> to download\n"
             "        and run the Depeche View network text viewer under wine.\n"
             #endif
             "\n"
             #ifdef _WIN32
             "      #dir | sfk tonetlog 192.168.1.100\n"
             #else
             "      #ls -la | sfk tonetlog 192.168.1.100\n"
             #endif
             "        send output of a folder listing to machine .100\n"
             "\n"
             "      #<exp> SFK_LOGTO=term,net:192.168.1.100\n"
             #ifdef _WIN32
             "      #cl mysrc.c 2>&1 | sfk tolog\n"
             #else
             "      #gcc mysrc.c 2>&1 | ./sfk tolog\n"
             #endif
             "        sends output of a command \"gcc\" as UDP text both\n"
             "        to terminal and to a text viewer running on .100\n"
             "\n"
             "      #<exp> SFK_LOGTO=term,net,duplex,timeout:3000\n"
             #ifdef _WIN32
             "      #cl mysrc.c 2>&1 | sfk tolog\n"
             #else
             "      #gcc mysrc.c 2>&1 | ./sfk tolog\n"
             #endif
             "        similar to above, but sends output to a viewer on the\n"
             "        local machine, asking for receipts within 3 seconds.\n"
             "\n"
             "      #<exp> SFK_LOGTO=file:log1.txt,net:192.168.1.30:5000,raw\n"
             "      #sfk list mydir +tolog\n"
             "        append filename list of folder mydir to log1.txt and\n"
             "        send it as raw network text to machine .30 port 5000.\n"
             "\n"
             #ifdef _WIN32
             "      #dview -net:3000,ip<def>\n"
             #else
             "      #wine dview.exe -linux -net:3000,ip &<def>\n"
             #endif
             "        runs dview on port 3000 with sender ip display.\n"
             "\n"
             "      #sfk tail -f mylog.txt +tonetlog .229:3000 +loop\n"
             "        whenever mylog.txt changes, send changed text lines\n"
             "        to a machine ending with .229 in the same subnet\n"
             "        on port 3000.\n"
             );
      ehelp;
      
      char *pszDstHost = 0;
      int   iDstPort   = 21323;
      bool  bVerbose   = 0;
      bool  bNoLF      = 0;
      bool  bUseCR     = 0;
      bool  bNoLine    = 0; // deprecated
      bool  bNetLogCmd = strstr(pszCmd, "netlog") ? 1 : 0;
      bool  bFromEnv   = 0;
      int   iCacheSize = 1000;
      const char *pszOpenMode = "a";

      char szEnvBuf[200];
      char szHostBuf[200];
      char szFilename[512];
      char *pszToken    = 0;
      char *pszFilename = 0;

      bool bToTerm = 0;
      bool bToFile = 0;
      bool bToNet  = bNetLogCmd ? 1 : 0;
      bool bHostParmGiven = 0;

      // init defaults
      sfkNetIO.bClRawText = 0;
      sfkNetIO.bClDuplex  = 0;
      sfkNetIO.iClPackageSize = 1000;
      sfkNetIO.iClTimeout = 1000;

      char *pszEnv = getenv("SFK_LOGTO");
      if (pszEnv) 
      {
         // term,net -> ,term,net
         szEnvBuf[0] = ',';
         strncpy(szEnvBuf+1, pszEnv, sizeof(szEnvBuf)-10);
         szEnvBuf[sizeof(szEnvBuf)-10] = '\0';
         pszEnv = szEnvBuf;
         
         if (!bNetLogCmd && (pszToken = strstr(pszEnv, ",term"))) {
            bToTerm = 1;
            bFromEnv = 1;
         }

         if (!bNetLogCmd && (pszToken = strstr(pszEnv, ",file:"))) {
            bToFile = 1;
            pszToken += 6;
            strcopy(szFilename, pszToken);
            char *psz = strchr(szFilename, ',');
            if (psz) *psz = '\0';
            pszFilename = szFilename;
            bFromEnv = 1;
         }

         if ((pszToken = strstr(pszEnv, ",net"))) 
         {
            bToNet = 1;
            bFromEnv = 1;
            strcopy(szHostBuf, "localhost");
            pszDstHost = szHostBuf;
            pszToken += 4;
            char *pszComma = 0;
            if (*pszToken==':') {
               pszToken++;
               // copy myhost:port,raw,duplex,...
               strncpy(szHostBuf, pszToken, sizeof(szHostBuf)-10);
               szHostBuf[sizeof(szHostBuf)-10] = '\0';
               // look for ,raw,duplex,recsize:n
               pszComma = strchr(szHostBuf, ',');
               // look for :port
               char *pszPort = strchr(szHostBuf, ':');
               if (pszPort) {
                  *pszPort++ = '\0';
                  iDstPort = atoi(pszPort);
               }
            } else {
               pszComma = strchr(pszToken, ',');
            }
            while (pszComma) 
            {
               *pszComma++ = '\0';
               if (!strncmp(pszComma, "raw", 3))
                  sfkNetIO.bClRawText = 1;
               else
               if (!strncmp(pszComma, "duplex", 6))
                  sfkNetIO.bClDuplex = 1;
               else
               if (!strncmp(pszComma, "toiso", 5))
                  cs.toiso = 1;
               else
               if (!strncmp(pszComma, "nolf", 4))
                  bNoLF = 1;
               else
               if (   !strncmp(pszComma, "recsize:", 8)
                   || !strncmp(pszComma, "recsize=", 8)
                  )
               {
                  int iRecSize = atoi(pszComma+8);
                  if (iRecSize < 50 || iRecSize > 2000)
                     return 9+perr("invalid SFK_LOGTO recsize, should be 50 to 1500.");
                  sfkNetIO.iClPackageSize = iRecSize;
               }
               else
               if (   !strncmp(pszComma, "timeout:", 8)
                   || !strncmp(pszComma, "timeout=", 8)
                  )
               {
                  int i = atoi(pszComma+8);
                  sfkNetIO.iClTimeout = i;
               }
               else
               if (   !strncmp(pszComma, "delay:", 6)
                   || !strncmp(pszComma, "delay=", 6)
                  )
               {
                  sfkNetIO.iClNonDuplexSendDelay = atoi(pszComma+6);
               }
               else
                  return 9+perr("wrong SFK_LOGTO option for net: %s\n", pszComma);
               pszComma = strchr(pszComma, ',');
            }  // endwhile
         }  // endif net
      }  // endif env
      
      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-recsize", &pszParm)) {
            if (!pszParm) return 9;
            int i = atoi(pszParm);
            if (i < 50 || i > 2000)
               return 9+perr("invalid -recsize, should be 50 to 1500.");
            sfkNetIO.iClPackageSize = i;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-timeout", &pszParm)) {
            if (!pszParm) return 9;
            int i = atoi(pszParm);
            sfkNetIO.iClTimeout = i;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-delay", &pszParm)) {
            if (!pszParm) return 9;
            sfkNetIO.iClNonDuplexSendDelay = atoi(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-verbose")) {
            bVerbose = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-noline")) {
            bNoLine = 1;
            continue;
         }
         else
         if (!mystricmp(argv[iDir], "-nolf")) {
            bNoLF = 1;
            continue;
         }
         else
         if (!mystricmp(argv[iDir], "-usecr")) {
            bUseCR = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-clear")) {
            sfkNetIO.addCommand(str("clear"));
            pszOpenMode = "w";
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-raw")) {
            sfkNetIO.bClRawText = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-duplex")) {
            sfkNetIO.bClDuplex = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:
         if (bNetLogCmd && !bHostParmGiven) 
         {
            bHostParmGiven = 1;
            if (alldigits(argv[iDir])) {
               iDstPort = atoi(argv[iDir]);
               strcopy(szHostBuf, "localhost");
            } else {
               strcopy(szHostBuf, argv[iDir]);
            }               
            pszDstHost = szHostBuf;
            char *psz = strchr(szHostBuf, ':');
            if (psz) {
               *psz++ = '\0';
               if (*psz)
                  iDstPort = atoi(psz);
            }
            continue;
         }
         
         perr("unexpected parameter: %s", argv[iDir]);

         if (!bNetLogCmd)
            pinf("use \"netlog\" to supply a hostname.\n");

         return 9;
      }
      
      // plausi and inits
      if (bToFile) {
         if (!pszFilename)
            return 9+perr("missing log filename\n");
         if (bFromEnv && bVerbose)
            pinf("using file output to %s\n", pszFilename);
      }
      if (bToNet) {
         if (sfkNetIO.bClRawText && sfkNetIO.bClDuplex)
            return 9+perr("netlog: -raw and -duplex cannot be combined.");
         if (iDstPort < 0 || iDstPort > 65535)
            return 9+perr("wrong port number (use 0 to 65535)");
         if (!pszDstHost) {
            strcopy(szHostBuf, "localhost");
            pszDstHost = szHostBuf;
         }
         if (bFromEnv && bVerbose) {
            pinf("using net output to %s:%d with delay=%d\n",
               pszDstHost, iDstPort, sfkNetIO.getTextSendDelay());
         }
         prepareTCP();
      }
      if (!bToFile && !bToNet)
         bToTerm = 1;
      
      if (!chain.usedata)
         myfgets_init();

      FILE *fout = 0;
      if (bToFile && pszFilename)
         if (!(fout = fopen(pszFilename, pszOpenMode)))
            return 9+perr("cannot open for append: %s\n", pszFilename);

      mclear(szLineBuf2);
      int iCacheUsed = 0;

      while (1)
      {
         // read single source line
         int iMaxLineChars = MAX_LINE_LEN - 2;

         char *pAttr = str("");

         if (chain.usedata) 
         {
            if (chain.indata->eod())
               break;
            char *psz = chain.indata->read(&pAttr);
            int iCopy = strlen(psz);
            if (iCopy > iMaxLineChars)
                iCopy = iMaxLineChars;
            memcpy(szLineBuf, psz, iCopy);
            szLineBuf[iCopy] = '\0';

            if (cs.toiso)
               utf8ToIso(szLineBuf);
            if (cs.toutf) {
               bool bSafe = (cs.toutf > 1) ? 1 : 0;
               UTF8Codec::toutf8(szLineBuf2, MAX_LINE_LEN, szLineBuf, bSafe);
               strcopy(szLineBuf, szLineBuf2);
            }

            if (bToTerm)
               printColorText(szLineBuf, pAttr, 1);
         }
         else 
         {
            if (!myfgets(szLineBuf, iMaxLineChars, stdin))
               break;
            szLineBuf[iMaxLineChars] = '\0';

            if (cs.toiso)
               utf8ToIso(szLineBuf);
            if (cs.toutf) {
               bool bSafe = (cs.toutf > 1) ? 1 : 0;
               UTF8Codec::toutf8(szLineBuf2, MAX_LINE_LEN, szLineBuf, bSafe);
               strcopy(szLineBuf, szLineBuf2);
            }

            if (bToTerm)
               fwrite(szLineBuf, 1, strlen(szLineBuf), stdout);
         }

         bool bHaveEOL = 0;
         int iLineLen = strlen(szLineBuf);
         if (    iLineLen > 0
             && (szLineBuf[iLineLen-1]=='\r' || szLineBuf[iLineLen-1]=='\n')
            )
            bHaveEOL = 1;

         if (!bHaveEOL) {
            if (bNoLF) {
               // append nothing
            }
            else
            if (bUseCR || bNoLine) {
               strcat(szLineBuf, "\r");
            } else {
               strcat(szLineBuf, "\n");
            }
            iLineLen = strlen(szLineBuf);
         }

         if (bToFile)
            fwrite(szLineBuf, 1, iLineLen, fout);

         if (bToNet)
         {
            int irc = 0;
            if (!sfkNetIO.isOpen())
               if ((irc = sfkNetIO.initSendReceive("nettext", -1, iDstPort, pszDstHost, 0)))
                  return irc+perr("cannot init UDP (rc=%d)", irc);
                  
            if ((irc = sfkNetIO.addOrSendText(szLineBuf, pAttr)) >= 9)
               return irc+perr("cannot send text (rc=%d)", irc);
         }

      }  // endfor input records

      if (bToTerm)
         fflush(stdout);

      if (fout)
         fclose(fout);

      if (bToNet)
         if (sfkNetIO.hasCachedOutput())
            sfkNetIO.flushSend(0);
      
      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   ifcmd (strBegins(pszCmd, "ip") || strBegins(pszCmd, "ownip"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported
      
      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      printx("<help>$sfk ip [-help], sfk ownips [-help]\n"
             "\n"
             "   list the current machines ip address(es).\n"
             "\n"
             );
      ehelp;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      int   nnum  = 0;
      char *plist = ownIPList(nnum, 0, "\t");
 
      chain.print("%s", plist);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "split"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 2)
      printx("<help>$sfk split partsize inputfile [outputfilebase] [-nov[erify]]]]\n"
             "\n"
             "   reads and splits inputfile into output files of specified size.\n"
             "   if output files exist already, split asks if it may overwrite;\n"
             "   specify -yes to overwrite outputs without asking.\n"
             "\n"
             "   partsize syntax:\n"
             "       100000b  ,  100k        = 100000 bytes\n"
             "       2000000k , 2000m , 2g   = 2 giga-bytes\n"
             "\n"
             "   if outputfilebase is omitted, outputfilenames will be:\n"
             "       inputfile.part1\n"
             "       inputfile.part2\n"
             "       inputfile.part3\n"
             "       ...\n"
             "   if outputfilebase is given, .part1 is appended to this.\n"
             "\n");
      printx("   $options\n"
             "      -yes         always overwrite existing output files.\n"
             "      -nov[erify]  no verify after split.\n"
             "      -altsize     use different method (fseek) to read the\n"
             "                   file size.\n"
             "      -getsize=n[:d] before splitting, read file size n times\n"
             "                   with a delay of d milliseconds (default=100).\n"
             "      -verbose     be verbose about file size results etc.\n"
             "      -buffer=xm   set I/O buffer to x MB (default=100 MB).\n"
             "      -update      do not rewrite existing parts of full size.\n"
             "                   useful when splitting repeatedly a growing\n"
             "                   input file, e.g. during a download.\n"
             "                   -update implies -yes.\n"
             "      -dig[its]=n  set minimum number of digits used for the\n"
             "                   .part extension. since sfk 1.6.5, sfk join\n"
             "                   will autodetect the number of digits.\n"
             "                   if output will be joined with older versions\n"
             "                   of sfk then -digits must stay default (1).\n"
             "      -text        split at line boundaries if possible.\n"
             "                   cannot be combined with -update.\n"
             "\n");
      printx("   $performance notes\n"
             "      the operating system may cache output files, writing\n"
             "      to disk in background after sfk has finished. subsequent\n"
             "      split commands may run slower, even if -noverify is used.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk split 2g c:\\bigfish.avi d:\\transfer\\easy.avi\n"
             "         splits bigfish.avi into easy.avi.part1, .part2 etc.\n"
             "\n"
             "      to rejoin the files, use the sfk join command:\n"
             "\n"
             "      #sfk join d:\\transfer\\easy.avi.part1 e:\\full.avi\n"
             "         joins easy.avi.part1, .part2 etc. into full.avi\n"
            );
      ehelp;

      // default working buffer: 100 mb
      num   nWorkBufSize = 100 * 1000000;
      char *pszSplitSize = 0;
      char *pszSrc       = 0;
      char *pszDstBase   = 0;
      bool  bVerify      = 1;
      int   iGetSizeTries= 1;
      int   iGetSizeDelay=100;
      int   iAltSize     = 0; // use fseek
      bool  bUpdate      = 0;
      int   iDigits      = 1;
      bool  bTextMode    = 0;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-buffer", &pszParm)) {
            if (!pszParm) return 9;
            nWorkBufSize = numFromSizeStr(pszParm, "-buffer");
            if (nWorkBufSize <= 0) return 9;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-getsize", &pszParm)) {
            if (!pszParm) return 9;
            // ntries:delay
            iGetSizeTries = atoi(pszParm);
            char *pszDelay = strchr(pszParm, ':');
            if (pszDelay)
               iGetSizeDelay = atoi(pszDelay+1);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-digits", &pszParm)) {
            if (!pszParm) return 9;
            iDigits = atoi(pszParm);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-dig", &pszParm)) {
            if (!pszParm) return 9;
            iDigits = atoi(pszParm);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-altsize")) {
            iAltSize = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-update")) {
            bUpdate = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nov", 4)) {
            bVerify = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-text")) {
            bTextMode = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }

         // process non-option keywords:
         if (!pszSplitSize) { pszSplitSize = argv[iDir]; continue; }
         if (!pszSrc      ) { pszSrc       = argv[iDir]; continue; }
         if (!pszDstBase  ) {
            pszDstBase = argv[iDir];
            if (isDir(pszDstBase))
               return 9+perr("supply a full output filename, not just a directory name.\n");
            continue; 
         }

         return 9+perr("unexpected parameter: \"%s\" (4)\n",argv[iDir]);
      }

      if (!pszSplitSize) return 9+perr("missing split size\n");
      if (!pszSrc      ) return 9+perr("missing input filename\n");

      num nSplitSize = numFromSizeStr(pszSplitSize);
      if (nSplitSize <= 0)
         return 9+perr("supply a size info like 1048100b 500k 2000m or 2g and a filename.\n");

      if (bTextMode && bUpdate) return 9+perr("-text cannot be combined with -update\n");

      printf("splitting into files of %s bytes each.\n", numtoa(nSplitSize));

      num  nRemain = 0;
      
      // files which are currently written to may need
      // a repeated read of their size.
      for (int i=0; i<iGetSizeTries; i++) 
      {
         if (iAltSize) {
            if ((nRemain = getFileSizeSeek(pszSrc)) < 0)
               return 9+perr("cannot get file size: %s (using seek)\n", pszSrc);
         } else {
            int bIsDir=0, bRead=1, bWrite=1;
            num nFileTime = 0;
            if (getFileStat(pszSrc, bIsDir, bRead, bWrite, nFileTime, nRemain,
                0,0,0, 
                #ifdef _WIN32
                1 // use GetFileAttributesEx as it performs better
                #else
                0
                #endif
                ))
                return 9+perr("cannot get file size: %s\n", pszSrc);
         }
         
         if (iGetSizeDelay > 0)
            doSleep(iGetSizeDelay);

         if (cs.verbose)
            printf("filesize.%d (delay=%d,alt=%d): %s\n", i+1, iGetSizeDelay, iAltSize, numtoa(nRemain));
      }
      
      if (nRemain <= 0)
         return 9+perr("no or empty input file: %s\n", pszSrc);

      uchar *pWorkBuf = new uchar[nWorkBufSize+1000];
      if (!pWorkBuf) return 9+perr("out of memory, cannot allocate working buffer.\n");

      UCharAutoDel odel(pWorkBuf);
      char szAddInfo[200];

      char *pTextBuf    = (char*)abBuf;
      int   iTextBufMax = (int)sizeof(abBuf)-100;
      int   iTextBufCur = 0;

      FILE *fin = fopen(pszSrc, "rb");
      if (!fin)
         return 9+perr("unable to open input file: %s\n", pszSrc);

      if (!pszDstBase)
           pszDstBase = pszSrc;

      int nout    = 1;
      bool ball   = cs.yes || bUpdate;
      num  ntotal = 0;

      SFKMD5 md5;

      bool bbail=0;
      while (!bbail && (nRemain > 0))
      {
         // next output part
         sprintf(szLineBuf, "%s.part%0*d", pszDstBase, iDigits, nout++);
         char *pszDst = szLineBuf;

         if (bUpdate != 0 && getFileSize(pszDst) == nSplitSize)
         {
            // just read input to update checksum, then skip part
            num nLocRemain = nSplitSize;
            while (nLocRemain > 0)
            {
               num nTotalMB = ntotal / 1000000;

               sprintf(szAddInfo, "%s mb", numtoa(nTotalMB));
               info.setStatus("skip ", pszDst, szAddInfo);

               int nMaxRead = nWorkBufSize;
               if (nMaxRead > nLocRemain)
                   nMaxRead = (int)nLocRemain;
               int nread = myfread(pWorkBuf, nMaxRead, fin);
               if (nread <= 0) {
                  perr("input file shrunk unexpectedly, cannot update output.\n");
                  perr("in part %d of %s\n", (nout-1), pszSrc);
                  fclose(fin);
                  return 9;
               }
   
               md5.update(pWorkBuf, nread);
   
               nLocRemain -= nread;
               nRemain -= nread;
               ntotal += nread;
            }
            
            continue;
         }

         if (!ball && fileExists(pszDst))
         {
            info.clear();
            while (1) {
               printf("%s exists, overwrite? (yes/no/all) ",pszDst);
               fflush(stdout);
               char nReply = getYNAchar();
               if (nReply == 'y') break;
               if (nReply == 'a') { ball=1; break; }
               if (nReply == 'n') { fclose(fin); return 5; }
            }
         }
 
         FILE *fout = fopen(pszDst, "wb");
         if (!fout) {
            fclose(fin); 
            return 9+perr("unable to write: %s\n", pszDst); 
         }
         if (cs.debug)
            printf("file: %s\n", pszDst);
          
         // copy binary part until splitsize is reached
         num nLocRemain  = nSplitSize;
         num nLocTotalIn = 0;
         bool bBlockBail = 0;
         while (bBlockBail == 0 && nLocRemain > 0) 
         {
            num nTotalMB = ntotal / 1000000;
            
            // printf("writing %s, %s mb done overall \r", pszDst, numtoa(nTotalMB));
            sprintf(szAddInfo, "%s mb", numtoa(nTotalMB));
            info.setStatus("write", pszDst, szAddInfo);

            int nMaxRead = nWorkBufSize;
            if (nMaxRead > nLocRemain)
                nMaxRead = (int)nLocRemain;
            int nread = 0;
            if (iTextBufCur) {
               // take over remainder from previous block
               if (iTextBufCur > nWorkBufSize)
                  return 9+perr("buffer overflow 1 (%d/%d)", (int)iTextBufCur, (int)nWorkBufSize);
               memcpy(pWorkBuf, pTextBuf, iTextBufCur);
               nread = iTextBufCur;
               iTextBufCur = 0;
               if (cs.debug)
                  printf("use :  takeover %d\n", nread);
            } else {
               nread = myfread(pWorkBuf, nMaxRead, fin);
               if (nread+nLocTotalIn >= nLocRemain && bTextMode != 0) 
               {
                  // completed read of a full intermediate block.
                  // isolate full line at block end.
                  char *pstart = (char*)pWorkBuf;
                  char *pend   = pstart+nread;
                  char *plend  = pend;
                  char *pmin   = pstart;
                  if (nread > iTextBufMax)
                        pmin   = plend - nread;
                  while (plend > pmin && plend[-1] != '\n')
                     plend--;
                  if (plend > pmin) {
                     // split block, take over incomplete line
                     int inow   = plend - pstart;
                     int ilater = pend - plend;
                     if (ilater > iTextBufMax)
                        return 9+perr("buffer overflow 2 (%d/%d)", (int)inow, (int)iTextBufMax);
                     memcpy(pTextBuf, plend, ilater);
                     iTextBufCur = ilater;
                     nread = inow;
                     if (cs.debug)
                        printf("cach:  takeover %d: \"%.*s\"\n", ilater, ilater, pTextBuf);
                     // must stop on this part now
                     bBlockBail = 1;
                  }
               }
            }
            if (nread <= 0) {
               bbail = 1;
               break; // EOF on input
            }

            int nwrite = (int)myfwrite(pWorkBuf, nread, fout);
            if (nwrite != nread) {
               fclose(fout); fclose(fin);
               return 9+esys("fwrite", "error while writing: %s (r=%d w=%d)\n", pszDst, nread, nwrite);
            }

            md5.update(pWorkBuf, nread);

            nLocTotalIn += nread;
            nLocRemain -= nread;
            nRemain -= nread;
            ntotal += nread;

         }  // endwhile locremain
 
         // close output file
         fclose(fout);

         if (cs.verbose)
            info.print("done: %s\n", pszDst);
      }
 
      fclose(fin);

      info.clear();
      
      // in case there are superfluous old output files from previous runs:
      sprintf(szLineBuf, "%s.part%0*d", pszSrc, iDigits, nout);
      char *pszDst = szLineBuf;
      if (fileExists(pszDst))
      {
         while (!ball) {
            printf("%s exists, overwrite? (yes/no/all) ",pszDst);
            fflush(stdout);
            char nReply = getYNAchar();
            if (nReply == 'y') break;
            if (nReply == 'a') { ball=1; break; }
            if (nReply == 'n') { fclose(fin); return 5; }
         }
         // then cleanup at least the first one.
         remove(pszDst);
      }
      
      // cleanup pWorkBuf
      odel.deleteNow();

      char szMD5Write[100];

      printf("%s split into %d files, %s total bytes.\n", pszSrc, nout-1, numtoa(ntotal));
      uchar *pmd5 = md5.digest();
      for (int i=0; i<16; i++)
         sprintf(&szMD5Write[i*2], "%02x", pmd5[i]);
      printf("md5 = %s   %s\n", szMD5Write, bVerify ? "[write ]":"");

      if (bVerify) {
         // run verify of output:
         sprintf(szLineBuf2, "%s.part%0*d", pszDstBase, iDigits, 1);
         if (execJoin(szLineBuf2, 0, 1, szMD5Write))
            return 9+perr("verification of output failed! splitting is incomplete.\n");
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "join"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("<help>$sfk join inputfile.part1 [outputfilebase] [-test]\n"
             "\n"
             "   join many input files into one output file. input files\n"
             "   must have extensions like .part1, .part001 etc.\n"
             "\n"
             "   if outputfilebase is omitted, outputfilename is just\n"
             "   like inputfile, but without the \".part1\" extension.\n"
             "\n"
             "   $options\n"
             "      -test  does not really join the files, but reads all\n"
             "             input files, telling the overall md5 checksum.\n"
             "             join -test is recommended after every \"sfk split\"\n"
             "             command, to verify if the splitted files are ok\n"
             "             and can be rejoined.\n"
             "\n"
             "      -force if the output file exists already, overwrite it\n"
             "             without asking back.\n"
             "\n"
             "   $see also\n"
             "      #sfk split<def>  - split large files into smaller ones\n"
             "      #sfk media<def>  - join files of any name by using sfk\n"
             "                   select -sort ... +media -joinraw\n"
             "                   without checksum verification.\n"
             "      #sfk snapto<def> - join text files into one document\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk join d:\\transfer\\easy.avi.part1 e:\\full.avi\n"
             "         joins easy.avi.part1, .part2 etc. into full.avi\n"
             "\n"
             "      #sfk join -test d:\\transfer\\easy.avi.part1\n"
             "         simulates joining (does not write any output file),\n"
             "         and tells if the input files are ok, by checksum.\n"
            );
      ehelp;

      char *pszFirstInput = 0;
      char *pszDst        = 0;
      bool bTest = 0;

      for (; iDir < argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-test")) {
            bTest = 1;
            continue;
         }

         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unexpected option: %s\n",argv[iDir]);
         }

         // first non-option parm
         if (!pszFirstInput) { pszFirstInput = argv[iDir]; continue; }
         if (!pszDst       ) { pszDst        = argv[iDir]; continue; }

         return 9+perr("unexpected parameter: \"%s\" (5)\n",argv[iDir]);
      }

      if (execJoin(pszFirstInput, pszDst, bTest, 0))
         return 9;

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "partcopy") || !strcmp(pszCmd, "copypart"))
   {
      ifhelp (nparm < 4)
      printx("<help>$sfk partcopy infile offset length outfile [offset2] [-yes]\n"
             "$sfk partcopy infile -allfrom startoffset outfile ...\n"
             "$sfk partcopy infile -fromto startoffset endoffset outfile ...\n"
             "\n"
             "   reads a block of bytes from infile at specified offset,\n"
             "   writing them into another file. if offset2 is specified,\n"
             "   outfile is not created, but the bytes are used to overwrite\n"
             "   other bytes within the output file.\n"
             "\n"
             "   by default, the command $simulates<def>, checking file lengths\n"
             "   but not copying any data. add -yes to really copy contents.\n"
             "\n"
             "   $negative offsets<def> can be used, to specify positions\n"
             "   relative to the $file end<def> instead of file start.\n"
             "\n"
             "   if output offset2 + length is larger than output file size,\n"
             "   the output file is extended. use -noext to avoid this.\n"
             "\n"
             "   length syntax:\n"
             "       100000   ,  100k        = 100000 bytes\n"
             "       2000000k , 2000m , 2g   = 2 giga-bytes\n"
             "\n"
             "   $options\n"
             "      -quiet    do not print number of copied bytes.\n"
             "      -verbose  tell how offsets and lengths are calculated.\n"
             "                type directly after \"partcopy\" for all infos.\n"
             "      -fromto   use this if you don't want to specify offset\n"
             "                and length for the input, but a start and end\n"
             "                offset (with length being end minus start).\n"
             "      -allfrom  copy all from start offset, until end of file.\n"
             "      -noext    do not allow an extension of the output file,\n"
             "                stop with error if writing beyond output end.\n"
             "      -append   if given after output filename, data is added\n"
             "                to the end of the output file.\n"
             "\n"
             "   $see also\n"
             "      $sfk media<def>     keep or cut multiple parts of a file\n"
             "      $sfk hexdump<def>   -offlen offset len infile\n"
             "      $sfk hexfind<def>   infile -bin /hexvalues/\n"
             "      $sfk hextobin<def>\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk partcopy first.dat 10000 50 second.dat 500000\n"
             "         copies 50 bytes from first.dat at offset 10000 into\n"
             "         second.dat (which should exist) at offset 500000\n"
             "\n"
             "      #sfk partcopy first.dat -fromto 0x2710 0x2950 second.dat\n"
             "         input start and end offset in hexadecimal numbers,\n"
             "         output file is created (no output offset given).\n"
             "\n"
             "      #sfk partcopy in.txt -allfrom 1000 out.txt -append\n"
             "         take from in.txt all data from offset 1000 until end\n"
             "         and append that to out.txt.\n"
             "\n"
             "      #sfk partcopy in.dat -fromto -1000 -900 out.dat -500\n"
             "         take from in.dat all bytes from end minus 1000\n"
             "         until end minus 900, i.e. a 100 bytes block, and\n"
             "         write this into output at end minus 500 bytes.\n"
             "         (type -verbose after partcopy for details.)\n"
             );
      ehelp;

      char  *pszSrc     = 0;
      char  *pszDst     = 0;
      num    nSrcOff    = 0;
      num    nDstOff    = 0;
      num    nCopyLen   = 0;
      num    nSrcEnd    = 0;
      bool   bDelDst    = 0;
      bool   bAbsolute  = 0;
      bool   bAllFrom   = 0;
      bool   bHaveSrcOff= 0;
      bool   bHaveDstOff= 0;
      bool   bDstAppend = 0;
      bool   bNoExt     = 0;

      char   sz1[50],sz2[50],sz3[50];

      int nstate = 1;
      for (; iDir<argc; iDir++) 
      {
         char *pszArg = argv[iDir];

         if (!strcmp(pszArg, "-fromto")) {
            bAbsolute = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-allfrom")) {
            bAllFrom = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-noext")) {
            bNoExt = 1;
            continue;
         }
         else
         if (strBegins(pszArg, "-append")) {
            pszArg = str("-0");
            // fall through
         }
         else
         if (*pszArg == '-' && isdigit(pszArg[1])) {
            // fall through
         }
         else
         if (*pszArg == '-') {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }

         // process non-option keywords:
         switch (nstate++) {
            case 1:
               pszSrc = pszArg;
               continue;
            case 2: 
               nSrcOff = myatonum(pszArg);
               bHaveSrcOff = 1;
               if (bAllFrom)
                  nstate++;
               continue;
            case 3:
               if (bAbsolute) {
                  nSrcEnd = myatonum(pszArg);
               } else {
                  nCopyLen = numFromSizeStr(pszArg, "length");
               }
               continue;
            case 4: 
               pszDst = pszArg;
               continue;
            case 5:
               if (!strcmp(pszArg, "-0")) {
                  if (cs.verbose)
                     printf("append to end of output file.\n");
                  bDstAppend = 1;
               }
               nDstOff = myatonum(pszArg);
               bHaveDstOff = 1;
               continue;
         }

         return 9+perr("unexpected parameter: \"%s\" (10)\n",pszArg);
      }

      if (!pszSrc)
         return 9+perr("missing input filename");
      if (!pszDst)
         return 9+perr("missing output filename");
      if (!bHaveSrcOff)
         return 9+perr("missing input offset");

      FileStat ofsInOut;
      if (ofsInOut.readFrom(pszSrc, 0, 1))
         return 9+perr("no such input file: %s", pszSrc);

      num nInFileSize = ofsInOut.getSize();

      if (nSrcOff < 0) {
         if (cs.verbose)
            printf("mapping source offset: %s = %s %s\n",
               numtoa(nInFileSize + nSrcOff, 0, sz1),
               numtoa(nInFileSize, 0, sz2),
               numtoa(nSrcOff, 0, sz3)
               );
         nSrcOff = nInFileSize + nSrcOff;
      }

      if (bAllFrom) {
         if (cs.verbose)
            printf("mapping copy length  : %s = %s - %s\n",
               numtoa(nInFileSize - nSrcOff, 0, sz1),
               numtoa(nInFileSize, 0, sz2),
               numtoa(nSrcOff, 0, sz3)
               );
         nCopyLen = nInFileSize - nSrcOff;
      }

      if (bAbsolute == 1) {
         if (nSrcEnd < 0) {
            if (cs.verbose)
               printf("mapping source end   : %s = %s %s\n",
                  numtoa(nInFileSize + nSrcEnd, 0, sz1),
                  numtoa(nInFileSize, 0, sz2),
                  numtoa(nSrcEnd, 0, sz3)
                  );
            nSrcEnd = nInFileSize + nSrcEnd;
         }
         if (cs.verbose)
            printf("mapping copy length  : %s = %s - %s\n",
               numtoa(nSrcEnd - nSrcOff, 0, sz1),
               numtoa(nSrcEnd, 0, sz2),
               numtoa(nSrcOff, 0, sz3)
               );
         nCopyLen = nSrcEnd - nSrcOff;
         if (nCopyLen < 0)
            return 9+perr("end offset is lower than start offset");
      }

      if (nCopyLen <= 0)
         return 9+perr("invalid copy length: %s\n", numtoa(nCopyLen));

      // output offset is optional.
      num nOutFileSize = -1;
      if (bHaveDstOff) {
         nOutFileSize = getFileSize(pszDst);
         if (nOutFileSize < 0)
            return 9+perr("no such output file: %s", pszDst);
         if (bDstAppend)
            nDstOff = nOutFileSize;
         else
         if (nDstOff < 0)
            nDstOff = nOutFileSize + nDstOff;
         if (nDstOff > nOutFileSize)
            return 9+perr("output offset %s is larger than output file (%s)\n",
               numtoa(nDstOff, 0, sz1), numtoa(nOutFileSize, 0, sz2));
      } else {
         bDelDst = 1;
         nDstOff = 0;
      }

      num nSrcOffMax = nSrcOff + nCopyLen;
      if (nInFileSize < nSrcOffMax)
         return 9+perr("input file %s has a size of %s bytes, cannot copy requested part.",pszSrc,numtoa(nInFileSize));

      cs.sim = !cs.yes;

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      if (cs.sim && !bDelDst) {
         // check target file size
         if (nOutFileSize < 0)
            return 9+perr("no such output file: %s", pszDst);
         num nDstOffMax = nDstOff + nCopyLen;
         if (nDstOffMax > nOutFileSize) {
            if (bNoExt)
               return 9+perr("would copy beyond end of output file (%s).\n", numtoa(nOutFileSize));
            if (cs.verbose)
               printf("output file has a size of %s bytes and will be extended.\n", numtoa(nOutFileSize));
         }
      }

      FILE *fin = fopen(pszSrc, "rb");
      if (!fin) return 9+perr("unable to open input file: %s\n", pszSrc);

      FILE *fout = 0;
      if (!cs.sim) {
         fout = fopen(pszDst, bDelDst ? "wb" : "r+b");
         if (!fout) { fclose(fin); return 9+perr("unable to write: %s\n", pszDst); }
      }

      // seek to target locations
      if (myfseek(fin, nSrcOff, SEEK_SET)) {
         fclose(fin); if (fout) fclose(fout);
         return 9+perr("unable to seek within source file\n");
      }
      if (!cs.sim && myfseek(fout, nDstOff, SEEK_SET)) {
         fclose(fin); fclose(fout);
         return 9+perr("unable to seek within target file\n");
      }

      // verbose info during simulation          
      if (cs.sim || cs.verbose) {
         printf("copying %s bytes, ",numtoa(nCopyLen));
         printf("from input offset %s ",numtoa(nSrcOff));
         printf("to %s, ",numtoa(nSrcOffMax));
         printf("to target offset %s\n",numtoa(nDstOff));
      }

      // copy binary part
      num nRemain = nCopyLen;
      num nTotal  = 0;
      while (nRemain > 0) 
      {
         int nMaxRead = sizeof(abBuf);
         if (nMaxRead > nRemain)
             nMaxRead = (int)nRemain;

         int nread = fread(abBuf, 1, nMaxRead, fin);
         if (nread <= 0) {
            perr("unable to fully read part from %s, copy failed", pszSrc);
            lRC = 9;
            break; // EOF on input
         }

         if (fout) {
            int nwrite = myfwrite(abBuf, nread, fout);
            if (nwrite != nread) {
               esys("fwrite", "error while writing: %s   \n", pszDst);
               lRC = 9;
               break;
            }
         }

         nRemain -= nread;
         nTotal  += nread;
      }

      if (fout) {
         fclose(fout);
         if (cs.keeptime)
            ofsInOut.writeTo(pszDst, __LINE__);
      }
      fclose(fin);

      if (!lRC && !cs.quiet) {
         if (cs.sim)
            printx("$[add -yes to really copy data.]\n");
         else
            printf("%s bytes copied.\n", numtoa(nTotal));
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "media"))
   {
      ifhelp(!chain.usefiles && (nparm < 1))
      printx("<help>$sfk media infile.mpg -keep n1-n2 -cut n3-n4 -tofile out.mpg\n"
             "$sfk media infile.m3u -keepbook -tofile out.mpg\n"
             "$sfk list mydir .m3u +media -keepbook -to outdir<sla><run>base.mpg\n" 
             "\n"
             "   cuts mpeg2 video or other binary file(s), by keeping or\n"
             "   dropping parts given as absolute byte positions in the file.\n"
             "\n"
             "   sfk media $does not interpret, decode or encode any video data<def>,\n"
             "   and knows nothing about the file format. it simply $copies\n"
             "   $blocks of bytes<def>, which $may or may not work<def>, depending on the\n"
             "   file format (mpeg2 is best), media player (VLC is best) and\n"
             "   installed codecs of the operating system. This command is\n"
             "   $not suitable<def> for mpeg4 or any format using file headers.\n"
             "\n"
             "   Splitting or reducing an mpeg2 file usually keeps the result\n"
             "   playable in media players. Joining multiple mpeg2 files into\n"
             "   one file strictly requires post processing by ffmpeg,\n"
             "   to recalculate PCR time stamps required for playback.\n"
             "\n"
             "   $parameters for cutting and post processing\n"
             "     -keep n1-n2 - keep this part of the file, from byte offset n1\n"
             "                   until before n2 (excluding offset n2), and cut\n"
             "                   everything before and after. keep must be given\n"
             "                   before any \"cut\" parameters.\n"
             "                   n1 means an absolute byte position like 12345.\n"
             "                   one \"keep\" can be followed by multiple n-n.\n"
             "     -cut n1-n2  - cut this part. multiple cut parameters can be\n"
             "                   given, and they can refer to an area within\n"
             "                   a \"keep\" range.\n"
             "     infile.m3u  - use a VLC player bookmark file instead of\n"
             "                   specifying file and positions manually.\n"
             "                   takes only the last entry in that file.\n"
             "                   file must contain an even number of start/end\n"
             "                   positions of sections to keep.\n"
             "     -keepbook   - only with .m3u files: keep all parts\n"
             "                   marked by a bookmark at start and end of part\n"
             "     -joinraw    - join all input files or parts into one output.\n"
             "                   with mpeg video, the output file will NOT work\n"
             "                   correctly in players due to wrong timestamps\n"
             "                   and therefore requires post processing like:\n"
             "                   ffmpeg -i in.mpg -target pal-dvd -c copy out.mpg\n"
             "                   (without -target, the output will have no sound)\n"
             "     -fix parm   - create a temporary file (with -tmp in filename)\n"
             "                   then run ffmpeg to fix the output file by re-\n"
             "                   rendering timestamps. \"parm\" is passed to ffmpeg\n"
             "                   as is, except for two special values which are\n"
             "                   extended like:\n"
             "                      pal-dvd  = -target pal-dvd  (for pal output)\n"
             "                      ntsc-dvd = -target ntsc-dvd (for ntsc output)\n"
             "                   requires ffmpeg 1.2 in the PATH. temporary files\n"
             "                   are cleaned automatically, use -keeptmp to keep.\n"
             "     -joinfull p - run joinraw and -fix p in one go. required to\n"
             "                   produce mpeg2 video suitable for playback.\n"
             "     -tmpdir d   - specify a folder to use for temporary files,\n"
             "                   and create unique filenames within.\n"
             "     -keepall    - keep whole content of input file(s). used only\n"
             "                   with -joinraw.\n"
             "\n"
             );
      printx("   $note:\n"
             "      #- all output files are overwritten without asking back,\n"
             "      #  including temporary files. check the simulation output.\n"
             "      #- check free disk space by \"sfk space\" before processing.\n"
             "      #  options -fix or -joinfull will use double disk space.\n"
             "\n"
             "   $general options\n"
             "      -tofile f    write output to a single file with name f\n"
             "      -to outmask  write multiple input files to output names\n"
             "                   given by a mask, like -to outdir<sla><run>file\n"
             "                   \"sfk help opt\" for details.\n"
             "      -movesrcto x after processing, move every video input file\n"
             "                   to an output folder x. move is done by rename,\n"
             "                   so x must be on same file system as input.\n"
             "                   if an output file of same name exists already\n"
             "                   then add option -force to overwrite.\n"
             "      -yes         really create or overwrite output file\n"
             "      -quiet       do not print part and progress infos\n"
             "      -verbose[=2] tell more details about what is done\n"
             "\n"
             "   $recommended process for video cutting\n"
             "      1. download the VLC media player installer,\n"
             "         run the tool and open an mpeg2 .mpg file.\n"
             "      2. select Playback / Custom bookmarks / manage (CTRL+B).\n"
             "         for every section to $keep<def>, create a bookmark\n"
             "         at the $start<def> and $end<def> of that section.\n"
             "      3. make sure there is an $even<def> number of bookmarks.\n"
             "      4. select Media / Save Playlist (CTRL+Y), select file type\n"
             "         M3U (not m3u8) and save, e.g., to cut01.m3u\n"
             "         (if you used the VLC installer, it will remember M3U\n"
             "          as the preferred export type.)\n"
             "      5. #sfk media cut01.m3u -keepbook -tofile out.mpg\n"
             "      6. if you process further files in the same VLC session,\n"
             "         the M3U files may contain references to many files,\n"
             "         but only the last (newest) entry is used.\n"
             "\n"
             );
      printx("   $see also\n"
             "      $sfk partcopy<def>  - copy a single part of a file\n"
             "      $sfk space [d]<def> - tell free disk space available\n"
             "                      in current of given directory d\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk media in.mpg -keep 100000-200000 -cut 150000-160000\n"
             "         #-tofile out.mpg\n"
             "         keep area from offset 100000 to 200000 (with a length\n"
             "         of 100000 bytes) except for 10000 bytes inbetween.\n"
             "\n"
             "      #sfk media in.mpg -keep 120578-301436 518297-783591\n"
             "         #-tofile out.mpg\n"
             "         keep the two sections and drop the rest.\n"
             "\n"
             "      #sfk media in.m3u -keepbook -tofile out.mpg\n"
             "         keep areas listed in the bookmark M3U file.\n"
             "\n"
             "      #sfk select mydir .m3u +media -keepbook -to out<sla><run>base.mpg\n"
             "         execute all .m3u files from mydir, write output\n"
             "         files to a folder out, with the same relative name\n"
             "         as the input .M3U, but with an .mpg output extension.\n"
             "\n"
             "      #sfk select n:\\dvd1\\part1.vob n:\\dvd1\\part2.vob\n"
             "         #+media -joinraw -tofile out.mpg\n"
             "         join two .vob files into one out.mpg without any\n"
             "         modifications. out.mpg will need post processing\n"
             "         before it can be used in a media player.\n"
             "\n"
             "      #sfk sel -sort d:\\ .vob +media -joinfull pal-dvd\n"
             "         #-tofile out.mpg -tmpdir c:\\tmp\n"
             "         join all .vob files of a PAL dvd, sorted by name,\n"
             "         into one out.mpg and call ffmpeg to fix timestamps.\n"
             "         uses a temporary file in c:\\tmp.\n"
             "\n"
             "      #sfk sel -sort d:\\ .vob +media -joinfull\n"
             "         #\"-target pal-dvd -map 0:0 -map 0:2\"\n"
             "         #-tofile out.mpg -tmpdir e:\\tmp -keeptmp\n"
             "         similar to above, but explicitely passing several\n"
             "         parameters to ffmpeg, selecting dvd output and to\n"
             "         mix channels 0:0 (e.g. video) and 0:2 (e.g. an\n"
             "         audio track with alternative language). temporary\n"
             "         file is stored on another drive and kept, in case\n"
             "         post processing fails and must be done manually.\n"
            );
      ehelp;

      Media &m = Media::current();

      m.reset();

      char  *pszm3u  = 0;
      char  *pszSrc  = 0;
      bool   bHaveInFile = 0;

      int   iSubRC=0;

      int istate = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm  = argv[iDir];
         char *pszParm2 = 0;
         if (!strcmp(pszParm, "-quiet")) {
            cs.verbose = 0;
            cs.quiet   = 1;
            continue;
         }
         else if (!strcmp(pszParm, "-joinraw")) {
            m.bClJoinOutput = 1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-joinfull", &pszParm2)) {
            if (!pszParm2) return 9;
            m.bClJoinOutput = 1;
            m.bClFixOutput = 1;
            m.setFixParms(pszParm2);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-fix", &pszParm2)) {
            if (!pszParm2) return 9;
            m.bClFixOutput = 1;
            m.setFixParms(pszParm2);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-movesrcto", &pszParm2)) {
            if (!pszParm2) return 9;
            if (!isDir(pszParm2))
               return 9+perr("directory not found: %s", pszParm2);
            strcopy(m.szClMoveSrcOutDir, pszParm2);
            continue;
         }
         else if (!strcmp(pszParm, "-keepbook")) {
            m.bClHaveKeep = 1;
            continue;
         }
         else if (!strcmp(pszParm, "-keeptmp")) {
            m.bClKeepTmp = 1;
            continue;
         }
         else if (!strcmp(pszParm, "-scan")) {
            m.bClScan = 1;
            continue;
         }
         else
         switch (istate)
         {
            case 4: // keep
            case 5: // cut
            {
               if (!strcmp(pszParm, "-keep"))
                  { istate=4; continue; }
               if (!strcmp(pszParm, "-cut"))
                  { istate=5; continue; }
               if (*pszParm=='-')
                  { istate=0; break; } // FIX: 1692: generic option
               if (m.iCmd >= MAX_MOV_CMD - 10)
                  return 9+perr("too many keep or cut parameters");
               m.aCmd[m.iCmd]  = (istate==4) ? SFKMOV_KEEP : SFKMOV_CUT;
               if ((iSubRC = atomovrange(pszParm, &m.aBeg[m.iCmd], &m.aEnd[m.iCmd])))
                  return 9;
               m.iCmd++;
               continue;
            }
            // "-parm" or just "parm"
            case 0: // list of keep and/or cut statements
            {
               if (!strcmp(pszParm, "-keep")) {
                  m.bClHaveKeep=1; 
                  istate=4; continue;
               }
               if (!strcmp(pszParm, "-cut"))
                  { istate=5; continue; }
               if (!strcmp(pszParm, "-keepall")) {
                  m.bClHaveKeep=1; 
                  if (m.iCmd > 0)
                     return 9+perr("-keepall is not allowed after other -keep or -cut");
                  m.bClKeepAll=1;
                  continue;
               }
               // else fall through
            }
         }

         // FIX: 1692: general option handling
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }

         // non option keywords
         if (!chain.usefiles && !bHaveInFile) {
            if (endsWithExt(pszParm, str(".m3u")))
               pszm3u = pszParm;
            else
               pszSrc = pszParm;
            continue;
         }

         return 9+perr("unexpected parameter: \"%s\"\n",pszParm);
      }
      
      // auto complete
      if (!m.iCmd && m.bClJoinOutput)
         m.bClKeepAll = 1;

      if (m.bClFixOutput && !listPathAny(str("ffmpeg"), 1))
         return 9+perr("ffmpeg not found within PATH, please install it first.");

      cs.sim = !cs.yes;
   
      if (cs.sim && !cs.nohead) {
         printx("$[simulating:]\n");
      }
         
      if (!chain.usefiles) 
      {
         if (!cs.sim) {
            if (!cs.tomask)
               return 9+perr("missing output filename");
            if (!cs.tomaskfile)
               return 9+perr("use -tofile for single file processing");
         }
         if (pszm3u)
            pszSrc = pszm3u;
         if (iSubRC = execMedia(pszSrc, cs.tomask))
            return iSubRC;
      } 
      else 
      {
         int iDirNext=0;
         if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) 
            return lRC;
         lRC = walkAllTrees(eFunc_Media, lFiles, lDirs, nBytes);
      }

      // in case of joined output:
      if (m.fClOut || (cs.sim && m.bClJoinOutput))
         m.closeOutput();

      if (m.iClDoneTS && !cs.quiet)
         printf("%d time stamps cleared.\n", m.iClDoneTS);

      if (m.iClInvalidFiles)
         perr("%d files are invalid or missing.\n", m.iClInvalidFiles);

      if (m.bClJoinOutput) {
         if (!m.bClFixOutput && cs.tomaskfile) {
            char szNameBuf[SFK_MAX_PATH+10];
            strcopy(szNameBuf, cs.tomask);
            char *pszBase = szNameBuf;
            char *pszExt  = strrchr(szNameBuf, '.');
            if (!cs.quiet && pszExt && !mystricmp(pszExt, ".mpg")) {
               *pszExt++ = '\0';
               printf("to fix timestamps, post process output like:\n");
               printf("ffmpeg -i %s -codec copy %s-fixed.%s\n",
                  cs.tomask, pszBase, pszExt);
            }
         }
      }

      if (cs.sim) {
         printf("%u files would be processed, with %d mb output.\n", 
            m.iClDoneFiles, (int)(m.nClGlobalBytes/1000000));
         if (m.szClRecentOutFile[0]) {
            num nfree = getFreeSpace(m.szClRecentOutFile);
            if (nfree >= 0 && nfree < m.nClGlobalBytes)
               pwarn("not enough disk space for file: %s\n", m.szClRecentOutFile);
         }
         printx("$[add -yes to really copy data.]\n");
      }
      else
      if (cs.quiet<2) {
         printf("processed %u files, with %d mb output.\n", 
            m.iClDoneFiles, (int)(m.nClGlobalBytes/1000000));
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "fuzz"))
   {
      ifhelp (nparm < 2)
      printx("<help>$sfk fuzz infile outfileBaseName [loops command]\n"
             "\n"
             "   change file contents at random, by intention, to test programs\n"
             "   for errors in its input file processing. a maximum of 10 percent\n"
             "   of the data is modified.\n"
             "\n"
             "   outfileBaseName is the output filename WITHOUT extension.\n"
             "   the output filename gets the same extension as the input,\n"
             "   plus an optional prefix if loops are used.\n"
             "\n"
             "   $optional parameters:\n"
             "\n"
             "      loops  run the fuzzing loops times, each time executing\n"
             "             a user defined command. the command string MUST\n"
             "             contain the phrase \"$$outfile\" which is replaced\n"
             "             by the current fuzzed output file.\n"
             "             the amount of modified data is near-zero in the first loop,\n"
             "             and then incremented per further loop, up to max. 10 percent.\n"
             "\n"
             "   $options:\n"
             "      -verbose  tell in detail which byte (offsets) are modified.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk fuzz in.dat tmp\\test 10 \"myprog.exe $$outfile\"\n"
             "          run 10 fuzzing tests, all output to console.\n"
             "\n"
             "      #sfk fuzz in.dat tmp\\test 10 \"myprog.exe $$outfile >$$outfile-report.txt 2>&1\"\n"
             "          run 10 fuzzing tests, output to report files in tmp.\n"
             );
      ehelp;

      char *pszSrc = 0;
      char *pszDst = 0;
      int  nloops = 1;
      char *pszCmd = 0;

      int nstate = 1;
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }

         // process non-option keywords:
         switch (nstate++) {
            case 1: pszSrc = argv[iDir]; continue;
            case 2: pszDst = argv[iDir]; continue;
            case 3: nloops = atol(argv[iDir]); continue;
            case 4: pszCmd = argv[iDir]; continue;
         }

         return 9+perr("unexpected parameter: \"%s\" (12)\n",argv[iDir]);
      }

      if (!pszSrc) return 9+perr("missing input filename");
      if (!pszDst) return 9+perr("missing output filename");
      if (nloops && !pszCmd) return 9+perr("missing user command");

      if (pszCmd && !strstr(pszCmd, "$outfile"))
         return 9+perr("missing phrase $outfile in user command");

      srand((unsigned)time(NULL));

      num nInFileSize = getFileSize(pszSrc);
      if (nInFileSize < 0)
         return 9+perr("no such input file: %s", pszSrc);

      char szOutName[300];
      char *pext = strrchr(pszSrc, '.');
      if (!pext) pext = str(".dat");

      for (int iloop=1; iloop <= nloops; iloop++)
      {
         // change a max. of 10 percent of the data
         num ndensity = (num)iloop * 10000 / (num)nloops;

         FILE *fin = fopen(pszSrc, "rb");
         if (!fin) return 9+perr("unable to open input file: %s\n", pszSrc);

         sprintf(szOutName, "%s-%05u%s", pszDst, (uint)iloop, pext);

         FILE *fout = fopen(szOutName, "wb");
         if (!fout) { fclose(fin); return 9+perr("unable to write: %s\n", szOutName); }
   
         // copy binary part
         num nRemain = nInFileSize;
         num nTotal  = 0;
         num nFuzzed = 0;
         while (nRemain > 0) 
         {
            int nMaxRead = sizeof(abBuf);
            if (nMaxRead > nRemain)
                nMaxRead = (int)nRemain;
   
            int nread = fread(abBuf, 1, nMaxRead, fin);
            if (nread <= 0) {
               perr("unable to fully read part from %s, copy failed", pszSrc);
               lRC = 9;
               break; // EOF on input
            }
   
            // modify buffer bytes at random
            num nshoot = nread * ndensity / 100000;
            for (num i=0; i<nshoot; i++) 
            {
               uint ioff   = (uint)(rand() % nread);
               uchar imod   = (uchar)(rand() & 0xFFUL);
               if (cs.verbose)
                  printf("xor offset %05xh with %02xh\n", ioff, (uint)imod);
               abBuf[ioff] ^= imod;
               nFuzzed++;
            }
   
            if (fout) {
               int nwrite = myfwrite(abBuf, nread, fout);
               if (nwrite != nread) {
                  esys("fwrite", "error while writing: %s   \n", szOutName);
                  lRC = 9;
                  break;
               }
            }
   
            nRemain -= nread;
            nTotal  += nread;
         }
   
         fclose(fout);
         fclose(fin);
   
         if (pszCmd) 
         {
            char szCmd[300];
            char szCmd2[300];

            strcopy(szCmd, pszCmd);

            // replace any number of outfile phrases
            while (1)
            {
               char *psz1 = strstr(szCmd, "$outfile");
               if (!psz1) break;
   
               int nleft = psz1 - szCmd;
               memcpy(szCmd2, szCmd, nleft);
               szCmd2[nleft] = '\0';
   
               strcat(szCmd2, szOutName);
   
               psz1 += 8;
               strcat(szCmd2, psz1);

               strcopy(szCmd, szCmd2);
            }

            // printf("FUZZ.BEGIN       \"%s\"\n", szCmd);

            int iRC = system(szCmd);

            printf("FUZZ.DONE density=%03d fuzzed=%05d %03d = \"%s\"\n",
               (int)(ndensity/10), (int)nFuzzed, (int)iRC, szCmd);
         }
         else
         if (!lRC && !cs.quiet) {
            printf("%s bytes written, %d modified into %s\n", numtoa(nTotal), (int)nFuzzed, szOutName);
         }

      }  // endfor loops

      bDone = 1;
   }

   ifcmd (strBegins(pszCmd, "webreq"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk webrequest [options] http://host[:port]/path\n"
             "$sfk webrequest host:port path [header1 header2 ...]\n"
             "\n"
             "   send a simple http text request and receive a text reply.\n"
             "\n"
             "   any text parameter after host:port is sent as a separate\n"
             "   text line (http header line), with CRLF being appended.\n"
             "\n"
             "   sfk webreq does not support http proxies and chunked\n"
             "   transfer encoding. use sfk wget if you need this.\n"
             "\n"
             "   $options:\n"
             "      -verbose  show exactly what is sent to the server,\n"
             "                with each line prefixed by \"<\".\n"
             "      -quiet    do not print reply header lines.\n"
             "\n"
             "   $see also:\n"
             "      #sfk wget<def>  for text and binary file downloads.\n"
             "      #curl<def>      powerful web request and download tool.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "      #sfk webreq http://127.0.0.1/\n"
             "         send a simple GET for the root page.\n"
             "\n"
             "      #sfk webreq 127.0.0.1:80 / \"Host: foobar.com:80\"\n"
             "         the same, but also add a Host header line.\n"
             "         the \"/\" is converted into a GET ... HTTP1.1 line.\n"
             "\n"
             "      #sfk webreq 127.0.0.1:80 \"GET / HTTP1.1\"\n"
             "         similar, but with the first request line\n"
             "         explicitely defined by the user.\n"
             "\n"
            );
      ehelp;
      
      if (!strcmp(pszCmd, "web"))
         cs.quiet = 1;

      char *pHostPort   = 0;
      int  nFirstReq   = 0;
      int  nMaxReq     = 0;
      bool  bnopath     = 0;
      int  nPort       = 80;
      char *pFullUrl    = 0;

      char  szHost[200];   mclear(szHost);
      char  szUrlBuf[200]; mclear(szUrlBuf);

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-nopath")) {
            bnopath = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         char *psz = argv[iDir];
         // accept also http://host:port/path
         if (!pFullUrl && strBegins(psz, "http://")) {
            pFullUrl = psz;
            strcopy(szUrlBuf, psz);
            pHostPort  = szUrlBuf + strlen("http://");
            char *psz2 = strchr(pHostPort, '/');
            if (!psz2) return 9+perr("incomplete url: %s\n", psz);
            *psz2 = '\0';
            nFirstReq = nMaxReq = iDir;
            continue;
         }
         if (!pHostPort)
            { pHostPort = argv[iDir]; continue; }
         if (!nFirstReq)
            { nFirstReq = nMaxReq = iDir; continue; }
         // continue to loop over further request phrases,
         // until next chain command is found.
         nMaxReq = iDir;
      }

      if (!pHostPort)
         return 9+perr("missing host:port\n");
      if (!nFirstReq && !chain.usedata)
         return 9+perr("no request string or chain input data given.\n");

      strcopy(szHost, pHostPort);
      char *psz1 = strchr(szHost, ':');
      if (psz1) {
         *psz1++ = '\0';
         nPort = atol(psz1);
      }

      prepareTCP();

      struct hostent *pTarget;
      struct sockaddr_in sock;
      SOCKET hSock = socket(AF_INET, SOCK_STREAM, 0);
      if (hSock == INVALID_SOCKET)
         return 9+perr("cannot create socket\n");
      if ((pTarget = sfkhostbyname(szHost)) == NULL)
         return 9+perr("cannot get host: %s\n", szHost);

      memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
      sock.sin_family = AF_INET;
      sock.sin_port = htons((unsigned short)nPort);

      if ((connect(hSock, (struct sockaddr *)&sock, sizeof(sock))) == -1) {
         perr("cannot connect to %s:%u, %s\n", szHost, nPort, netErrStr());
         return 9;
      }

      // szLineBuf3 is the Host: header
      if (nPort == 80) // FIX: 163R5: no longer include default port 80
         snprintf(szLineBuf3, MAX_LINE_LEN, "Host: %s", szHost);
      else
         snprintf(szLineBuf3, MAX_LINE_LEN, "Host: %s:%d", szHost, nPort);
      char *pszHostHead = szLineBuf3;
      
      do
      {
         bool bGotHeaderEnd = 0;
         bool bGotHostHead  = 0;
         char *pline = 0;
         int ireq = nFirstReq; // if any
         while (1)
         {
            // get next input line
            if (chain.usedata) {
               // either from chain input data
               if (chain.indata->eod())
                  break;
               pline = chain.indata->read(0);
               removeCRLF(pline);
            } else {
               // or from command parameters
               if (ireq > nMaxReq)
                  break;
               pline = argv[ireq];
               if (ireq == nFirstReq && strBegins(pline, "http://")) {
                  pline += strlen("http://");
                  pline = strchr(pline, '/');
                  if (!pline) return 9+perr("wrong url: %s\n", argv[ireq]);
               }
               if (ireq == nFirstReq && !startsLikeHttpCommand(pline)) {
                  snprintf(szLineBuf2, MAX_LINE_LEN, "GET %s HTTP/1.1", pline);
                  pline = szLineBuf2;
               }
               ireq++;
            }
            if (striBegins(pline, "host:"))
               bGotHostHead = 1;
            if (!strlen(pline) && !bGotHeaderEnd) {
               // reached end of input header
               bGotHeaderEnd = 1;
               // RFC2616 section 14.23: client MUST send a Host: header.
               // if none was provided, auto-append it now.
               if (!bGotHostHead) {
                  bGotHostHead = 1;
                  sendLine(hSock, pszHostHead);
               }
            }
            sendLine(hSock, pline);
         }
         if (!bGotHostHead) {
            bGotHostHead = 1;
            sendLine(hSock, pszHostHead);
         }
         if (!bGotHeaderEnd) {
            // header must be completed by an empty line
            sendLine(hSock, "");
         }

         bool bfirst = 1;
         int nwebrc = 0;
         int istate = 0;
         int itotal = 0;
         int iLineLen = 0;
         int iContentLen = 0;
         while (!readLineRaw(hSock, szLineBuf, iLineLen))
         {
            if (istate)
               itotal += iLineLen;

            removeCRLF(szLineBuf);

            if (cs.quiet==0 || istate>0)
               chain.print("%s\n", szLineBuf);

            // get reply RC
            if (bfirst) {
               bfirst = 0;
               // HTTP/1.1 200 OK
               char *psz1 = szLineBuf;
               skipToWhite(&psz1);
               nwebrc = atol(psz1);
            }

            // fix: 1692: check for EOD by content length
            if (!istate && striBegins(szLineBuf, "content-length")) {
               char *psz = szLineBuf+14;
               while (*psz && !isdigit(*psz))
                  psz++;
               iContentLen = atoi(psz);
            }
            if (istate && iContentLen && (itotal >= iContentLen))
               break;

            // check for end of header
            if (!szLineBuf[0])
               istate = 1;
         }

         // lRC = nwebrc;
      }
      while (0);

      closesocket(hSock);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   #ifdef VFILENET
   bool bGetDV = 0;

   ifcmd (!strcmp(pszCmd, "wget") || !strcmp(pszCmd, "getdv"))
   {
      bGetDV = strcmp(pszCmd, "getdv") ? 0 : 1;

      ifhelp (nparm < 1 && bGetDV == 0)
      printx("<help>$sfk wget [options] url [outfile|outdir] [options]\n"
             "\n"
             "   download content from a given http:// URL.\n"
             "   an output filename or directory can be specified.\n"
             "   existing output files are overwritten without asking back.\n"
             "\n"
             "   $options:\n"
             "      -proxy     hostname:port of a proxy server. from within a company\n"
             "                 network, it is often required to connect through proxies.\n"
             "                 alternatively, set the environment variable SFK_PROXY :\n"
             #ifdef _WIN32
             "                   #set SFK_PROXY=myproxyhost:8000\n"
             #else
             "                   #export SFK_PROXY=myproxyhost:8000\n"
             #endif
             "                 to find out what proxy your browser is using, see\n"
             "                 - Firefox: tools/options/advanced/network/settings\n"
             "                 - IE: tools/internet options/connections/lan settings\n"
             "      -path2name include web path in generated output name,\n"
             "                 to create unique names on multiple downloads.\n"
             "                 this option is default on chained processing.\n"
             "      -fullpath  recreate the whole web path within output dir.\n"
             "      -nodom     do not include domain name in output name.\n"
             "      -nopath    do not include any path and domain information\n"
             "                 within the output names. will not work if URL\n"
             "                 does not contain any relative filename.\n"
         //  "      -usecache  allow caching of downloads.\n"
             "      -quiet     or -noprog shows no download progress indicator.\n"
             "      -addext    always add a filename extension like .txt, .html\n"
             "                 or .dat even if the URL has no such extension.\n"
             "\n"
             "   $limitations:\n"
             "      although sfk wget can download a list of URLs, it is not\n"
             "      a real webpage downloader/archiver, as this would require\n"
             "      the conversion of html pages to adapt contained links.\n"
             "\n"
             "   $chaining support\n"
             "      output filename chaining is supported.\n"
             "\n"
             "   $see also\n"
             "      #sfk webreq<def>   send a simple web request with instant\n"
             "                   result output to terminal\n"
             #ifndef _WIN32
             "      #wget<def>         linux command for file download\n"
             #endif
             "      #curl<def>         powerful web request and download tool\n"
             "\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "      #sfk wget -proxy myproxy:8000 http://foobar.com/x.zip foo.zip\n"
             "         download x.zip, writing the content into a file foo.zip,\n"
             "         connecting through a proxy server myproxy on port 8000.\n"
             "\n"
             "      #sfk filt urls.txt +wget mydir\n"
             "         if urls.txt contains a list of http:// URLs, load it\n"
             "         and download all contents into mydir. the output names\n"
             "         will include path information found in the source URL.\n"
             "\n"
             "      #sfk filt urls.txt +wget -fullpath mydir +list -big\n"
             "         the same as above, but create the whole dir structure,\n"
             "         and then list biggest files from the downloaded.\n"
             "\n"
             "      #sfk wget -quiet=2 http://server/info.xml tmp.txt +ffilter -nofile\n"
             "         download info.xml from server, write it as file tmp.txt\n"
             "         and instantly print the tmp.txt content to terminal\n"
             "         without any status messages or filename infos.\n"
            );
      ehelp;

      CommandScope oscope("WGet");

      char *pSrcName    = 0;
      char *pDstName    = 0;
      bool  bchained    = chain.useany();
      bool  bpath2name  = bchained;
      bool  bpath2path  = 0;
      bool  bwithdom    = 1;
      bool  bcache      = 0;
      bool  bsynext     = 0;

      if (bGetDV)
      {
         pSrcName = str("http://stahlworks.com/dview.exe");
         #ifdef _WIN32
         pDstName = str(".");
         #else
         pDstName = str("dview-linux.exe");
         #endif
         bpath2name = 0;
      }

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (bGetDV && !strcmp(argv[iDir], "-web")) {
            #ifdef _WIN32
            printx("$opening :<def> %s\n", pSrcName);
            ShellExecute(NULL, "open", pSrcName, NULL, NULL, SW_SHOWNORMAL);
            #endif
            return 0;
         }
         else
         if (!strcmp(argv[iDir], "-path2name")) {
            bpath2name = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-fullpath") || !strcmp(argv[iDir], "-path2path"))
         {
            bpath2path = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-nopath")) {
            bpath2name = bpath2path = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-nodom")) {
            bwithdom = 0;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-usecache")) {
            bcache = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-addext")) {
            bsynext = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pSrcName && !bchained)
            { pSrcName = argv[iDir]; continue; }
         if (!pDstName)
            { pDstName = argv[iDir]; continue; }
         return 9+perr("unexpected parameter: %s\n", argv[iDir]);
      }

      if (bGetDV)
      {
         printx("$download:<def> Depeche View Lite\n"
                "$from URL:<def> %s\n",
                pSrcName
               );
      }
      
      if (!pSrcName && !bchained)      return 9+perr("missing URL\n");

      uint nmode = bpath2name ? 1 : 0;
      if (bpath2path) nmode |= 2;
      if (bwithdom)   nmode |= 4;

      if (pDstName && !isDir(pDstName))
         nmode |= 8; // single output file

      if (bsynext)    nmode |= 16;

      if (chain.usedata)
         chain.convInDataToInFiles();

      if (pSrcName) 
      {
         // TODO: mem/disk caching is yet undefined
         Coi *psrc = bcache ? glblVCache.get(pSrcName) : 0;
         if (!psrc) {
            psrc = new Coi(pSrcName, 0);
            if (!psrc) return 9+perr("out of memory");
            psrc->incref("wget");
         }
         CoiAutoDelete odel(psrc, 1); // with decref

         if (execWGet(psrc, pDstName, nmode)) {
            // download failed
            #ifdef _WIN32
            if (bGetDV)
               printx("You may try #sfk getdv -web<def> to download via web browser.\n");
            #else
            if (bGetDV)
               printx("Please download manually from %s\n", pSrcName);
            #endif
         } else {
            #ifndef _WIN32
            if (bGetDV) {
               // post process: make binary executable
               snprintf(szLineBuf, sizeof(szLineBuf)-10, "chmod +x \"%s\"", pDstName);
               if (system(szLineBuf))
                  perr("cannot set x attribute (%s)\n", szLineBuf);
               // and duplicate to "dview" without .exe
               snprintf(szLineBuf, sizeof(szLineBuf)-10, "cp \"%s\" dview", pDstName);
               if (system(szLineBuf))
                  perr("cannot copy %s to \"dview\"\n", pDstName);
               else {
                  printf("done : ./dview (copy of %s)\n", pDstName);
                  printf("note : please copy \"dview\" into a folder listed in your PATH.\n");
                  char *pszPath = getenv("PATH");
                  if (pszPath)
                     printf("       PATH = %s\n", pszPath);
               }
            }
            #endif
         }

         if (bcache && !psrc->isCached() && psrc->data().src.data) {
            glblVCache.put(psrc->orgName(), psrc, "wget");
         }
      }
      else
      if (chain.usefiles)
      {
         if ((nmode & 8)!=0 && chain.numberOfInFiles()>1)
            return 9+perr("more than 1 input URLs, but no existing output folder given.");

         for (int i=0; i<chain.numberOfInFiles(); i++)
         {
            Coi *pcoi = chain.getFile(i);
            if (!pcoi) return 9+perr("int. #9529726");
            execWGet(pcoi, pDstName, nmode);
         }
      }
      else
         return 9+perr("wrong chain input, need filenames.");

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }
   #endif // VFILENET

   ifcmd (   !strcmp(pszCmd, "filesys") || !strcmp(pszCmd, "fsinfo")
          || !strcmp(pszCmd, "diskspace") || !strcmp(pszCmd, "space")
          || !strcmp(pszCmd, "freespace")
         )
   {
      ifhelp (argc >= 3 && isHelpOpt(argv[2]))
      #ifdef _WIN32
      printx("<help>$sfk diskspace [dirname|-help]\n"
             "$sfk fsinfo [dirname]\n"
             "\n"
             "   show disk space and/or file system informations.\n"
             "   a folder name can be specified which relates\n"
             "   to a specific volume or hard disk.\n"
             "\n"
             "   $options\n"
             "      -byte[s]  all size infos in bytes\n"
             "      -tab[s]   pure values, tab separated\n"
             "      -bin[ary] calculate with binary megabytes\n"
             "                of 1048576 bytes each.\n"
             "\n"
             "   $aliases\n"
             "      $space<def>     - same as diskspace\n"
             "      $filesys<def>   - same as fsinfo\n"
             "      $freespace<def> - tell only free space\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk fsinfo\n"
             "         tell details about the file system of the\n"
             "         current directory (.)\n"
             "\n"
             "      #sfk fsinfo D:\n"
             "         tell about the file system used for drive D:\n"
             "\n"
             "      #sfk space\n"
             "         tell total and free MB of the current volume.\n"
             );
      #else
      // no filesystem (name) infos yet available under linux
      printx("<help>$sfk [-help] diskspace [dirname]\n"
             "\n"
             "   show disk space informations.\n"
             "   a folder name can be specified which relates\n"
             "   to a specific volume or hard disk.\n"
             "\n"
             "   $options\n"
             "      -byte[s]  all size infos in bytes\n"
             "      -tab[s]   pure values, tab separated\n"
             "      -bin[ary] calculate with binary megabytes\n"
             "                of 1048576 bytes each.\n"
             "\n"
             "   $aliases\n"
             "      $space<def>     - same as diskspace\n"
             "      $freespace<def> - tell only free space\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk space /thedir\n"
             "         tell total and free MB of the file system\n"
             "         used in /thedir. This can be a different\n"
             "         volume or medium than the current directory.\n"
             );
      #endif
      ehelp;

      bool bspace = (!strcmp(pszCmd, "diskspace") || !strcmp(pszCmd, "space")) ? 1 : 0;
      bool bfree  = 0;
      char *proot = 0;
      bool btabs  = 0;
      num  nDivisor = 1000000;
      
      if (!strcmp(pszCmd, "freespace"))
         { bspace=1; bfree=1; }

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (strBegins(argv[iDir], "-tab")) {
            btabs = 1;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-byte")) {
            nDivisor = 1;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-bin")) {
            nDivisor = 1048576;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!proot)
            { proot = argv[iDir]; continue; }
         return 9+perr("unexpected parameter: %s", argv[iDir]);
      }

      if (!proot)
         proot = str(".");

      num nTotal=0, nFree=0;
      char szFSName[200];
      char szVolID[200];
      uint nVolID=0;
   
      if (getFileSystemInfo(proot, nTotal, nFree, szFSName, sizeof(szFSName)-10, szVolID, sizeof(szVolID)-10, nVolID))
         return 9+perr("unable to read file system infos.");
         
      char szTotal[100]; mclear(szTotal);
      char szFree[100];  mclear(szFree);

      numtoa(nTotal/nDivisor, 0, szTotal);
      numtoa(nFree/nDivisor, 0, szFree);
      
      const char *pszUnit = (nDivisor > 1) ? "mb":"";

      if (bfree)
         chain.print("%s\n", szFree);
      else
      if (bspace) 
      {
         if (btabs)
            chain.print("%s\t%s\n", szTotal, szFree);
         else
            chain.print("total%s=%s\tfree%s=%s\n", pszUnit, szTotal, pszUnit, szFree);
      }
      else 
      {
         if (btabs)
            chain.print("\"%s\"\t\"%s\"\t%s\t%s\n",
               szFSName, szVolID, szTotal, szFree);
         else
            chain.print("filesys=\"%s\" volume=\"%s\" total%s=%s free%s=%s\n",
               szFSName, szVolID, pszUnit, szTotal, pszUnit, szFree);
      }            

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   const char *pszWPutServerScript =

      "<?php\n"
      "   // example script for storing an uploaded file.\n"
      "   // for some safety, this accepts only files\n"
      "   // named test*.dat without any given path.\n"
      "   // files are stored in same folder as this script.\n"
      "\n"
      "function dostop($s) {\n"
      "   header(\"HTTP/1.0 500 Internal Error\");\n"
      "   die(\"error: \".$s);\n"
      "}\n"
      "\n"
      "   if (!isset($_FILES)) dostop(\"1\");\n"
      "   if (!isset($_FILES[\"file\"])) dostop(\"2\");\n"
      "   if (!isset($_FILES[\"file\"][\"error\"])) dostop(\"3\");\n"
      "\n"
      "   $aUpload = $_FILES[\"file\"];\n"
      "\n"
      "   if ($aUpload[\"error\"] > 0)\n"
      "      die(\"upload error: \".$aUpload[\"error\"]);\n"
      "\n"
      "   $sTmpFilename = $aUpload[\"tmp_name\"];\n"
      "   $sTargetName  = $aUpload[\"name\"];\n"
      "   $sSize        = $aUpload[\"size\"];\n"
      "\n"
      "   // Anyone knowing the script's web address may try to\n"
      "   // upload files, therefore block paths in filenames:\n"
      "   if (strpos($sTargetName, \"/\") !== false) dostop(\"4\");\n"
      "   if (strpos($sTargetName, \"..\") !== false) dostop(\"5\");\n"
      "   if (!strcmp($sTargetName, \".\") !== false) dostop(\"6\");\n"
      "\n"
      "   // furthermore only accept predefined filenames \"test*.dat\"\n"
      "   if (strncmp($sTargetName, \"test\", 4)) dostop(\"7\");\n"
      "   if (strpos($sTargetName, \".dat\") === false) dostop(\"8\");\n"
      "\n"
      "   print(\"type: \".$aUpload[\"type\"].\"<br>\\n\");\n"
      "   print(\"size: \".$aUpload[\"size\"].\"<br>\\n\");\n"
      "\n"
      "   // store file in same folder as this script\n"
      "   $sOwnLocation = $_SERVER[\"PATH_TRANSLATED\"];\n"
      "   $iPath = strrpos($sOwnLocation, \"/\");\n"
      "   if ($iPath === false) dostop(\"9\");\n"
      "   $sAbsTarget = substr($sOwnLocation,0,$iPath+1).$sTargetName;\n"
      "   move_uploaded_file($sTmpFilename, $sAbsTarget);\n"
      "   print(\"success: stored: \".$sTargetName.\" ($sSize bytes).\\n\");\n"
      "?>\n"
      ;

   // experimental
   ifcmd (strBegins(pszCmd, "wput"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk wput [options] http://host[:port]/path filename\n"
             "\n"
             "   POST a file to a webserver.\n"
             "\n"
             "   $options:\n"
             "      -script   print PHP example script that handles a file\n"
             "                upload on a web server. Be aware that anoyone\n"
             "                may post to this script if the address is known,\n"
             "                uploading any content! Therefore the example script\n"
             "                contains some fundamental checks, accepting only\n"
             "                filenames matching a pattern, and without a path.\n"
             "                You may also want to check configured upload limits\n"
             "                (maximum file size) at your web server.\n"
             "      -verbose  print server return code as well as reply lines\n"
             "                starting with \"error: \" or \"success: \".\n"
             "      -verbose=2 print whole server reply.\n"
             "      -quiet    show no progress indicator.\n"
             "\n"
             "   $return code:\n"
             "      0   if web server responded with 200 OK\n"
             "      >0  else the web server code, e.g. 404\n"
             "\n"
             "   $error display:\n"
             "      the server must reply with code 200 OK, otherwise\n"
             "      an error is shown. if the server reply also contains\n"
             "      a line starting with \"error: \" then the error text\n"
             "      is included in the printed error message.\n"
             "\n"
             "   $see also:\n"
             "      #sfk wget<def>  for text and binary file downloads.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "      #sfk wput http://myhost/dopost.php test1.dat\n"
             "         send the file test1.dat to a php script\n"
             "         which then can use move_uploaded_file etc.\n"
             "\n"
             "      #sfk wput -script +tofile postrcv519.php\n"
             "         write upload receiver script for a web server,\n"
             "         with a non-generic name to avoid automatic\n"
             "         detection by scanner scripts.\n"
            );
      ehelp;

      char *pszHostPort    = 0;
      char *pFullUrl     = 0;
      char *pszWebPath   = 0;
      char *pszLocalFile = 0;
      char *pszRelFile   = 0;
      int  nPort         = 80;
      num  nFileSize     = 0;
      bool bShowScript   = 0;
      int  iWebRC        = 0;

      char  szHost[200];   mclear(szHost);
      char  szUrlBuf[200]; mclear(szUrlBuf);

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-script"))
         {
            bShowScript = 1;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) 
         {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:
         char *psz = argv[iDir];
         
         // require http://host:port/path
         if (!pFullUrl && strBegins(psz, "http://")) 
         {
            pFullUrl = psz;
            strcopy(szUrlBuf, psz);
            pszHostPort  = szUrlBuf + strlen("http://");
            char *psz2 = strchr(pszHostPort, '/');
            if (!psz2) return 9+perr("incomplete url: %s\n", psz);
            *psz2++ = '\0';
            pszWebPath = psz2;
            continue;
         }

         if (!pszLocalFile)
         {
            pszLocalFile = argv[iDir]; 
            pszRelFile = relativeFilename(pszLocalFile);
            continue; 
         }

         return 9+perr("unexpected parameter: %s\n", argv[iDir]);            
      }

      if (bShowScript)
      {
         char *psz = (char*)pszWPutServerScript;
         while (psz && *psz)
         {
            char *psz2 = strchr(psz, '\n');
            if (!psz2)
                  psz2 = psz + strlen(psz);
                  
            int iLen = psz2 - psz;
            chain.print("%.*s\n", iLen, psz);
            
            if (*psz2)
               psz = ++psz2;
            else
               break;
         }
      }
      else
      {
         if (!pFullUrl || !pszHostPort)
            return 9+perr("missing host:port\n");
            
         if (!pszLocalFile)
            return 9+perr("missing filename to send.\n");
            
         nFileSize = getFileSize(pszLocalFile);
         if (nFileSize < 0)
            return 9+perr("cannot read: %s\n", pszLocalFile);
   
         strcopy(szHost, pszHostPort);
         char *psz1 = strchr(szHost, ':');
         if (psz1) {
            *psz1++ = '\0';
            nPort = atol(psz1);
         }
   
         prepareTCP();
   
         struct hostent *pTarget;
         struct sockaddr_in sock;
         SOCKET hSock = socket(AF_INET, SOCK_STREAM, 0);
         if (hSock == INVALID_SOCKET)
            return 9+perr("cannot create socket\n");
         if ((pTarget = sfkhostbyname(szHost)) == NULL)
            return 9+perr("cannot get host: %s\n", szHost);
   
         memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
         sock.sin_family = AF_INET;
         sock.sin_port = htons((unsigned short)nPort);
   
         if ((connect(hSock, (struct sockaddr *)&sock, sizeof(sock))) == -1) {
            perr("cannot connect to %s:%u, %s\n", szHost, nPort, netErrStr());
            return 9;
         }
   
         info.setStatus("send", pszLocalFile);
   
         const char *pszBoundary = 
            "---------------------------315712991614773";
         
         char szHeader1[500];
         snprintf(szHeader1, sizeof(szHeader1)-10, 
            "--%s\r\n"
            "Content-Disposition: form-data; name=\"file\"; filename=\"%s\"\r\n"
            "Content-Type: application/octet-stream\r\n"
            "\r\n"
            ,  pszBoundary
            ,  pszRelFile
            );
            
         char szForm[500];
         snprintf(szForm, sizeof(szForm)-10,
            "--%s--\r\n"
            ,  pszBoundary
            );
               
         int iTotalContentLength =
               strlen(szHeader1)
            +  (int)nFileSize
            +  2
            +  strlen(szForm);
   
         snprintf(szLineBuf2, MAX_LINE_LEN,
            "POST /%s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "User-Agent: %s\r\n"
            "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
            "Accept-Language: en-us,en;q=0.5\r\n"
            "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\n"
            "Connection: close\r\n"
            "Content-Type: multipart/form-data; boundary=%s\r\n"
            "Content-Length: %d\r\n"
            "\r\n"
            , pszWebPath
            , pszHostPort
            , getHTTPUserAgent()
            , pszBoundary
            , iTotalContentLength
            );
         if (cs.verbose >= 2) printf("%s", szLineBuf2);         
         send(hSock, szLineBuf2, strlen(szLineBuf2), 0);
         
         if (cs.verbose >= 2) printf("%s", szHeader1);
         send(hSock, szHeader1, strlen(szHeader1), 0);
         
         FILE *fin = fopen(pszLocalFile, "rb");
         if (!fin)
            return 9+perr("cannot read: %s\n", pszLocalFile);
   
         int iTotalSent = 0;         
         while (1)
         {
            int iRead = fread(abBuf, 1, sizeof(abBuf)-10, fin);
            if (iRead <= 0)
               break;
            if (send(hSock, (char*)abBuf, iRead, 0) != iRead)
               { perr("failed to fully send"); break; }
            iTotalSent += iRead;            
            info.setProgress(nFileSize/1000, iTotalSent/1000, "kb");
         }         
         fclose(fin);
   
         send(hSock, "\r\n", 2, 0);
   
         if (cs.verbose >= 2) printf("%s", szForm);
         send(hSock, szForm, strlen(szForm), 0);
         
         char szErrorLine[200];
         mclear(szErrorLine);

         char szSuccessLine[200];
         mclear(szSuccessLine);
   
         // read reply
         bool bfirst = 1;
         int iLineLen = 0;
         while (!readLineRaw(hSock, szLineBuf, iLineLen))
         {
            removeCRLF(szLineBuf);
            
            if (bfirst) 
            {
               bfirst = 0;
               // HTTP/1.1 200 OK
               if (cs.verbose)
                  chain.print("%s\n", szLineBuf);
               char *psz1 = szLineBuf;
               skipToWhite(&psz1);
               iWebRC = atol(psz1);
               continue;
            } 
            else 
            {
               if (cs.verbose >= 2)
               {
                  chain.print("%s\n", szLineBuf);
               }
               else
               if (cs.verbose)
               {
                  if (   striBegins(szLineBuf, "error: ")
                      || striBegins(szLineBuf, "success: ")
                     )
                     chain.print("%s\n", szLineBuf);
               }
               
               if (iWebRC == 500 && cs.quiet < 2 && striBegins(szLineBuf, "error: "))
                  strcopy(szErrorLine, szLineBuf + strlen("error: "));

               if (iWebRC == 200 && cs.quiet < 2 && striBegins(szLineBuf, "success: "))
                  strcopy(szSuccessLine, szLineBuf + strlen("success: "));
            }
         }
   
         closesocket(hSock);

         if (iTotalSent < nFileSize) 
            perr("failed to fully send: %s\n", pszLocalFile);
         else
         if (iWebRC == 200) {
            if (szSuccessLine[0])
               info.print("> %s\n", szSuccessLine);
            else
               info.print("< %s sent, %s bytes.       \n", pszLocalFile, numtoa(nFileSize));
         } else {
            perr("send failed (RC %d%s%s): %s\n", iWebRC, 
               szErrorLine[0] ? ", ":"",
               szErrorLine,
               pszLocalFile);
         }
      }
      
      STEP_CHAIN(iChainNext, 1);

      if (!bShowScript)
         lRC = (iWebRC == 200) ? 0 : iWebRC;

      bDone = 1;
   }

   if (!strcmp(pszCmd, "testattr"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];
      Coi ocoi(pszFile, 0);
      uint nattr = ocoi.getAttr();

      printf("sfkattr %08X:\n", nattr);

      printf("   %c%c%c %c%c%c %c%c%c\n",
         (nattr & (1U << 8)) ? 'r':'-',
         (nattr & (1U << 7)) ? 'w':'-',
         (nattr & (1U << 6)) ? 'x':'-',

         (nattr & (1U << 5)) ? 'r':'-',
         (nattr & (1U << 4)) ? 'w':'-',
         (nattr & (1U << 3)) ? 'x':'-',

         (nattr & (1U << 2)) ? 'r':'-',
         (nattr & (1U << 1)) ? 'w':'-',
         (nattr & (1U << 0)) ? 'x':'-'
         );

      printf("   uid=%d gid=%d stk=%d\n",
         (nattr & (1U << 11)) ? 1:0,
         (nattr & (1U << 10)) ? 1:0,
         (nattr & (1U <<  9)) ? 1:0
         );
         
      bDone = 1;
   }

   if (!strcmp(pszCmd, "fileinfo"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];

      sfkstat_t ostat;

      int bdir=0,bread=0,bwrite=0;
      num  nmtime=0,nsize=0;
   
      num aExtTimes[2];
      memset(aExtTimes, 0, sizeof(aExtTimes));

      if (getFileStat(pszFile, bdir, bread, bwrite,
          nmtime, nsize, aExtTimes, &ostat, sizeof(ostat))) {
         perr("cannot read: %s", pszFile);
      } else {
         // num nctime   = aExtTimes[0];
         // num natime   = aExtTimes[1];
         uint nmode  = (uint)ostat.st_mode;
         uint ninode = (uint)ostat.st_ino;
         uint ndev   = (uint)ostat.st_dev;
         uint nrdev  = (uint)ostat.st_rdev;
         printf("mode=%08Xh inode=%u device=%u rdev=%u\n", nmode, ninode, ndev, nrdev);
         printf("   S_IFDIR  %d\n", (nmode & S_IFDIR ) ? 1 : 0);
         printf("   S_IFCHR  %d\n", (nmode & S_IFCHR ) ? 1 : 0);
         printf("   S_IFREG  %d\n", (nmode & S_IFREG ) ? 1 : 0);
         printf("   S_IREAD  %d\n", (nmode & S_IREAD ) ? 1 : 0);
         printf("   S_IWRITE %d\n", (nmode & S_IWRITE) ? 1 : 0);
         printf("   S_IEXEC  %d\n", (nmode & S_IEXEC ) ? 1 : 0);
         #ifndef _WIN32
         printf("   S_IFIFO  %d\n", (nmode & S_IFIFO ) ? 1 : 0);
         printf("   S_IFLNK  %d\n", (nmode & S_IFLNK ) ? 1 : 0);
         printf("   S_IFBLK  %d\n", (nmode & S_IFBLK ) ? 1 : 0);
         printf("   S_IFSOCK %d\n", (nmode & S_IFSOCK) ? 1 : 0);
         #ifdef SFK_LINUX_FULL
         struct passwd *ppass = getpwuid(ostat.st_uid);
         if (ppass)
         printf("   owner    %s\n", ppass->pw_name);
         #endif
         #endif
      }

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "rawcol"))
   {
      if (argc < 3) return 9;
      int nval = atol(argv[2]);
      SetConsoleTextAttribute(hGlblConsole, nval);
      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "filetime"))
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk filetime [opts] filename\n"
             "\n"
             "   print times available for a file or directory.\n"
             "\n"
             "   $main options\n"
             "      -mtime    print modification time (default)\n"
             "      -atime    print access time\n"
             #ifdef _WIN2
             "      -ctime    print creation time\n"
             #endif
             "      -all      print all available times\n"
             "      -utc      UTC/GMT instead of local time\n"
             "      -flat     print times like 20130413 065127\n"
             "      -flat2    print times like 20130413065127\n"
             "      -tab      separate output by TAB characters\n"
             "      -full     full technical view with all times,\n"
             "                utc, unix and windows timestamps\n"
             "      -noname   do not print filename in output\n"
             /*
             "\n"
             "   $technical view options\n"
             "      -loc[al]  print local time\n"
             "      -utc      print UTC time.\n"
             "      -ux       print the unix time seconds.\n"
             #ifdef _WIN32
             "      -wft      print the windows file time.\n"
             #endif
             */
             "\n"
             "   $see also\n"
             "      #sfk touch<def> - change times of a file\n"
             "      #sfk list<def>  - list files with time and size\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk filetime myfile.txt\n"
             "         print modification time for myfile.txt\n"
             "\n"
             "      #sfk filetime -all myfile.txt\n"
             "         print all times for myfile.txt\n"
             "\n"
             "      #sfk filetime -full myfile.txt\n"
             "         print all times as local, utc and\n"
             "         internal system timestamp values.\n"
             "\n"
             "      #sfk filetime -all -tab -flat2 mydir .txt\n"
             #ifdef _WIN32
             "         list modify, access and creation time for\n"
             #else
             "         list modification and access time for\n"
             #endif
             "         all .txt files in folder mydir as tab\n"
             "         separated data, with each date and time\n"
             "         combined as a flat timestamp.\n"
             );
      ehelp;

      cs.timemask = 0;
      cs.tabform  = 0;
      cs.flatTime = 0;
      
      uint mzone  = 0;
      uint mtype  = 0;
      
      bool bName  = 1;
      bool bCompact = 1;
      bool bUTC   = 0;

      for (; iDir<argc; iDir++) 
      {
         char *pszArg  = argv[iDir];

         // if (strbeg (pszArg, "-loc"  )) { mzone |=  16; continue; } else
         if (strcase(pszArg, "-utc"  )) { bUTC = 1; continue; } else
         // if (strcase(pszArg, "-ux"   )) { mzone |=  64; continue; } else
         // if (strcase(pszArg, "-wft"  )) { mzone |= 128; continue; } else

         if (strcase(pszArg, "-mtime")) { mtype |=   1; continue; } else
         if (strcase(pszArg, "-atime")) { mtype |=   2; continue; } else
         if (strcase(pszArg, "-ctime")) { mtype |=   4; continue; } else
         if (strcase(pszArg, "-all"))   { mtype |=   7; continue; } else

         if (strcase(pszArg, "-flat" )) { cs.flatTime  =   1; continue; } else
         if (strcase(pszArg, "-flat2")) { cs.flatTime  =   2; continue; } else
         if (strbeg (pszArg, "-tab"  )) { cs.tabform   =   1; continue; } else
         if (strbeg (pszArg, "-name" )) { bName        =   1; continue; } else
         if (strbeg (pszArg, "-noname")){ bName        =   0; continue; } else
         if (strcase(pszArg, "-full" )) {
            mzone = 16+32+64+128;
            mtype = 1+2+4;
            bCompact = 0;
            continue;
         }
         else
         if (strbeg (pszArg, "-plain")) {
            mzone = 16;
            mtype =  1;
            cs.flatTime = 1;
            cs.tabform = 1;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         // process non-option keywords:
         break;
      }

      int iDirNext = 0;
      bool bAnyDirParms = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext, &bAnyDirParms))) return lRC;
      if (btest) return 0;
      
      if (!mzone) mzone = 16;
      if (!mtype) mtype = 1;

      cs.timemask = mzone | mtype;

      // if showing only one time type then list no prefix
      uint n = (cs.timemask & 7);
      if (n==1 || n==2 || n==4)
         cs.timemask = cs.timemask & (0xFFFFUL ^ 8);
      else
         cs.timemask |= 8;

      if (bName   ) cs.timemask |= 256;
      if (bCompact) cs.timemask |= 512;
      if (bUTC    ) cs.timemask |= 1024;

      lRC = walkAllTrees(eFunc_FileTime, lFiles, lDirs, nBytes);

      if (chain.coldata) {
         STEP_CHAIN(iDirNext, 1);
      } else {
         STEP_CHAIN(iDirNext, 0);
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "loadlib") || !strcmp(pszCmd, "loaddll"))
   {
      int iChainNext = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // load another library:
         #ifdef _WIN32
         char *pszFile = argv[iDir];
   
         HINSTANCE hlib = LoadLibraryA(pszFile);
         if (hlib != NULL)
            printf("loaded: %s   (%p)\n", pszFile, hlib);
         else
         {
            int nerr = GetLastError();
            char buffer[128];
            buffer[0] = '\0';
            FormatMessageA(
               FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
               NULL, nerr, 
               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
               buffer, sizeof(buffer)-10, NULL);
            printf("failed to load %s : rc=%d %s\n",pszFile,nerr,buffer);
         }
   
         #else
   
      /*
         #ifdef MAC_OS_X
         NSObjectFileImage himg = 0;
         NSObjectFileImageReturnCode hres = 0;
         hres = NSCreateObjectFileImageFromFile(pszFile, &himg);
         if (hres == NSObjectFileImageSuccess) {
            NSModule hmod = NSLinkModule(himg, pszFile, NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_RETURN_ON_ERROR);
            NSDestroyObjectFileImage(himg);
            if (hmod != NULL)
               printf("loaded: %s\n", pszFile);
            else
               printf("failed to load: %s\n", pszFile);
         } else {
            printf("failed to load: %s\n", pszFile);
         }
         #else
         void *plib = dlopen(pszFile, RTLD_NOW);
         if (plib)
            printf("loaded: %s\n", pszFile);
         else
            printf("failed to load: %s\n", pszFile);
         #endif
      */
   
         #endif
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "readtest"))
   {
      if (argc < 3) return 9;
      
      char *pszSrc = argv[2];

      num nstart = getCurrentTime();
      int nlines = 0;

      Coi ocoi(pszSrc, 0);
      if (ocoi.open("rb"))
         return 9+perr("cannot read: %s", pszSrc);
      while (ocoi.readLine(szLineBuf, MAX_LINE_LEN) > 0) {
         nlines++;
         // if (!(nlines & 65535))
         //   { printf("%d lines   \r", nlines); fflush(stdout); }
         printf("%s",szLineBuf);
      }
      ocoi.close();

      num nelaps = getCurrentTime() - nstart;
      fprintf(stderr, "%d lines in %s msec\n",nlines,numtoa(nelaps));

      bDone = 1;
   }

   if (!strcmp(pszCmd, "md5test"))
   {
      SFKMD5 md5;
      uchar adata[] = { 0xFF };
      md5.update(adata, 1);
      uchar *pmd5 = md5.digest();
      mtklog(("test digest: %02X %02X %02X %02X",pmd5[0],pmd5[1],pmd5[2],pmd5[3]));
      printf("test digest: %02X %02X %02X %02X\n",pmd5[0],pmd5[1],pmd5[2],pmd5[3]);
      bDone = 1;
   }

   if (!strcmp(pszCmd, "noop") || !strcmp(pszCmd, "rem"))  // +chaining
   {
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
      }

      int iDirNext = 0;
      if (processDirParms(pszCmd, argc, argv, iDir, 0, &iDirNext)) return 9;

      STEP_CHAIN(iDirNext, 0);

      bDone = 1;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "coninfo"))
   {
      hGlblConsole = GetStdHandle(STD_OUTPUT_HANDLE);
      CONSOLE_SCREEN_BUFFER_INFO oConInf;
      if (!GetConsoleScreenBufferInfo(hGlblConsole, &oConInf)) {
         printf("no console info available.\n");
      } else {
         WORD nAttrib = oConInf.wAttributes;
         printf("cons.attrib:\t0x%02lx\n", nAttrib);
         printf("cons.width :\t%u\n", oConInf.dwSize.X);
         printf("cons.height:\t%u\n", oConInf.dwSize.Y);
      }
      bDone = 1;
   }
   #endif

   /*
      NOTE:
         Between SystemInWinterTime and SystemInDST,
         -  FAT  mtimes and wft are NOT jumping,
         -  NTFS mtimes ARE jumping, wft are NOT jumping.
      SOLUTION:
         -  on Windows, do not read mtime, but use GetFileTime()
            then either convert this back to mtime (with local-
            dst-conversion)
            or store and use it directly in FileStat::writeTo().
            Also think on what to optimize:
            -  unchanged windows filetime
            -  and/or unchanged displayed filetime,
               which is relative to the current system DST mode.
            -  check also what xcopy does.
      TODOS:
        - /S /H /I /R /K /Y /D
        -  x  .  x  .  x  x  .
        - copy write-protected files
        - copy hidden dirs, files by default
        - do NOT copy empty directories
   */
   ifcmd (   !strcmp(pszCmd, "copy")  || !strcmp(pszCmd, "sync")
          || !strcmp(pszCmd, "xcopy") || !strcmp(pszCmd, "xsync")
         )
   {
      bool bext = 0;
      if (pszCmd[0] == 'x') { bext=1; pszCmd++; }

      ifhelp (!chain.usefiles && (argc < 4))

         printx("<help>$sfk copy srcRoot dstRoot [-dir subdir1 subdir2] [-file .ext1 .ext2]\n"
                "$sfk sync srcRoot dstRoot [-dir subdir1 subdir2] [-file .ext1 .ext2]\n"
                "\n");
         if (bext)
         printx("   Extended tree copy (experimental).\n");
         else
         printx("   Directory tree copy, update copy and synchronization.\n");
         printx("\n"
                "   If destination does not yet exist, whole content of source is copied,\n"
                "   #INCLUDING HIDDEN AND SYSTEM FILES.<def> If destination already exists,\n"
                "   only updates are copied.\n"
                "\n"
                "   #Symbolic links are NOT kept<def>, but their content is duplicated. If this\n"
                "   is a problem, use a copy command of your operating system instead.\n"
                "\n"
                "   $copy<def>   copies files from source to destination if the target file\n"
                "          doesn't exist yet, or if the source is NEWER than the target.\n"
                "          copy will NOT copy OLDER files over NEWER files. furthermore,\n"
                "          files that exist in destination but not in source are not removed,\n"
                "          so copy will ADD and REPLACE, but not DELETE.\n"
                "\n"
                "   $sync<def>   nearly same as copy, however files that exist in destination\n"
                "          but not in the source are called STALE files, and are DELETED\n"
                "          if their age is >= %d days. USE WITH CARE. If you specify wrong\n"
                "          folders or file masks, this may delete files unintentionally.\n"
                "          Take a close look at the output of the simulation mode, which\n"
                "          is active by default.\n"
                ,nGlblActiveFileAgeLimit);
         printx("\n"
            //  "   -cache      try to cache many small files in memory before writing\n"
            //  "               them to the target directory.\n"
            //  "   -verify     try(!) to verify files after write. not active by default,\n"
            //  "               as verify may succeed even if files have been corrupted on the\n"
            //  "               target media (written data is often cached by operating system).\n"
                "   -mirror     with sync, copy even older files from source over destination.\n"
                /*
                "   -del        delete files in destination that do not exist in source,\n"
                "               i.e. cleanup trash files. \"sfk copy -del\" is the same\n"
                "               as \"sfk sync\". trash files younger than %d days are called\n"
                "               \"stale\", and are not deleted even with -del specified.\n"
                "   -nodel      do not delete files or directories in destination.\n"
                "               \"sfk sync -nodel\" is the same as \"sfk copy\".\n"
                */
                );
         printx("   -wipe       delete stale files now (ignoring file ages).\n"
                "   -nocopy     with sync, do not copy files, run only delete cleanup.\n"
                "               can be used if you want copy files first with a different\n"
                "               copy program, and then run an sfk sync-delete.\n"
                "   -diff       list files in destination which have been modified after\n"
                "               last copy. Whenever you get a short info \"n differing files\n"
                "               in dest\", add -dif to get their names listed.\n"
                "   -since      or -sincedir/dif/add/chg copies only files selected by age\n"
                "               or difference to another directory. \"sfk list\" for details.\n"
                "   -nohidden   exclude hidden and system files from copy.\n"
                #ifndef _WIN32
                "   -nofollow   do not follow symbolic link directory contents.\n"
                #endif
                "   -stat       in simulation: do not list filenames, only size statistics.\n"
                "   -keepstale=n   change the 30 days limit for stale files until deletion.\n"
                "   -noinfo     do not comment on skipped files.\n"
                "   -rel[names] only with input chaining: strips source root directory names\n"
                "               from filenames. if not selected, absolute paths starting\n"
                "               like C:\\ or /tmp will be stripped automatically.\n"
                "               some chain commands may provide filenames without separate\n"
                "               directories, in this case -relnames will produce an error.\n"
             // "   -mem=mb     during read, data is cached in memory to reduce head movements\n"
             // "               on HD. the buffer size (default=100mb) can be changed here.\n"
                "   -ltarg      always list target filenames (instead of source filenames).\n"
                );
         if (bext)
         printx("   -deep       verify content of files with same time and size. this takes\n"
                "               much time, but is useful if you suspect that some hardware,\n"
                "               esp. usb sticks, sometimes damages files during write.\n"
                "               in this case, add an extra sfk sync -deep call (without -yes),\n"
                "               just to have the files scanned after copy (with usb sticks,\n"
                "               remove and re-insert them first to clear all file caches).\n"
                "\n");
         if (bext)
         printx("   $special options for use with unreliable media (usb sticks):\n"
                "\n"
                "   -sign[meta] write signature databases for later verify, in a subdir\n"
                "               \"zz-shadow-01\" within the target root directory.\n"
                "\n"
                "   -save[meta] write signature databases AND redundant copies of copied\n"
                "               files in destination, within the \"zz-shadow-01\" dir.\n"
                "\n"
                "   -load[meta] reads meta informations from source directory, verifies if\n"
                "               source files have been modified, and if so, takes redundant\n"
                "               shadow copies instead.\n"
                "\n"
                "   -shadow=5m  limit creation of shadow files to small files < 5 mbytes.\n"
                /*
                "   same as above, only more detailed:\n"
                "\n"
                "   -signto     with \"-signto filename\", a signature database is created,\n"
                "               containing content checksums of all source files. it is\n"
                "               recommended to create a signature directory, e.g. e:\\sign,\n"
                "               containing all signature files on the target media.\n"
                "   -check      with \"-check filename\", a signature database is loaded, and all\n"
                "               source files are checked against this database. if the filename\n"
                "               is not found, or the content differs, the file is NOT copied.\n"
                "   -shadow     with -signto, copies every file twice, creating a \"shadow\"\n"
                "               of every file in a parallel target directory \"zz-shadow-01\".\n"
                "               \"sfk sync -check\" will look for shadow files automatically\n"
                "               in case that a (master) file is corrupted.\n"
                "\n"
                */
                );
         printx("\n"
                "   files with whole content being copied are listed in default color.\n"
                "   files that will be deleted during sync are listed in <warn>warning color<def>.\n"
                "   files with differing time but equal content are listed in <time>time color<def>.\n"
                "\n"
               );
         printx("   $completeness and efficiency:\n"
                "   -  under Windows, SFK uses the CopyFileEx API function, which should\n"
                "      be able to copy most file attributes and contents as good and fast\n"
                "      as the XCopy command provided with Windows.\n"
                "   -  under Linux, no native copy function is available, therefore SFK may\n"
                "      not be able to copy all attributes, access rights and timestamps\n"
                "      of the original files. Furthermore, copying can be slower than \"cp\".\n"
                "   -  Directory attributes, access rights and time stamps may not be\n"
                "      completely reproduced both on Windows and Linux.\n"
                "   -  Changes from/to Daylight Saving Time, differing time zones or copies\n"
                "      between FAT and NTFS may always copy files which were copied already.\n"
                "      this is a general problem with all copy commands.\n"
                "\n"
               );
         printx("   $using file system views:\n"
                "      if you want to specify many directory trees and dir/file masks,\n"
                "      you may create a fileset, containing a list of directories.\n"
                "      type \"sfk help fileset\" for details.\n"
                "\n"
                "   #NO WARRANTY FOR DATA INTEGRITY.<def> SFK copy is very convenient to use,\n"
                "   but if you need to copy massive amounts of highly important data, it is\n"
                "   recommended to use the original copy command of your operating system.\n"
                "   Always keep backups of important stuff. After large copies, do some spot\n"
                "   checking if important files were really copied without modifications.\n"
                "   Always double-check the reliability of external media like USB sticks,\n"
                "   e.g. by creating md5 lists (see \"sfk md5gento\").\n"
                "\n"
                );
      // printx("   $see also:\n"
      //        "      #sfk help select<def> - about the file selection syntax.\n"
      //        "\n"
      //        );
         webref(pszCmd);
         printx("   $examples:\n"
                "      #sfk copy c:\\work d:\\arc\\work -dir . <not>\\tmp\\ <not>\\save\\ -file <not>.bak\n"
                "         copy directory tree c:\\work to d:\\arc\\work, excluding all dirs\n"
                "         called tmp or save, including all files except .bak files.\n"
                "\n"
                "      #sfk copy d:\\proj v:\\team\\proj -dir foosys\\include foosys\\source tools\n"
                "         within directory tree proj, copy subdirectory trees foosys\\include,\n"
                "         foosys\\source and tools, including all files therein.\n"
                "\n"
                "      #sfk filter testfiles -+foo +copy \\tmp\n"
                "         copy all files from testfiles containing \"foo\" to \\tmp.\n"
                "\n"
                "      #sfk copy work archive -fileset myflist.txt\n"
                "         copy the files listed in myflist.txt from work to archive.\n"
                "         note that \"-yes\" must be specified directly after \"copy\".\n"
                "         see also \"sfk help fileset\".\n"
                "\n"
                "      #sfk list mydir .txt .doc code.cpp +copy d:\\save\n"
                "         copies all .txt, .doc and code.cpp files from within mydir,\n"
                "         including all subdirs, to d:\\save. ALSO copies mycode.cpp,\n"
                "         subcode.cpp.1 etc. as \"code.cpp\" ist just a pattern.\n"
                "\n"
                "      #sfk list -sincedir mydir1 -dir mydir2 -subdir <not><sla>save<sla>\n"
                "         #-file <not>.bak +copy mydir3\n"
                "         copies all files that were added or changed between mydir1\n"
                "         and mydir2 to mydir3, excluding files in sub folders \"save\",\n"
                "         and excluding .bak files (type whole command in one line).\n"
                "         type \"sfk list\" for more on -sincedir, -sinceadd or -sincedif.\n"
                "\n");
         if (bext)
         printx("      #sfk sync -save x:\\ e:\\ -dir src -wipe\n"
                "         copy directory \"src\" from X: onto usb stick (E:), with checksums\n"
                "         and shadow files, instantly deleting stale files that are found\n"
                "         within E:\\src but not within X:\\src .\n"
                "\n"
                "      #sfk verify e:\\ -all\n"
                "         verifies files on the stick (leave out -all to check only the ones\n"
                "         copied most recently). you must remove and re-insert the stick before\n"
                "         running the verify, otherwise data is taken from cache, leading always\n"
                "         to successful verifies even if files are corrupted.\n"
                "\n"
                "      #sfk sync -load e:\\ z:\\ -dir src\n"
                "         copies files from stick to hard disk (Z:), verifying all source files\n"
                "         before copy. files that fail verification are replaced by shadows.\n"
                "\n"
                "      #sfk copy -save x:\\ e:\\ -dir src -since today\n"
                "         copies today's changed or added files from X:\\src to E:\\src.\n"
                "\n"
                );

      ehelp;

      DisableCtrlCProcessExit(); // copy

      bool bchain = chain.usefiles;

      char *pszSrc   = 0;
      char *pszDst   = 0;
      bool  bCopy    = 1;
      int  nDoSave  = 0;
      bool  bDoLoad  = 0;
      int  nBufMB   = 100;
      int iChainNext = 0;

      cs.verifyLate = 0;
      cs.hidden = 1; // include hidden/system by default
      cs.syncFiles = !strncmp(pszCmd, "sync", 4);

      // int iDir = 2;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-mem", &pszParm)) {
            if (!pszParm) return 9;
            nBufMB = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nov", 4)) {
            cs.verifyEarly = 0;
            cs.verifyLate  = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-ver", 4)) {
            cs.verifyEarly = 0;
            cs.verifyLate  = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-mir", 4)) {
            cs.syncOlder = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-noca", 5)) {
            bGlblUseCopyCache = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-del", 4)) {
            cs.syncFiles = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-wipe")) {
            cs.delStaleFiles = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nodel", 6)) {
            cs.syncFiles = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-noco", 5)) {
            bCopy = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-dif", 4)) {
            bGlblShowSyncDiff = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-cache")) {
            bGlblUseCopyCache = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-deep")) {
            bGlblIgnoreTime = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-style")) {
            nGlblCopyStyle = 0;
            continue;
         }
         else
         if (strBegins(argv[iDir], "-link")) {
            cs.copyLinks = 1; // windows only, untested.
            continue;
         }
         else
         if (strBegins(argv[iDir], "-nobuf")) {
            cs.copyNoBuf = 1; // windows only, untested.
            continue;
         }
         else
         if (strBegins(argv[iDir], "-decrypt")) {
            cs.copyDecrypt = 1; // windows only, untested.
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-stat"))  { cs.dostat=1; continue; }
         else
         if (!strncmp(argv[iDir], "-save", 5))   { nDoSave=2; continue; }
         else
         if (!strncmp(argv[iDir], "-sign", 5))   { nDoSave=1; continue; }
         else
         if (!strncmp(argv[iDir], "-load", 5))   { bDoLoad=1; continue; }
         else
         if (!strcmp(argv[iDir], "-shadow")) {
            nGlblCopyShadows = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-shadow=", 8)) {
            nGlblCopyShadows = 1;
            nGlblShadowSizeLimit = atol(argv[iDir]+8) * 1000000;
            continue;
         }
         /*
         else
         if (haveParmOption(argv, argc, iDir, "-signto", &pszParm)) {
            if (!pszParm) return 9;
            pszSignTo = pszParm;
            continue;
         }
         */
         else
         if (haveParmOption(argv, argc, iDir, "-check", &pszParm)) {
            if (!pszParm) return 9;
            if (filedb.openRead(pszParm, 1)) return 9;
            // -> filedb.canRead() is set
            cs.skipOwnMetaDir = 1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-checksigns", &pszParm)) {
            if (!pszParm) return 9;
            if (filedb.openRead(pszParm, 1)) return 9;
            // -> filedb.canRead() is set
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-nodirtime")) { 
            cs.nodirtime = 1;
            continue; 
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!bchain && !pszSrc) { 
            pszSrc = argv[iDir]; 
            if (!coiExists(pszSrc, 1)) // 1: or dir
               return 9+perr("no such file or directory: %s\n", pszSrc);
            continue; 
         }
         if (!pszDst) { pszDst = argv[iDir]; continue; }
         // further parms: file selection masks
         break; // fall through
      }

      // init source and target dirs or files.

      if (!bchain && !pszSrc) return 9+perr("missing source directory or file.\n");
      if (!pszDst) return 9+perr("missing target directory%s.\n", bchain? "":" or file");

      // remember this, have to strip it from full paths
      pszGlblCopySrc = pszSrc; // NULL on chaining

      // num nTime1 = getCurrentTime();

      // parse subdirs and general options
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iChainNext)))
         return lRC;

      // now we know if in simulation or not
      cs.sim = !cs.yes;

      // reset global statistics
      nGlblBytes = 0;

      // activate source shadow skip implicitely if meta data are found
      if (!bchain && !cs.skipOwnMetaDir) {
         joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszSrc, str("zz-shadow-01"));
         if (isDir(szRefNameBuf)) {
            joinPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, szRefNameBuf, str("zz-sign"));
            if (filedb.isSignatureFile(szRefNameBuf2)) {
               filedb.setMetaDir(szRefNameBuf);
               cs.skipOwnMetaDir = 1;
            }
         }
      }

      if (!bchain)
      {
         // execute aliases: save, load, verify
         if (bDoLoad) {
            // same as -check dstroot\zz-shadow-01\sign.dat -shadow
            // setup signature database name:
            if (filedb.canRead()) return 9+perr("specify -load OR -check, but not both");
            joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszSrc, str("zz-shadow-01"));
            if (!isDir(szRefNameBuf)) return 9+perr("metadb directory not found: %s\n", szRefNameBuf);
            if (filedb.setMetaDir(szRefNameBuf)) return 9;
            joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszSrc, str("zz-sign"));
            // if (!cs.sim)
            if (filedb.openRead(szRefNameBuf2, 1)) return 9;
            // avoid copying of own metadir to target
            cs.skipOwnMetaDir = 1;
         } 
         else
         if (nDoSave) {
            // user said -save explicitely
            if (!cs.sim) {
               if (createSubDirTree(pszDst, str("zz-shadow-01")))
                  return 9;
               joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszDst, str("zz-sign"));
               if (filedb.openUpdate(szRefNameBuf2))
                  return 9;
               if (nDoSave >= 2)
                  nGlblCopyShadows = 1;
            }
         } else {
            // no -save: check if a signature db exists in target
            joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszDst, str("zz-shadow-01"));
            if (isDir(szRefNameBuf)) {
               joinPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, szRefNameBuf, str("zz-sign"));
               if (filedb.isSignatureFile(szRefNameBuf2)) {
                  if (!cs.sim) {
                     // user forgot -save: open for update implicitely
                     // setTextColor(nGlblTimeColor);
                     // oprintf("updating signature database: %s-nn.dat\n", szRefNameBuf2);
                     // setTextColor(-1);
                     filedb.openUpdate(szRefNameBuf2); // ignore rc
                  } else {
                     setTextColor(nGlblTimeColor);
                     printf("NOTE: signature database found. say -save to write shadows.\n");
                     setTextColor(-1);
                  }
               }
            }
         }

         // check: -shadow requires explicite -dir name listings
         if (nGlblCopyShadows || nDoSave) {
            if (!cs.sim) {
               if (!filedb.canRead() && !filedb.canUpdate())
                  return 9+perr("-shadow requires -signto or -check\n");
            }
         }
      }  // endif nochain

      // setup work buffer
      if (!cs.sim && nBufMB) {
         nGlblWorkBufSize = (num)nBufMB * 1000000;
         pGlblWorkBuf = new uchar[nGlblWorkBufSize];
         if (!pGlblWorkBuf) return 9+perr("out of memory, cannot allocate working buffer.\n");
         glblCopyCache.setBuf(pGlblWorkBuf, nGlblWorkBufSize);
      }
      // NO RETURN W/O DELETE FROM HERE

      bool bSrcDir = bchain || isDir(pszSrc);
      bool bDstDir = isDirByName(pszDst) || isDir(pszDst);
      int nVerFiles  = 0;
      int nVerFailed = 0;
      int nSignsWritten = 0;
 
      mtklog(("copy: copy=%d chain=%d sdir=%d ddir=%d", bCopy,bchain,bSrcDir,bDstDir));
      mtklog(("copy: src=\"%s\" dir=%d", pszSrc, bSrcDir));
      mtklog(("copy: dst=\"%s\" dir=%d", pszDst, bDstDir));

      if (!bchain && !bSrcDir && !bDstDir) {
         if (!bCopy) return 9+perr("-nocopy not supported with single file operation.\n");
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         // single conditional file copy.
         createOutDirTree(pszDst);
         lRC = execFileCopySub(pszSrc, pszDst);
         glblCopyCache.flush();
      }
      else
      if (!bchain && !bSrcDir) {
         if (!bCopy) return 9+perr("-nocopy not supported with single file operation.\n");
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         // src is a file, target a dir.
         strcopy(szRefNameBuf, pszDst);
         int nLen = strlen(szRefNameBuf);
         if ((nLen > 0) && (szRefNameBuf[nLen-1] != glblPathChar))
            strcat(szRefNameBuf, glblPathStr);
         // isolate last part of source name
         char *pszRelName = strrchr(pszSrc, glblPathChar);
         #ifdef _WIN32
         if (!pszRelName) pszRelName = strrchr(pszSrc, ':');
         #endif
         if (pszRelName) pszRelName++;
         else pszRelName = pszSrc;
         // combine target filename
         strcat(szRefNameBuf, pszRelName);
         if (cs.verbose)
            info.print("%s => %s\n",pszSrc,szRefNameBuf);
         createOutDirTree(szRefNameBuf);
         lRC = execFileCopySub(pszSrc, szRefNameBuf);
         glblCopyCache.flush();
      }
      else
      while (bSrcDir) // need to exit by break
      {
         // copy directory tree to a target tree.
         pszGlblPreRoot = pszSrc; // NULL on chaining
         pszGlblCopyDst = pszDst;

         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");

         if (bCopy) {
            mtklog(("copy: calling walktrees, hasroot.0 = %d", glblFileSet.hasRoot(0)));
            lRC = walkAllTrees(eFunc_Copy, lFiles, lDirs, nBytes);
            if (lRC)
               break;
         }
         glblCopyCache.flush();

         // separate verify pass after copy, to (hopefully)
         // get around file system caching:
         if (!cs.sim && cs.verifyLate) // verify
         {
            glblVerifier.verify();
            nVerFiles  = glblVerifier.matchedFiles();
            nVerFailed = glblVerifier.failedFiles();
            info.clear(); // status output below
         }

         if (!bchain && cs.syncFiles)
         {
            // cleanup pass: check target for trash files

            // 1. reverse copy direction
            pszGlblPreRoot = pszDst;
            pszGlblCopySrc = pszDst;
            pszGlblCopyDst = pszSrc;

            if (nGlblCopyShadows) {
               // 2. meta dir was written on copy, filter it out on reverse scan.
               cs.skipOwnMetaDir = 1;
               joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszGlblCopySrc, str("zz-shadow-01"));
               if (!cs.sim && !isDir(szRefNameBuf)) return 9+perr("metadb directory not found: %s\n", szRefNameBuf);
               filedb.setMetaDir(szRefNameBuf);
            }

            cs.filesScanned = 0;
            cs.dirsScanned  = 0;
            lRC = walkAllTrees(eFunc_Cleanup, lFiles, lDirs, nBytes);
         }

         if (filedb.canUpdate())
            filedb.save(nSignsWritten); // ignore rc

         break;         
      }

      glblCopyCache.flush();

      // NO RETURN W/O DELETE UNTIL HERE

      info.clear();

      if (cs.sim && !cs.nohead) {
         if (cs.files || cs.dirs || cs.filesDeleted || cs.dirsDeleted || cs.filesCloned || cs.dirsCloned)
            printx("$[add -yes to execute.]\n");
         else
            printx("$[no differences.]\n");
      }

      bool bsilent = (cs.nohead || cs.quiet);

      // num nTime2 = getCurrentTime();
      bool bTold = 0;
      if (!bSrcDir && !bDstDir) 
         { } // single file copy
      else 
      if (!bsilent && (cs.files || cs.dirs || cs.filesCloned || cs.dirsCloned))
      {
         const char *pszVerb = cs.sim ? "would copy":"copied";
         if (!cs.filesCloned && !cs.dirsCloned)
            printx("$%s %u files, %u dirs.", pszVerb, cs.files, cs.dirs);
         else {
            printx("$%s %u files, %u dirs (%u/%u attribs", pszVerb, cs.files, cs.dirs, cs.filesCloned, cs.dirsCloned);
            if (nVerFiles > 0)
               printx("$, %d verified",nVerFiles);
            if (nVerFailed > 0)
               printx("$, <err>%d failed",nVerFailed);
            printx("$).");
         }
         if (nGlblBytes > 0) {
            num nmbytes = nGlblBytes / 1000000;
            num nkbytes = nGlblBytes / 1000;
            if (nmbytes > 0)
               printx(" <time>%s mb.<def>",numtoa(nmbytes));   
            else
            if (nkbytes > 0)
               printx(" <time>%s kbytes.<def>",numtoa(nkbytes));
            else
               printx(" <time>%s bytes.<def>",numtoa(nGlblBytes));
         }
         bTold = 1;
      }
      if (!bsilent && (cs.filesDeleted || cs.dirsDeleted)) {
         const char *pszVerb = cs.sim ? "would delete":"deleted";
         setTextColor(nGlblWarnColor, 1);
         printf("%s%s %d files, %d dirs.", bTold?" ":"", pszVerb, cs.filesDeleted, cs.dirsDeleted);
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && cs.filesNewerInDst) {
         // setTextColor(nGlblWarnColor, 1);
         printx("%s$(%d differing files in dest)", bTold?" ":"", cs.filesNewerInDst);
         // setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && (cs.numHiddenFilesSkipped || cs.numHiddenDirsSkipped)) {
         setTextColor(nGlblWarnColor, 1);
         printf("%sskipped %d hidden files, %d dirs.", bTold?" ":"", cs.numHiddenFilesSkipped, cs.numHiddenDirsSkipped);
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && bTold && (nSignsWritten > 0)) { // && filedb.canUpdate()
         setTextColor(nGlblTimeColor, 1);
         printf(" %d signatures", nSignsWritten);
         if (cs.shadowsWritten)
            printf(", %d shadows", cs.shadowsWritten);
         printf(".");
         setTextColor(-1);
         bTold = 1;
      }
      if (!bsilent && filedb.canRead() && filedb.anyEvents())
      {
         cchar *pszpre = " ";
         cchar *pszsub = "signs ";
         if (filedb.numberOfVerFailed() > 0) {
            if (filedb.numberOfVerFailed() == cs.shadowFallbacks)
               setTextColor(nGlblWarnColor, 1);
            else
               setTextColor(nGlblErrColor, 1);
            printf(" %d signatures failed", filedb.numberOfVerFailed());
            if (cs.shadowFallbacks) {
               setTextColor(nGlblWarnColor, 1);
               printf(", %d shadow fallbacks", cs.shadowFallbacks);
            }
            pszpre=", "; pszsub="";
         }
         if (filedb.numberOfVerMissing() > 0) {
            setTextColor(nGlblErrColor, 1);
            printf("%s%d %snot found", pszpre, filedb.numberOfVerMissing(), pszsub);
            pszpre=", "; pszsub="";
         }
         setTextColor(nGlblTimeColor, 1);
         if (filedb.numberOfVerifies() > 0) {
            printf("%s%d %schecked.", pszpre, filedb.numberOfVerifies(), pszsub);
            pszpre=", "; pszsub="";
         }
         setTextColor(-1);
         bTold = 1;
      }
      if (bTold)
         printf("\n");

      if (cs.filesStale) {
         setTextColor(nGlblWarnColor, 1);
         printf("%d stale but recently edited files are kept until deletion limit (%d days).\n", cs.filesStale, nGlblActiveFileAgeLimit);
         setTextColor(-1);
      }

      delete [] pGlblWorkBuf;
      pGlblWorkBuf = 0;

      pszGlblPreRoot = 0;

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "verify") ||!strcmp(pszCmd, "syncver"))
   {
      if (blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      if (argc < 3) {
      printx("<help>$sfk sfk verify [-cleanup] [-all] rootdir\n"
             "\n"
             "   verify contents of directory by a given file meta database,\n"
             "   as it is created by sfk copy -sign ...\n"
             "\n"
             "   $options\n"
             "      -cleanup     cleanup records that fail to verify, and/or\n"
             "                   update records with timestamp mismatches.\n"
             "      -all         by default, only records that have been updated\n"
             "                   recently are checked. say -all to check all.\n"
             "\n"
             "   $see also\n"
             "      sfk copy\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk verify e: -all\n"
             "         verify contents on E:, which could be an USB stick.\n"
             );
      return 9;
      }

      char *pszDBFile = 0;
      pszGlblCopySrc  = 0;
      bool bCheckAll  = 0;
      bool bCleanup   = 0;
      char *pszParm1  = 0;
      char *pszParm2  = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-all")) {
            bCheckAll = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-cle", 4)) {
            bCleanup = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // process non-option keywords:
         if (!pszParm1) { pszParm1 = argv[iDir]; continue; }
         if (!pszParm2) { pszParm2 = argv[iDir]; continue; }
         return 9+perr("unexpected parameter: \"%s\" (7)\n", argv[iDir]);
      }

      if (!pszParm2)
         // just one parm: have rootdir
         pszGlblCopySrc = pszParm1;
      else {
         pszDBFile      = pszParm1;
         pszGlblCopySrc = pszParm2;
      }

      if (!pszGlblCopySrc) return 9+perr("missing root directory name\n");

      if (pszDBFile) {
         if (filedb.openRead(pszDBFile, 1))
            return 9;
      } else {
         joinPath(szRefNameBuf, sizeof(szRefNameBuf)-10, pszGlblCopySrc, str("zz-shadow-01"));
         if (!isDir(szRefNameBuf)) return 9+perr("metadb directory not found: %s\n", szRefNameBuf);
         joinShadowPath(szRefNameBuf2, sizeof(szRefNameBuf2)-10, pszGlblCopySrc, str("zz-sign"));
         if (filedb.openRead(szRefNameBuf2, 1)) return 9;
      }

      int nVerMixRC = 0;
      int nSkipped = 0;
      for (int i=0; i<filedb.numberOfFiles(); i++) 
      {
         if (userInterrupt())
            break;
         int nflags = filedb.getFileFlags(i);
         if (bCheckAll || (nflags >= 2)) {
            nVerMixRC |= filedb.verifyFile(i, bCleanup);
         } else {
            nSkipped++;
         }
      }
      info.clear();

      bool bTold = 0;

      if (!cs.quiet) {
         if (!filedb.numberOfVerifies() && !bCheckAll) {
            int ncnt = filedb.numberOfFiles();
            printf("%s contains no recently updated files. say -all to check all %d entries.",pszGlblCopySrc,ncnt);
         } else {
            const char *pxinfo = bCheckAll ? "" : "recently updated ";
            printf("%s %d %sfiles verified.",pszGlblCopySrc,filedb.numberOfVerifies(),pxinfo);
         }
         bTold = 1;
      }

      if (!cs.quiet && filedb.canRead() && filedb.anyEvents())
      {
         cchar *pszpre = " ";
         cchar *pszsub = "signs ";
         if (filedb.numberOfVerFailed() > 0) {
            if (filedb.numberOfVerFailed() == cs.shadowFallbacks)
               setTextColor(nGlblWarnColor, 1);
            else
               setTextColor(nGlblErrColor, 1);
            printf(" %d signatures failed", filedb.numberOfVerFailed());
            if (cs.shadowFallbacks) {
               setTextColor(nGlblWarnColor, 1);
               printf(", %d shadow fallbacks", cs.shadowFallbacks);
            }
            pszpre = ", ";
         }
         if (filedb.numberOfVerMissing() > 0) {
            setTextColor(nGlblErrColor, 1);
            printf("%s%d %snot found", pszpre, filedb.numberOfVerMissing(), pszsub);
            pszpre=", "; pszsub="";
         }
         setTextColor(nGlblTimeColor, 1);
         printf("%s%d %schecked", pszpre, filedb.numberOfVerifies(), pszsub);
         if (nSkipped)
            printf(", %d skipped", nSkipped);
         printf(".");
         setTextColor(-1);
         bTold = 1;
      }
      if (bTold)
         printf("\n");

      if (nVerMixRC && bCleanup) {
         // at least one record failed to verify, and cleanup is selected:
         // rewrite meta db.
         int nRecWritten = 0;
         int nSaveRC = filedb.save(nRecWritten);
         if (!nSaveRC)
            printf("metadb cleaned up, %d records written.\n", nRecWritten);
         // else error was printed within save()
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "getcwd") || !strcmp(pszCmd, "cwd"))
   {
      ifhelp (nparm >= 1 && isHelpOpt(argv[iDir]))
      printx("<help>$sfk getcwd\n"
             "\n"
             "   print the current working directory.\n"
             "\n"
             "   $examples\n"
             "      #sfk getcwd +filter -form \"workdir is $$col1\"\n"
             "         print workdir with some additional text.\n"
             );
      ehelp;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s", argv[iDir]);
      }

      szLineBuf[0] = '\0';
      if (getcwd(szLineBuf,sizeof(szLineBuf)-10)) { }

      if (chain.colfiles) {
         Coi ocoi(szLineBuf, 0);
         chain.addFile(ocoi); // is copied
      }
      else
      if (chain.coldata) {
         chain.addLine(szLineBuf, str(""), 0);
      } else {
         printf("%s\n", szLineBuf);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "cd")) 
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk cd targetdir +nextcmd ...\n"
             "\n"
             "   change the directory for the next chain command.\n"
             "   does NOT change the directory of the command shell.\n"
             "\n"
             "   $options\n"
             "      -echo     echo the command on execution\n"
             "\n"
             "   $examples\n"
             "      #sfk cd testfiles +list -time -size .\n"
             "         enter directory \"testfiles\", then list all files.\n"
             );
      ehelp;

      char *pszDir = 0;
      bool  becho  = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-echo")) {
            becho = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszDir)
            pszDir = argv[iDir];
         else
            return 9+perr("unexpected: %s", argv[iDir]);
      }

      if (!pszDir) return 9+perr("missing dir name for cd");

      // plausi check
      if (iChainNext <= 0) {
         perr("missing chain commands after \"cd\"");
         pinf("cd can change the dir for subsequent chain commands only.\n");
         pinf("to change the dir of your command shell, use \"cd\" but not \"sfk cd\"\n");
         return 9;
      }

      int nrc = chdir(pszDir);
      if (nrc) return 9+perr("cannot cd into: %s", pszDir);

      if (becho)
         printx("<time>cd %s<def>\n", pszDir);

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "mkdir")) 
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk mkdir path\n"
             "\n"
             "   create a directory, or directory tree.\n"
             "\n"
             "   $options\n"
             "      -echo     echo the command on execution\n"
             "\n"
             "   $examples\n"
             "      #sfk mkdir tmp\\foo\\bar\n"
             "         create directory bar within foo within tmp.\n"
             );
      ehelp;

      char *pszDir = 0;
      bool  becho  = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-echo")) {
            becho = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszDir)
            pszDir = argv[iDir];
         else
            return 9+perr("unexpected: %s", argv[iDir]);
      }

      if (!pszDir) return 9+perr("missing dir name for mkdir");

      lRC = createSubDirTree(pszDir, str(""));
      if (lRC) return lRC;

      if (becho)
         printx("<time>mkdir %s<def>\n", pszDir);

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   if (strBegins(pszCmd, "linelen") || strBegins(pszCmd, "strlen"))
   {
      if (!chain.useany() && (nparm < 1)) {
      printx("<help>$sfk linelen [options]\n"
             "$sfk strlen phrase\n"
             "\n"
             "   tell the length of text lines supplied via stdin\n"
             "   or through command chaining, or tell the length\n"
             "   of a single string.\n"
             "\n"
             "   the result is printed to terminal, and supplied\n"
             "   as a return code to the command shell.\n"
             "\n"
             "   \"sfk strlen\" does not accept any options,\n"
             "   allowing to supply a string starting with \"-\".\n"
             "\n"
             "   $options\n"
             "      -i         read lines from standard input,\n"
             "                 tell the longest line length.\n"
             "      -min       tell the minimum, not the maximum length.\n"
             "      -minmax    tell both min and max length.\n"
             "      -verbose   tell minmax, line numbers and line text.\n"
             "                 you may also type -all or -ver\n"
             "      -quiet     do not print anything to terminal,\n"
             "                 just provide the shell return code.\n"
             "\n"
             "   $limitations\n"
             "      if the input contains stream text, i.e. text where\n"
             "      linefeeds are used only for paragraphs (not lines),\n"
             "      the result will be a paragraph length, and it can be\n"
             "      completely wrong if there are paragraphs longer than\n"
             "      4000 characters approx.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk strlen \"foo bar\"\n"
             "         results in a string length of 7.\n"
             "\n"
             "      #sfk filter foo.txt +linelen -all\n"
             "         list the shortest and longest line of foo.txt\n"
             );
      return 9;
      }

      bool  braw = strBegins(pszCmd, "strlen");

      char *pphrase = 0;
      bool  bstdin  = 0;
      bool  bdetail = 0;
      bool  bmin    = 0;
      bool  bmax    = 1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!braw && !strcmp(argv[iDir], "-i")) {
            bstdin = 1;
            continue;
         }
         else
         if (!braw && !strcmp(argv[iDir], "-min")) {
            bmin = 1; bmax = 0;
            continue;
         }
         else
         if (!braw && !strcmp(argv[iDir], "-max")) {
            bmax = 1;
            continue;
         }
         else
         if (!braw && !strcmp(argv[iDir], "-minmax")) {
            bmin = 1; bmax = 1;
            continue;
         }
         else
         if (!braw && (strBegins(argv[iDir], "-ver") || !strcmp(argv[iDir], "-all")))
         {
            bdetail = 1;
            continue;
         }
         else
         if (!braw && !strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pphrase) {
            pphrase = argv[iDir];
            continue;
         }
         return 9+perr("only one phrase can be supplied.\n");
      }

      if (!pphrase && !chain.usedata && !bstdin)
         return 9+perr("missing phrase, chain text or -i option.\n");

      if (pphrase)
         { bmin=0; bdetail=0; }

      int iline = 0;
      int nmin  = -1;
      int nmax  = 0;
      int imin  = 0;
      int imax  = 0;
      mclear(szLineBuf2);  // will contain min line
      mclear(szLineBuf3);  // will contain max line

      if (bstdin)
         myfgets_init();

      if (pphrase) {
         nmax = strlen(pphrase);
         bdetail = 0;
      }
      else
      while (1) 
      {
         if (chain.usedata) {
            if (chain.indata->eod())
               break;
            char *psz = chain.indata->read(0);
            mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
         } else {
            if (!myfgets(szLineBuf, MAX_LINE_LEN, stdin))
               break;
         }
         iline++;
         removeCRLF(szLineBuf);
         int nlen = strlen(szLineBuf);
         if (nmin < 0 || nlen < nmin) {
            nmin = nlen;
            imin = iline;
            strcopy(szLineBuf2, szLineBuf);
         }
         if (nlen > nmax) {
            nmax = nlen;
            imax = iline;
            strcopy(szLineBuf3, szLineBuf);
         }
      }

      lRC = nmax;

      if (!cs.quiet) {
         if (bdetail) {
            chain.print("min\t%d\t%d\t\"%s\"", nmin, imin, szLineBuf2);
            chain.print("max\t%d\t%d\t\"%s\"", nmax, imax, szLineBuf3);
         }
         else
         if (bmin && bmax) {
            chain.print("%d\t%d", nmin, nmax);
         }
         else
         if (bmin) {
            chain.print("%d", nmin);
            lRC = nmin;
         }
         else {
            chain.print("%d", nmax);
         }
      }

      if (iChainNext > 0) 
         lRC = 0;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   // internal
   if (!strcmp(pszCmd, "getlines"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];
      FILE *fin = fopen(pszFile, "rb");
      if (!fin) return 9+perr("failed\n");
      memset(szLineBuf, '$', MAX_LINE_LEN);
      myfgets_init();
      while (myfgets(szLineBuf, MAX_LINE_LEN, fin))
      {
         printf(">%s<\n", szLineBuf);
         memset(szLineBuf, '$', MAX_LINE_LEN);
      }
      fclose(fin);
      bDone = 1;
   }

   if (!strcmp(pszCmd, "mdfuzzy"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];
      if (getFuzzyTextSum(pszFile, abBuf))
         return 9;
      for (int i=0; i<16; i++)
         printf("%02x ", abBuf[i]);
      printf("\n");
      bDone = 1;
   }

   // create cd batch to current directory
   ifcmd (!strcmp(pszCmd, "mkcd"))
   {
      if (!bhelp && blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported

      ifhelp (nparm < 1)
      printx("<help>$sfk mkcd cdname\n"
             "\n"
             "   creates an alias batch file, remembering the current directory.\n"
             "   this batch can be used later to re-enter the remembered directory.\n"
             "\n"
             "   #example:\n"
             "\n"
             "   1. you are currently working in\n"
             "         C:\\Documents And Long Complicated Paths\\Users\\You\\Work\n" 
             "\n"
             "   2. now type:\n"
             "         #sfk mkcd cd1\n"
             "            which saves above path in a command \"cd1\".\n"
             "\n"
             "   3. you go into a different directory, e.g.\n"
             "         C:\\Another Project\\Nested Dirs\\Work2\n"
             "\n"
             "   4. now type:\n"
             "         #sfk mkcd cd2\n"
             "\n"
             "   => now, anytime you type:\n"
             "         #cd1\n"
             "            you jump instantly into\n"
             "               C:\\Documents And Long Complicated Paths\\Users\\You\\Work\n" 
             "\n"
             "      and anytime you type:\n"
             "         #cd2\n"
             "            you jump instantly into\n"
             "               C:\\Another Project\\Nested Dirs\\Work2\n"
             "\n"
             "   if the creation of the alias fails, please type \"sfk alias\" to read\n"
             "   about the required directories and access rights.\n"
         );
      ehelp;

      if (checkArgCnt(argc, 3)) return 9;
      char *pszAlias = argv[2];

      // find ourselves, result in szLineBuf
      char *pszSFKCmd = findPathLocation("sfk" EXE_EXT, 1); // 1: exclude work dir
      if (!pszSFKCmd) return 9+perr("cannot find location of sfk" EXE_EXT " within PATH.\n");
      // create batch filename parallel to sfk.exe
      szRefNameBuf[0] = '\0';
      char *psz1 = strrchr(pszSFKCmd, glblPathChar);
      if (!psz1) return 9+perr("unable to find path of sfk" EXE_EXT "\n");
      sprintf(szRefNameBuf, "%.*s", (int)(psz1-pszSFKCmd+1),pszSFKCmd);
      strcat(szRefNameBuf, pszAlias);
      #ifdef _WIN32
      strcat(szRefNameBuf, ".bat");
      #endif
      char nReply = 'y';
      if (fileExists(szRefNameBuf)) {
         printf("%s exists, overwrite? (yes/no) ",szRefNameBuf);
         fflush(stdout);
         nReply = getYNAchar();
      }
      if (nReply == 'y') 
      {
         // determine current directory
         szLineBuf[0] = '\0';
         if (getcwd(szLineBuf,sizeof(szLineBuf)-10)) { }

         // write the batch
         FILE *fout = fopen(szRefNameBuf, "w");
         if (!fout) return 9+perr("cannot write batch file: %s\n", szRefNameBuf);

         // write alias batch header for later re-identification.
         fprintf(fout, "%s\n", pszGlblAliasBatchHead);

         #ifdef _WIN32
         // include drive change
         char *psz2 = strchr(szLineBuf, ':');
         if (psz2)
            fprintf(fout, "@%.*s\n@cd \"%s\"\n",
               (int)(psz2-szLineBuf+1),szLineBuf,  // e.g. C:
               psz2+1);   // rest of path, relative to drive
         else
            fprintf(fout, "@cd \"%s\"\n", szLineBuf);
         #else
         fprintf(fout, "cd \"%s\"\n", szLineBuf);
         #endif

         fclose(fout);

         #ifndef _WIN32
         chmod(szRefNameBuf, S_IREAD | S_IWRITE | S_IEXEC);
         #endif

         printf("batch created: %s\n", szRefNameBuf);
         #ifdef _WIN32
         printf("type \"%s\" to reenter %s\n",pszAlias,szLineBuf);
         #else
         printf("type \". %s\" to reenter %s\n",pszAlias,szLineBuf);
         #endif
      }
      bDone = 1;
   }

   // create alias batch
   ifcmd (!strcmp(pszCmd, "alias"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk alias [-list|-del|-ren] [shortname] [=] [command]\n"
             "\n"
             "   create, list, delete or rename command aliases. aliases are\n"
             "   short command names selected by yourself to save typing effort.\n"
             "\n"
             "   $sfk alias shortname = command ...\n"
             "\n"
             "      create an alias. this actually creates a small batch file\n"
             "      in the directory where sfk itself is located.\n"
             "\n"
             "      requirements:\n"
             "      #-  the sfk executable has been copied into some directory x.\n"
             "      #-  this directory x must be in your PATH.\n"
             "      #-  you must have write permission for directory x.\n"
             "      #-  directory x is NOT the current working directory \".\".\n"
             "\n"
             "      if any of these requirements is not met, the command will fail.\n"
             "      for example, if sfk" EXE_EXT " is located just in your current\n"
             "      working directory \".\", copy sfk" EXE_EXT " into a different\n"
             "      directory of the PATH, and then start aliasing.\n"
             "\n"
             "   $see also\n"
             "      sfk mkcd : create an alias remembering the current directory.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk alias list = \"sfk list\"\n"
             "         creates the alias named \"list\". from now on, you can\n"
             "         type \"list\" instead of \"sfk list\".\n"
             "\n"
             #ifdef _WIN32
             "      #sfk alias wherc = \"sfk list -arc . .jar filter -+%%1.class\"\n"
             #else
             "      #sfk alias wherc = \"sfk list -arc . .jar filter -+\\$$1.class\"\n"
             #endif
             "         creates alias \"wherc\", searching for class files in jars.\n"
             "         after the alias exists, command \"wherc Foo\" executes the\n"
             "         commands from above, listing all class names with \"Foo\".\n"
             #ifdef _WIN32
             "\n"
             "      #sfk alias tab2c \"sfk fromclip +filt -spat -rep _\\t_,_ +toclip\"\n"
             "         then type tab2c to replace tabs by commas within clipboard.\n"
             #endif
             "\n"
             "      #sfk alias copytoday \"sfk run \\\"copy <run>file c:\\tmp\\\" . -today\"\n"
             "         copy all files changed today to c:\\tmp. if double quotes \"\n"
             "         should be part of your command, they must be escaped as \\\"\n"
             #ifdef _WIN32
             "\n"
             "      #sfk alias wide MODE CON COLS=160\n"
             "         extend the current shell window to a width of 160 columns.\n"
             "\n"
             "      #sfk alias ec \"notepad c:\\app\\bin\\%%1.bat\"\n"
             "         provided that c:\\app\\bin is in your path, creates\n"
             "         a command \"ec\" to instantly edit further commands.\n"
             #else
             "\n"
             "      #sfk alias ec \"vi /home/myuser/tools/\\$$1\"\n"
             "         provided that /home/myuser/tools is in your path, creates\n"
             "         a command \"ec\" to instantly edit further commands.\n"
             #endif
             "\n"
             "      #PARAMETER LIMITATION:<def> note that the created batch files\n"
             #ifdef _WIN32
             "      may accept only a maximum of 9 parameters, called %%1 to %%9.\n"
             #else
             "      may accept only a maximum of 9 parameters. they must be typed\n"
             "      with back slash \\$$1 to \\$$9 and will appear as $$1 to $$9\n"
             "      in the created batch script.\n"
             #endif
             "      Further parameters may be ignored, or cannot be addressed.\n"
             "\n"
             "      #USE SURROUNDING QUOTES<def> whenever your command string contains\n"
             "      special characters like %% \\ ! otherwise these chars may be\n"
             "      removed (or misinterpreted) by the command shell.\n"
             "\n"
             "   $sfk alias -list\n"
             "      list all existing aliases. this actually scans the directory\n"
             "      where sfk is located for batch files containing aliases.\n"
             "\n"
             "   $sfk alias shortname\n"
             "      list definition of an existing alias.\n"
             "\n"
             "   $sfk alias -del aliasname\n"
             "      delete an alias (deletes the associated batchfile).\n"
             "\n"
             "   $sfk alias -ren oldname newname\n"
             "      rename an alias (renames the associated batchfile).\n"
            );
      #ifdef SFINT
      printx("\n"
             "   $COMMAND NAME ALIASING:\n"
             "\n"
             "   another way to avoid typing \"sfk\" on every command is this:\n"
             "\n"
             "   - in the directory where sfk is located, create another executable,\n"
             "     for example \"list.exe\", as a link to sfk.exe:\n"
             #ifdef _WIN32
             "        fsutil hardlink create list.exe sfk.exe\n"
             #else
             "        ln -sf sfk list\n"
             #endif
             "\n"
             "   - now simply type \"list\" instead of \"sfk\": sfk will detect that\n"
             "     its name is no longer \"sfk\", and tries to run the supplied\n"
             "     command name automatically.\n"
             "\n"
             "   - this behaviour can be disabled by " SFK_SETENV_CMD " SFK_CONFIG=ignore-exec-name\n"
             "\n"
             "   if in any doubt what version of sfk is run by the aliased command,\n"
             "   type the new command name with \"-version\" as first parameter.\n"
             );
      #endif
      ehelp;

      // find ourselves, result in szLineBuf
      char *pszSFKCmd = findPathLocation("sfk" EXE_EXT, 1); // 1: exclude work dir
      if (!pszSFKCmd) return 9+perr("cannot find location of sfk" EXE_EXT " within PATH.\n");

      // isolate path of sfk.exe in szRefNameBuf
      szRefNameBuf[0] = '\0';
      char *psz1 = strrchr(pszSFKCmd, glblPathChar);
      if (!psz1) return 9+perr("unable to find path of sfk" EXE_EXT "\n");
      sprintf(szRefNameBuf, "%.*s", (int)(psz1-pszSFKCmd+1),pszSFKCmd);

      if ((nparm >= 1) && !strcmp(argv[iDir], "-list"))
      {
         // list all aliases located parallel to sfk.exe,
         // by scanning the header of all files in its directory.

         // first continue processing real parameters, if any
         for (iDir++; iDir<argc; iDir++)
         {
            if (isChainStart(pszCmd, argv, argc, iDir, 0))
               break;
            return 9+perr("unexpected: %s\n", argv[iDir]);
         }
         if (btest) return 0;

         // create virual directory parms
         char *pSubArgv[10];
         pSubArgv[0] = str("sfk-dummy");
         pSubArgv[1] = str("alias-list");
         pSubArgv[2] = str("-norec");
         pSubArgv[3] = szRefNameBuf;
         pSubArgv[4] = str(".bat");
         #ifdef _WIN32
         int nSubArgc = 5; // win: reduce scan to .bat files
         #else
         int nSubArgc = 4; // linux: no specific file extension, scan all files
         #endif
         int iSubDir  = 3;
         printx("$current aliases from the sfk home %s :\n", szRefNameBuf);

         // process and walk virtual directory parameters
         if ((lRC = processDirParms(str("alias-list"), nSubArgc, pSubArgv, iSubDir, 3))) return lRC;
         lRC = walkAllTrees(eFunc_AliasList, lFiles, lDirs, nBytes);

         // complete real parameters, just to find iDirNext
         int iDirNext = 0;
         int lRC2 = 0;
         if ((lRC2 = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC2;

         // now continue chain, e.g. filtering, if any
         if (chain.coldata) {
            STEP_CHAIN(iDirNext, 1);
         } else {
            STEP_CHAIN(iDirNext, 0);
         }

         bDone = 1;
      }
      else
      if ((argc > 3) && !strcmp(argv[2], "-del"))
      {
         // delete one or more aliases
         if (blockChain(str("alias -delete"), iDir, argc, argv, 2)) // 2: no pinf
            return 9;
   
         for (iDir=3; iDir < argc; iDir++)
         {
            char *pszToDel = argv[iDir];
            sprintf(szLineBuf, "%s%s", szRefNameBuf, pszToDel);
            #ifdef _WIN32
            strcat(szLineBuf, ".bat");
            #endif

            // check if it's really an alias batch
            FILE *fin = fopen(szLineBuf, "r");
            if (!fin) 
               { perr("%s - no such file\n",szLineBuf); continue; }
            if (!fgets(szLineBuf2, sizeof(szLineBuf2), fin))
               { perr("%s - no data\n",szLineBuf); fclose(fin); continue; }
            fclose(fin);
            if (strncmp(szLineBuf2, pszGlblAliasBatchHead, strlen(pszGlblAliasBatchHead)))
               { perr("%s - no valid alias batch, will not delete.\n",szLineBuf); continue; }

            if (remove(szLineBuf))
               perr("%s - cannot delete file\n",szLineBuf);
            else
               printf("alias deleted: %s\n", szLineBuf);
         }
         bDone = 1;
      }
      else
      if ((argc >= 5) && !strcmp(argv[2], "-ren"))
      {
         // rename an alias
         if (blockChain(str("alias -rename"), iDir, argc, argv, 2)) // 2: no pinf
            return 9;

         char *pszFrom = argv[3];
         char *pszTo   = argv[4];

         sprintf(szLineBuf, "%s%s", szRefNameBuf, pszFrom);
         #ifdef _WIN32
         strcat(szLineBuf, ".bat");
         #endif

         sprintf(szLineBuf2, "%s%s", szRefNameBuf, pszTo);
         #ifdef _WIN32
         strcat(szLineBuf2, ".bat");
         #endif

         if (fileExists(szLineBuf2))
            return 9+perr("%s already exists, rename failed.\n", szLineBuf2);

         // check if it's really an alias batch
         FILE *fin = fopen(szLineBuf, "r");
         if (!fin) 
            return 9+perr("%s - no such file\n",szLineBuf);
         if (!fgets((char*)abBuf, sizeof(abBuf), fin))
            { fclose(fin); return 9+perr("%s - no data\n",szLineBuf); }
         fclose(fin);
         if (strncmp((char*)abBuf, pszGlblAliasBatchHead, strlen(pszGlblAliasBatchHead)))
            return 9+perr("%s - no valid alias batch, will not rename.\n",szLineBuf);

         if (rename(szLineBuf, szLineBuf2))
            perr("%s - cannot rename to %s\n",szLineBuf,szLineBuf2);
         else
            printf("alias renamed: %s\n", szLineBuf2);

         bDone = 1;
      }
      else
      if (argc == 3)
      {
         // list single alias
         if (blockChain(str("alias [show]"), iDir, argc, argv, 2)) // 2: no pinf
            return 9;

         char *pszAlias = argv[2];
         strcat(szRefNameBuf, pszAlias);
         #ifdef _WIN32
         strcat(szRefNameBuf, ".bat");
         #endif
         bool bIsAlias = 0;
         execAliasList(szRefNameBuf, &bIsAlias);
         if (!bIsAlias)
         {
            printf("No sfk alias \"%s\" is defined", pszAlias);
            int nhits = listPathAny(pszAlias, 1); // silent
            if (nhits > 0) {
               printf(", but path contains:\n");
               listPathAny(pszAlias, 0); // loud
            }
            else printf(".\n");
         }
         bDone = 1;
      }
      else
      {
         // create new alias
         if (blockChain(str("alias [create]"), iDir, argc, argv, 2)) // 2: no pinf
            return 9;

         if (checkArgCnt(argc, 4)) return 9;
         char *pszAlias = argv[2];
   
         // create batch filename parallel to sfk.exe
         strcat(szRefNameBuf, pszAlias);
         #ifdef _WIN32
         strcat(szRefNameBuf, ".bat");
         #endif
         char nReply = 'y';
         if (fileExists(szRefNameBuf)) {
            printf("%s exists, overwrite? (yes/no) ",szRefNameBuf);
            fflush(stdout);
            nReply = getYNAchar();
         }
         if (nReply == 'y') 
         {
            // open output batchfile
            FILE *fout = fopen(szRefNameBuf, "w");
            if (!fout) return 9+perr("cannot write batch file: %s\n", szRefNameBuf);

            // write alias batch header for later re-identification.
            fprintf(fout, "%s\n", pszGlblAliasBatchHead);

            bool  bHaveAnySubst = 0;
            uchar aHaveSubst[20];
            memset(aHaveSubst, 0, sizeof(aHaveSubst));

            // collect ALL further parameters, add
            iDir = 3;
            int nAdd = 0;
            if (!strcmp(argv[iDir], "="))
                iDir++;
            #ifdef _WIN32
            fprintf(fout, "@"); // silent, don't list command on execution
            #endif
            while (iDir < argc) {
               char *psz3 = argv[iDir];
               // check if user supplies parameter substitution
               for (int i=1; i<10; i++) {
                  #ifdef _WIN32
                  sprintf(szLineBuf, "%%%d", i);
                  #else
                  sprintf(szLineBuf, "$%d", i);
                  #endif
                  if (strstr(psz3, szLineBuf)) {
                     bHaveAnySubst = 1;
                     aHaveSubst[i] = 1;
                  }
               }
               fprintf(fout, "%s ", argv[iDir]);
               iDir++;
               nAdd++;
            }
   
            if (nAdd == 0)
               perr("missing parameters after \"=\"\n");
            else {
               // finalize: add support for not yet used substitution parms
               if (!bHaveAnySubst) {
                  #ifdef _WIN32
                  fprintf(fout, "%%*");   // pass ALL parms (.bat)
                  #else
                  fprintf(fout, "$@");    // pass ALL parms (bash)
                  #endif
               }
               else
               for (int i=1; i<10; i++)
                  if (!aHaveSubst[i])
                     #ifdef _WIN32
                     fprintf(fout, "%%%d ", i);
                     #else
                     fprintf(fout, "$%d ", i);
                     #endif
            }
   
            fclose(fout);

            #ifndef _WIN32
            chmod(szRefNameBuf, S_IREAD | S_IWRITE | S_IEXEC);
            #endif

            printx("$batch created: %s\n", szRefNameBuf);
            char *pszTmp = loadFile(szRefNameBuf);
            if (pszTmp) {
               printf("%s",pszTmp);
               int nLen = strlen(pszTmp);
               if ((nLen > 0) && (pszTmp[nLen-1] != '\n'))
                  printf("\n");
               delete [] pszTmp;
            }
            printx("$type \"%s\" to use.\n", pszAlias);
         }
         bDone = 1;
      }
   }

   regtest("replace -text /src/dst/ -file xfile1 xfile2");
   regtest("rep -binary /A0A1A2/B5B6B7/ -dir xdir -file .dat -yes");
   regtest("rep -dump -wide -context=20 -bylist xreplist.txt -dir . -file xfile1 xfile2");
   regtest("list xdir .txt +rep /foo/bar/");

   bool bIsFHexFind = 0; // fixed text
   bool bIsFReplace = 0; // fixed text
   bool bIsXExtract = 0; // extract command
   bool bIsXReplace = 0; // xreplace command
   bool bIsHexFind  = 0; // hexfind or xhexfind
   bool bIsAnyFind  = 0;
   bool bIsXText    = 0;
   bool bIsXPat     = 0;
   bool bExtract    = 0;
   bool bFullHelp   = 0;
   bool bIsReplace  = 0;
   bool bIsXFind    = 0;
   bool bIsXHexFind = 0; // pure alias

   bool bXdXe = 0;

   ifcmd (   !strcmp(pszCmd, "rep") || !strcmp(pszCmd, "replace")    // +chaining
          || strBegins(pszCmd, "hexfind") // or hexfindle
          || (bXdXe && !strcmp(pszCmd, "xrep"))
          || (bXdXe && !strcmp(pszCmd, "xreplace"))
          || (bXdXe && !strcmp(pszCmd, "xfind"))
          || (bXdXe && !strcmp(pszCmd, "xtext"))
          || (bXdXe && !strcmp(pszCmd, "xhex") )
          || (bXdXe && strBegins(pszCmd, "xhexfind")) // or xhexfindle
          || (bXdXe && !strcmp(pszCmd, "extract"))
         )
   {
      // xhexfind: alias of xfind -arc
      if (strBegins(pszCmd, "xhex")) {
         pszCmd   = str("xfind");
         bIsXHexFind  = 1;
      }

      bIsFHexFind = strBegins(pszCmd, "hexfind");
      bIsFReplace = strBegins(pszCmd, "rep");
      bIsXExtract = !strcmp(pszCmd, "extract");
      bIsXReplace = strBegins(pszCmd, "xrep");
      bIsXText    = !strcmp(pszCmd, "xtext"); // read text files only
      bIsXFind    = !strcmp(pszCmd, "xfind") || bhelp; // help default
      bIsHexFind  = bIsFHexFind || bIsXHexFind;
      bExtract    = bIsXFind || bIsXText || bIsXExtract;
      bIsAnyFind  = bIsXFind || bIsXText || bIsHexFind;
      bIsXPat     = strBegins(pszCmd, "x") || bExtract;
      bFullHelp   = (nparm >= 1 && !strcmp(argv[iDir], "-full"));
      bIsReplace  = strstr(pszCmd, "rep") ? 1 : 0;

      ifhelp ((nparm < 1) || bFullHelp)

      if (bIsFHexFind)
      printx("<help>$sfk hexfind [opts] -pat /pattern/ -dir anydir -file .ext1 [.ext2]\n"
             "\n"
             "   search text or binary data in text and binary files.\n"
             "   if multiple patterns are given then they are searched\n"
             "   independently (pattern1 OR pattern2).\n");
      else if (bIsFReplace)
      printx("<help>$sfk replace singleFile [-text] /src/dst/ [pattern2] [...] [-yes]\n"
             "$sfk replace -[s]pat -bin[ary] /A0A1A2/B5B6B7/ -dir anydir -file .ext1 [-yes]\n"
             "$sfk rep [-dump [-wide]]]] -bylist words.txt file1 [file2 ...] [-yes]\n"
             "\n"
             "   replace text or binary data in text and binary files.\n"
             "   may replace many different patterns in parallel.\n");
      else if (bIsXHexFind)
      printx("<help>$sfk xhexfind dirName \"/searchtext/totext/\"\n"
             "\n"
             "   search in text and binary files using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [],\n"
             "   creating a hexadecimal dump output.\n"
             #ifndef SFKPRO
             "\n"
             "   $license notice:\n"
             "      this command is freeware and not part of sfk ose.\n"
             #endif
             );
      else if (bIsXFind)
      printx("<help>$sfk xfind dirName \"/searchtext/totext/\"\n"
             "\n"
             "   search in text and binary files using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [].\n"
             #ifndef SFKPRO
             "\n"
             "   $license notice:\n"
             "      this command is freeware and not part of sfk ose.\n"
             #endif
             );
      else if (bIsXText)
      printx("<help>$sfk xtext dirName \"/searchtext/totext/\"\n"
             "\n"
             "   search in text files only using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [].\n"
             #ifndef SFKPRO
             "\n"
             "   $license notice:\n"
             "      this command is freeware and not part of sfk ose.\n"
             #endif
             );
      else if (bIsXExtract)
      printx("<help>$sfk extract dirName \"/searchtext/totext/\"\n"
             "\n"
             "   extract data from text and binary files using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [].\n"
             "\n"
             "   produces a (binary) data stream that can be\n"
             "   - written to terminal as hex dump (default)\n"
             "   - written to file by option -tofile\n"
             "   - sent to xed by +xed command chaining\n"
             #ifndef SFKPRO
             "\n"
             "   $license notice:\n"
             "      this command is freeware and not part of sfk ose.\n"
             #endif
             );
      else if (bIsXReplace)
      printx("<help>$sfk xreplace dirName \"/searchtext/totext/\"\n"
             "\n"
             "   replace in text and binary files using wildcards * and ?\n"
             "   as well as SFK Simple Expressions in brackets [].\n"
             #ifndef SFKPRO
             "\n"
             "   $license notice:\n"
             "      this command is commercial and part of SFK XE.\n"
             #endif
             );

      printx("\n");

      if (bIsReplace)
      printx("   Multiple search patterns are executed in the given sequence. Mind this\n"
             "   if they overlap, e.g. /foo/bar/ /foosys/thesys/ makes no sense (foo is\n"
             "   replaced by the first expression, so the 2nd one will fail to match).\n"
             "\n"
             "   $by default, replace functions run in SIMULATION mode,\n"
             "      previewing hits without changing anything. add -yes to apply changes.\n"
             "      Changing binaries may lead to unpredictable results, therefore keep\n"
             "      backups of your files in any case.\n"
             "\n"
             );

      #ifndef SFKPRO
      if (bIsFReplace)
      printx("   $license notice:\n"
             "      this is the open source version of sfk replace.\n"
             "      replacing source / target patterns #of different length<def> is slower\n"
             "      and may require much memory compared to replacements #of same length<def>.\n"
             "      SFK XE contains a different implementation with high performance.\n"
             "\n"
             );
      #endif

      printx("   $subdirectories are included by default\n"
             "      the sfk default for most commands is to process the given directories,\n"
             "      #as well as all subdirs within them<def>. specify -nosub to disable this.\n"
             "\n");
      printx("   $options:\n"
             "      -nosub        do not include files in subdirectories.\n"
             "      -nobin[ary]   skip binary files.\n");
      if (bIsXPat)
      printx("      -case         case-sensitive text comparison. default is insensitive.\n");
      else
      printx("      -case         case-sensitive text comparison. default is case-insensitive\n"
             "                    comparison for all -text strings, but NOT for -bin blocks.\n"
             "                    case-sensitive comparison is faster then case-insensitive.\n"
             "      -nocase       force case-insensitive comparison ALSO on -bin patterns.\n"
             );
      printx("      -pat          starts a list of search or replace patterns of the form\n"
             "                    xsrcxdstx where x is the separator char, src the source\n"
             "                    to search for, and dst the destination to replace it with.\n"
             "                    e.g. /foo/bar/ or _foo_bar_ both replace foo by bar.\n"
             "                    -pat is not required if a singleFile name is given.\n"
             "      -text         the same as -pat, starting a text pattern list.\n"
             );
      if (!bIsXPat)
      printx("      -spat         the same, but also activates slash patterns like \\t .\n"
             "                    type \"sfk help pat\" for the list of possible patterns.\n"
             "      -spats[trict] same as -spat, but stops with error on undefined\n"
             "                    slash patterns like \\m in C:\\myproj. every slash\n"
             "                    must then be escaped, e.g. using C:\\\\myproj.\n"
             );
      if (!bIsXPat)
      printx("      -bin[ary]     starts a list of binary replace patterns, specified\n"
             "                    as hexcode like /0A0D/2020/\n");

      if (bFullHelp)
      printx("      -bylist x.txt read search/replace patterns from a file (see below).\n");
      else
      printx("      -bylist x.txt read search patterns from a file x.txt, supporting\n"
             "                    multiple lines per pattern. (add -full for more.)\n"
             "      -bylinelist x read /from/to/ or just /from/ patterns from a file x\n"
             "                    with one pattern per line. (add -full for more.)\n");
      printx("      -enddir       to use -dir ... -file ... as first parameters, type:\n"
             "                    sfk %s -dir ... -file ... -enddir -pat ...\n"
             , pszCmd);
      if (bIsAnyFind || bIsXExtract)
         arcinf(10); // hexfind, xfind, xtext, xhexfind, extract

             #ifndef SFKXEREP
      if (bIsReplace)
      printx("      -recsize      with same length replacements: set input record size\n"
             "                    for processing (default=100k)\n");
             #endif
      printx("      -firsthit     %s only first found pattern match per file.\n"
             , (bIsXFind || bIsXText) ? "show":"process");
      if (bIsXFind || bIsXText)
      printx("      -prog[ress]   show progress infos.\n"
             "      -justrc       print no search results, just set return code on hits.\n"
             "      -showrc       show return code at end of command.\n");
      else
      printx("      -quiet        do not show progress infos.\n"
             "      -stat         show statistics like hits per pattern and no. of files.\n"
             "      -perf         show performance statistics.\n");
             #ifndef SFKXEREP
      if (bIsReplace)
      printx("      -memlimit=nm  with different-length replacements, files must be loaded\n"
             "                    into memory for processing. the default limit for memory\n"
             "                    use is 300 MB. set -memlimit=500m to select 500 MB.\n");
             #endif
      #ifdef WITH_REPEAT
      if (bIsReplace)
      printx("      -repeat=n     XE only: repeat replace on the same file up to n times,\n"
             "                    to also replace hits produced by previous replace runs.\n"
             "                    can be used only when changing files directly, but not\n"
             "                    with -to[file]. if possible, always try to rewrite your\n"
             "                    search patterns to avoid use of this option, as it is\n"
             "                    slower to rewrite the same file over and over. replace-\n"
             "                    ments producing new hits may indicate a logical error\n"
             "                    within your search/replace patterns.\n"
             );
      #endif // WITH_REPEAT
      printx("      -full         print full help text telling about -bylist pattern files,\n"
             "                    batch file return codes, special character case sensi-\n"
             "                    tivity and nested or repeated replace behaviour.\n"
             "\n");

      printx("   $output options:\n");
      if (!bIsHexFind && (bIsXFind || bIsXText))
      printx("      -conlines=n1  show n lines of context around search hits. by default\n"
             "                    only text lines containing one or more hits are shown.\n"
             "                    all lines together cannot hold more than:\n"
             "      -conchars=n2  max. number of characters of all context lines together.\n"
             "                    default is 240 or n1*160. cannot be larger than 32000.\n"
             "      -conresline   show full result line but no further context (default)\n"
             "      -sep[arator]  show \"---\" separator between hits within a file.\n"
             "      -septext s    use separator text s (supports slash patterns \\n etc.)\n"
             "      -nosep        do not show \"---\" separator between hits within a file.\n"
             "      -indent=n     set n chars of indentation for result display.\n"
             "      -pure         extract only searched data, same as -context=0.\n"
             "                    you may also set an environment variable:\n"
             "                    <exp> SFK_CONFIG=xfind:pure,xtext:pure\n"
             "                    use -pure -tofile x to extract binary content as is.\n"
             "      -fill=c       replace binary null and other unprintable characters\n"
             "                    with character c. default is a dot \".\"\n"
             "      -hex          print output as hex dump instead of plain text.\n");
      if (!bIsXText && !bIsXFind && !bIsHexFind)
      printx("      -dump [-lean] create hexdump of hits, listing  8 bytes per line.\n"
             "                    also previews changes on replacements of same length.\n"
             "      -dump -wide   create hexdump of hits, listing 16 bytes per line;\n"
             "                    requires a shell window with at least 120 columns.\n");
      if (bIsHexFind)
      printx("      -nodump       hexfind shows a data dump by default. specify -nodump\n"
             "                    to just list the names of files containing matches.\n");
      printx("      -showle       highlight CR/LF line endings in hex dump output\n");
      if (!bIsXFind && !bIsXText)
      printx("      -context=n    with hexdump: show additional n bytes of context.\n"
             "      -reldist      with hexdump: tell relative distances to previous hits.\n");
      if (bExtract)
      printx("      -nofile       do not insert :file header lines in output.\n"
             "      -crlf, -lf    for file headers and default totext: force crlf or lf\n"
             "                    line endings instead of system default\n");
      if (bIsXPat && bExtract && !bIsHexFind)
      printx("      -filehead s   file header to insert on every matching file.\n"
             "                    only [file.name] surrounded by text can be used.\n"
             "                    default is -filehead \":file [file.name]\\n\"\n"
             "                    unless a single input filename is given.\n"
             "                    does not change hex dump output headers.\n"
             "      -sep s        define separator s between hits in a file\n");
      if (bIsXFind || bIsXText)
      printx("      -rawterm      on output to terminal do not strip codes below 32.\n"
             "                    null bytes are always stripped.\n");
      if (!bIsHexFind)
      printx("      -to dir<sla><run>file write output files to given path. for details about\n"
             "                    output file masks, type \"sfk help opt\" or \"sfk run\".\n"
             "      -tofile x     write output data to a single output filename x\n"
             "                    (which is not interpreted as a mask but taken as is).\n");
      if (!bIsReplace)
      printx("      +tofile x     as last parameter (command chaining): write text as\n"
             "                    displayed on terminal to a file x.\n");

      printx("\n");
      if (bFullHelp)
      printx("   $return codes for batch files\n"
             "      0 = no matches, 1 = matches found, >1 = major error occurred.\n"
             "      see also \"sfk help opt\" on how to influence error processing.\n"
             "\n");
      if (bFullHelp && bIsXPat)
      printx("   $the -bylist pattern command file\n"
             "      may contain /from/to/ commands as well as remark lines starting\n"
             "      with \":##\" and blank lines. commands can be split into several\n"
             "      lines forming blocks. when doing so, spaces around lines are\n"
             "      stripped, and all lines after the first line must start with\n"
             "      the separator character, or a space (not tab). multi line\n"
             "      commands must end with a dot '.' after the final separator.\n"
             "      search patterns for xfind or xtext must end with /[all]\\n/\n"
             "      if output text is not reformatted.\n"
             "      To keep whitespace at line start use \"\\ \" for a blank.\n"
             "      example: extract ID3v1 data from an .mp3 file\n"
             "        :## id3v1 tag, search for zero byte then 'TAG'\n"
             "        /\\0\\x54\\x41\\x47[30 bytes][30 bytes][30 bytes]\n"
             "        /[file.name]:\n"
             "         \\ [strip(part3,\\0)],[strip(part2,\\0)],[strip(part4,\\0)]\\n/.\n"
             "\n"
             "   $the -bylinelist simplified pattern command file\n"
             "      may contain /from/to/ or just /from/ commands, with exactly\n"
             "      one command per line. the /to/ part is optional, allowing\n"
             "      to search many phrases without typing /[all]\\n/ everytime.\n"
             "\n"
             );
      else
      if (bFullHelp)
      printx("   $the -bylist pattern command file for sfk replace and hexfind\n"
             "      may contain \":text\" or \":binary\" commands followed by any number\n"
             "      of replacement patterns, and remark lines starting with \":##\".\n"
             "      if the first line is no command, a \":text\" section is assumed.\n"
             "      specify -spat before -bylist to enable slash patterns like \\x0d\\x0a.\n"
             "      commands can be split into several lines. when doing so, whitespace\n"
             "      around lines is stripped, and all lines after the first line\n"
             "      must start with the separator or a blank character. multi line\n"
             "      commands must end with a dot '.' after the final separator,\n"
             "      search commands with empty /to/ text should end like //.\n"
             "      example file with single line and multi line formatting:\n"
             "      :text\n"
             "      :## now comes a single line command. this is a remark.\n"
             "      /foobar/barfoo/\n"
             "      _the test_the text_\n"
             "      :## now comes a free formatted command.\n"
             "      /foobar 123 the quick brown fox/\n"
             "       foobar 987 the quick brown fox/.\n"
             "      :binary\n"
             "      /0d0a/200a/\n"
             "\n"
             );
      if (bFullHelp)
      printx("   $case sensitive search with \\xnn, accents and umlauts\n"
             "    - since SFK 1.69, hex codes like \\x41 are not treated as characters\n"
             "      even if they represent a character code, and are therefore not\n"
             "      searched case insensitive. this can be changed by option -xchars.\n"
             "    - accents and umlauts in -text patterns are searched case insensitive\n"
             "      according to code page ISO 8859-1, e.g. code 0xC0 (small a accent)\n"
             "      is equal to 0xE0. this can be disabled by option -noacc[ents].\n"
             "      options can also be set by environment like:\n"
             "         <exp> SFK_CONFIG=xchars,noaccents\n"
             "\n");
      if (bIsReplace)
      printx("   $about nested replacement patterns\n"
             "      #sfk replace myfile.dat /foo/bar/ /bar/goo/\n"
             "      with SFK base, \"foo\" will be replaced by \"bar\" and then\n"
             "      immediately \"bar\" is replaced again by \"goo\".\n"
             "      with SFK XE, a replaced part of text is not replaced again\n"
             "      in the same command, so \"foo\" stays replaced by \"bar\".\n"
             #ifdef WITH_REPEAT
             "      this can be changed by option -repeat (read more there).\n"
             #endif
             "\n"
             );
      if (bIsReplace)
      {
      printx("   $unexpected repeat replace behaviour\n"
             "      depending on the input data and search/replace expressions,\n"
             "      it can happen that running the same replace multiple times\n"
             "      on the same file produces further hits that didn't exist\n");
      if (!bFullHelp)
      printx("      in the first run. add option -full to read more on this.\n"
             "\n");
      else
      printx("      in the first run, for example:\n"
             "      -  input file contains #foothenbar\n"
             "      -  patterns are #-text /then// -text /foobar//\n"
             "      then this will happen with SFK XE:\n"
             "      -  on the first replace run, no \"foobar\" is found, but\n"
             "         \"then\" is removed from text, producing a new \"foobar\".\n"
             "         however, this new \"foobar\" is NOT replaced, because\n"
             "         text processing already reached the position after\n"
             "         \"foo\", i.e. the word \"bar\".\n"
             "      -  on the second replace run, a \"foobar\" is found that\n"
             "         did not exist in the first run, and replaced.\n"
             #ifdef WITH_REPEAT
             "      SFK XE has an option -repeat=n to reiterate on the same file\n"
             "      up to n times. read more under the -repeat help text.\n"
             "      SFK Base behaves slightly different, due to a different\n"
             "      replace implementation, but it also does not reiterate\n"
             "      and has no option to do so. With a pattern sequence\n"
             "      \"/foobar//\" \"/then//\" the same will happen with SFK Base.\n"
             #else
             "      please note that there is no option to reiterate on the\n"
             "      same file in one call of sfk replace, so re-replaces\n"
             "      over newly combined text cannot be done automatically.\n"
             "      SFK Base behaves slightly different, due to a different\n"
             "      replace implementation, but it also does not reiterate.\n"
             "      With a pattern sequence -text /foobar// -text /then//\n"
             "      in the above example the same will happen with SFK Base.\n"
             #endif
             "\n");
      }
      printSearchReplaceCommands();
      printBewareLean();
      webref(pszCmd);
      if (!bIsXPat)
      printx("   $common usage errors\n"
             "      #sfk hexfind in.txt \"/foo\\r\\n/\"\n"
             "         will not find \"foo\" at line ends, but searches literal\n"
             "         strings like \"slash and r\". add option -spat to enable\n"
             #ifndef SFKXDXE
             "         slash patterns, converting \\r\\n to real CRLF codes.\n"
             "      #sfk hexfind mydir \"/foo*bar/\"\n"
             "         will not find \"foo\" and \"bar\" with any characters\n"
             "         inbetween, but searches a literal star \"*\". get SFK\n"
             "         Base+XD or XE then use #xhexfind<def> to enable wildcards.\n"
             #else
             "         slash patterns, converting \\r\\n to real CRLF codes,\n"
             "         or use #xhexfind<def> where slash patterns are default.\n"
             "      #sfk hexfind mydir \"/foo*bar/\"\n"
             "         will not find \"foo\" and \"bar\" with any characters\n"
             "         inbetween, but searches a literal star \"*\".\n"
             "         use #xhexfind<def> to enable search with wildcards.\n"
             "      #sfk rep in.txt \"/foo[1000 bytes]bar/---/\"\n"
             "         will not replace 1000 bytes between \"foo\" and \"bar\",\n"
             "         but replaces a literal string \"foo\" then \"[1000 bytes]\"\n"
             "         then \"bar\". use #xreplace<def> to enable SFK expressions.\n"
             #endif
             #ifndef _WIN32
             "      #sfk hexfind any.exe -spat /\\x00$$version/\n"
             "         will not search for a string \"$$version\" prefixed by\n"
             "         a null byte. the linux console will destroy the \\ and\n"
             "         $$ arguments, giving junk to sfk. type instead:\n"
             "         #sfk hexfind any.exe -spat \"/\\x00\\$$version/\"\n"
             #endif
             "\n"
             );
      if (bIsFHexFind)
      printx("   $examples\n"
             "      #sfk hexfind -text \"/foo/\" \"/bar/\" -dir mydir -file .txt .hpp\n"
             "         find words \"foo\" or \"bar\" case insensitive\n"
             "         in all .txt or .hpp files in a folder mydir.\n"
             "      #sfk hexfind -binary /666f6f/ -dir mydir -file .exe +view\n"
             "         find binary data with hex values 0x66, 0x6f, 0x6f\n"
             "         in all .exe files of mydir and show result in dview.\n"
             "\n");
      else
      if (!bIsXPat)
      {
      printx("   $examples\n"
             "      #sfk replace myfile.dat \"/Lemon/Curry/\"\n"
             "         replace Lemon by Curry within myfile.dat. search is\n"
             "         case-insensitive, therefore \"lemon\" will be replaced as well.\n"
             "         the quotes \"\" are optional here.\n"
             "      #sfk replace -pat /FooCase// -dir . -file .txt\n"
             "         search for FooCase in all .txt files below current directory.\n"
             "         note that if you leave out the single fileOrDir parameter,\n"
             "         you have to say -[s]pat, -bin or -text first to tell clearly\n"
             "         that you will specify the target fileset later on.\n"
             "      #sfk rep -spat \"/The foo/The\\tbar/\" -dir mydocs\n"
             "         replaces \"The foo\" by \"The\" and \"bar\" separated by TAB char,\n"
             "         within all files within mydocs.\n"
             "      #sfk rep -binary /1A/20/ -dir docs -file .txt .info .note\n"
             "         replaces all bytes with code 0x1A by code 0x20, in all .txt,\n"
             "         .info and .note files, in directory docs and all subdirectories.\n"
             "      #sfk replace tmp\\image.dat -bylist patches.txt\n"
             "         searches for source patterns in file tmp\\image.dat,\n"
             "         replaces by patterns specified in patches.txt\n"
             );
      #if defined(SFKXDXE)
      printx("      $SFK Base and XE: swap text in two steps\n");
      #else
      printx("      $SFK Base: swap text in two steps\n");
      #endif
      printx("      #sfk -yes rep io.txt /foo34/foo99/ /foo12/foo34/ +rep /foo99/foo12/\n"
             "         replaces foo12 by foo34 and vice versa. with SFK Base, a word\n"
             "         which is replaced may be replaced again by a following pattern,\n"
             "         therefore the intermediate step: turn foo34 into something\n"
             "         not used anywhere in io.txt, then replace foo12, then replace\n"
             "         the intermediate pattern back in a second replace command\n"
             "         on the same file.\n");
      printx("      #sfk hexfind mydir -pat /FooCase/ +list -late\n"
             "         do not replace, just find binary files containing \"FooCase\",\n"
             "         then list them sorted by time. also accepts -bylist files.\n");
      }
      else
      {
         printXRepExamples(pszCmd, bIsReplace ? 0 : 1, bIsReplace);
      }

      if (bIsFReplace || bGlblCollectHelp)
      printx("      #sfk replace -binary /666f6f/626172/ -dir mydir -file .dat\n"
             "         replace binary data with hex values 0x66, 0x6f, 0x6f\n"
             "         by data with values 0x62, 0x61, 0x72 in all .dat files.\n");

      if (bIsXFind || bGlblCollectHelp)
      printx("      #sfk xfind in.dat \"/foo[0.100 bytes of (a-z0-9_@ )]bar/\"\n"
             "         searches a single input file in.dat for all phrases\n"
             "         starting foo and ending bar, with 0 to 100 characters\n"
             "         inbetween being alphanumeric, @ or _ or space.\n"
             "      #sfk xfind -text \"/foo*bar/[part2]\\n\" -dir mydir -file .txt\n"
             "         find foo*bar in all .txt files of folder mydir\n"
             "         but print only the text between foo and bar.\n"
             "      #sfk xfind -text \"/\\x66\\x6f\\x6f[0.100 bytes]\\x62\\x61\\x72/\"\n"
             "       #-dir mydir -file .exe +view\n"
             "         find binary data starting with bytes 0x66, 0x6f, 0x6f,\n"
             "         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween\n"
             "         in all .exe files of mydir and show result in dview. [14]\n"
             "      #sfk xfind -arc in.zip \"/class*/\"\n"
             "         XE: find phrases starting with \"class\" in .zip contents\n"
             );

      if (bIsXText || bGlblCollectHelp)
      printx("      #sfk xtext -pure -text \"/foo*bar/[part2]\\n/\"\n"
             "       #-dir mydir -file .txt +view\n"
             "         search foo*bar in all .txt files of folder mydir,\n"
             "         extract the text between foo and bar without any\n"
             "         context (-pure), and display this in dview. [15]\n"
             "      #sfk xtext -arc in.zip \"/class*/\"\n"
             "         XE: find phrases starting with \"class\" in .zip contents\n"
             );

      if (bIsXHexFind || bGlblCollectHelp)
      printx("      #sfk xhexfind -text \"/\\x66\\x6f\\x6f[0.100 bytes]\\x62\\x61\\x72/\"\n"
             "       #-dir mydir -file .exe +view\n"
             "         find binary data starting with bytes 0x66, 0x6f, 0x6f,\n"
             "         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween\n"
             "         in all .exe files of mydir and show result in dview. [16]\n");

      if (bIsXReplace || bGlblCollectHelp)
      printx("      #sfk xreplace in.txt \"/foo*bar/other/\"\n"
             "         replace phrases starting with \"foo\" and ending with \"bar\"\n"
             "         by word \"other\" in single file in.txt\n"
             "      #sfk xreplace -text \"/foo*bar/===[part2]===\\n\" -dir mydir -file .txt\n"
             "         replace foo*bar in all .txt files of folder mydir\n"
             "         with a new pattern containing the text between foo and bar\n"
             "         surrounded by \"===\".\n"
             "      #sfk xrep -text \"/\\x66\\x6f\\x6f[0.100 bytes]\\x62\\x61\\x72/---/\" -dir mydir -file .dat\n"
             "         replace binary data starting with bytes 0x66, 0x6f, 0x6f,\n"
             "         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween\n"
             "         by \"---\" within all .dat files of folder mydir.\n");

      if (bIsXExtract || bGlblCollectHelp)
      {
      printx("      #sfk extract in.txt \"/foo[0.100 chars of (a-z0-9_@ )]bar/\"\n"
             "         extracts from a single input file in.txt all phrases\n"
             "         starting foo and ending bar, in the same line, with\n"
             "         0 to 100 characters inbetween being alphanumeric or\n"
             "         one of @ _ or a blank character.\n"
             "      #sfk extract mydir \"/\\x66\\x6f\\x6f[0.100 bytes]\\x62\\x61\\x72/\" -tofile out.dat\n"
             "         find binary data starting with bytes 0x66, 0x6f, 0x6f,\n"
             "         ending with 0x62, 0x61, 0x72 and up to 100 bytes inbetween\n"
             "         within all files of folder mydir, writing found data\n"
             "         to a single file out.dat\n");
      printx("      #sfk extract -text \"/class [bytes]{[bytes]}/[all]\\n\\n/\"\n"
             "       #-tofile out.txt -dir mydir -file .hpp\n"
             "         collect class definitions from mydir directly to out.txt [10]\n"
             "      #sfk extract -dir mydir -file .cpp -text \"/printf([bytes]);/[all]\\n/\"\n"
             "       #+xed \"/);[eol]/[all]/\" \"/[eol][1.* white]/ /\"\n"
             "         extract all (multi line) printf statements from source code,\n"
             "         convert multi line to single line, stripping whitespace. [11]\n"
             "         the \"/);[eol]/[all]/\" keeps all line endings after \");\"\n"
             "      #sfk extract -text \"/%c%cversion:vernum=*,*name=*,*os=*,/\n"
             "       #[file.name]: [part6] v[part2] for [part10]\\n/\"\n"
             "       #-tofile versions.txt -dir mydir -file .exe -nofilenames\n"
             "         search all .exe files in mydir for a text block like\n"
             "          #%c%cversion:vernum=1.6.9,name=fooprog,os=windows\n"
             "         then extract and reformat version informations,\n"
             "         writing results without :file headers to versions.txt [12]\n"
             ,'$','$','$','$' // to avoid version command error on binary
             );
      }

      #ifndef SFKXEREP
      if (strBegins(pszCmd, "xrep")) {
         printf("\nThis help is only for information, the actual command requires SFK XE.\n"
                "Please type \"sfk help xe\" for more.\n");
         return 9;
      }
      #endif

      ehelp;

      #ifndef SFKXEREP
      if (strBegins(pszCmd, "xrep"))
         return 9+perr("xreplace requires SFK XE. type \"sfk help xe\" for more.");
      #endif

      char *pszConf = getenv("SFK_CONFIG");
      if (!pszConf) pszConf = str("");

      char *pszRepFile  = 0;
      char *pszFirstPat = 0;
      char *pszChainOutCmd = 0;
      bool  bRevert     = 0;
      int  nstate       = 0;
      bool bGotFileDir  = 0;
      bool bcolpat      = 0;
      bool bforcedump   = 0;
      bool bNoTmp       = 0;
      bool bIncomplete  = 0;
      int  iShowPreState = 0;
      bool bHaveSingleNames = 0;
      bool bSendNames   = 0;
      bool bGotIndent   = 0;
      bool bGotPure     = 0;
      bool bGotLean     = 0;
      bool bUsedContext = 0;
      bool bGotHex      = 0;

      cs.usefilehead    = 0;
      cs.szfilehead[0]  = '\0';
      cs.placeholder    = '.';

      cs.repDumpHalve   = bIsHexFind;

      #ifdef VFILEBASE
      if (bIsAnyFind || bExtract)
         cs.precachezip = 1;
      #endif // VFILEBASE
      
      cs.recordsize     = 100000;
      cs.contextchars   = 240;

      memset(abBuf, 0, sizeof(abBuf)); // for direct patterns

      // autoselect hex dump width by console width
      if (bGlblConsColumnsSet && (nGlblConsColumns >= 120))
         bGlblHexDumpWide = 1;

      // autoselect dump per command
      if (bIsXFind || bIsXText) { // init
         cs.repDump = 1;
         bforcedump = 1;
         cs.astext  = 1;
         cs.noind   = 1;
         cs.xtext   = 1;
         cs.quiet   = 1;
         cs.litattr = 'e'; // literal highlight attribute
         cs.xfind   = !strcmp(pszCmd, "xfind");
         if (bIsXFind!=0 && strstr(pszConf, "xfind:pure"))
            { bUsedContext=1; cs.contextlines = 0; }
         else
         if (bIsXText!=0 && strstr(pszConf, "xtext:pure"))
            { bUsedContext=1; cs.contextlines = 0; }
         else
            cs.contextlines = 1; // current line
      }
      if (bIsHexFind) {
         cs.repDump  = 1;
         cs.astext   = 0;
         cs.xtext    = 0;
         cs.hexfind  = 1;
         if (strEnds(pszCmd, "le"))
            cs.leattr = 'e';
      }
      if (bIsXText)
         cs.textfiles = 1;
      // changed later in case of -justrc

      cs.xpat    = bIsXPat;
      cs.extract = bExtract;

      char szDefaultTo[100];
      szDefaultTo[0] = '\0';

      int iFirst = iDir;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-dir")) 
         {
            // parse initial -dir ... -file ... parameters
            int iDirNext = 0;
            if (cs.debug)
               printf("[processDirParms.1 from idx=%d]\n", iDir);
            if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 5, &iDirNext))) {
               nGlblError=1;
               pinf("try to add -enddir after initial -dir ... -file ...\n");
               return 9;
            }
            // continue with command local parms after that
            if (cs.debug)
               printf("[processDirParms.1 done, inext=%d]\n", iDirNext);
            if (iDirNext <= 0) {
               // sfk rep -dir ... -enddir -text ...
               if (iDir == iFirst)
                  return 9+perr("missing -enddir after initial -dir ... -file ... options\n");
               // sfk rep -text ... -dir ...
               iDir = argc; // fix: 169: [2131217] folders done twice
               break;
            }
            iDir = iDirNext;
         }
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-bylist", &pszParm)) {
            if (!pszParm) return 9;
            pszRepFile = pszParm;
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-bylinelist", &pszParm)) {
            if (!pszParm) return 9;
            pszRepFile = pszParm;
            cs.fixedbylist = 1;
            continue;
         }
         #ifdef WITH_REPEAT
         if (haveParmOption(argv, argc, iDir, "-repeat", &pszParm)) {
            if (!pszParm) return 9;
            if (!(cs.reprep = atoi(pszParm)))
               return 9+perr("supply -repeat=n or repeat n with a non zero value.");
            continue;
         }
         #endif
         if (haveParmOption(argv, argc, iDir, "-fill", &pszParm)) {
            if (!pszParm) return 9;
            cs.placeholder = *pszParm;
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-filehead", &pszParm)) {
            if (!pszParm) return 9;
            cs.usefilehead = 1;
            copyFromFormText(pszParm,strlen(pszParm), cs.szfilehead,sizeof(cs.szfilehead)-20);
            if (strchr(cs.szfilehead, '%'))
               return 9+perr("percent \"%%\" is not allowed in file header");
            char *psz = strstr(cs.szfilehead, "[file.name]");
            if (psz) {
               char *psz2 = psz+strlen("[file.name]");
               strcpy(psz, "%s");
               memmove(psz+2, psz2, strlen(psz2)+1);
            }
            continue;
         }
         if (!strcmp(argv[iDir], "-rawterm")) {
            cs.rawterm = 1;
            continue;
         }
         if (!strcmp(argv[iDir], "-revert")) {
            bRevert = 1; // internal
            continue;
         }
         if (!strcmp(argv[iDir], "-text")) {
            bcolpat = 1;
            nstate = 1;
            strcat((char*)abBuf, ":text\n");
            continue;
         }
         if (!strncmp(argv[iDir], "-bin", 4)) {
            bcolpat = 1;
            nstate = 2;
            strcat((char*)abBuf, ":binary\n");
            continue;
         }
         if (!strcmp(argv[iDir], "-dump")) {
            cs.repDump = 1;
            bforcedump = 1;
            continue;
         }
         if (!strcmp(argv[iDir], "-wide")) {
            bGlblHexDumpWide = 1;
            continue;
         }
         if (!strncmp(argv[iDir], "-pat", 4)) {
            bcolpat = 1;
            continue;
         }
         if (!strncmp(argv[iDir], "-spats", 6)) {
            bcolpat = 1;
            cs.spat = 2; // strict slash patterns
            continue;
         }
         if (!strncmp(argv[iDir], "-spat", 5)) {
            bcolpat = 1;
            cs.spat = 1;
            continue;
         }
         if (!strcmp(argv[iDir], "-reldist")) {
            cs.reldist = 1;
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-recsize", &pszParm)) {
            if (!pszParm) return 9;
            cs.recordsize = numFromSizeStr(pszParm, "record size");
            if (cs.recordsize < 1)
               return 9+perr("invalid record size");
            if (cs.verbose)
               printf("using record size: %s bytes\n", numtoa(cs.recordsize));
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-recordsize", &pszParm)) {
            if (!pszParm) return 9;
            cs.recordsize = numFromSizeStr(pszParm, "record size");
            if (cs.recordsize < 1)
               return 9+perr("invalid record size");
            if (cs.verbose)
               printf("using record size: %s bytes\n", numtoa(cs.recordsize));
            continue;
         }
         if (!strcmp(argv[iDir], "-lean") || !strcmp(argv[iDir], "-narrow"))
         {
            bGlblHexDumpWide = 0;
            bGotLean = 1;
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-context", &pszParm)) {
            if (!pszParm) return 9;
            nGlblDumpCtx = atoi(pszParm);
            continue;
         }
         if (!strcmp(argv[iDir], "-conresline")) {
            cs.contextlines = 1;
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-conlines", &pszParm)) {
            if (!pszParm) return 9;
            int ival = atoi(pszParm);
            if (ival > 0) {
               cs.contextlines = ival + 1;
               cs.contextchars = ival * 160;
               sprintf(cs.szseparator, "---%s", cs.szeol);
            } else {
               cs.contextlines = 0;
            }
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-conchars", &pszParm)) {
            if (!pszParm) return 9;
            int ival = atoi(pszParm);
            if (ival < 1 || ival > SFK_CTX_SIZE)
               return 9+perr("-conchars cannot be larger than %d", SFK_CTX_SIZE-100);
            cs.contextchars = ival;
            continue;
         }
         if (!strcmp(argv[iDir], "-pure")) {
            bGotPure = 1;
            cs.szseparator[0] = 0;
            cs.contextlines = 0;
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-indent", &pszParm)) {
            if (!pszParm) return 9;
            cs.indent = atoi(pszParm);
            bGotIndent = 1;
            continue;
         }
         if (strBegins(argv[iDir], "-showle")) {
            cs.leattr   = 'e';
            continue;
         }
         if (strBegins(argv[iDir], "-nole")) {
            cs.leattr   = 0;
            continue;
         }
         if (strBegins(argv[iDir], "-show")) {
            char *psz = argv[iDir]+5;
            int iwhat = 0;
            if (strBegins(psz, "part"))  iwhat |= 1;
            if (strBegins(psz, "best"))  iwhat |= 2;
            if (strBegins(psz, "list"))  iwhat |= 4;
            if (strBegins(psz, "all" ))  iwhat |= 7;
            if (iwhat & 1) {
               cs.showpre = 1;
               iShowPreState = 1;
            }
            if (iwhat & 2)
               cs.showpost = 1;
            if (iwhat & 4)
               cs.showlist = 1;
            continue;
         }
         if (!strcmp(argv[iDir], "-fixedbylist")) { // inofficial
            cs.fixedbylist = 1; // see -bylinelist instead
            continue;
         }
         if (!strcmp(argv[iDir], "-blank")) { // deprecated since 173
            sprintf(szDefaultTo, "[all]%s%s", cs.szeol, cs.szeol);
            continue;
         }
         if (!strcmp(argv[iDir], "-astext")) { // inofficial
            cs.astext = 1;
            continue;
         }
         if (strBegins(argv[iDir], "-hex")) {
            cs.astext   = 0;
            cs.xtext    = 0;
            cs.hexfind  = 1;
            bGotHex     = 1;
            continue;
         }
         if (!strcmp(argv[iDir], "-nodump")) {
            if (bGotHex)
               return 9+perr("-nodump excludes -hex. use xhexfind instead.");
            cs.repDump = 0;
            cs.dostat  = 1;
            continue;
         }
         if (haveParmOption(argv, argc, iDir, "-septext", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), cs.szseparator, sizeof(cs.szseparator)) < 0)
               return 9;
            continue;
         }
         if (strBegins(argv[iDir], "-sep") || strBegins(argv[iDir], "-separator")) {
            sprintf(cs.szseparator, "---%s", cs.szeol);
            continue;
         }
         if (strBegins(argv[iDir], "-nosep")) {
            cs.szseparator[0] = 0;
            continue;
         }
         if (!strcmp(argv[iDir], "-stat")) {
            cs.dostat = 1;
            continue;
         }
         if (strBegins(argv[iDir], "-prog")) {
            cs.quiet = 0;
            continue;
         }
         if (!strcmp(argv[iDir], "-fast")) { // no function
            cs.fastopt = 1;
            continue;
         }
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir])) {
               break; // fall through
            }
            if (setGeneralOption(argv, argc, iDir)) {
               continue;
            } else {
               return 9+perr("unknown option: %s\n", argv[iDir]);
            }
         }
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
         {
            if (bIsReplace && !strcmp(argv[iDir], "+xed")) {
               perr("(x)replace ... +xed is not supported.");
               pinf("you may use extract ... +xed instead.\n");
               return 9;
            }
            pszChainOutCmd = argv[iDir];
            if (!strcmp(argv[iDir], "+view") && !bGotLean)
               bGlblHexDumpWide = 1;
            break;
         }
 
         // non "-" parms
         if (!bcolpat && !chain.usefiles && !bGotFileDir) // && (iDir == iDirFirst)
         {
            // single dir or file specified.
            bGotFileDir = 1;
            Coi ocoi(argv[iDir], 0);
            if (ocoi.isTravelDir()) {
               // since 169: support single dir with all commands
               if ((lRC = setProcessSingleDir(argv[iDir])))
                  return lRC;
            } else {
                if (!ocoi.existsFile()) {
                  perr("no such file or dir: %s\n", argv[iDir]);
                  pinf("if this is a pattern, say -pat %s\n", argv[iDir]);
                  return 9;
               }
               if (cs.textfiles && ocoi.isBinaryFile()) {
                  if (cs.quiet < 2)
                     pwarn("skipping binary: %s", ocoi.name());
                  return 9;
               }
               glblSFL.addEntry(ocoi); // is copied
               bHaveSingleNames = 1;
               // cs.pure = 1;
            }
            bGlblShortSyntax = 1;
            continue;
         }
 
         // expecting patterns either after fileOrDir or -pat
         if (!pszRepFile) {
            if (nstate == 0) {
               // implicitely guess -text by default
               nstate = 1;
               strcat((char*)abBuf, ":text\n");
               bcolpat = 1;
            }
            if (bcolpat) {
               // add another /src/dst/ pattern string
               if (!pszFirstPat) pszFirstPat = argv[iDir];
               strcat((char*)abBuf, argv[iDir]);
               strcat((char*)abBuf, "\n");
               continue;
            }
         }
 
         return 9+perr("unexpected: %s\n", argv[iDir]);
         // continue w/next pattern, option or chain cmd.
      }
 
      if (btest) return 0;

      if (cs.verbose && bUsedContext)
         pinf("used SFK_CONFIG=%s\n", pszConf);

      if (!cs.usefilehead) {
         cs.usefilehead = 1;
         strcpy(cs.szfilehead, ":file %s");
         strcat(cs.szfilehead, cs.szeol);
      }

      if (bHaveSingleNames==1 && glblSFLNumberOfEntries()==1)
         cs.usefilehead = 0;

      if (cs.nohead || cs.nonames)
         cs.usefilehead = 0;

      if (cs.nonames)
         cs.noind = 1;

      if (bIsXFind || bIsXText) { // init.2
         // chaining to xed: binary only if pure
         if (!bGotPure)
            chain.colbinary = 0;
      }
      if (bIsReplace && !cs.quiet) {
         cs.dostat = 1;
      }

      if (!szDefaultTo[0]) {
         bool bUseDumpWithContext = cs.xtext && (cs.contextlines || cs.indent || cs.szseparator[0]);
         if (bUseDumpWithContext)
            sprintf(szDefaultTo, "[all]");
         else
            sprintf(szDefaultTo, "[all]%s", cs.szeol);
      }

      char *pszRepList = 0;

      if (pszRepFile) {
         if (strlen((char*)abBuf))
            return 9+perr("cannot combine patterns on command line with -bylist file. (1)\n");
         if (!(pszRepList = loadRepList(pszRepFile)))
            return 9+perr("unable to load -bylist file \"%s\"\n", pszRepFile);
      } else {
         if (!strlen((char*)abBuf)) {
            perr("no patterns found for processing.\n");
            pinf("say -text /src/dst/ or -binary _src_dst_ or -bylist file.txt\n");
            pinf("specify -dir or -file after patterns only.\n");
            return 9;
         }
         pszRepList = strdup((char*)abBuf);
      }
 
      // create replacement expression table
      if (iShowPreState==1) {
         iShowPreState = 2;
         printx("$Pat.  Range  MaxOut Memory FromText\n");
      }

      nBinRepExp = 0; // FIX: 1.69: missing init

      // 1. estimate size, allocate
      int nLines = 0;
      char *psz1 = pszRepList;
      for (; *psz1; psz1++) if (*psz1 == '\n') nLines++;
      // FIX: 1652: crash due to nMaxExp being to small by one.
      nLines++; // ALWAYS add one line in case last one has no LF.
      int nMaxExp = nLines + 10; // max. array entries with tolerance
      apRepSrcExp = new uchar*[nMaxExp];
      apRepDstExp = new uchar*[nMaxExp];
      apRepSrcLen = new int[nMaxExp];
      apRepDstLen = new int[nMaxExp];
      apRepFlags  = new int[nMaxExp];
      apRepOffs   = new num[nMaxExp];
      memset(apRepFlags, 0, sizeof(int)*nMaxExp);
      if (!apRepSrcExp || !apRepDstExp || !apRepSrcLen || !apRepDstLen || !apRepFlags)
         return 9+perr("out of memory\n");

      // FIX: 1683: missing init
      memset(apRepSrcExp, 0, sizeof(uchar*) * nMaxExp);
      memset(apRepDstExp, 0, sizeof(uchar*) * nMaxExp);
      memset(apRepSrcLen, 0, sizeof(int) * nMaxExp);
      memset(apRepDstLen, 0, sizeof(int) * nMaxExp);
      memset(apRepFlags , 0, sizeof(int) * nMaxExp);
      memset(apRepOffs  , 0, sizeof(num) * nMaxExp);

      #ifdef WITH_CASE_XNN
      if (!(apRepSrcBit = new uchar*[nMaxExp]))
         return 9+perr("out of memory\n");
      memset(apRepSrcBit, 0, sizeof(uchar*) * nMaxExp);
      #endif

      // REMEMBER PATTERN MEMORY ON RETURN.
      // In case of parameter errors, nGlblError must be set,
      // to avoid memory leak checks on exit.

      bool bHaveDiffLen = 0;
      bool bVarMode     = 0;

      // 2. parse expressions
      // since 1643: -bylist default is :text
      nstate = pszRepFile ? 1 : 0;
      char *psz2  = 0;
      int nLine  = 0;
      for (psz1 = pszRepList; psz1 && (*psz1); psz1=psz2) 
      {
         // fetch and prepare line
         nLine++;
         psz2 = strchr(psz1, '\n');
         if (!psz2) psz2 = psz1+strlen(psz1);
         *psz2++ = '\0';
         char *psz3 = strchr(psz1, '\r');
         if (psz3) *psz3 = '\0';
         if (!*psz1) continue; // empty line
         // extract line number prefix, if any
         if (!strncmp(psz1, ":@", 2)) {
            psz1 += 2;
            nLine = atoi(psz1);
            while (isdigit(*psz1))
               psz1++;
            if (*psz1==' ')
               psz1++;
         }
         if (!strncmp(psz1, ":#", 2)) continue; // remark
         // process line
         if (!strcmp(psz1, ":text"))
            { nstate=1; continue; }
         else
         if (!strcmp(psz1, ":binary"))
            { nstate=2; continue; }
         else
         if (!nstate || (*psz1 == ':')) {
            nGlblError=1;
            return 9+reperr("unexpected command", psz1, pszRepFile, nLine);
         }
         // within expression block /from/to/
         char *pszfs = psz1; // from, start
         char cLimit = *pszfs++;
         if (!cLimit) break;
         if (!*pszfs) return 9+reperr("incomplete replacement pattern", psz1, pszRepFile, nLine);
         char *pszfe = strchr(pszfs, cLimit);
         if (!pszfe) return 9+reperr("incomplete replacement pattern", psz1, pszRepFile, nLine);
         char *pszts = pszfe+1;
         char *pszte = strchr(pszts, cLimit);
         if (!pszte) {
            // uncomplete /to/ text
            if (bIsAnyFind || cs.extract) {
               // accept /foo/ and /foo// but not /foo/any
               if (*pszts)
                  return 9+reperr("wrong find pattern, missing delimiter", psz1, pszRepFile, nLine);
               // empty /to/ with extract
               if (cs.xpat) {
                  pszts = szDefaultTo;
                  pszte = pszts+strlen(pszts);
               } else {
                  pszte = pszts;
               }
            } else {
               return 9+reperr("incomplete replacement pattern", psz1, pszRepFile, nLine);
            }
         }
         // check for garbage after closing delimiter
         if (pszte && (strlen(pszte) > 1))
            return 9+reperr("wrong pattern, check delimiters", psz1, pszRepFile, nLine);
         // pszfs is exact start of from
         // pszfe is one after end of from
         *pszfe = '\0';
         // same for pszts, pszte
         *pszte = '\0';
         // shrink \\t and the like in both expressions
         uchar *pFromBits=0,**ppFromBits=0;
         uchar *pToBits=0,**ppToBits=0;
         int nFromLen = pszfe-pszfs;
         int nToLen   = pszte-pszts;
         if (!cs.xpat)
         {
            ppFromBits = cs.xpat ? 0 : &pFromBits;
            ppToBits = cs.xpat ? 0 : &pToBits;
            if (shrinkFormTextVar(pszfs, nFromLen, ppFromBits)) return 9+reperr("wrong syntax in pattern", pszfs, pszRepFile, nLine);
            if (shrinkFormTextVar(pszts, nToLen, ppToBits))     return 9+reperr("wrong syntax in pattern", pszts, pszRepFile, nLine);
            // => nFromLen, nToLen may have been reduced.
         }
         if (cs.xpat || (!bIsAnyFind && nFromLen != nToLen)) 
         {
            // different source / pattern length: select variable mode
            bHaveDiffLen = 1;
            bVarMode = 1;
            cs.repDumpHalve = 1;
         }
         if (bRevert) {
            int nSwap=nFromLen; nFromLen=nToLen; nToLen=nSwap;
            char *pSwap=pszfs; pszfs=pszts; pszts=pSwap;
                  pSwap=pszfe; pszfe=pszte; pszte=pSwap;
            #ifdef WITH_CASE_XNN
            uchar *pBits=pFromBits; pFromBits=pToBits; pToBits=pBits;
            #endif
         }
         #ifdef WITH_CASE_XNN
         if (pToBits) delete [] pToBits;
         #endif
         // store source and target.
         // FIX: 1652: missing array overflow check
         if (nBinRepExp >= nMaxExp) // internal, should not happen 
            return 9+reperr("pattern array overflow", pszfs, pszRepFile, nLine);
         if (nstate == 1) {
            // as text
            {
               apRepSrcLen[nBinRepExp] = nFromLen;
               apRepDstLen[nBinRepExp] = nToLen;
               apRepSrcExp[nBinRepExp] = (uchar*)mymemdup(pszfs, nFromLen);
               apRepDstExp[nBinRepExp] = (uchar*)mymemdup(pszts, nToLen);
               apRepFlags[nBinRepExp]  = (0 << 0); // is text
               bool bUseCase = cs.nocase ? 0 : cs.usecase;
               if (bUseCase)
                  apRepFlags[nBinRepExp] |= (1 << 2); // case sensitive
               #ifdef WITH_CASE_XNN
               apRepSrcBit[nBinRepExp] = pFromBits; // if any
               #endif
            }
            nBinRepExp++;
         } else {
            // as binary
            if (nFromLen & 1) return 9+reperr("wrong length of hex expression", pszfs, pszRepFile, nLine);
            if (nToLen   & 1) return 9+reperr("wrong length of hex expression", pszts, pszRepFile, nLine);
            int nSrcBinLen = nFromLen / 2;
            int nDstBinLen = nToLen   / 2;
            apRepSrcLen[nBinRepExp] = nSrcBinLen;
            apRepDstLen[nBinRepExp] = nDstBinLen;
            apRepSrcExp[nBinRepExp] = new uchar[nSrcBinLen+10];
            apRepDstExp[nBinRepExp] = new uchar[nDstBinLen+10];
            if (hexToBin(pszfs, apRepSrcExp[nBinRepExp], nSrcBinLen))
               return 9+reperr("syntax error in hex expression", pszfs, pszRepFile, nLine);
            if (hexToBin(pszts, apRepDstExp[nBinRepExp], nDstBinLen))
               return 9+reperr("syntax error in hex expression", pszts, pszRepFile, nLine);
            apRepFlags[nBinRepExp]  = (1 << 0); // is binary
            bool bUseCase = cs.nocase ? 0 : 1;
            if (bUseCase)
               apRepFlags[nBinRepExp] |= (1 << 2); // case sensitive
            #ifdef WITH_CASE_XNN
            apRepSrcBit[nBinRepExp] = pFromBits; // if any
            #endif
            nBinRepExp++;
         }
      }  // endfor RepList

      if (bIncomplete) {
         printx("$[complete all /from/to/ patterns to continue]\n");
         bGlblEscape = 1;
         return 5;
      }

      if (!nBinRepExp)
         { nGlblError=1; return 9+perr("no patterns for replacement, nothing to do.\n"); }

      int iDirNext=0;
      if (iDir < argc) {
         if (cs.debug)
            printf("[processDirParms.2 from idx=%d]\n", iDir);
         if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 5, &iDirNext)))
            { nGlblError=1; return lRC; }
      }
      
      if (!chain.usefiles && !bGotFileDir && !glblFileSet.rootDirs().numberOfEntries()) {
         perr("please specify a fileset using -dir ... -file ...\n");
         if (pszFirstPat)
            pinf("if %s is a filename, specify it BEFORE -spat or -pat.\n", pszFirstPat);
         nGlblError=1;
         return 9;
      }

      cs.sim = !cs.yes;

      // plausi checks:
      if (chain.colfiles) {
         if (cs.sim && !bIsAnyFind) {
            perr("cannot chain output this way. say \"hexfind\" instead.\n");
            nGlblError=1;
            return 9;
         }
         cs.nohead  = 1;
         cs.quiet = 1;
         // if collecting filenames, hexdump only if requested.
         cs.repDump = bforcedump;
      }
      // no replace with hexfind
      if (bIsHexFind && !bIsXHexFind && !cs.xtext) {
         if (!cs.sim) {
            nGlblError=1;
            return 9+perr("option -yes cannot be used with hexfind.");
         }
         cs.nohead = 1;
         if (cs.justrc) {
            cs.repDump = 0;
            cs.quiet = 2;
         }
      }
      if (cs.justrc && !bIsAnyFind)
         return 9+perr("-justrc can be used only with find commands.\n");
      // no sim with output to console or single file
      if (cs.extract) {
         if (!cs.tomask || cs.tomaskfile) {
            // auto correct: extract ... +view instead of +xed
            if (!cs.xtext && chain.coldata && !chain.colbinary) {
               if (cs.verbose)
                  pinf("%s accepts only text, sending hex dump.\n", pszChainOutCmd ? pszChainOutCmd : "next command");
               cs.repDump = 1;            
            }
            if (!chain.coldata && !cs.tomaskfile && !bIsHexFind)
               cs.repDump = 1;
            cs.yes = 1;
            cs.sim = 0;
         }
      }
      if (bIsHexFind && cs.tomask) {
         perr("-to[file] cannot be used with (x)hexfind.");
         pinf("use \"+tofile filename\" as last parameter to store hex dump output.\n");
         pinf("use \"sfk extract\" to store binary data with option -tofile.\n");
         nGlblError=1;
         return 9;
      }
      if ((bIsXFind || bIsXText) && cs.hexfind && cs.tomask) {
         perr("-to[file] cannot be used with xfind -hex output.");
         pinf("use \"+tofile filename\" as last parameter to store hex dump output.\n");
         pinf("use \"sfk extract\" to store binary data with option -tofile.\n");
         nGlblError=1;
         return 9;
      }
      #ifndef SFKXEREP
      // -to ... not supported with (x)replace, (x)hexfind
      if (!cs.extract && cs.tomask)
         { nGlblError=1; return 9+perr("replace with -to[file] requires SFK XE.\n"); }
      #endif

      #ifdef WITH_BITFILTER
      // to speed up search in some cases use a big bitfield
      if (cs.fastopt > 0)
      do
      {
         if (cs.xpat)
            return 9+perr("-fast can be used only with replace (not xreplace)\n");
         if (glblBitFilter.reinit())
            return 9+perr("out of memory\n");
   
         // init the 3char sequences start filter field
         int iminlen=0, imaxlen=0;
         for (int iPat=0; iPat<nBinRepExp; iPat++)
         {
            uchar *pPatText = apRepSrcExp[iPat];
            int   nPatLen   = apRepSrcLen[iPat];
            int   nPatFlags = apRepFlags[iPat];
            bool   bUseCase = (nPatFlags & (1<<2)) ? 1 : 0;
            uchar *pFlags   = apRepSrcBit[iPat]; // can be NULL
            uint  nPatStart = 0;
            if (iminlen==0 || nPatLen<iminlen) iminlen=nPatLen;
            if (imaxlen==0 || nPatLen>imaxlen) imaxlen=nPatLen;
            if (nPatLen < 1)
               continue;
            switch (nPatLen)
            {
               case 1: nPatStart =    (((uint)pPatText[0]) << 16);
                       glblBitFilter.setbits(nPatStart, 1, bUseCase, pFlags);
                       break;
   
               case 2: nPatStart =    (((uint)pPatText[0]) << 16)
                                   |  (((uint)pPatText[1]) <<  8);
                       glblBitFilter.setbits(nPatStart, 2, bUseCase, pFlags);
                       break;
   
               default:nPatStart =    (((uint)pPatText[0]) << 16)
                                   |  (((uint)pPatText[1]) <<  8)
                                   |  (((uint)pPatText[2]) <<  0);
                       glblBitFilter.setbits(nPatStart, 3, bUseCase, pFlags);
                       break;
            }
         }
         // now bitfilter provides maxlen from 0 to 3
         if (glblBitFilter.maxlen >= 2)
            cs.fastopt = 2; // use full lookup

         if (cs.verbose)
            printf("using -fast mode %d. pattern minlen=%d maxlen=%d\n", cs.fastopt, iminlen, imaxlen);
      }
      while (0);
      #endif // WITH_BITFILTER

      if (cs.sim && !cs.nohead)
         printx("$[simulating:]\n");

      if (cs.dostat || cs.verbose)
      {
         chain.print('h', 0, "[total hits/matching patterns/non-matching patterns]\n");
      }

      if (bVarMode && cs.sim && cs.repDump) {
         bVarMode = 0;        // varrep in simulation: use replacefix for hexdump
         cs.repDumpHalve = 1; // only source hits, no replacement preview
      }
      
      if (cs.memcheck) sfkmem_checklist("replace.parse");

      {
         if (bVarMode || cs.tomask)
            lRC = walkAllTrees(eFunc_ReplaceVar, lFiles, lDirs, nBytes);
         else
            lRC = walkAllTrees(eFunc_ReplaceFix, lFiles, lDirs, nBytes);
      }

      if (!lRC && (cs.filesChg > 0)) lRC = 1; // any hits or changes

      if (cs.memcheck) sfkmem_checklist("replace.exec");

      globalExtractOutCleanup();

      if (cs.xtext)
         { }
      else
      if (cs.extract && chain.coldata)
         { }
      else
      if (cs.dostat || cs.verbose)
      {
         if (bIsAnyFind || cs.extract)
            chain.print("%d files checked, %d files matched.\n", cs.files, cs.filesChg);
         else
            chain.print("%d files checked, %d%s %s.\n",
               cs.files, cs.filesChg, cs.sim?" would be":"", cs.extract ? "written":"changed");
      }

      #ifndef SFKXEREP
      if (cs.sim && bVarMode && cs.verbose && !cs.extract) {
         pinf("source and target patterns have %s lengths. replacement may be slow.\n",
            cs.xpat ? "variable":"differing");
      }
      #endif

      if (cs.sim && !cs.nohead)
         printx("$[add -yes to execute.]\n");

      for (int i=0; i<nBinRepExp; i++) {
         if (apRepSrcExp[i])
            delete [] apRepSrcExp[i];
         if (apRepDstExp[i])
            delete [] apRepDstExp[i];
         #ifdef WITH_CASE_XNN
         if (apRepSrcBit[i])
            delete [] apRepSrcBit[i];
         #endif
      }

      #ifdef WITH_CASE_XNN
      delete [] apRepSrcBit; apRepSrcBit=0;
      #endif
      delete [] apRepSrcExp; apRepSrcExp=0;
      delete [] apRepDstExp; apRepDstExp=0;
      delete [] apRepSrcLen; apRepSrcLen=0;
      delete [] apRepDstLen; apRepDstLen=0;
      delete [] apRepFlags;  apRepFlags=0;
      delete [] apRepOffs;   apRepOffs=0;
      delete [] pszRepList;  pszRepList=0;

      nBinRepExp = 0;

      STEP_CHAIN(iDirNext, 1);

      bDone = 1;
   }

   bFullHelp = 0;
   
   bool bIsXed = 0;
   bool bIsXex = 0;

   
   // internal
   if (!strcmp(pszCmd, "testrep"))
   {
      int iTestCases = 1;
      
      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         iTestCases = atoi(argv[iDir]);
      }
      
      printf("Running %d test cases ...\n", iTestCases);
      
      for (int i=0; i<iTestCases; i++)
      {
         printf("[%d]\r", i+1); fflush(stdout);
         
         int irc = testReplace(1);
         if (irc)
            { lRC = irc; break; }
      }      
      
      printf("Done with RC=%d.\n", lRC);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "csvtotab") || !strcmp(pszCmd, "csvtab"))
   {
      ifhelp (bFullHelp || (chain.usedata == 0 && nparm < 1))
      printx("<help>$sfk csvtotab infile.csv [options]\n"
             "\n"
             "   convert csv data to plain tab separated.\n"
             "\n"
             "   $default input/output format:\n"
             "   - input fields are separated by a comma \",\"\n"
             "   - input fields can be surrounded by double quotes \"\n"
             "     and may contain escaped double quotes as \"\"\n"
             "   - output fields are separated by TAB characters\n"
             "   - surrounding quotes are stripped, and escaped\n"
             "     quotes are reduced to normal quotes\n"
             "   - if input contains any TABs they are changed to\n"
             "     a single blank character\n"
             "   - input fields cannot contain line breaks\n"
             "\n"
             "   $options\n"
             "     -tofile x     write output to file x\n"
             "     -insep=\"x\"    set input separator to character x\n"
             "                   e.g. ; or \\t\n"
             "     -outsep=\"x\"   change output separator\n"
             "     -quote=\"x\"    change quote character, e.g. \\x27\n"
             "                   uses single quote.\n"
             "     -tabrep=\"x\"   change tab replacement character\n"
             "\n"
             "   $see also\n"
             "     #sfk ascii<def>     list of ASCII codes for characters\n"
             "     #sfk tabtocsv<def>  further conversion examples\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "     #sfk csvtotab in.csv -tofile out.txt\n"
             "        convert to tab separated out.txt\n"
             "     #sfk filter in.csv -+foo +csvtotab\n"
             "        convert only lines with word \"foo\"\n"
             "     #sfk csvtotab in.csv +filter \"-<not>[warning]\"\n"
             "        drop all lines with [warning] from output\n"
             #ifdef _WIN32
             "     #sfk csvtotab in.csv +view -tab 10\n"
             "        view in.csv in Depeche View for convenient browse\n"
             "        and search of contents, with a tab size of 10.\n"
             "        Within DView press Ctrl+Tab to change tab size\n"
             "        in small steps, or Ctrl+Shift+Tab for large tabs.\n"
             #endif
             );
      ehelp;

      char *pszInFile = 0;
      char *pszOutFile = 0;
      char  szInSep[20];
      char  szOutSep[20];
      char  szQuote[20];
      char  szOutEsc[20];

      strcpy(szInSep , ",");
      strcpy(szOutSep, "\t");
      strcpy(szQuote , "\"");
      strcpy(szOutEsc, " ");

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-insep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szInSep, sizeof(szInSep)) != 1) {
               perr("invalid or too long input separator: %s", pszParm);
               pinf("use only a single char like ; or a valid slash pattern like \\t\n");
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-outsep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szOutSep, sizeof(szOutSep)) != 1) {
               perr("invalid or too long output separator: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-quote", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szQuote, sizeof(szQuote)) != 1) {
               perr("invalid quote: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-tabrep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szOutEsc, sizeof(szOutEsc)) != 1) {
               perr("invalid tab replacement: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszInFile) {
            pszInFile = pszArg;
            continue;
         }
         return 9+perr("unexpected parameter: %s\n", pszArg);
      }

      if (cs.tomask && cs.tomaskfile)
         pszOutFile = cs.tomask;

      cs.cinsep     = szInSep[0];
      cs.coutsep    = szOutSep[0];
      cs.cquote     = szQuote[0];
      cs.coutsepesc = szOutEsc[0];

      if (pszInFile) {
         Coi ocoi(pszInFile, 0);
         lRC = execCsvConv(0, &ocoi, 0, 0, -1, pszOutFile);
      } else {
         lRC = execCsvConv(0, 0, stdin, chain.usedata ? chain.indata : 0, -1, pszOutFile);
      }

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "tabtocsv") || !strcmp(pszCmd, "tabcsv"))
   {
      ifhelp (bFullHelp || (chain.usedata == 0 && nparm < 1))
      printx("<help>$sfk tabtocsv infile.txt [options]\n"
             "\n"
             "   convert plain tab separated data to csv.\n"
             "\n"
             "   $default input/output format:\n"
             "   - input fields are separated by a tab and should\n"
             "     not be surrounded by quotes, as these are not\n"
             "     interpreted. input fields themselves cannot\n"
             "     contain TAB characters.\n"
             "   - output fields are separated by comma \",\"\n"
             "   - output fields are surrounded by quotes \"\n"
             "     if input contains a comma or quote\n"
             "   - if input contains quotes it is escaped as \"\"\n"
             "\n"
             "   $options\n"
             "     -tofile x     write output to file x\n"
             "     -quotetext    surround all text by quotes\n"
             "     -quoteall     surround all output by quotes\n"
             "     -outsep=\"x\"   change output separator to\n"
             "                   character x, e.g. ; or \\t\n"
             "     -quote=\"x\"    change quote character\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "     #sfk tabtocsv in.txt -tofile out.csv\n"
             "        convert tab separated to csv in default format\n"
             "     #sfk csvtotab -quote=\"\\x27\" -insep=\";\" in.csv -tofile tmp.tsv\n"
             "        reads a CSV with input fields separated by semicolon and\n"
             "        surrounded by single quotes ' with ASCII code hex 27\n"
             "     #sfk tabtocsv -outsep=\";\" -quote=\"\\x27\" tmp.tsv -tofile out.csv\n"
             "        converts tab separated to an output CSV, with output fields\n"
             "        separated by semicolon and surrounded by single quotes\n"
             );
      ehelp;

      char *pszInFile  = 0;
      char *pszOutFile = 0;
      char  szInSep[20];
      char  szOutSep[20];
      char  szQuote[20];
      char  szOutEsc[20];

      strcpy(szInSep , "\t");
      strcpy(szOutSep, ",");
      strcpy(szQuote , "\"");
      strcpy(szOutEsc, " ");

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-insep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szInSep, sizeof(szInSep)) != 1) {
               perr("invalid or too long input separator: %s", pszParm);
               pinf("use only a single char like ; or a valid slash pattern like \\t\n");
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-outsep", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szOutSep, sizeof(szOutSep)) != 1) {
               perr("invalid or too long output separator: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-quote", &pszParm)) {
            if (!pszParm) return 9;
            if (copyFromFormText(pszParm, strlen(pszParm), szQuote, sizeof(szQuote)) != 1) {
               perr("invalid quote: %s", pszParm);
               return 9;
            }
            continue;
         }
         else
         if (!strcmp(pszArg, "-quotetext")) {
            cs.quotetext = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-quoteall")) {
            cs.quoteall = 1;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszInFile) {
            pszInFile = pszArg;
            continue;
         }
         return 9+perr("unexpected parameter: %s\n", pszArg);
      }

      if (cs.tomask && cs.tomaskfile)
         pszOutFile = cs.tomask;

      cs.cinsep     = szInSep[0];
      cs.coutsep    = szOutSep[0];
      cs.cquote     = szQuote[0];
      cs.coutsepesc = szOutEsc[0];

      if (pszInFile) {
         Coi ocoi(pszInFile, 0);
         lRC = execCsvConv(1, &ocoi, 0, 0, -1, pszOutFile);
      } else {
         lRC = execCsvConv(1, 0, stdin, chain.usedata ? chain.indata : 0, -1, pszOutFile);
      }

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "touch"))
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk touch [-date n] [opts] file\n"
             "$sfk touch -from srcfile [opts] file\n"
             "\n"
             "   change date and time of file(s) or directories.\n"
             "   if just a file- or directory name is given then\n"
             "   the access and modification time is set to the\n"
             "   current time. with SFK for windows, creation time\n"
             "   is not changed by default.\n"
             "\n"
             "   $options\n"
             "      -force   create empty file if it doesn't exist\n"
             "      -date n  set file date/time to this value\n"
             "               given like  YYYYMMDDhhmmss,\n"
             "               for example 20130412063015.\n"
             #ifdef _WIN32
             "               NTFS second fractions are set to 0\n"
             "               unless option -nsec is given.\n"
             "      -nsec n  specify nanoseconds part for -date\n"
             "               as a 9 digit number. the last 2 digits\n"
             "               are not used and should be 00.\n"
             #endif
             "      -from f  copy file date/time from another file\n"
             "      -atime   change only access time\n"
             "      -mtime   change only modification time\n"
             #ifdef _WIN32
             "      -ctime   change only creation time (Windows only)\n"
          // "      -amtime  change access and modification time\n"
             "      -full    set or copy atime, mtime and ctime\n"
             #endif
             "\n"
             "   $command chaining support\n"
             "      multiple files can be touched through chaining:\n"
             "      #sfk select mydir .ext +touch ...\n"
             "\n"
             "   $see also\n"
             "      #sfk filetime<def> - print times of a file\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk touch foo.txt\n"
             "         sets access and modification time of foo.txt\n"
             "         to the current time.\n"
             "\n"
             "      #sfk touch -date 20130412063015 foo.txt\n"
             "         sets access and modification time of foo.txt\n"
             "         to 12-Apr-2013 at 06:30:15.\n"
             "\n"
             "      #sfk touch -from src.txt myfile.txt\n"
             "         reads access and modification time of src.txt\n"
             "         and copies it to myfile.txt\n"
             "\n"
             "      #sfk select mydir .cpp .hpp +touch\n"
             "         touch all .cpp and .hpp files from mydir.\n"
             );
      ehelp;

      char *pszDate = 0;
      char *pszDst  = 0;
      char *pszFrom = 0;
      bool  bATime  = 1;
      bool  bMTime  = 1;
      bool  bCTime  = 0; // windows only
      num   nNanoSec= 0;
      bool  bMake   = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-date", &pszParm)) {
            if (!pszParm) return 9;
            if (pszFrom) return 9+perr("-date cannot be combined with -from\n");
            pszDate = pszParm;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            if (pszDate) return 9+perr("-date cannot be combined with -from\n");
            pszFrom = pszParm;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-nsec", &pszParm)) {
            if (!pszParm) return 9;
            if (strlen(pszParm) != 9)
               return 9+perr("need a 9 digits value for -nsec\n");
            nNanoSec = atonum(pszParm);
            continue;
         }
         else
         if (!strcmp(pszArg, "-force")) {
            bMake = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-atime")) {
            bATime = 1;
            bMTime = 0;
            bCTime = 0;
            continue;
         }
         else
         if (!strcmp(pszArg, "-mtime")) {
            bATime = 0;
            bMTime = 1;
            bCTime = 0;
            continue;
         }
         else
         if (!strcmp(pszArg, "-amtime")) {
            bATime = 1;
            bMTime = 1;
            bCTime = 0;
            continue;
         }
         else
         if (!strcmp(pszArg, "-ctime")) {
            bATime = 0;
            bMTime = 0;
            bCTime = 1;
            continue;
         }
         else
         if (!strcmp(pszArg, "-full")) {
            bATime = 1;
            bMTime = 1;
            bCTime = 1;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            // if (isDirParm(pszArg))
            //    break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         // else
         // if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
         //    break;
         // process non-option keywords:
         if (!pszDst) {
            pszDst = pszArg;
            continue;
         }
         return 9+perr("unexpected parameter: %s\n", pszArg);
      }

      if (!chain.usefiles && !pszDst)
         return 9+perr("missing target filename\n");

      // int iDirNext = 0;
      // bool bAnyDirParms = 0;
      // if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext, &bAnyDirParms))) return lRC;
      // if (btest) return 0;
      
      glblTouchSrc.reset();
      mclear(glblTouchOpt);

      num nTmpTime = 0;

      #ifdef _WIN32
      FILETIME nWinTime; mclear(nWinTime);
      #endif
      
      if (pszFrom) {
         if (glblTouchSrc.readFrom(pszFrom))
            return 9+perr("cannot read: %s\n", pszFrom);
         #ifdef _WIN32
         glblTouchOpt.bUseWFT = glblTouchSrc.src.nHaveWFT;
         #endif
      }
      else if (pszDate || !pszFrom) {
         if (pszDate) {
            if (timeFromString(pszDate, nTmpTime))
               return 9;
         } else {
            nTmpTime = (num)getSystemTime();
         }
         if (bATime) glblTouchSrc.src.nATime = nTmpTime;
         if (bMTime) glblTouchSrc.src.nMTime = nTmpTime;
         if (bCTime) glblTouchSrc.src.nCTime = nTmpTime;
         #ifdef _WIN32
         if (makeWinFileTime(nTmpTime, nWinTime, nNanoSec))
            return 9;
         if (bATime) memcpy(&glblTouchSrc.src.ftATime, &nWinTime, sizeof(nWinTime));
         if (bMTime) memcpy(&glblTouchSrc.src.ftMTime, &nWinTime, sizeof(nWinTime));
         if (bCTime) memcpy(&glblTouchSrc.src.ftCTime, &nWinTime, sizeof(nWinTime));
         glblTouchOpt.bUseWFT = 1;
         #endif
      }
      else
         return 9+perr("missing parameters for touch\n");

      glblTouchOpt.bATime = bATime;
      glblTouchOpt.bMTime = bMTime;
      glblTouchOpt.bCTime = bCTime;

      if (pszDst) {
         if (bMake && !fileExists(pszDst, 1)) {
            FILE *fout = fopen(pszDst, "wb");
            if (!fout)
               return 9+perr("cannot create: %s\n", pszDst);
            fclose(fout);
         }
         lRC = execTouch(pszDst, 1);
      } else {
         cs.sim = !cs.yes;
         if (cs.sim && !cs.nohead)
            printx("$[simulating:]\n");
         lRC = walkAllTrees(eFunc_Touch, lFiles, lDirs, nBytes);
         if (cs.sim && !cs.nohead)
            printx("$[add -yes to execute.]\n");
      }

      bDone = 1;
   }

   // internal
   if (!strcmp(pszCmd, "nmatch"))
   {
      if (argc < 4) return 9;
      char *pszMask = argv[2];
      char *pszStr  = argv[3];
      bool bPart    = 0;
      bool bmatch   = matchesNormName(pszStr, pszMask, &bPart);
      printf("%d = match(mask %s,str %s) %d\n",bmatch,pszMask,pszStr,bPart);
      return 0;
   }

   // internal
   if (!strcmp(pszCmd, "info"))
   {
      printf("testing getCurrentTime():\n");
      #ifndef _WIN32
      struct timeval tv;
      gettimeofday(&tv, NULL);
      printf("tv_sec %d usec %d\n",(int)tv.tv_sec,(int)tv.tv_usec);
      num nval = tv.tv_sec + tv.tv_usec / 1000;
      printf("nval dec %s\n",numtoa(nval));
      printf("nval hex %s\n",numtohex(nval));
      #endif
      printf("testing info:\n");
      info.setStatus("verb", "subject", "addinfo", eNoCycle);
      info.printLine();
      printf("interactiveConsole=%d\n",bGlblHaveInteractiveConsole);
      return 0;
   }

   #ifdef WINFULL
   if (!strcmp(pszCmd, "ansitooem"))
   {
      char szBuf[20];
      for (uint i=0; i<256; i++) {
         uchar cansi = (uchar)i;
         szBuf[0] = (char)cansi;
         szBuf[1] = '\0';
         CharToOemA(szBuf, szBuf+10);
         uchar coem = szBuf[10];
         printf("0x%02lX,0x%02lX, ", (uint)cansi, (uint)coem);
      }
      return 0;
   }
   #endif

   #ifdef _WIN32
   if (!strcmp(pszCmd, "mdx"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];
      uchar abmd[20];
      memset(abmd, 0, sizeof(abmd));
      int lrc = getFileMD5NoCache(pszFile, abmd, 0);
      printf("%d = md5nocache: ", lrc);
      for (int i=0; i<16; i++)
         printf("%02X",abmd[i]);
      printf(" errno %d lasterr %d\n",(int)errno, GetLastError());
      return 0;
   }
   #endif

   if (!strcmp(pszCmd, "fileage"))
   {
      if (argc < 3) return 9;
      char *pszFile = argv[2];
      num nage = getFileAge(pszFile);
      printf("%s sec, %d days\n", numtoa(nage), (int)(nage / (24 * 3600)));
      return 0;
   }

   #ifdef _WIN32
   // internal
   if (!strcmp(pszCmd, "clipinfo"))
   {
      if (!OpenClipboard(0))
         return 5+perr("failed to open clipboard\n");
      HGLOBAL hglb = 0;
      uchar *pdata = 0;
      int    ndata = 0;
      if (IsClipboardFormatAvailable(CF_TEXT)) {
         if (hglb = GetClipboardData(CF_TEXT)) {
            char *pMem = (char*)GlobalLock(hglb);
            if (pMem) {
               printf("CF_TEXT: %.50s\n", pMem);
               printf(" as hex: %.50s\n", dataAsHex(pMem,strlen(pMem)));
            }
            GlobalUnlock(hglb);
         }
      }
      // if (IsClipboardFormatAvailable(CF_LOCALE)) {
      //    if (hglb = GetClipboardData(CF_LOCALE)) {
      //       char *pMem = (char*)GlobalLock(hglb);
      //       if (pMem) {
      //          printf("CF_LOCL: %s\n", dataAsHex(pMem,4));
      //       }
      //       GlobalUnlock(hglb);
      //    }
      // }
      if (IsClipboardFormatAvailable(CF_UNICODETEXT)) {
         if (hglb = GetClipboardData(CF_UNICODETEXT)) {
            char *pMem = (char*)GlobalLock(hglb);
            if (pMem) {
               ushort *pwtext = (ushort *)pMem;
               printf("CF_UNI : ");
               int ilen=0;
               for (; pwtext[ilen]!=0 && ilen<10; ilen++)
                  printf("U+%04X ", pwtext[ilen]);
               printf("\n");
            }
            GlobalUnlock(hglb);
         }
      }
      CloseClipboard();
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "toclip"))
   {
      ifhelp ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
      printx("<help>$sfk toclip<def>\n"
             "\n"
             "   copy text to clipboard.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #echo hello | sfk toclip\n"
             "         copy the word hello to clipboard\n"
             "\n"
             "      #sfk sel mydir +toclip\n"
             "         copy a directory listing to clipboard\n"
            );
      ehelp;

      // copy stdin or chain text to clipboard

      // calling this only for chaining support:
      int iDirNext=0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 0, &iDirNext)))
         return lRC;

      StringTable st;
      int nSize = 0;

      if (chain.usedata) {
         // take text from chain
         while (!chain.indata->eod()) {
            char *psz = chain.indata->read(0);
            mystrcopy(szLineBuf, psz, MAX_LINE_LEN);
            removeCRLF(szLineBuf);
            st.addEntry(szLineBuf);
            nSize += strlen(szLineBuf) + 2;
         }
      } else {
         myfgets_init();
         while (myfgets(szLineBuf, MAX_LINE_LEN, stdin))
         {
            szLineBuf[MAX_LINE_LEN] = '\0';
            removeCRLF(szLineBuf);
            st.addEntry(szLineBuf);
            nSize += strlen(szLineBuf) + 2;
         }
      }

      char *pszTmp = new char[nSize+1000];
      if (!pszTmp) return 9+perr("out of memory\n");
      pszTmp[0] = '\0';
      int nLines = st.numberOfEntries();
      int iout=0;
      for (int i=0; i<nLines; i++)
      {
         char *psz = st.getEntry(i, __LINE__);
         int nLen = (int)strlen(psz);
         if (iout+nLen < nSize)
         {
            strcat(pszTmp, psz);
            strcat(pszTmp, "\r\n");
            iout = strlen(pszTmp);
         }
         else
            break;
      }
      putClipboard(pszTmp);
      delete [] pszTmp;

      STEP_CHAIN(iDirNext, 0);   // no chain output was created

      bDone = 1;
   }

   ifcmd (   !strcmp(pszCmd, "fromclip") || !strcmp(pszCmd, "rawclip")
          || !strcmp(pszCmd, "lclip"))
   {
      ifhelp ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
      printx("<help>$sfk fromclip [-wait] [-clear]<def>\n"
             "\n"
             "   dump plain text from clip to terminal.\n"
             "\n"
             "   $options\n"
             "      -wait   wait until plain text is available.\n"
             "      -clear  empty clipboard after use.\n"
             "\n"
             "   $aliases\n"
             "      #sfk lclip<def>   - same as #sfk fromclip -ltrim<def>\n"
             "                    to get text left side trimmed\n"
             "      #sfk rawclip<def> - same as #sfk fromclip +toclip<def>\n"
             "                    to remove unwanted formatting\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk fromclip +filter -rep x/x\\x +toclip\n"
             "         change all / into \\ within the clipboard text\n"
            );
      ehelp;

      bool bWait  = 0;
      bool bClear = 0;
      bool bRaw   = strcmp(pszCmd, "rawclip") ? 0 : 1;
      bool bltrim = strcmp(pszCmd, "lclip") ? 0 : 1;
      int  iChainNext = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-wait"))
            bWait = 1;
         else
         if (!strcmp(argv[iDir], "-clear"))
            bClear = 1;
         else
         if (!strcmp(argv[iDir], "-ltrim"))
            bltrim = 1;
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         else {
            // process non-option keywords:
            return 9+perr("unexpected: %s\n", argv[iDir]);
         }
      }

      if (btest) return 0;

      // now get the clipboard data:

      char *pszClip = 0;

      while (!IsClipboardFormatAvailable(CF_TEXT)) {
         if (!bWait)
            return 5+perr("no plain text in clipboard\n");
         Sleep(250);
      }

      if (!OpenClipboard(0)) // GetDesktopWindow())) 
         return 5+perr("failed to open clipboard\n");
      HGLOBAL hglb = GetClipboardData(CF_TEXT); 
      if (hglb == NULL) {
         perr("no clipboard data available\n");
      } else {
         char *pMem = (char*)GlobalLock(hglb); 
         if (pMem != NULL)
            pszClip = strdup(pMem);
         GlobalUnlock(hglb);
      }

      // clear the clipboard?
      if (bClear)
         EmptyClipboard();

      CloseClipboard();

      // we're now owner of pszClip.
      if (bltrim)
      {
         char *psrc = pszClip;
         char *pdst = pszClip;
         while (*psrc) {
            // line start
            while (*psrc!=0 && (*psrc==' ' || *psrc=='\t'))
               psrc++;
            // line text
            while (*psrc!=0 && (*psrc!='\r' && *psrc!='\n'))
               *pdst++ = *psrc++;
            // eol
            while (*psrc!=0 && (*psrc=='\r' || *psrc=='\n'))
               *pdst++ = *psrc++;
         }
         *pdst = '\0';
      }
 
      if (bRaw) {
         putClipboard(pszClip);
         if (cs.verbose)
            printf("converted %d bytes.\n", strlen(pszClip));
      }
      else if (chain.colany()) {
         // do not dump to terminal, but to chain buffer:
         num nlen = strlen(pszClip);
         num iin  = 0;
         // split into buffer records.
         while (iin<nlen) {
            int ibuf = 0;
            for (; iin<nlen; iin++) {
               char c = pszClip[iin];
               if (c == '\r')
                  continue;
               if (c == '\n')
                  { iin++; break; }
               szLineBuf[ibuf++] = c;
               if (ibuf >= MAX_LINE_LEN-10)
                  break; // hard line wrap
            }
            szLineBuf[ibuf] = '\0';
            chain.addLine(szLineBuf, str(""));
         }         
      } else {
         // pszClip MAY contain 0D0A format, but writing to stdout
         // also converts every 0A to 0D0A. filter 0D's out.
         num nlen = strlen(pszClip);
         for (num i=0; i<nlen; i++) {
            char c = pszClip[i];
            if (c == '\r')
               continue;
            putchar(c);
         }
      }
 
      delete [] pszClip;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "sleep")) // +chaining
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk sleep msec\n"
             "\n"
             "   delay execution for a number of milliseconds.\n"
             "\n"
             "   $usage example:\n"
             "\n"
             "      runapache.bat:\n"
             "      #start sfk sleep 3000 +tail -f logs\\access.log -pat \"GET * 404 \"\n"
             "      #apache.exe\n"
             "\n"
             "         creates an error log viewer, and runs apache in parallel.\n"
             "         sfk will wait 3 seconds before tail goes active.\n"
             );
      ehelp;

      int nmsec = -1;

      for (; iDir<argc; iDir++) 
      {
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
         }
         else
         if (nmsec < 0) {
            // process non-option keywords
            char *psz = argv[iDir];
            if (!isdigit(*psz))
               return 9+perr("wrong number format: %s\n", psz);
            nmsec = atol(psz);
            continue;
         }
         return 9+perr("unexpected parameter: \"%s\" (8)\n", argv[iDir]);
      }

      doSleep(nmsec);

      // calling this only for chaining support:
      int iDirNext=0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC;

      // we haven't collected any filenames, but maybe previous
      // commands have, so keep chain list as it is.
      STEP_CHAIN(iDirNext, 0);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "pause")) // +chaining
   {
      ifhelp ((iDir < argc) && isHelpOpt(argv[iDir]))
      printx("<help>$sfk pause [text]<def>\n"
             "\n"
             "   wait for user input before continuing command execution.\n"
      //     "\n"
      //     "   $options\n"
      //     "      -maxwait=n   without input, continue after n milliseconds.\n"
             "\n"
             "   $see also\n"
             "      sfk sleep    delay execution for a given time.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk echo hello +pause\n"
             "         prints hello and then waits.\n"
            );
      ehelp;

      char *pszText  = 0;
      int  ntimeout = 0;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-maxwait", &pszParm)) {
            if (!pszParm) return 9;
            ntimeout = atol(pszParm);
            continue;
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
         }
         else
         if (!pszText) {
            pszText = argv[iDir];
            continue;
         }
         return 9+perr("unexpected parameter: \"%s\" (8)\n", argv[iDir]);
      }

      if (!pszText && !cs.quiet) {
         #ifdef _WIN32  
         pszText = str("Press any key to continue, CTRL+C or ESC to stop.");
         #else
         pszText = str("Press ENTER to continue, or CTRL+C to stop.");
         #endif
      }

      // wait for user input:
      int nkey   = 0;
      #ifdef _WIN32
      num  nstart = getCurrentTime();
      if (pszText)
         { printf("%s\r", pszText); fflush(stdout); }
      while (true) {
         nkey = getKeyPress(1); // only DOWN events
         if (nkey > 0) {
            if (cs.verbose) printf("[key 0x%x]\n", (uint)nkey);
            if (nkey >= 0x20) break;
            if (nkey == '\n' || nkey == '\r' || nkey == '\t' || nkey == 0x1B)
               break;
            // else ignore non-printable keys, esp. CTRL (0x11)
         }
         int ndelay = ntimeout ? 500 : 100;
         doSleep(ndelay);
         num nelapsed = getCurrentTime() - nstart;
         if (ntimeout) {
            if (nelapsed > ntimeout) break;
            num nremain = ntimeout - nelapsed;
            printf("[%d] - %s\r",(int)(nremain/1000),pszText);
            fflush(stdout);
         }
      }
      printf("\n");
      #else
      if (pszText) printf("%s\n", pszText);
      nkey = (int)getchar(); // requires enter
      #endif

      // calling this only for chaining support:
      int iDirNext=0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC;

      // continue chain processing only if no ESCAPE pressed
      if (nkey != 0x1B) {
         STEP_CHAIN(iDirNext, 0);
      } else {
         lRC = nkey;
      }

      bDone = 1;
   }

   regtest("tail -lines=10 -follow -quiet -polltime=500 xfile");

   bool bIsTail = 0;

   ifcmd (   !strcmp(pszCmd, "tail") || !strcmp(pszCmd, "head")
          || !strcmp(pszCmd, "ttail") || !strcmp(pszCmd, "thead")
         )
   {
      bIsTail = (strstr(pszCmd, "tail") ? 1 : 0);
      
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk head [-lines=n] [-f[ollow]] [filename]\n"
             "$sfk tail [-lines=n] [-f[ollow]] [filename]\n"
             "$sfk ... +[t]head | +[t]tail [-lines=n]\n"
             "\n"
             "   1. print first or last lines of a file, optionally following changes.\n"
             "      to use file content processing, provide a single filename.\n"
             "\n"
             "   2. print first or last text lines procuded by a previous command.\n"
             "      to process chain text, thead or ttail are recommended.\n"
             "\n"
             "   $options\n"
             "      -lines=n     print first or last n lines (default is 10).\n"
             "      -follow      or -f waits for file changes, printing them endlessly.\n"
             "                   if file is recreated or shrunk, rereads the last lines.\n"
             "                   if file is changed, head will always reread from front.\n"
             "                   to post-process tail output, e.g. with +filter, always\n"
             "                   add +loop at the end of the command sequence.\n"
             "      -quiet       do not tell verbosely about read restarts.\n"
             "      -polltime=n  with -follow, specifies the delay in milliseconds before\n"
             "                   the file is checked again for changes. default is 500.\n"
             "      -altsize     use a different method to determine the file size\n"
             "                   (stat instead of seek). may help if the default method\n"
             "                   fails to read the file, or to improve performance.\n"
             #ifdef _WIN32
             "\n"
             "   $see also\n"
             "      #sfk view<def>     GUI tool to view all text files of a folder, then jump\n"
             "                   through file heads/ends by ctrl+pageDown or ctrl+end.\n"
             #endif
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk tail -follow logs\\access.log\n"
             "         immediately lists last lines, then all added lines over time.\n"
             "      #sfk tail -f c:\\temp\\log.txt +filter -+error: -+warning: +loop\n"
             "         endless filter of error and warning messages from log.txt.\n"
             "      #type myfile.txt | sfk filter +thead -lines=50\n"
             "         filter first 50 lines from stdin, via sfk filter.\n"
             "\n"
             "   $example sfk script with conditional execution\n"
             "     #file logfilter.txt:\n"
             "       sfk label checklog\n"
             "          +tail -follow logfile.txt\n"
             "          +tee toterm +storetext\n"
             "          +filter -+error: +if \"rc>0\" call myalert\n"
             "          +gettext +filter -+alldone: +if \"rc>0\" stop\n"
             "          +loop +end\n"
             "       sfk label myalert\n"
             "          +then run -yes \"myalert.bat\" +end\n"
             "     #sfk script logfilter.txt\n"
             "        will run myalert.bat whenever errors appear in logfile.txt.\n"
             "        the script stops as soon as \"alldone\" appears in the log.\n"
             "        to allow double filtering of the chain text it must be\n"
             "        stored before the first filter, then restored.\n"
             );
      ehelp;

      char *pszFile   =   0;
      int nLastLines =  10;
      int nPollTime  = 500;
      bool bFollow    =   0;
      int nMaxLines  = 10000;
      int  iChainNext =   0;
      bool bUseSeek   =   1;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-lines", &pszParm)) {
            if (!pszParm) return 9;
            nLastLines = atol(pszParm);
            if (!chain.usedata && bIsTail && (nLastLines > nMaxLines))
               pwarn("tail supports only %d -lines at maximum.\n", nMaxLines);
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-polltime", &pszParm)) {
            if (!pszParm) return 9;
            nPollTime = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-f", 2)) {
            if (chain.usedata) {
               perr("-f[ollow] not supported with chain text input");
               pinf("check if previous commands produce filenames or text");
               return 9;
            }
            bFollow = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-altsize")) {
            bUseSeek = 0;
            if (cs.verbose) pinf("using fseek file size detect\n");
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszFile) {
            pszFile = argv[iDir];
            continue;
         }
         return 9+perr("unexpected parameter: \"%s\" (9)\n", argv[iDir]);
      }

      if (btest) return 0;

      if (chain.usedata) 
      {
         // head or tail the chain text
         int nsize = chain.indata->numberOfEntries();
         int nfrom = 0, nto = nsize;
         if (bIsTail) {
            nfrom = nsize - nLastLines;
            if (nfrom < 0) nfrom = 0;
         } else {
            nto = nLastLines;
            if (nto > nsize) nto = nsize;
         }
         for (int i=nfrom; i<nto; i++) {
            char *ptext=0, *pattr=0;
            ptext = chain.indata->getEntry(i, __LINE__, &pattr);
            if (!ptext) return 9+perr("int. #168281112");
            if (chain.coldata)
               chain.addLine(ptext, pattr);
            else
               printColorText(ptext, pattr, 1); // with lf
         }
      }
      else 
      {
         // head or tail file contents
         if (!pszFile) {
            if (chain.usefiles && chain.numberOfInFiles() == 1) {
               Coi *pcoi = chain.getFile(0);
               if (!pcoi) return 9;
               pszFile = pcoi->name();
            } else {
               cchar *pcmd = bIsTail ? "tail" : "head";
               perr("too many input filenames for %s (%d)",pcmd,chain.numberOfInFiles());
               pinf("%s can only process a single input filename.\n",pcmd);
               pinf("use +t%s instead of %s if you want to process text.\n",pcmd,pcmd);
               pinf("try +ftt to convert filenames to text. see also \"sfk help chain\".\n");
               return 9;
            }
         }
   
         if (!cperm.tailnsize) {
            cperm.tailnsize = bUseSeek ? getFileSizeSeek(pszFile) : getFileSize(pszFile);
            if (cperm.tailnsize < 0) return 9+perr("cannot read: %s\n", pszFile);
         }
   
         // keyword +loop supplied?
         bool bHaveLoop = 0;
         if (argc > 0) {
            for (int iback=argc-1; iback > 0; iback--)
               if (!strcmp(argv[iback], "+loop"))
                  {  bHaveLoop = 1; break; }
         }
   
         if (!bHaveLoop && bFollow && iChainNext && !cs.quiet)
            pwarn("chain commands after tail -follow may not work as expected without +loop.\n");
   
         do
         {
            if (bIsTail)
            {
               if (!cperm.tailnpos)
               {
                  // find initial position of nLastLines from end
                  num *ppos = new num[nMaxLines+10]; // with tolerance
                  if (!ppos) return 9+perr("out of memory\n");
                  memset(ppos, 0, sizeof(num)*nMaxLines);
                  int nbufpos = 0;
         
                  // scan all line positions
                  FILE *fin = fopen(pszFile, "rb");
                  if (!fin) return 9+perr("unable to read: %s\n", pszFile);
                  myfgets_init();
                  while (myfgets(szLineBuf, sizeof(szLineBuf)-10, fin))
                  {
                     removeCRLF(szLineBuf);
                     // cannot use mygetpos here, as myfgets caches.
                     num npos2 = nGlblGetFPos;
                     memmove(&ppos[1], &ppos[0], sizeof(num) * nbufpos);
                     ppos[0] = npos2;
                     if (nbufpos < nMaxLines)
                        nbufpos++;
                     if (cs.debug)
                        printf("line %d pos %s \"%s\"\n",nbufpos,numtoa(npos2),szLineBuf);
                  }
                  fclose(fin);
         
                  // fetch requested line position
                  if (nLastLines > nbufpos)
                     nLastLines = nbufpos;
                  if (nLastLines > nMaxLines)
                     return 9+perr("overflow, too many lines from file end specified.\n");
                  cperm.tailnpos = ppos[nLastLines];
         
                  if (cs.debug)
                     printf("\ntake pos %s from offset %d\n",numtoa(cperm.tailnpos),nLastLines);
         
                  delete [] ppos;
               } 
               else
               {
                  // wait until file changes, then proceed
                  bool bTold  = 0;
                  int iturn  = 0;
                  cchar *aturn = "\\|/-";
                  while (!userInterrupt()) 
                  {
                     doSleep(nPollTime);
                     num nsize2 = bUseSeek ? getFileSizeSeek(pszFile) : getFileSize(pszFile);
                     if (nsize2 < 0) {
                        if (!cs.quiet && !bTold)
                           printf("[file removed, waiting for recreation]\n");
                        bTold = 1;
                        continue;
                     }
                     if (nsize2 != cperm.tailnsize) {
                        if (bIsTail && (nsize2 < cperm.tailnsize)) {
                           if (!cs.quiet)
                              printf("[file %srecreated, rereading last %d lines]\n", bTold?"":"shrunk or ",nLastLines);
                           cperm.tailnsize = nsize2;
                           cperm.tailnpos = 0;
                           break;
                        }
                        if (!bIsTail) {
                           if (!cs.quiet)
                              printf("[file changed, restarting read]\n");
                        }
                        cperm.tailnsize = nsize2;
                        break;
                     }
                     bTold = 0;
                     if (cs.verbose)
                        printf("[%c %s bytes filesize]\r",aturn[iturn++%4],numtoa(nsize2));
                  }
               }
            }
      
            int nrc = 0;
      
            // dump new content, from pos to end
            FILE *fin = fopen(pszFile, "rb");
            if (!fin) return 9+perr("unable to read: %s\n", pszFile);
   
            if (bIsTail) {
               nrc = mysetpos(fin, cperm.tailnpos, pszFile);
               if (nrc) {
                  fclose(fin);
                  return 9+perr("unable to set position: %s\n", pszFile);
               }
            }
   
            // dump from current position until end (if tail)
            int nLocLine = 0;
            myfgets_init();
            while (myfgets(szLineBuf, MAX_LINE_LEN-10, fin))
            {
               szLineBuf[MAX_LINE_LEN-10] = '\0';
               removeCRLF(szLineBuf);
               nLocLine++;
   
               if (chain.coldata)
                  chain.addLine(szLineBuf, str(""));
               else
                  printf("%s\n", szLineBuf);
   
               if (!bIsTail && nLocLine >= nLastLines)
                  break;
            }
   
            if (nrc) {
               fclose(fin);
               return 9+perr("error while filtering, rc %d\n", nrc);
            }
   
            // remember end position of read.
            // can NOT use nGlblGetFPos here as it's relative.
            nrc = mygetpos(fin, cperm.tailnpos, pszFile);
            fclose(fin);
            if (nrc) return 9+perr("unable to read position: %s\n", pszFile);
         }
         while (bFollow && !bHaveLoop && !userInterrupt());
      }
   
      // if -follow is not selected
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "view") || !strncmp(pszCmd, "fv", 2))
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk list ... +[f]view [-noshl|-nocol] [\"-...\"]\n"
             "\n"
             "   Show SFK command text output #interactively in Depeche View,<def>\n"
             "   #a high speed text browser and filter tool<def> for Windows which\n"
             "   also runs on Linux/Mac if WINE is installed.\n"
             "\n"
             "   The tool allows #browsing of text with soft scrolling<def>\n"
             "   and #instant search<def> as you type or click on words.\n"
             "\n"
             "   Type #sfk getdv<def> to download Depeche View Lite now,\n"
             "   or visit #www.depecheview.com<def> for manual download.\n"
             "   The tool is fully portable and needs no installation.\n"
             "\n"
             "   Many SFK commands allow to add #+view<def> to have their output\n"
             "   shown instantly in DView. This requires #dview, dview.exe\n"
             "   or #dview.bat<def> being located in the PATH. If you have downloaded\n"
             "   an executable like dview155.exe, rename it before use.\n"
             "\n"
             "   DView can be run under #Linux and Mac<def>, but this is experimental\n"
             "   and unsupported. The latest #WINE<def> version must be installed.\n"
             "   Google for \"linux wine\", or search it in your package manager.\n"
             "\n"
             "   $use as a chain command, or to display stdin:\n"
             "\n"
             "      +[f]view can be used only #after another command<def>\n"
             "      producing a list of filenames or plain text data:\n"
             "\n"
             "         #+view<def>  expects text as input.\n"
             "         #+fview<def> expects a list of filenames.\n"
             "\n"
             "      or use \"sfk view -i\" to display text from stdin.\n"
             "\n");
      printx("   $options\n"
             "      -nocol[or]   disable colored output and display.\n"
             "                   set this if you're using dview < 1.1.4\n"
             "                   or any other viewer.\n"
             "      -wrap[=n]    wrap lines at column n. currently, this feature\n"
             "                   disables colors (implies -nocol), but depending\n"
             "                   on the content processed, dview may still show\n"
             "                   colors based on syntax highlighting.\n"
             "      -noshl       disable syntax highlighting at dview.\n"
             "      \"-x1 -x2\"    all other options are passed through unchanged\n"
             "                   to the viewer application. if multiple parameters\n"
             "                   have to be passed, surround them by double quotes.\n"
             "      -verbose     tell verbosely which target binary is invoked.\n"
             #ifdef _WIN32
             "      -noback      by default, dview is run as a background process,\n"
             "                   by prefixing the overall command with \"start \".\n"
             "                   say -noback to let sfk wait until dview is stopped.\n"
             #else
             "      -noback      by default, dview is run as a background process,\n"
             "                   by appending ampersand & to the overall command.\n"
             "                   say -noback to let sfk wait until dview is stopped.\n"
             "      -nowine      sfk for linux creates a command \"wine dview ...\" to\n"
             "                   make sure Depeche View is run in the wine environment.\n"
             "                   specify -nowine to disable this.\n"
             "      -nolinux     sfk for linux adds option -linux when calling dview\n"
             "                   or dview.exe. specify -nolinux to disable this.\n"
             "      -plain       combines -nowine, -nolinux.\n"
             #endif
             "\n"
             "   $dview options and parameters\n"
             "      all non sfk options and parameters are passed through, like:\n"
             "\n"
             "      -tab n                set tab size n (dview 1.6.3 or higher)\n"
             "      -area 20:20:600:400   open at position 20,20 with size 600x400\n"
             "      -find \"a text\"        search a text instantly\n"
             "      -sfind \"a \\qtext\\q\"   search text given with slash patterns\n"
             "\n"
             "      for all dview options try: dview -help -find \"all*options\"\n"
             "\n");
      printx("   $temporary files\n"
             "      this command #creates a temporary file<def> which is currently\n"
             "      not deleted. type \"sfk help options\" for options on that.\n"
             "\n"
             "   $using a different viewer\n"
             "      when viewing a list of files, this command runs\n"
             "         \"dview -flist tmpfilename\"\n"
             "      with tmpfilename containing a list of filenames.\n"
             "\n"
             "      when viewing text line output, this command runs\n"
             "         \"dview tmpfilename\"\n"
             "      with tmpfilename containing ascii text data.\n"
             "\n"
             "      specify -verbose to see what is invoked in detail.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk list docs .txt +fview\n"
             "         view content of all .txt files in directory docs.\n"
             "\n"
             "      #sfk echo x +view -verbose\n"
             "         tell verbosely which dview(.exe?) executable is actually used.\n"
             "\n"
             "      #sfk list docs .txt +ffilter -+foo -hitfiles +fview \"-max -over\"\n"
             "         view all .txt $files<def> from docs containing \"foo\", pass options\n"
             "         -max -over to the viewer, showing a maximized window in overscan\n"
             "         mode (without any title bar).\n"
             "\n"
             "      #sfk list docs .txt +ffilter -+foo +view \"-space 0:0:40\"\n"
             "         view only text $lines<def> from docs containing \"foo\", in a window\n"
             "         covering the whole desktop, except for 40 pixels at the bottom.\n"
             #ifdef _WIN32
             "\n"
             "      #sfk fromclip +view\n"
             "         display current clipboard content (plain text only).\n"
             #endif
             "\n"
             "      #tar tvf foo.tar | sfk view -i\n"
             "         display a tar file's content listing.\n"
             "\n"
             "      #sfk larc -size -time -withdirs foo.tar +view\n"
             "         the same, with sfk reading the .tar directly.\n"
            );
      ehelp;

      bool bback    = 0;
      bool bcolor   = 1;
      int bcompact = 1;
      #ifdef _WIN32
      char *pszsopt = str("start ");
      char *pszwopt = str("");
      char *pszxopt = str("");
      #else
      char *pszsopt = str(" &");
      char *pszwopt = str("wine ");
      char *pszxopt = str(" -linux");
      #endif
      bool  bShowGetDV = 0;

      // additional dview options are collected in abBuf:
      strcpy((char*)abBuf, " ");

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-back")) {
            bback = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nocol", 6)) {
            bcolor = 0;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-col", 4)) {
            bcolor = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-snap", 5)) {
            bcompact = 0; // normal snapfile format
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-comp", 5)) {
            bcompact = 2; // leave out blank lines before files
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-noba", 5)) {
            pszsopt = str("");
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-noli", 5)) {
            pszxopt = str("");
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-nowi", 5)) {
            pszwopt = str("");
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-plain")) {
            pszwopt = str("");
            pszxopt = str("");
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            // collect and pass through to dview
            if (myrchar((char*)abBuf) != ' ')
               strcat((char*)abBuf, " ");
            strcat((char*)abBuf, argv[iDir]);
            continue;
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // collect and pass through to dview
         if (myrchar((char*)abBuf) != ' ')
            strcat((char*)abBuf, " ");
         // enquote all non option parameters
         bool bquote = strchr(argv[iDir], ' ') ? 1 : 0;
         if (bquote)
            strcat((char*)abBuf, "\"");
         strcat((char*)abBuf, argv[iDir]);
         if (bquote)
            strcat((char*)abBuf, "\"");
      }

      // render extra options for dview
      if (cs.wrapcol) {
         char *psz = (char*)abBuf;
         sprintf(&psz[strlen(psz)], " -wrap=%d", cs.wrapcol);
         bcolor = 0; // todo: -wrap with color support
      }
      // if (bnoshl) {
      //   strcat((char*)abBuf, " -noshl");
      // }

      // find the target executable:
      // dview, dview.bat, dview.exe [but not dview120.exe]
      // does not search for other extensions like .cmd.
      char *pszTarg    = str("dview");
      char *pszTargAbs = findPathLocation(pszTarg, 0);

      if (!pszTargAbs)
         pszTargAbs = findPathLocation("dview.exe", 0);

      if (!pszTargAbs)
         if ((pszTargAbs = findPathLocation("dview.bat", 0))) {
            pszwopt    = str("");
            pszxopt    = str("");
         }

      if (pszTargAbs)
         pszTarg = pszTargAbs;

      if (cs.verbose) {
         if (!pszTargAbs) {
            pinf("dview, dview.exe or dview.bat not found directly, but trying\n");
            pinf("anyway, in case another extensions is present within PATH.\n");
         }
      }

      if (chain.usefiles)
      {
         if (chain.numberOfInFiles()) 
         {
            SFTmpFile tmp(".txt", 1, 1); // 1: nodelete, 1: fixed file number
            char *pszTmpFile = tmp.name();
            if (!pszTmpFile) return 9;
   
            FILE *fout = fopen(pszTmpFile, "w");
            if (!fout) return 9+perr("cannot write temporary file: %s\n", pszTmpFile);
   
            for (int i=0; i<chain.numberOfInFiles(); i++) {
               Coi *pcoi = chain.getFile(i);
               if (!pcoi) return 9+perr("int. #141271853\n");
               fprintf(fout, "%s\n", pcoi->name());
            }
            fclose(fout);
   
            #ifdef VFILEBASE
            // cleanup possible connections to sfk ftp server
            mtklog(("view: cleanup connections"));
            resetLoadCaches(0);
            #endif // VFILEBASE

            #ifdef _WIN32
            sprintf(szLineBuf2, "%s%s%s -flist %s", pszsopt, pszTarg, (char*)abBuf, pszTmpFile);
            #else
            sprintf(szLineBuf2, "%s%s%s%s -flist %s%s", pszwopt, pszTarg, pszxopt, (char*)abBuf, pszTmpFile, pszsopt);
            #endif
            if (cs.verbose) pinf("[nopre] running: %s\n", szLineBuf2);
            int iRC = system(szLineBuf2);
            if (iRC) {
               printf("failed to run, rc=%d: %s\n", iRC, szLineBuf2);
               bShowGetDV = 1;
            }
         } else {
            printf("%s: received no input files for viewing.\n", pszCmd);
         }
      }
      else
      if (   (chain.usedata && chain.indata->numberOfEntries())
          ||  bGlblStdInAny
         )
      {
         SFTmpFile tmp(".txt", 1, 1); // 1: nodelete, 1: fixed file number
         char *pszTmpFile = tmp.name();
         if (!pszTmpFile) return 9;

         // write text data to temporary file
         FILE *fout = fopen(pszTmpFile, "w");
         if (!fout) return 9+perr("cannot write temporary file: %s\n", pszTmpFile);

         if (chain.usedata)
         {   
            if (bcolor)
               fprintf(fout, "<interleaved-attributes-text version=\"1.0\" prefix=\"\">\n");
   
            bool bsnap = 0;
   
            for (int i=0; i<chain.indata->numberOfEntries(); i++) 
            {
               char *pattr = 0;
               strcopy(szLineBuf2, chain.indata->getEntry(i, __LINE__, &pattr));
               removeCRLF(szLineBuf2);
   
               // if the first text record is a :file header
               bool bsubhead = 0;

               // :file text records with 'f' in rightmost extended attribute area
               // are real subfile headers.
               if (pattr) {
                  int natrlen = strlen(pattr);
                  if (natrlen > 0 && pattr[natrlen-1] == 'f' && !strncmp(szLineBuf2, ":file ", 6))
                     bsubhead = 1;
               }

               if (i==0 && bsubhead)
               {
                  // create snapfile format.
                  if (bcompact) {
                     fprintf(fout, ":snapfile sfk,1.1,prefix=:file: ,\n");
                     if (bcolor)
                     fprintf(fout, "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n");
                  } else {
                     fprintf(fout, ":snapfile sfk,1.1,lprefix=:file:\n");
                     if (bcolor)
                     fprintf(fout, "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n");
                  }
                  bsnap = 1;
               }
   
               // if creating snapfile, reformat every file header
               if (bsnap && bsubhead) {
                  if (bcompact) {
                     // 1. optional blank line
                     // 2. :file: filename
                     if (bcompact < 2) {
                        fprintf(fout, "\n"); if (bcolor) fprintf(fout, "\n");
                     }
                     fprintf(fout, ":file: %s\n", szLineBuf2+6); 
                     if (bcolor) {
                        for (int k=7+strlen(szLineBuf2+6); k>0; k--)
                           fputc('b',fout);
                        fputc('\n',fout);
                     }
                  } else {
                     // 1. blank line
                     // 2. :file:
                     // 3. filename
                     fprintf(fout, "\n");       if (bcolor) fprintf(fout, "\n");
                     fprintf(fout, ":file:\n"); if (bcolor) fprintf(fout, "\n");
                     fprintf(fout, "%s\n", szLineBuf2+6); 
                     if (bcolor) {
                        for (int k=strlen(szLineBuf2+6); k>0; k--)
                           fputc('b',fout);
                        fputc('\n',fout);
                     }
                  }
               } else {
                  mtklog(("vtext: %04d \"%s\"",(int)strlen(szLineBuf2),szLineBuf2));
                  fprintf(fout, "%s\n", szLineBuf2);
                  if (bcolor) {
                     // map and print color attribute codes. dview displays only:
                     // r,g,b,y,c,m for red,green,blue,yellow,cyan,magenta
                     // therefore logical attributes must be mapped.
                     szAttrBuf[0] = '\0';
                     if (pattr) strcopy(szAttrBuf, pattr);
                     for (char *psz=szAttrBuf; *psz; psz++)
                        switch (*psz) {
                           case 'f': *psz = 'B'; break; // nGlblFileColor 
                           case 'l': *psz = 'C'; break; // nGlblLinkColor 
                           case 'h': *psz = 'g'; break; // nGlblHeadColor 
                           case 'i': *psz = 'g'; break; // nGlblHitColor  
                           case 'a': *psz = 'M'; break; // nGlblRepColor  
                           case 'x': *psz = 'M'; break; // nGlblExampColor
                           case 'e': *psz = 'R'; break; // nGlblErrColor  
                           case 'w': *psz = 'Y'; break; // nGlblWarnColor 
                           case 't': *psz = 'B'; break; // nGlblTimeColor 
                           case 'p': *psz = 'B'; break; // nGlblPreColor
                           // map white codes to default
                           case 'v': *psz = ' '; break;
                           case 'V': *psz = ' '; break;
                        }
                     mtklog(("vattr: %04d \"%s\"",(int)strlen(szAttrBuf),szAttrBuf));
                     fprintf(fout, "%s\n", szAttrBuf);
                  }
               }
            }
         }
         else
         {
            // copy from stdin
            size_t nread = 0;
            while ((nread = fread(szAttrBuf, 1, MAX_LINE_LEN, stdin)) > 0)
               myfwrite((uchar*)szAttrBuf, nread, fout);
         }

         fclose(fout);

         #ifdef _WIN32
         sprintf(szLineBuf3, "%s%s%s %s", pszsopt, pszTarg, (char*)abBuf, pszTmpFile);
         #else
         sprintf(szLineBuf3, "%s%s%s%s %s%s", pszwopt, pszTarg, pszxopt, (char*)abBuf, pszTmpFile, pszsopt);
         #endif
         if (cs.verbose) pinf("[nopre] running: %s\n", szLineBuf3);
         int iRC = system(szLineBuf3);
         if (iRC) {
            printf("failed to run, rc=%d: %s\n", iRC, szLineBuf3);
            bShowGetDV = 1;
         }
      }
      else 
      {
         printf("%s: received no input text for viewing.\n", pszCmd);
      }

      if (bShowGetDV) {
         if (!pszTargAbs) {
            perr("dview.exe was not found within folders of PATH:\n");
            char *pszPath = getenv("PATH");
            if (pszPath)
               printf("%s\n", pszPath);
            printx("To download Depeche View Lite now, type:\n"
                   "\n"
                   "   #sfk getdv\n"
                   "\n"
                   );
            printx("Then retry your command. If downloading fails you may\n"
                   "also visit www.depecheview.com and download it manually.\n");
         }
      }

      bDone = 1;
   }

   #ifdef _WIN32
   if (!strcmp(pszCmd, "beep")) // +chaining
   {
      if (nparm < 1) {
      printx("<help>$sfk beep messageid\n"
             "\n"
             "   play a system sound. possible ids are:\n"
             "\n"
             "       0  default sound\n"
             "      10  SystemHand\n"
             "      20  SystemQuestion\n"
             "      30  SystemExclamation\n"
             "      40  SystemAsterisk\n"
             );
      return 9;
      }
      int nid = -1; // default id
      bool breadid = 0;
      for (; iDir<argc; iDir++) 
      {
         if (   !strncmp(argv[iDir], "-", 1)
             && strcmp(argv[iDir], "-1")
            )
         {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, 0))
            break;
         // process non-option keywords:
         if (!breadid) {
            breadid = 1;
            char *psz = argv[iDir];
            if (strlen(psz) == 1 || psz[0] == '-')
               nid = atol(argv[iDir]);
            else
               nid = getTwoDigitHex(argv[iDir]); // -1 on error
         }
         else
            return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC;
      if (btest) return 0;

      MessageBeep(nid);

      STEP_CHAIN(iDirNext, 0);

      bDone = 1;
   }
   #endif

   regtest("filefind -time -size foo bar");

   // easy dir lister: sfk :pattern
   ifcmd (   !strcmp(pszCmd, "filefind") || !strcmp(pszCmd, "ff")
          || (iDir == 2 && pszCmd[0] == ':')
         )
   {
      ifhelp (!strcmp(pszCmd, ":") || (pszCmd[0] != ':' && nparm < 1))
      printx("<help>$sfk filefind [or ff] pattern [pattern2 <not>pattern3 ...] [opts]\n"
             "\n"
             "   easy file name finder for the current directory tree.\n"
             "   if you remember any words of a filename, or its path,\n"
             "   type \"sfk ff \" and the words to find matching filenames.\n"
             "   to type even less, try \"sfk :\" followed by the first word,\n"
             "   without blank: \"sfk :word1 word2 ...\"\n"
             "\n"
             "   $note:\n"
             "   - searches the current directory \".\" and all subdirectories.\n"
             "   - the full filename paths, including relative filenames,\n"
             "     are compared (not just the relative filenames).\n"
             "   - the patterns are AND combined (not OR as with list),\n"
             "     meaning that ALL given patterns must appear in a path\n"
             "     to have it listed. the pattern sequence is ignored.\n"
             "   - options may appear anywhere.\n"
             "   - exclude patterns starting with <not> are also supported.\n"
             "\n"
             "   $options\n"
             "      -time  list also file times.\n"
             "      -size  list also file sizes.\n"
             );


      printx("\n"
             "   $chaining support\n"
             "      output chaining is supported.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk filefind foo bar <not>save\n"
             "         lists all files in the current directory tree having both\n"
             "         foo and bar in their path+filename, regardless of sequence.\n"
             "         files having \"save\" in their path (or name) are excluded.\n"
             "\n"
             "      #sfk ff foo<wild>bar thing +fview\n"
             "         similar to the above, lists all files having bar AFTER foo\n"
             "         in their path+filename. thing must also be present.\n"
             "         resulting files are loaded and shown in Depeche View.\n"
             "\n"
             "      #sfk :.pdf\n"
             "         list all .pdf files down somewhere in the directory tree.\n"
             "\n"
             "      #sfk :debug<wild>.o +del\n"
             "         delete all debug executables in the current directory tree.\n"
             );
      ehelp;

      bool bShortForm = (pszCmd[0] == ':');

      if (glblFileSet.beginLayer(false, __LINE__)) return 9;
      if (glblFileSet.addRootDir(str("."), __LINE__, false)) return 9;
      if (bShortForm) {
         char *pszpat = pszCmd+1;
         sprintf(szLineBuf, "*%s*", pszpat);
         glblFileSet.addDirMask(szLineBuf);
      }
      glblFileSet.addFileMask(str("*")); // dummy

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-size")) {
            // do not just remember the flag, but also option sequence.
            cs.listForm = ((cs.listForm << 8) | 0x01);
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-time")) {
            // do not just remember the flag, but also option sequence.
            cs.listForm = ((cs.listForm << 8) | 0x02);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         char *pszmask = argv[iDir];
         if (isNotChar(pszmask[0])) {
            // mask parts starting with "!" are negative dir AND file masks.
            glblFileSet.addDirMask(pszmask);
            glblFileSet.addFileMask(pszmask);
         } else {
            // anything else is a PATH mask.
            sprintf(szLineBuf, "*%s*", pszmask);
            glblFileSet.addDirMask(szLineBuf);
         }
      }

      if (btest) return 0;

      glblFileSet.setBaseLayer();

      if (chain.colany())
         cs.nohead = 1;

      nGlblListMode = 2;
      cs.dirMaskAndMatch = 1;
      cs.incFNameInPath  = 1;
      lRC = walkAllTrees(eFunc_FileStat, lFiles, lDirs, nBytes);
      info.clear();

      if (!cs.quiet) {
         if (cs.noFiles)
            printf("%u non-regular files skipped.\n", cs.noFiles);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   // internal
   if (!strcmp(pszCmd, "data"))
   {
      if (nparm < 1) {
      printx("<help>$sfk data [options] col \"<run>namecom,<run>stradr,<run>city\" [numrec]\n"
             "\n"
             "   create numrec records of random text\n"
             "   to produce synthetic test or example data.\n"
             "\n"
             "   $formal syntax\n"
             "     sfk data format template [numrec]\n"
             "\n"
             "   $supported template formats\n"
             "     #col[umns]<def>  a list of data columns, with each column\n"
             "                content type prefixed by <run>.\n"
             "     #text<def>       create a text, keeping commas as is\n"
             "\n"
             "   $template format details\n"
             "     #col<def>  format:\n"
             "     - column types must be prefixed by <run>\n"
             "     - columns are separated by comma on input\n"
             "       which is replaced by TAB character on output\n"
             "     #text<def> format:\n"
             "     - symbols must be prefixed by <run>\n"
             "     - comma \",\" is kept within text as is\n"
             "\n"
             "   $supported column types\n"
             "     #nameper<def>    name of a person\n"
             "     #namecom<def>    name of a company\n"
             "     #stradr<def>     street address\n"
             "     #city<def>       city name\n"
             "     #statecode<def>  two character string\n"
             "     #zip<def>        five digit string\n"
             "     #person<def>     person address record\n"
             "     #company<def>    company address record\n"
             "\n"
             "   $options\n"
             "     -makedb db.txt  export database to out.txt for editing\n"
             "     -from   db.txt  load phrase database from db.txt\n" 
             "     -seed   n       set random seed to a fixed value\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "     #sfk data col \"<run>namecom, <run>stradr, <run>city <run>statecode <run>zip\" 20\n"
             "       create 20 records with random company data\n"
             "\n"
             "     #sfk data col \"<run>company\" 20 +tabtocsv -quoteall\n"
             "       same as above, but using the predefined company type\n"
             "       and with comma separated fully quoted output\n"
             "\n"
             "     #sfk data text \"<run>news\"\n"
             "       create a california business news text\n"
             "\n"
             );
      return 9;
      }

      char *pszAll   =  0;
      int  iNumRec   = -1;
      int  iTemplate =  0;
      uint nseed     = (uint)time(NULL);

      char *pszSrc   = strdup((char*)szGlblData);

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            delete [] pszSrc;
            if (!(pszSrc = loadFile(pszParm, 0)))
               return 9;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-makedb", &pszParm)) {
            if (!pszParm) return 9;
            delete [] pszSrc;
            if (saveFile(pszParm, (uchar*)szGlblData, strlen(szGlblData)))
               return 9;
            printf("saved to: %s\n", pszParm);
            return 0;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-seed", &pszParm)) {
            if (!pszParm) return 9;
            nseed = atoi(pszParm);
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!iTemplate) {
            if (!strncmp(pszArg, "col", 3))
               { iTemplate=1; continue; }
            if (!strcmp(pszArg, "text"))
               { iTemplate=2; continue; }
            return 9+perr("invalid command: %s", pszArg);
         }
         if (!pszAll) {
            pszAll = pszArg;
            continue;
         }
         if (iNumRec < 0) {
            iNumRec = atoi(pszArg);
            continue;
         }
         return 9+perr("unexpected parameter: %s\n", pszArg);
      }

      CharAutoDel odel(pszSrc);

      if (!pszAll)
         return 9+perr("missing template text");

      if (!strBegins(pszSrc, "#:sfk-phrase-db:")) {
         perr("invalid or missing phrase database header\n");
         pinf("file must start with: #:sfk-phrase-db:\n");
         return 9;
      }

      if (iNumRec < 0)
         iNumRec = 1;

      srand((unsigned int)nseed);

      // convert , to tab for all
      char *psrc = pszAll;
      char *pdstcur = (char*)abBuf;
      char *pdstmax = pdstcur + MAX_ABBUF_SIZE;
      while (*psrc != 0 && pdstcur < pdstmax)
      {
         if (iTemplate==1 && *psrc == ',') {
            *pdstcur++ = '\\';
            *pdstcur++ = '\t';
         }
         else
         if (iTemplate==2 && *psrc == ',') { 
            *pdstcur++ = '\x01';
         }
         else
         if (*psrc == '#')
            *pdstcur++ = '$';
         else
            *pdstcur++ = *psrc;
         psrc++;
      }
      *pdstcur = '\0';
      pszAll = (char*)abBuf;

      // convert , to tab for data
      psrc = pszSrc;
      pdstcur = pszSrc;
      for (; *psrc; psrc++) {
         if (!strncmp(psrc, "\\,", 2)) {
            *pdstcur++ = '\\';
            *pdstcur++ = '\t';
            psrc++;
            continue;
         }
         if (!strncmp(psrc, "\\;", 2)) {
            *pdstcur++ = ';';
            psrc++;
            continue;
         }
         if (*psrc == ';') {
            *pdstcur++ = '\x01';
            continue;
         }
         *pdstcur++ = *psrc;
      }
      *pdstcur = '\0';

      Phraser *p = new Phraser();
      if (p->load(pszAll, (char*)pszSrc))
         return 9;

      for (int i=0; i<iNumRec; i++)
      {
         p->resetIndexes();

         char *pres = p->solve(str("all"));
         if (!pres) return 9+perr("cannot solve 'all'\n");

         if (chain.coldata) {
            if (chain.colbinary) {
               if (chain.addBinary((uchar*)pres, strlen(pres)))
                  return 9;
            } else {
               if (chain.addLine(pres, str("")))
                  return 9;
            }
         } else {
            printf("%s\n", pres);
         }
      }

      p->reset();
      delete p;

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }

   #ifdef WITH_TCP
   // internal
   if (!strcmp(pszCmd, "ping"))
   {
      if (nparm < 1) {
      printx("<help>$sfk ping ip [maxwaitmsec]\n"
             "\n"
             "   check if machine on given ip replies to pings.\n"
             "   requires admin rights.\n"
             "\n"
             );
      return 9;
      }

      char *pszHost =  0;
      int iWaitMSec = -1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (pszHost == 0) {
            pszHost = pszArg;
            continue;
         }
         if (iWaitMSec == -1) {
            iWaitMSec = atoi(pszArg);
            int ilen = strlen(pszArg);
            if (ilen > 0 && pszArg[ilen-1]=='s')
               iWaitMSec *= 1000;
            continue;
         }
         return 9+perr("unexpected parameter: %s\n", pszArg);
      }

      if (iWaitMSec == -1)
         iWaitMSec = 500;

      if (pszHost == 0)
         return 9+perr("missing target ip\n");

      int iSingleWaitMSec = 200;

      int ires = 0;

      num nstart = getCurrentTime();

      while (getCurrentTime() < nstart + iWaitMSec)
      {
         ires = sfkping(pszHost, iSingleWaitMSec);
   
         if (ires >= 0) {
            if (!cs.quiet)
               printf("OK within %d msec\n", (int)(getCurrentTime()-nstart));
            break;
         }
         else
         if (ires == -1) {
         } else {
            printf("ping returned error %d\n", ires);
            break;
         }
      }

      if (ires == -1) {
         printf("no reply within %d (%d) msec\n", iWaitMSec, iSingleWaitMSec);
         return 1;
      }

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;
   }
   #endif // WITH_TCP

   // yet internal
   if (strBegins(pszCmd, "tobase64") || strBegins(pszCmd, "frombase64"))
   {
      if (nparm < 1) {
         printx("<help>$sfk tobase64 infile [outfile]\n"
            "$sfk frombase64 infile outfile\n"
            );
         return 9;
      }

      bool bencode = strBegins(pszCmd, "tobase64");

      char *pszInFile  = 0; 
      char *pszOutFile = 0;
      int iChainNext   = 0;

      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszInFile)  pszInFile = argv[iDir];
         else
         if (!pszOutFile) pszOutFile = argv[iDir];
         else
            return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (!pszInFile)  return 9+perr("missing input filename.\n");
      if (!bencode && !pszOutFile) return 9+perr("missing output filename.\n");

      num nFileSize = 0;
      uchar *pdata = loadBinaryFile(pszInFile, nFileSize);
      if (!pdata) return 9;

      num nOutSize = nFileSize * 2; // approx.
      uchar *pout = new uchar[nOutSize+100];
      if (!pout) return 9+perr("out of memory.\n");

      int nrc = 0;
      int nsave = -1;
      if (bencode) {
         nrc = encode64(pdata, nFileSize, pout, nOutSize, 40);
         if (nrc)
            perr("encoding failed, rc %d\n", nrc);
         else
            nsave = strlen((char*)pout);
      } else {
         nrc = decode64(pdata, nFileSize, pout, nOutSize);
         if (nrc < 0)
            perr("decoding failed.");
         else
            nsave = nrc;
      }

      if (nsave >= 0)
      {
         if (!pszOutFile) {
            printf("%s",pout);
         } else {
            FILE *fout = fopen(pszOutFile, "wb");
            if (fout) {
               int ndone = myfwrite(pout, nsave, fout);
               if (ndone != nsave)
                  perr("failed to fully write output file");
               fclose(fout);
            }
         }
      }

      delete [] pdata;
      delete [] pout;

      bDone = 1;      
   }

   ifcmd (strBegins(pszCmd, "char"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk char[s] word\n"
             "\n"
             "   print ascii codes of all chars of a word,\n"
             "   or print chars for the given code(s).\n"
             "\n"
             "   $options\n"
             "      -codes    force listing of character codes,\n"
             "                do not check if word is a number.\n"
             "      -literal  or -lit stops interpretation of any further\n"
             "                options or chain commands. required if you\n"
             "                need the code of \"-\" or \"+\".\n"
             "      -hexlist  print flat list of hex codes\n"
             "      -hexsrc   print as hex source code\n"
             "      -fromutf  decode utf8 sequence from hexadecimal\n"
             "                input like 0xe28098\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk chars hello\n"
             "         prints 5 lines of codes, one for each char.\n"
             "\n"
             "      #sfk chars 0x53464b\n"
             "         prints 'SFK', the letters for these hex codes.\n"
             "         any number of hex values can be provided.\n"
             "\n"
             "      #sfk chars -fromutf 0x54657374e28098e28099\n"
             "         decodes ASCII characters and UTF-8 sequences,\n"
             "         listing code points of each character found.\n"
             "\n"
             "      #sfk char 65\n"
             "         prints 'A', the letter for that decimal code.\n"
             "         only a single decimal value can be provided.\n"
             "\n"
             "      #sfk char -lit +\n"
             "         print the code of the plus char.\n"
             );
      ehelp;
      
      char *pword  = 0;
      bool bdecode = 0;
      bool blit    = 0;
      bool butf    = 0;
      int  iFormat = 0;
      uint uixor   = 0;
      int  iutf    = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (!blit) {
            if (strBegins(argv[iDir], "-code")) {
               bdecode = 1;
               continue;
            }
            else
            if (strBegins(argv[iDir], "-lit")) {
               blit = 1;
               continue;
            }
            else
            if (strBegins(argv[iDir], "-fromutf")) {
               butf = 1;
               continue;
            }
            else
            if (!strcmp(argv[iDir], "-hexlist")) {
               iFormat = 1;
               continue;
            }
            else
            if (!strcmp(argv[iDir], "-hexsrc")) {
               iFormat = 2;
               continue;
            }
            else
            if (haveParmOption(argv, argc, iDir, "-xor", &pszParm)) {
               if (!pszParm) return 9;
               uixor = (uint)myatonum(pszParm);
               continue;
            }
            else
            if (!strncmp(argv[iDir], "-", 1)) {
               if (isDirParm(argv[iDir]))
                  break; // fall through
               if (setGeneralOption(argv, argc, iDir))
                  continue;
               else
                  return 9+perr("unknown option: %s\n", argv[iDir]);
            }
            else
            if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
               break;
         }
         // process non-option keywords:
         if (!pword)
            { pword = argv[iDir]; continue; }
         return 9+perr("unexpected parameter: %s\n", argv[iDir]);
      }

      if (!pword)
         return 9+perr("missing argument\n");

      char *psz = pword;
      bool bjustdigits = 1;
      for (; *psz; psz++)
         if (!isdigit(*psz))
            bjustdigits = 0;

      if (!bdecode && (bjustdigits || strBegins(pword, "0x")))
      {
         if (bjustdigits) {
            int npre = atol(pword);
            if (npre > 255)
               return 9+perr("value too large");
            uchar n = (uchar)npre;
            chain.print("%d\t0x%02X\t%c\n", n, n, (char)n);
         } else {
            pword += 2;
            for (; *pword; pword+=2) {
               if (strlen(pword) == 0)
                  break;
               if (strlen(pword) == 1)
                  return 9+perr("unexpected character: %s\n", pword);
               uchar n = (uchar)getTwoDigitHex(pword);
               if (butf) {
                  if (iutf > MAX_LINE_LEN)
                     return 9+perr("overflow");
                  szLineBuf[iutf++] = n;
               } else {
                  chain.print("%d\t0x%02X\t%c\n", n, n, (char)n);
               }
            }
            if (butf) {
               UTF8Codec utf(szLineBuf, iutf);
               while (utf.hasChar()) {
                  uint n = utf.nextChar();
                  chain.print("U+%04X\t%c\n", n, unicodeToIso(n));
               }
            }
         }
      }
      else
      {
         for (; *pword; pword++) 
         {
            uchar uc = ((uchar)*pword) ^ uixor;
            switch (iFormat) 
            {
               case 1: 
                  chain.print(' ', 0, "%02X", uc); 
                  break;
               case 2: 
                  chain.print(' ', 0, "0x%02X%s", uc, pword[1]?",":""); 
                  break;
               default:
                  chain.print("%d\t0x%02X\t%c\n", uc, uc, *pword);
                  break;
            }
         }
      }
      
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strncmp(pszCmd, "hextobin", 9))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk ... +hextobin outfile\n"
             "\n"
             "   convert lines of text containing hexdump to binary.\n"
             "\n"
             "   $chain-only command\n"
             "      hextobin can be used only #after another command<def>,\n"
             "      typically filter, which reads and prepares the input data.\n"
             "\n"
             "   $options\n"
             "      -fuzzy  ignore >< and ## characters\n"
             "\n"
             "   $supported input formats since SFK 1.6.9:\n"
             "\n"
             "      - if >...< is found then only hex data inside that is used.\n"
             "      - if ## is found then only hex data before that is used.\n"
             "      - else any hex characters are used, and with\n"
             "        option -fuzzy any >< or ## characters are ignored.\n"
             "      - whitespace at line start is ignored.\n"
             "\n"
             "   $1. sfk hexdump full bracket delimited format:\n"
             "\n"
             "      :file test.dat\n"
             "       >6578616D 706C6520 77697468 206E6F6E< example with non 00000000\n"
             "       >20616C6E 756D0D0A 63686172 61637465<  alnum..characte 00000010\n"
             "       >73202D2B 28295C2F 2E0D0A<            s -+()\\/...      00000020\n"
             "\n"
             "   $2. sfk postdump minimal format, for forums and wiki:\n"
             "\n"
             "      :file test.dat\n"
             "      65 78 61 6D 70 6C 65 20 77 69 74 68 20 6E 6F 6E ## example.with.non 0000\n"
             "      20 61 6C 6E 75 6D 0D 0A 63 68 61 72 61 63 74 65 ## .alnum..characte 0010\n"
             "      73 20 2D 2B 28 29 5C 2F 2E 0D 0A                ## s..........      0020\n"
             "\n"
             "   $3. any text with hex data inbetween that does not contain\n"
             "      $the >< or ## characters (else -fuzzy must be used):\n"
             "\n"
             "      --== 6578616D 706C6520 77697468 ==--\n"
             "      // 0x65, 0x78, 0x61, 0x6D ::\n"
             "\n"
             "   $input line length limitation:\n"
             "      text lines in the input file should not be longer than\n"
             "      4000 characters or sfk filter will split them, causing\n"
             "      hextobin to produce errors like \"wrong hex format\".\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk filter dump.txt +hextobin out.dat\n"
             "         convert file dump.txt and write to out.dat\n"
             #ifdef _WIN32
             "\n"
             "      #sfk fromclip +hextobin %%TEMP%%\\tmp1.dat +hexdump\n"
             "         takes a hex sequence like 22737769 73732066 from clipboard,\n"
             "         printing its text via a temporary file and hexdump.\n"
             #endif
            );
      ehelp;

      if (!chain.usedata) {
         perr("%s needs input data from a previous command.\n", pszCmd);
         pinf("type \"sfk hextobin\" for help.\n");
         return 9;
      }

      char *pszOutFile = 0;
      bool bFuzzy = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszArg = argv[iDir];
         if (!strcmp(pszArg, "-fuzzy")) {
            bFuzzy = 1;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         pszOutFile = argv[iDir];
      }

      FILE *fout=0;

      if (chain.coldata && chain.colbinary) {
         // no file output
      } else {
         if (!pszOutFile)
            return 9+perr("hextobin: missing output filename.\n");
         if (!(fout = fopen(pszOutFile, "wb")))
            return 9+perr("hextobin: cannot write: %s\n", pszOutFile);
      }

      SFKMD5 outmd;

      uchar *poutmax = abBuf + sizeof(abBuf) - 100;
      bool berr=0,bprefix=0;
      int nConvLines=0, nSkippedLines=0;
      num nTotalBytes = 0;
      for (int i=0; !berr && i<chain.indata->numberOfEntries(); i++)
      {
         // fetch another hex input line
         char *pszLine = chain.indata->getEntry(i, __LINE__);
         // skip initial whitespace
         while (*pszLine!=0 && (*pszLine==' ' || *pszLine=='\t'))
            pszLine++;
         // auto-skip filename header
         if (!strncmp(pszLine, ":file ", 6)) {
            pinf("skipping filename line on input\n");
            continue;
         }
         // >3135302E 38343820 42797465 73206672<
         char  *psz  = pszLine;
         uchar *pout = abBuf;
         char szByte[10];
         int iLineState=0;
         while (*psz) 
         {
            // skip over noise like " > "
            while (*psz && !isxdigit(*psz)) {
               if (!bFuzzy)
               switch (iLineState) {
                  case 0:
                     if (*psz=='>') iLineState=1; 
                     if (*psz=='#') iLineState=2;
                     break;
                  case 1:
                     if (*psz=='<') iLineState=2;
                     break;
               }
               psz++;
            }
            if (iLineState==2)
               break;
            bprefix = 0;
            if (!strncmp(psz, "0x", 2)) {
               bprefix = 1;
               psz += 2; // 0x12,0x15, 0x19
            }
            if (!*psz) break;
            szByte[0] = psz[0];
            if (isxdigit(psz[1])) {
               // two hex chars: 00 57 38 29
               szByte[1] = psz[1];
               szByte[2] = '\0';
               psz += 2;
            }
            else if (bprefix) {
               // FIX 163R5: accept single hex char expression "0xa "
               szByte[1] = '\0';
               psz += 1;
            }
            else {
               perr("wrong hex format: \"%s\"\n", psz); 
               berr=1;
               break;
            }
            *pout++ = (uchar)strtol(szByte, 0, 0x10);
            if (pout >= poutmax) { perr("buffer overflow: input lines too large\n"); berr=1; break; }
         }
         // flush collected binary line
         int nBinSize = pout-abBuf;
         if (nBinSize > 0) {
            if (chain.coldata && chain.colbinary) {
               if (chain.addBinary(abBuf, nBinSize))
                  return 9;
            } else {
               if ((int)myfwrite(abBuf, nBinSize, fout) != nBinSize) {
                  esys("fwrite", "failed to write %s   \n", pszOutFile);
                  berr=1;
                  break;
               }
            }
            outmd.update(abBuf, nBinSize);
            nTotalBytes += pout-abBuf;
            nConvLines++;
         } else {
            nSkippedLines++;
         }
      }

      if (fout)
         fclose(fout);

      if (!cs.quiet) {
         printf("%d lines converted, %d skipped, %s output bytes.\n", nConvLines, nSkippedLines, numtoa(nTotalBytes));
         unsigned char *pmd5 = outmd.digest();
         for (int i=0; i<16; i++)
            sprintf(&szLineBuf[i*2], "%02x", pmd5[i]);
         printf("md5: %s\n", szLineBuf);
      }

      // pass output filename if requested
      if (chain.colfiles) {
         Coi ocoi(pszOutFile, 0);
         chain.addFile(ocoi); // is copied
         STEP_CHAIN(iChainNext, 1);
      } else {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }

      bDone = 1;      
   }

   regtest("dupfind -listorg -minsize=3m");

   ifcmd (!strncmp(pszCmd, "dupfind", 3)) 
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk dupfind -dir anydir [-file .ext1 .ext2]\n"
             "\n"
             "   find and list duplicate files.\n"
             "\n"
             "   $options\n"
             "      -diffdirs    list only duplicates residing in different\n"
             "                   root directories. this option requires that\n"
             "                   you specify at least two dirs after -dir.\n"
             "      -listorg     list all original filenames,\n"
             "                   leave out any duplicate filenames.\n"
             "      -minsize=n   compare only files with size >= n.\n"
             "                   examples for n are:\n"
             "                      5m = 5000000 bytes (5 mbytes)\n"
             "                    100k =  100000 bytes (5 kbytes)\n"
             "                      1M = 1048576 bytes (2<<20 bytes)\n"
             "                   9000b =    9000 bytes\n"
             "\n"
             "   $command chaining\n"
             "      - by default, this command passes the names\n"
             "        of found duplicate files to the next command.\n"
             "\n"
             "      - option -listorg does the opposite: it passes\n"
             "        only original filenames, but no duplicates,\n"
             "        to the next chain command.\n"
             "\n"
             "   $NOTE:\n"
             "      if identical files are found, the decision what is listed\n"
             "      as \"original\" or \"duplicate\" is currently based on the\n"
             "      order in the file system: the file found first is listed as\n"
             "      \"original\". check carefully if this is what you think,\n"
             "      before cleaning up any duplicates.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk dupfind .\n"
             "         find all duplicates within the current directory tree.\n"
             "\n"
             "      #sfk dupfind -dir docs1 docs2 docs3\n"
             "         find all dups across and within the given directories.\n"
             "\n"
             "      #sfk dupfind -diffdir -dir docs1 docs2 docs3\n"
             "         find dups between docs1/docs2, docs2/docs3, docs1/docs3,\n"
             "         but does NOT list dups within the same root directory.\n"
             "\n"
             "      #sfk dupfind docs .doc +del\n"
             "         find all duplicate .doc files, within the docs\n"
             "         directory tree, and delete them.\n"
             "\n"
             "      #sfk dupfind -listorg docs .doc +run \"copy <run>file docs2\"\n"
             "         copy all .doc files from docs to docs2,\n"
             "         but leave out any duplicate files.\n"
             "\n"
             "      #sfk dupfind -dir pic1 -dir pic2 -dir pic3\n"
             "         find duplicates across three different directory trees.\n"
             "         specifying multiple -dirs is also a way of influencing\n"
             "         the result order; if a file is found both in pic1 and pic3,\n"
             "         the file from pic1 will be listed as original, the other one\n"
             "         as the duplicate.\n"
             "\n"
             "      #sfk sel -dir pic1 pic2 pic3 -file .jpg +dup -minsize=1m\n"
             "         similar to the above, this example uses command chaining:\n"
             "         list all .jpg files from the pic directories, then pass\n"
             "         this to the dupfind command, also filtering by size.\n"
             );
      ehelp;

      bool blistorg = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-minsize", &pszParm)) {
            if (!pszParm) return 9;
            cs.selMinSize = numFromSizeStr(pszParm, "-minsize");
            if (cs.selMinSize < 0) return 9;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-diffdir")) {
            glblDupScan.clDiffDirs = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-listorg")) {
            blistorg = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         break;
      }
      
      num nstart = getCurrentTime();

      int iDirNext = 0;
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 3, &iDirNext))) return lRC;
      if (btest) return 0;

      if (glblDupScan.clDiffDirs && (glblFileSet.numberOfRootDirs() < 2))
         return 9+perr("need at least two -dir parameters with option -diffdir.");

      lRC = walkAllTrees(eFunc_DupScan, lFiles, lDirs, nBytes);
      info.clear();
      
      int nelapsed1 = (int)(getCurrentTime() - nstart);

      glblDupScan.analyze(blistorg);
      info.clear();

      int nelapsed2 = (int)(getCurrentTime() - nstart);

      if (!chain.colany() && !cs.quiet) {
         printx("$%d duplicates with %d mb.", glblDupScan.clNumDups,(int)(glblDupScan.clDupBytes/1000000));
         if (blistorg)
            printx(" $%d originals with %d mb.\n",glblDupScan.clNumOrgs,(int)(glblDupScan.clOrgBytes/1000000));
         else
            printf("\n");
      }
      if (cs.verbose) {
         printf("scanned %d file infos in %d msec.\n", glblDupScan.clSizes.numberOfEntries(), nelapsed1);
         printf("total duplicate scan took %d msec.\n", nelapsed2);
      }

      glblDupScan.reset();

      STEP_CHAIN(iDirNext, 1);
      
      bDone = 1;
   }

   #if 0
   // internal
   if (!strcmp(pszCmd, "data")) // deprecated
   {
      /*
      ifhelp (nparm < 1)
      printx("<help>$sfk data id\n"
             "\n"
             "   produce predefined data for quick testing\n"
             "\n"
             "   $id parameters\n"
             "      xml1   produce xml music meta data\n"
             "      tsv1   produce tab separated music data\n"
             "\n"
             "   $examples\n"
             "      #sfk data xml1 +filter\n"
             "         send test data to filter command\n"
             );
      ehelp;
      */

      int iFormat=0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszArg  = argv[iDir];
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!strcmp(pszArg, "xml1")) 
            {  iFormat=1; continue; }
         if (!strcmp(pszArg, "tsv1")) 
            {  iFormat=2; continue; }
         if (!strcmp(pszArg, "longlines")) 
            {  iFormat=3; continue; }
      }
      if (!iFormat)
         return 9+perr("missing data id, e.g. xml1");

      static const char *adata[] = 
      {
         "Depeche Mode\tConstruction Time Again\tEverything Counts",
         "Howard Jones\tHuman\x27s Lib\tHide And Seek",
         "Desireless\tFran\xe7ois\tVoyage, Voyage",
         0
      };

      if (iFormat==3)
      {
         char szBuf[MAX_LINE_LEN+100];
         char szNumBuf[50];
         memset(szBuf, 0, sizeof(szBuf));

         for (int iLen=MAX_LINE_LEN-5; iLen<MAX_LINE_LEN+50; iLen++)
         {
            memset(szBuf, '-', iLen);
            szBuf[0] = '>';
            szBuf[iLen-1] = '<';
            szBuf[iLen] = '\0';
            sprintf(szNumBuf, "%u", iLen);
            memcpy(szBuf+4, szNumBuf, strlen(szNumBuf));
            if (chain.coldata)
               chain.outdata->addEntry(szBuf, str(""));
            else {
               fwrite(szBuf, 1, strlen(szBuf), stdout);
               fputc('\n', stdout);
               fflush(stdout);
            }
         }
      }
      else
      for (int i=0; adata[i]; i++)
      {
         strcopy(szLineBuf, adata[i]);

         char *afield[10];

         afield[0]=szLineBuf;
         int ifield=1;

         for (char *psz=szLineBuf; *psz; psz++) {
            if (*psz=='\t') {
               *psz = '\0';
               afield[ifield++] = psz+1;
            }
         }

         switch (iFormat) {
            case 1:
               chain.print(
                  "<row>\n"
                  "  <artist>%s</artist>\n"
                  "  <album>%s</album>\n"
                  "  <track>%s</track>\n"
                  "</row>\n"
                  ,  afield[0]
                  ,  afield[1]
                  ,  afield[2]
                  );
               break;
            case 2:
               chain.print(
                  "%s\t%s\t%s\n"
                  ,  afield[0]
                  ,  afield[1]
                  ,  afield[2]
                  );
               break;
         }
      }

      if (iChainNext) {
         if (chain.coldata) {
            STEP_CHAIN(iChainNext, 1);
         } else {
            STEP_CHAIN(iChainNext, 0);
         }
      }
      
      bDone = 1;
   }
   #endif

   ifcmd (   !strncmp(pszCmd, "samp", 4) || !strncmp(pszCmd, "examp", 5)
          || !strcmp(pszCmd, "batch")
         )
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk sample java|cpp|... [outfile.java|.cpp|...]\n"
             "\n"
             "   print a short example code in a programming language.\n"
             "\n"
             "   $supported parameters:\n"
             "      java       - create a java class doing text  file I/O\n"
             "      javaimg    - create a java class doing image file I/O\n"
             "      javahex    - create a hexdump of binary data in java\n"
             "      javagui    - create a simple java gui application\n"
             "      cpp        - create a c++ text file I/O example\n"
             "      cppnetlog  - how to send UDP network text in C++\n"
             "      javanetlog - how to send UDP network text in Java\n"
             "      php        - create command line php code for text I/O\n"
             "      phpimg     - create php example for image processing\n"
             "      cmd        - create a windows .cmd or .bat file\n"
             "      bash       - create a linux bash script\n"
             "      sfk        - create an sfk script\n"
             "      sfkcmd     - sfk script embedded in a .cmd or .bat\n"
             "      sfkbash    - sfk script embedded in a bash script\n"
         //  "      sfkcmdphp  - mixture of windows .bat, sfk and php,\n"
         //  "                   to list pixel sizes of images in a dir.\n"
         //  "      html       - simple html page with css and javascript.\n"
         //  "      firefox    - create a simple firefox extension, onto\n"
         //  "                   terminal by default. add parameter \"write\"\n"
         //  "                   to really write the listed files.\n"
             "\n"
             "   $options:\n"
             "      -force    if output file exists already, overwrite it.\n"
             "\n"
             "   $command shortcut:\n"
             #ifdef _WIN32
             "      #sfk batch myscript.bat\n"
             "         does the same as \"sfk samp sfkcmd myscript.bat\"\n"
             #else
             "      #sfk batch myscript\n"
             "         does the same as \"sfk samp sfkbash myscript\"\n"
             #endif
             "\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "      #sfk samp sfkcmd foo.bat\n"
             "         creates batch file foo.bat with embedded sfk script.\n"
             "         type \"foo.bat\" to run the created script. note that\n"
             "         foo.bat must be created in a directory of your PATH,\n"
             "         or in the current directory.\n"
             "\n"
             "      #sfk batch foo.bat -force\n"
             "         the same as above, and overwrites an existing file.\n"
             "\n"
             "      #sfk samp java foo.java\n"
             "         create a java class foo. if the java JDK is available,\n"
             "         type \"javac foo.java\" and then \"java foo\" to run it.\n"
             "\n"
             "      #sfk samp phpimg doimg.php\n"
             "         create image processing script that can be run by:\n"
             "         #php doimg.php\n"
             "         if php.exe is in your PATH (read remarks in the script).\n"
             "\n"
             #ifdef _WIN32
             "      #sfk samp javahex +toclip\n"
             "         copy example for java hexdump creation to the clipboard.\n"
             #endif
             /*
             "\n"
             "      #sfk samp firefox write\n"
             "         create an empty firefox extension named \"myext@mydomain.org\",\n"
             "         that adds a popup menu function \"Say Hello\".\n"
             "         you SHOULD do this only within the \"extensions\" directory of\n"
             "         your Firefox installation. after creation, replace every \"myext\"\n"
             "         and/or mydomain.org you can find by the name of your project.\n"
             "         see also \"sfk help firefox\".\n"
             */
             );
      ehelp;

      bool bbatch = !strcmp(pszCmd, "batch");
      bool bWriteFile    = 0;
      int nlang         = 0;
      char *pszLang      = str("");
      char *pszOutFile   = 0;
      char *pszClassName = str("fileio");
      bool bLocalFile    = 0;

      #ifdef _WIN32
      if (bbatch) nlang = 6;
      #else
      if (bbatch) nlang = 7;
      #endif

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // template keywords are non-option keywords
         char *pszkey = argv[iDir];
         if (nlang == 0) {
            // expecting language as next key
            if (!strcmp(pszkey, "java"))      nlang =  1; else
            if (!strcmp(pszkey, "cpp"))       nlang =  2; else
            if (!strcmp(pszkey, "cmd"))       nlang =  3; else
            if (!strcmp(pszkey, "bash"))      nlang =  4; else
            if (!strcmp(pszkey, "sfk"))       nlang =  5; else
            if (!strcmp(pszkey, "sfkcmd"))    nlang =  6; else
            if (!strcmp(pszkey, "sfkbash"))   nlang =  7; else
            if (!strcmp(pszkey, "javaimg"))   nlang =  8; else
            if (!strcmp(pszkey, "php"))       nlang =  9; else
            if (!strcmp(pszkey, "phpimg"))    nlang = 10; else
            if (!strcmp(pszkey, "html"))      nlang = 11; else
            if (!strcmp(pszkey, "sfkcmdphp")) nlang = 12; else
            if (!strcmp(pszkey, "javahex"))   nlang = 13; else
            if (!strcmp(pszkey, "javagui"))   nlang = 14; else
            if (!strcmp(pszkey, "firefox")) { nlang = 15; bLocalFile = 1; pszLang = pszkey; } else
            if (!strcmp(pszkey, "cppnetlog")) nlang = 16; else
            if (!strcmp(pszkey, "javanetlog")) nlang = 17; else
               return 9+perr("unknown example: %s\n", pszkey);
         } else {
            pszOutFile = pszkey;
         }
      }

      if (!bLocalFile && pszOutFile) {
         if (strchr(pszOutFile, glblPathChar))
            return 9+perr("no path allowed in output filename.\n");
         // isolate class name from output filename
         strcopy(szLineBuf, pszOutFile);
         char *psz = strchr(szLineBuf, '.');
         if (psz) {
            *psz = '\0';
            pszClassName = szLineBuf;
         }
         else
         if (nlang < 3)
            return 9+perr("need an output filename like x.java or x.cpp\n");
         if (!cs.force && fileExists(pszOutFile)) {
            perr("file already exists: %s\n", pszOutFile);
            pinf("add -force to overwrite.\n");
            return 9;
         }
         if (!(cs.outfile = fopen(pszOutFile, "w")))
            return 9+perr("cannot write: %s\n", pszOutFile);
      }

      if (bLocalFile && pszOutFile) {
         if (!strcmp(pszOutFile, "write"))
            bWriteFile = 1;
         else
            return 9+perr("specify \"write\" or nothing after %s\n", pszLang);
      }

      /*
         sfk fromclip +filt -srep "_\\_\\\\_" -srep "_\q_\\\q_" -sform "          \q$col1\\n\q"
      */

      switch (nlang) {
      case 1:
      chain.print(
          "import java.io.*;\n"
          "\n"
          "public class %s\n"
          "{\n"
          "    static void log(String s) { System.out.println(\"main: \"+s); }\n"
          "\n"
          "    public static void main(String args[]) throws Throwable\n"
          "    {\n"
          "        if (args.length < 2)\n"
          "            { log(\"supply in- and output filename.\"); return; }\n"
          "\n"
          "        // copy or convert text file\n"
          "        BufferedReader rin = new BufferedReader(\n"
          "            new InputStreamReader(\n"
          "                new FileInputStream(args[0]), \"ISO-8859-1\"\n"
          "                // or US-ASCII,UTF-8,UTF-16BE,UTF-16LE,UTF-16\n"
          "                ));\n"
          "\n"
          "        PrintWriter pout = new PrintWriter(\n"
          "            new OutputStreamWriter(\n"
          "                new FileOutputStream(args[1]), \"ISO-8859-1\"\n"
          "                ));\n"
          "\n"
          "        while (true) {\n"
          "            String sline = rin.readLine();\n"
          "            if (sline == null) break; // EOD\n"
          "            log(\"copying line: \"+sline);\n"
          "            pout.println(sline);\n"
          "        }\n"
          "\n"
          "        pout.close();\n"
          "        rin.close();\n"
          "    }\n"
          "};\n",
          pszClassName
        );
         break;

      case 2:
      chain.print(
         "#include <stdio.h>\n"
         "#include <string.h>\n"
         "#include <stdarg.h>\n"
         "\n"
         "// print error message with variable parameters.\n"
         "int perr(const char *pszFormat, ...) {\n"
         "   va_list argList;\n"
         "   va_start(argList, pszFormat);\n"
         "   char szBuf[1024];\n"
         "   ::vsprintf(szBuf, pszFormat, argList);\n"
         "   fprintf(stderr, \"error: %%s\", szBuf);\n"
         "   return 0;\n"
         "}\n"
         "\n"
         "// copy text lines from one file into another.\n"
         "int main(int argc, char *argv[]) \n"
         "{\n"
         "  if (argc < 2) return 9+perr(\"specify input and output filename.\\n\");\n"
         "\n"
         "  char *pszInFile  = argv[1];\n"
         "  char *pszOutFile = argv[2];\n"
         "\n"
         "  FILE *fin  = fopen(pszInFile , \"rb\"); if (!fin ) return 9+perr(\"cannot read %%s\\n\" , pszInFile);\n"
         "  FILE *fout = fopen(pszOutFile, \"wb\"); if (!fout) return 9+perr(\"cannot write %%s\\n\", pszOutFile);\n"
         "\n"
         "  char szBuf[1024];\n"
         "  memset(szBuf, 0, sizeof(szBuf));\n"
         "  while (fgets(szBuf, sizeof(szBuf)-10, fin)) \n"
         "  {\n"
         "     char *psz = strchr(szBuf, '\\r'); if (psz) *psz = '\\0'; // strip cr\n"
         "           psz = strchr(szBuf, '\\n'); if (psz) *psz = '\\0'; // strip lf\n"
         "     printf(\"line: \\\"%%s\\\"\\n\", szBuf);\n"
         "     strcat(szBuf, \"\\n\");\n"
         "     int nlen = strlen(szBuf);\n"
         "     if (fwrite(szBuf, 1, nlen, fout) != nlen)\n"
         "        return 9+perr(\"failed to fully write %%s\\n\", pszOutFile);\n"
         "  }\n"
         "\n"
         "  fclose(fout);\n"
         "  fclose(fin);\n"
         "\n"
         "  return 0;\n"
         "}\n"
        );
         break;

      case 3:
      chain.print(
         "@rem windows command shell batch example\n"
         "@echo off\n"
         "IF \"%%1\"==\"\" GOTO xerr01\n"
         "echo \"parameter is %%1\"\n"
         "GOTO xdone\n"
         "\n"
         ":xerr01\n"
         "echo \"please supply a parameter.\"\n"
         "echo \"example: mybat parm123\"\n"
         "GOTO xdone\n"
         "\n"
         ":xdone\n"
         );
         break;

      case 4:
      chain.print(
         "#!/bin/bash\n"
         "\n"
         "function pmsg {\n"
         "   # uses a local variable mystr\n"
         "   local mystr=\"info: $1\"\n"
         "   echo $mystr\n"
         "}\n"
         "\n"
         "myparm1=\"$1 and $2\"       # no blanks around \"=\"\n"
         "\n"
         "if [ \"$2\" = \"\" ]; then    # requires all blanks\n"
         "   pmsg \"please supply two parameters.\"\n"
         "else\n"
         "   pmsg \"you supplied \\\"$myparm1\\\".\"\n"
         "\n"
         "   #  < -lt   > -gt   <= -le   >= -ge   == -eq   != -ne\n"
         "   i=1\n"
         "   while [ $i -le 5 ]; do # not \"$i < 5\"\n"
         "      echo counting: $i   # quotes are optional\n"
         "      let i+=1            # not \"i += 1\" or \"$i+=1\"\n"
         "   done\n"
         "fi\n"
         );
         break;

      case 5:
      chain.print(
         "sfk select testfiles .txt .hpp .cpp\n"
         "\n"
         "   // find words supplied by user.\n"
         "   // note that %%1 is the same as $1.\n"
         "   +find\n"
         "      %%1 %%2 %%3 $4 $5 $6\n"
         "\n"
         "   // process files containing hits\n"
         "   +run -quiet \"sfk echo \\\"Found hit in: [green]$file[def]\\\"\" -yes\n"
         "\n"
         "   // run the script by:\n"
         "   // \"sfk script %s pattern1 [pattern2 ...]\"\n",
         pszOutFile ? pszOutFile : "thisfile"
         );
         break;

      case 6:
      chain.print(
         "@echo off\n"
         "sfk script %s -from begin %%*\n"
         "GOTO xend\n"
         "\n"
         "sfk label begin\n"
         "\n"
         "   // select text files from testfiles:\n"
         "   +select testfiles .txt\n"
         "\n"
         "   // filter words foo, and user-supplied:\n"
         "   +ffilter\n"
         "      -+foo\n"
         "      %%1\n"
         "      %%2\n"
         "\n"
         "   // display results in depeche view:\n"
         "   +view\n"
         "\n"
         "   // end of sfk script:\n"
         "   +end\n"
         "\n"
         ":xend\n",
         pszOutFile ? pszOutFile : "thisfile.bat"
         );
         break;

      case 7:
      chain.print(
         "#!/bin/bash\n"
         "sfk script %s -from begin $@\n"
         "function skip_block\n"
         "{\n"
         "sfk label begin\n"
         "\n"
         "   // select text files from testfiles:\n"
         "   +select testfiles .txt\n"
         "\n"
         "#  // filter words foo, and user-supplied.\n"
         "#  // note that # lines are skipped by bash,\n"
         "#  // but not by sfk.\n"
         "#  +ffilter\n"
         "#     -+foo\n"
         "#     $1\n"
         "#     $2\n"
         "\n"
         "   // display results in depeche view:\n"
         "   +view\n"
         "\n"
         "   // end of sfk script:\n"
         "   +end\n"
         "}\n",
         pszOutFile ? pszOutFile : "thisfile.bat"
         );
         break;

      case 8:
      chain.print(
         "\n"
         "// Example source code for image file conversion\n"
         "// and simple image processing with Java.\n"
         "// Requires SUN's Java Advanced Imaging I/O Tools.\n"
         "// Usage: java imtool input.png outbase\n"
         "// Creates: outbase-jpg.jpg and further.\n"
         "\n"
         "import java.io.*;\n"
         "import java.awt.image.*;\n"
         "import javax.imageio.*;\n"
         "import com.sun.image.codec.jpeg.*;\n"
         "\n"
         "public class %s\n"
         "{\n"
         "    static void log(String s) { System.out.println(s); }\n"
         "\n"
         "    public static void main(String args[]) throws Throwable\n"
         "    {\n"
         "        if (args.length < 2)\n"
         "            throw new Exception(\"specify input filename and output basename.\");\n"
         "\n"
         "        String src  = args[0];\n"
         "        String dst1 = args[1]+\"-jpg.jpg\";\n"
         "        String dst2 = args[1]+\"-png.png\";\n"
         "        String dst3 = args[1]+\"-green.jpg\";\n"
         "        String dst4 = args[1]+\"-green.png\";\n"
         "\n"
         "        // load a PNG image, with or without transparency (alpha channel).\n"
         "        BufferedImage buf = ImageIO.read(new File(src));\n"
         "        int nwidth  = buf.getWidth();\n"
         "        int nheight = buf.getHeight();\n"
         "        log(\"width = \"+nwidth+\" pixels, height = \"+nheight);\n"
         "\n"
         "        // trivial file conversion: save as a JPEG or PNG image.\n"
         "        // JPEG will work only if input contained no transparency.\n"
         "        ImageIO.write(buf, \"jpg\", new File(dst1)); log(dst1);\n"
         "        ImageIO.write(buf, \"png\", new File(dst2)); log(dst2);\n"
         "\n"
         "        // image processing: turn all transparent pixels into green.\n"
         "\n"
         "        // 1. get access to main pixels, and transparency.\n"
         "        WritableRaster rmain = buf.getRaster();\n"
         "        WritableRaster rtran = buf.getAlphaRaster();\n"
         "\n"
         "        // 2. create a memory image to write to, WITHOUT transparency.\n"
         "        BufferedImage bout  = new BufferedImage(nwidth,nheight,BufferedImage.TYPE_INT_RGB);\n"
         "        WritableRaster rout = bout.getRaster();\n"
         "\n"
         "        int apixm[] = new int[4]; // main  pixel\n"
         "        int apixt[] = new int[4]; // trans pixel\n"
         "        int apixr[] = new int[4]; // repl. color\n"
         "\n"
         "        apixt[0] = 0xFF; // default is non-transparent\n"
         "        apixr[1] = 0xFF; // set replacement color to green\n"
         "\n"
         "        for (int y=0; y<nheight; y++)\n"
         "         for (int x=0; x<nwidth; x++) \n"
         "         {\n"
         "            rmain.getPixel(x,y,apixm);\n"
         "            if (rtran != null)\n"
         "                rtran.getPixel(x,y,apixt);\n"
         "            if (apixt[0] == 0x00)\n"
         "                // pixel is fully transparent: set to green\n"
         "                rout.setPixel(x,y,apixr);\n"
         "            else\n"
         "                // else copy through, do not change.\n"
         "                rout.setPixel(x,y,apixm);\n"
         "         }\n"
         "\n"
         "        // save memory image as JPEG, with control of quality.\n"
         "        File file = new File(dst3);\n"
         "        FileOutputStream out = new FileOutputStream(file);\n"
         "        JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);\n"
         "        JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(bout);\n"
         "        param.setQuality((float)90.0, false); // 90 percent quality\n"
         "        encoder.setJPEGEncodeParam(param);\n"
         "        encoder.encode(bout);\n"
         "        out.close();\n"
         "        log(dst3);\n"
         "\n"
         "        // save memory image as PNG.\n"
         "        ImageIO.write(bout, \"png\", new File(dst4)); log(dst4);\n"
         "    }\n"
         "};\n"
         ,pszClassName
         );
         break;

      case 9:
      chain.print(
         "<?php\n"
         "   // simple text file read and write in php.\n"
         "   // requires the php command line interface:\n"
         "   // 1. get the php 5.x zip package\n"
         "   // 2. unzip into a dir like c:\\app\\php\n"
         "   // 3. set PATH=%PATH%;c:\\app\\php;c:\\app\\php\\ext\n"
         "   // then run this script by \"php %s\"\n"
         "\n"
         "   if ($argc < 3) {\n"
         "      print(\"usage: php %s infile outfile\\n\");\n"
         "      return;\n"
         "   }\n"
         "\n"
         "   $ssrc = $argv[1];\n"
         "   $sdst = $argv[2];\n"
         "\n"
         "   if (($fsrc = fopen($ssrc, \"r\")) === false) die(\"cannot read $ssrc\\n\");\n"
         "   if (($fdst = fopen($sdst, \"w\")) === false) die(\"cannot write $sdst\\n\");\n"
         "\n"
         "   $nlines = 0;\n"
         "   while (!feof($fsrc)) {\n"
         "      $sline = fgets($fsrc, 4096);\n"
         "      if (fputs($fdst, $sline) === false)\n"
         "         { print(\"failed to write (disk full?)\\n\"); break; }\n"
         "      $nlines++;\n"
         "   }\n"
         "\n"
         "   fclose($fdst);\n"
         "   fclose($fsrc);\n"
         "\n"
         "   print(\"$nlines lines copied from $ssrc to $sdst.\\n\");\n"
         "?>\n"
         ,pszOutFile ? pszOutFile : "thisfile.php"
         ,pszOutFile ? pszOutFile : "thisfile.php"
         );
         break;

      case 10:
      chain.print(
         "<?php\n"
         "   // create a thumbnail image from a large image.\n"
         "   // requires the php command line interface:\n"
         "   // 1. get the php 5.x zip package\n"
         "   // 2. unzip into a dir like c:\\app\\php\n"
         "   // 3. set PATH=PATH;c:\\app\\php;c:\\app\\php\\ext\n"
         "   // then run this script by \"php %s in.jpg out.jpg\"\n"
         "\n"
         "   if ($argc < 3) {\n"
         "      print(\"usage: php %s input.jpg output.jpg [targetwidth quality]\\n\");\n"
         "      return;\n"
         "   }\n"
         "\n"
         "   $ssrc = $argv[1];\n"
         "   $sdst = $argv[2];\n"
         "   $wdst = isset($argv[3]) ? $argv[3] : 100;\n"
         "   $nqty = isset($argv[4]) ? $argv[4] :  80;\n"
         "\n"
         "   if (strstr($ssrc, \".jpg\"))\n"
         "      $isrc = ImageCreateFromJPEG($ssrc);\n"
         "   else\n"
         "      $isrc = ImageCreateFromPNG($ssrc);\n"
         "   if ($isrc === false) die(\"cannot load: $ssrc\");\n"
         "\n"
         "   $nsrcw = ImageSX($isrc);\n"
         "   $nsrch = ImageSY($isrc);\n"
         "   print(\"input: $ssrc with $nsrcw\".\"x$nsrch pixels\\n\");\n"
         "\n"
         "   $hdst  = intval($wdst * $nsrch / $nsrcw);\n"
         "   $idst  = ImageCreateTrueColor($wdst, $hdst);\n"
         "   if ($idst === false) die(\"cannot create thumb\");\n"
         "\n"
         "   imagecopyresampled($idst, $isrc, 0,0,0,0, $wdst,$hdst, $nsrcw, $nsrch);\n"
         "   imagejpeg($idst, $sdst, $nqty);\n"
         "   print(\"thumb: $sdst with $wdst\".\"x$hdst pixels, quality=$nqty\\n\");\n"
         "\n"
         "   imagedestroy($idst);\n"
         "   imagedestroy($isrc);\n"
         "?>\n"
         ,pszOutFile ? pszOutFile : "thisfile.php"
         ,pszOutFile ? pszOutFile : "thisfile.php"
         );
         break;

      case 11:
      chain.print(
         "<html>\n"
         " <head>\n"
         "  <title>Welcome to FooBar</title>\n"
         "   <style type=\"text/css\">\n"
         "      body     { font: 12px verdana,arial; }\n"
         "      table    { font: 12px verdana,arial; }\n"
         "      h1       { font: 16px verdana,arial; font-weight: bold; }\n"
         "      b.red    { color: #ee6622; }\n"
         "   </style>\n"
         "   <script type=\"text/javascript\">\n"
         "      function hello() {\n"
         "         document.write(\"hello from JavaScript.\");\n"
         "      }\n"
         "   </script>\n"
         " </head>\n"
         "<body leftmargin=\"0\" topmargin=\"0\" marginwidth=\"0\" marginheight=\"0\">\n"
         "\n"
         "<table width=\"980\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\" border=\"0\">\n"
         "\n"
         " <tr>\n"
         "  <td width=\"120\" align=\"center\" valign=\"middle\">\n"
         "  &nbsp;<br>\n"
         "  home\n"
         "  </td>\n"
         "  <td width=\"740\" align=\"center\" valign=\"top\">\n"
         "  &nbsp;<br>\n"
         "  <h1>Welcome to FooBar.</h1>\n"
         "  </td>\n"
         "  <td width=\"120\" align=\"center\" valign=\"middle\">\n"
         "  &nbsp;<br>\n"
         "  other\n"
         "  </td>\n"
         " </tr>\n"
         "\n"
         " <tr>\n"
         "  <td align=\"center\" valign=\"top\">&nbsp;</td>\n"
         "  <td>\n"
         "      <b class=\"red\">bold</b> and normal text.\n"
         "      <p>\n"
         "      <script type=\"text/javascript\">\n"
         "         hello();\n"
         "      </script>\n"
         "  </td>\n"
         "  <td align=\"center\" valign=\"top\">&nbsp;</td>\n"
         " </tr>\n"
         "\n"
         "</table>\n"
         "\n"
         "</body>\n"
         "</html>\n"
         );
         break;

      case 12:
      chain.print(
         "@rem <?php print(\"\\r\"); /*\n"
         "@echo off\n"
         "\n"
         "IF \"%%1\"==\"\" GOTO xerr01\n"
         "\n"
         "sfk script %s -from begin %%*\n"
         "GOTO xend\n"
         "\n"
         ":xerr01\n"
         "sfk echo \"[green]jpeg image size lister.[def]\"\n"
         "sfk echo \"lists width, height of all .jpg in a dir.\"\n"
         "sfk echo \"usage: %s dirname\"\n"
         "GOTO xend\n"
         "\n"
         "   // this script requires the php command line interface:\n"
         "   // 1. get the php 5.x zip package\n"
         "   // 2. unzip into a dir like c:\\app\\php\n"
         "   // 3. set PATH=PATH;c:\\app\\php;c:\\app\\php\\ext\n"
         "\n"
         "   // ----- begin of sfk script code -----\n"
         "\n"
         "sfk label begin\n"
         "\n"
         "   +sel %%1 .jpg\n"
         "\n"
         "   +run -quiet -yes \"php %s $file\"\n"
         "\n"
         "   +end\n"
         "\n"
         "*/ // ----- end of sfk, begin of php script -----\n"
         "\n"
         "   // print the width and height in pixel\n"
         "   // of the supplied image file name:\n"
         "\n"
         "   $asize = getimagesize($argv[1]);\n"
         "   printf(\"w=%%04d h=%%04d %%s\\n\", $asize[0], $asize[1], $argv[1]);\n"
         "\n"
         "/* // ----- end of php script, end of batch -----\n"
         ":xend\n"
         "@rem */ ?>\n"
         ,pszOutFile ? pszOutFile : "thisfile.bat"
         ,pszOutFile ? pszOutFile : "thisfile.bat"
         ,pszOutFile ? pszOutFile : "thisfile.bat"
         );
         break;

      case 13:
      chain.print(
         "import java.io.*;\n"
         "\n"
         "public class %s\n"
         "{\n"
         "    static void log(String s) { System.out.println(s); }\n"
         "\n"
         "    // convert a single byte record into a hexdump record.\n"
         "    // by default, set nrec to 16, and ndoff to 0.\n"
         "    public static String hexRecord(byte ab[], int noffset, int nlen, int nrec, int ndoff)\n"
         "    {\n"
         "        // create hex and text representation\n"
         "        StringBuffer sline = new StringBuffer();\n"
         "        StringBuffer stext = new StringBuffer();\n"
         "        for (int i=0; i<nlen; i++) {\n"
         "            int nval = ab[noffset+i] & 0xFF;\n"
         "            if (nval < 0x10) sline.append(\"0\");\n"
         "            sline.append(Integer.toString(nval, 0x10));\n"
         "            sline.append(\" \");\n"
         "            if (Character.isLetter(nval))\n"
         "                stext.append((char)nval);\n"
         "            else\n"
         "                stext.append('.');\n"
         "        }\n"
         "        // fill rest of line, if any\n"
         "        int npadlen = nrec;\n"
         "        while (stext.length() < npadlen) stext.append(' ');\n"
         "        npadlen *= 3;\n"
         "        while (sline.length() < npadlen) sline.append(' ');\n"
         "        sline.setLength(sline.length()-1);\n"
         "        // create offset as hex value\n"
         "        String soffset = \"\";\n"
         "        soffset = Integer.toString(ndoff, 0x10).toUpperCase();\n"
         "        while (soffset.length() < 10) soffset = \"0\"+soffset;\n"
         "        // combine hex, text and offset\n"
         "        return \">\"+sline.toString().toUpperCase()+\"< \"+stext+\" \"+soffset;\n"
         "    }\n"
         "    \n"
         "    // hexdump a whole byte array, from a given offset.\n"
         "    // nrec is the number of bytes per output record, use 16 by default.\n"
         "    // ndosv is the display offset start value, use 0 by default.\n"
         "    public static void hexDump(byte ab[], int noffset, int nlen, int nrec, int ndoff)\n"
         "    {\n"
         "        while (nlen > 0) {\n"
         "            int nblock  = (nlen < nrec) ? nlen : nrec;\n"
         "            String srec = hexRecord(ab, noffset, nblock, nrec, ndoff);\n"
         "            System.out.println(srec);\n"
         "            noffset += nblock;\n"
         "            ndoff   += nblock;\n"
         "            nlen    -= nblock;\n"
         "        }\n"
         "    }\n"
         "\n"
         "    // hex dump a whole binary file's content\n"
         "    public static void main(String args[]) throws Throwable\n"
         "    {\n"
         "        if (args.length < 1)\n"
         "            { log(\"usage: java %s inputfilename\"); return; }\n"
         "\n"
         "        byte abBuf[] = new byte[1600];\n"
         "\n"
         "        FileInputStream oin = new FileInputStream(args[0]);\n"
         "\n"
         "        int nread  = 0;\n"
         "        int ntotal = 0;\n"
         "        do {\n"
         "            nread = oin.read(abBuf, 0, abBuf.length);\n"
         "            if (nread > 0) hexDump(abBuf, 0, nread, 16, ntotal);\n"
         "            ntotal += nread;\n"
         "        }   while (nread > 0);\n"
         "\n"
         "        oin.close();\n"
         "    }\n"
         "}\n"
          ,pszClassName,pszClassName
        );
         break;

      case 14:
      chain.print(
         "\n"
         "import java.awt.*;\n"
         "import java.awt.event.*;\n"
         "import java.io.*;\n"
         "import javax.swing.*;\n"
         "import java.util.*;\n"
         "\n"
         "// can be run both as an applet and a command line application\n"
         "public class %s extends JApplet implements ActionListener\n"
         "{\n"
         "    // a panel to collect all objects for display\n"
         "    Container clPane = null;\n"
         "\n"
         "    // a hashmap to collect the same objects for retrieval by an id\n"
         "    HashMap<String,Component> clComp = new HashMap<String,Component>();\n"
         "    // HashMap clComp = new HashMap(); // for JDK 1.4.2\n"
         "\n"
         "    // the current add position\n"
         "    int xadd = 0, yadd = 0;\n"
         "\n"
         "    // set component placement cursor to a position\n"
         "    void setPos(int x,int y) { xadd=x; yadd=y; }\n"
         "    \n"
         "    // add and remember a generic component for display.\n"
         "    // steps the placement cursor w pixels to the right.\n"
         "    void add(int x,int y,int w,int h,String id,Component o) {\n"
         "        o.setBounds(x,y,w,h);   // set absolute position of object\n"
         "        clPane.add(o);          // add to panel to display object\n"
         "        clComp.put(id, o);      // and remember object in a hashmap\n"
         "        xadd += w;              // step add position horizontally\n"
         "    }\n"
         "    \n"
         "    // add a non-editable text label\n"
         "    void addLabel(int w, int h, String id, String text)\n"
         "        { add(xadd,yadd,w,h, id, new JLabel(text)); }\n"
         "\n"
         "    // add a single line editable text field    \n"
         "    void addTextField(int w, int h, String id, String text)\n"
         "        { add(xadd,yadd,w,h, id, new JTextField(text)); }\n"
         "\n"
         "    // add a multi linex editable text area\n"
         "    void addTextArea(int w, int h, String id, String text) {\n"
         "        JTextArea   oarea   = new JTextArea(text);\n"
         "        JScrollPane oscroll = new JScrollPane(oarea);\n"
         "        oscroll.setBounds(xadd,yadd,w,h);\n"
         "        clPane.add(oscroll);\n"
         "        clComp.put(id,oarea);\n"
         "    }\n"
         "\n"
         "    // add a push button\n"
         "    void addButton(int w, int h, String id, String text) {\n"
         "        JButton o = new JButton(text);\n"
         "        o.addActionListener(this);\n"
         "        add(xadd,yadd,w,h, id, o);\n"
         "    }\n"
         "\n"
         "    // easy access to any object by its id\n"
         "    JTextField getTextField(String id) { return (JTextField)clComp.get(id); }\n"
         "    JTextArea  getTextArea (String id) { return (JTextArea )clComp.get(id); }\n"
         "    JLabel     getLabel    (String id) { return (JLabel    )clComp.get(id); }\n"
         "\n"
         "    // setup visible objects at absolute positions\n"
         "    private void fillPane() \n"
         "    {        \n"
         "        clPane.setLayout(null); // absolute positioning layout\n"
         "        \n"
         "        setPos      ( 20, 20);\n"
         "        addLabel    ( 70, 20, \"lname\", \"filename\");\n"
         "        addTextField(620, 20, \"tname\", \"c:\\\\test.txt\");\n"
         "\n"
         "        setPos      ( 90, yadd + 30);\n"
         "        addButton   (620, 20, \"bload\", \"load\");\n"
         "\n"
         "        setPos      ( 20, yadd + 30);\n"
         "        addLabel    ( 70, 20, \"lcont\", \"content\");\n"
         "        addTextArea (620,400, \"acont\", \"\");\n"
         "    }\n"
         "\n"
         ,pszClassName);
    chain.print(
         "    // process push button command    \n"
         "    public void actionPerformed(ActionEvent e) \n"
         "    {\n"
         "        String sout = \"\";\n"
         "        try {\n"
         "            String scmd = e.getActionCommand();\n"
         "            if (scmd.equals(\"load\")) \n"
         "            {\n"
         "                String sFilename = getTextField(\"tname\").getText();\n"
         "                BufferedReader rin = new BufferedReader(\n"
         "                    new InputStreamReader(new FileInputStream(sFilename), \"ISO-8859-1\"));\n"
         "                while (true) {\n"
         "                    String sline = rin.readLine();\n"
         "                    if (sline == null) break; // EOD\n"
         "                    sout += sline + \"\\n\";\n"
         "                }\n"
         "                rin.close();\n"
         "            }\n"
         "        } catch (Throwable t) {\n"
         "            sout = \"\"+t;\n"
         "        }\n"
         "        getTextArea(\"acont\").setText(sout);\n"
         "    }\n"
         "\n"
         "    // to run it from the command line:\n"
         "    public static void main(String[] args)\n"
         "        { new %s().main2(args); }\n"
         "\n"
         "    public void main2(String[] args) {\n"
         "        JFrame frame = new JFrame(\"Simple File Viewer\");\n"
         "        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n"
         "        clPane = frame.getContentPane();\n"
         "        fillPane();\n"
         "        frame.setSize(760, 560);\n"
         "        frame.setVisible(true);\n"
         "    }\n"
         "\n"
         "    // to run it as an applet:\n"
         "  public void init() {\n"
         "     clPane = new JPanel();\n"
         "     this.setContentPane(clPane);\n"
         "     fillPane();\n"
         "  }\n"
         "    /*\n"
         "       create a page \"show.html\" containing\n"
         "\n"
         "       <html><body>\n"
         "          <Applet Code=\"%s.class\" width=800 height=600></Applet>\n"
         "       </body></html>\n"
         "      \n"
         "       and then type \"appletviewer show.html\"\n"
         "    */\n"
         "}\n"
          ,pszClassName,pszClassName
        );
        break;

      case 15:
      chain.printFile(
"myext@mydomain.org\\chrome\\content\\myext.xul", bWriteFile,
"<overlay id=\"myextOverlay\" xmlns=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\">\n"
"   <script type=\"application/x-javascript\" src=\"chrome://myext/content/myextOverlay.js\"/>\n"
"   <popup id=\"contentAreaContextMenu\">\n"
"      <menuitem id=\"myext-sayhello\" label=\"Say Hello\" oncommand=\"sayHello(event);\" />\n"
"   </popup>\n"
"</overlay>\n"
         );
      chain.printFile(
"myext@mydomain.org\\chrome\\content\\myextOverlay.js", bWriteFile,
"function sayHello(event) {\n"
"   alert(\"hello.\");\n"
"}\n"
         );
      chain.printFile(
"myext@mydomain.org\\chrome.manifest", bWriteFile,
"content myext chrome/content/\n"
"overlay chrome://browser/content/browser.xul chrome://myext/content/myext.xul\n"
         );
      chain.printFile(
"myext@mydomain.org\\install.rdf", bWriteFile,
"<?xml version=\"1.0\"?>\n"
"<RDF xmlns=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n"
"     xmlns:em=\"http://www.mozilla.org/2004/em-rdf#\">\n"
"  <Description about=\"urn:mozilla:install-manifest\">\n"
"    <em:id>myext@mydomain.org</em:id>\n"
"    <em:version>0.1.0</em:version>\n"
"    <em:type>2</em:type>\n"
"    <em:targetApplication>\n"
"      <Description>\n"
"        <em:id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</em:id> <!-- Firefox -->\n"
"        <em:minVersion>1.0</em:minVersion>\n"
"        <em:maxVersion>3.0.*</em:maxVersion>\n"
"      </Description>\n"
"    </em:targetApplication>\n"
"    <em:name>MyExt</em:name>\n"
"    <em:description>A very simple demo extension</em:description>\n"
"    <em:creator>My Self</em:creator>\n"
"    <em:homepageURL>http://mydomain.org/myext/</em:homepageURL>\n"
"  </Description>      \n"
"</RDF>\n"
         );
         break;
         
      case 16:
      chain.print(
          "/*\n"
          "   Example for sending UDP color text in C++.\n"
          "   For more details read \"sfk netlog\".\n"
          "\n"
          "   Compile like:\n"
          "      Windows gcc : g++ %s -lws2_32\n"
          "      Windows VC  : cl  %s ws2_32.lib\n"
          "      Linux/Mac   : g++ %s\n"
          "*/\n"
          "\n"
          "#include <stdio.h>\n"
          "#include <stdlib.h>\n"
          "#include <string.h>\n"
          "#include <stdarg.h>\n"
          "#include <errno.h>\n"
          "\n"
          "#ifdef _WIN32\n"
          "  #include <windows.h>\n"
          "  #ifdef _MSC_VER\n"
          "    #define snprintf  _snprintf \n"
          "    #define vsnprintf _vsnprintf \n"
          "    #define sockerrno WSAGetLastError()\n"
          "  #else\n"
          "    #include <ws2tcpip.h>\n"
          "    #define sockerrno errno\n"
          "  #endif\n"
          "  #define socklen_t int\n"
          "#else\n"
          "  #include <sys/socket.h>\n"
          "  #include <netdb.h>\n"
          "  #ifdef __APPLE__\n"
          "    #define SOL_IP IPPROTO_IP\n"
          "  #endif\n"
          "  #ifndef INVALID_SOCKET\n"
          "    #define INVALID_SOCKET -1\n"
          "  #endif\n"
          "  #define sockerrno errno\n"
          "#endif\n"
          "\n"
          "char szLineBuf[500];\n"
          "\n"
          "int iNetSock = INVALID_SOCKET;\n"
          "int iRequest = 1;\n"
          "struct sockaddr_in oAddr;\n"
          "socklen_t iAddrLen = sizeof(oAddr);\n"
          "\n"
          "int perr(const char *pszFormat, ...)\n"
          "{\n"
          "   va_list argList;\n"
          "   va_start(argList, pszFormat);\n"
          "   vsnprintf(szLineBuf, sizeof(szLineBuf)-10, pszFormat, argList);\n"
          "   szLineBuf[sizeof(szLineBuf)-10] = '\\0';\n"
          "   printf(\"Error: %s\\n\", szLineBuf);\n"
          "   return 0;\n"
          "}\n"
          "\n"
          "int netlog(const char *pszFormat, ...)\n"
          "{\n"
          "   char szHeadBuf[100];\n"
          "   int  iHeadLen = 0;\n"
          "\n"
          "   va_list argList;\n"
          "   va_start(argList, pszFormat);\n"
          "   vsnprintf(szLineBuf+100, sizeof(szLineBuf)-110, pszFormat, argList);\n"
          "   szLineBuf[sizeof(szLineBuf)-10] = '\\0';\n"
          "   \n"
          "   // change all [red] to compact color codes \\x1Fr\n"
          "   for (char *psz=szLineBuf+100; *psz; psz++)\n"
          "      if (psz[0]=='[')\n"
          "         for (int i=1; psz[i]; i++)\n"
          "            if (i>=2 && psz[i]==']')\n"
          "               { psz[0]=0x1F; memmove(psz+2, psz+i+1, strlen(psz+i+1)+1); break; }\n"
          "\n"
          "   // add sfktxt header before text\n"
          "   snprintf(szHeadBuf, sizeof(szHeadBuf)-10, \":sfktxt:v100,req%s,cs1\\n\\n\", iRequest++);\n"
          "   iHeadLen = strlen(szHeadBuf);\n"
          "   char *pData = szLineBuf+100-iHeadLen;\n"
          "   memcpy(pData, szHeadBuf, iHeadLen);\n"
          "\n"
          "   sendto(iNetSock, pData, strlen(pData), 0, (struct sockaddr *)&oAddr, iAddrLen);\n"
          "\n"
          "   return 0;\n"
          "}\n"
          "\n"
          "int main(int argc, char *argv[])\n"
          "{\n"
          "   const char *pszHost = \"localhost\";\n"
          "   unsigned short iPort = 21323;\n"
          "   \n"
          "   #ifdef _MSC_VER\n"
          "   WORD wVersionRequested = MAKEWORD(1,1);\n"
          "   WSADATA wsaData;\n"
          "   if (WSAStartup(wVersionRequested, &wsaData)!=0)\n"
          "      return 9+perr(\"WSAStartup failed\");\n"
          "   #endif\n"
          "\n"
          "   memset((char *)&oAddr, 0,sizeof(oAddr));\n"
          "   oAddr.sin_family      = AF_INET;\n"
          "   oAddr.sin_port        = htons(iPort);\n"
          "\n"
          "   struct hostent *pHost = gethostbyname(pszHost);\n"
          "   memcpy(&oAddr.sin_addr.s_addr, pHost->h_addr, pHost->h_length);\n"
          "\n"
          "   if ((iNetSock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n"
          "      return 9+perr(\"cannot create socket\");\n"
          "\n"
          "   netlog(\"[Red]Foo[def] and [Blue]bar[def] went to the [Green]zoo[def].\\n\");\n"
          "   \n"
          "   return 0;\n"
          "}\n"
          "\n"
          , pszOutFile ? pszOutFile : "netlog.cpp"
          , pszOutFile ? pszOutFile : "netlog.cpp"
          , pszOutFile ? pszOutFile : "netlog.cpp"
          , "%s" // literally
          , "%d" // literally
         );
         if (!pszOutFile)
            printf("// to write .cpp file use:\n"
                   "// sfk samp cppnetlog netlog.cpp\n");
         break;
      
      case 17:
      if (!pszOutFile) pszClassName = str("netlog");
      chain.print(
          "/*\n"
          "   Example for sending UDP color text in Java.\n"
          "   For more details read \"sfk netlog\".\n"
          "*/\n"
          "\n"
          "import java.io.*;\n"
          "import java.net.*;\n"
          "\n"
          "public class %s\n"
          "{\n"
          "   public static DatagramSocket clSocket = null;\n"
          "   public static InetAddress clAddress = null;\n"
          "   public static int iClPort = -1;\n"
          "   static int iClRequest = 1;\n"
          "\n"
          "   public static void init(String sHost, int iPort) throws Throwable\n"
          "   {\n"
          "      clAddress = InetAddress.getByName(sHost);\n"
          "      iClPort = iPort;\n"
          "      clSocket = new DatagramSocket();\n"
          "   }\n"
          "\n"
          "   public static void log(String sTextIn) throws Throwable\n"
          "   {\n"
          "      String sText   = sTextIn+\"\\n\";\n"
          "\n"
          "      // change all [red] to compact color codes \\x1Fr\n"
          "      byte[] abData1 = sText.getBytes();\n"
          "      int    iSize1  = abData1.length;\n"
          "      byte[] abData2 = new byte[iSize1+100];\n"
          "\n"
          "      // keep 100 bytes space for header\n"
          "      int i2=100;\n"
          "      for (int i1=0; i1<iSize1;)\n"
          "      {\n"
          "         if (abData1[i1]=='[') {\n"
          "            i1++;\n"
          "            if (i1>=iSize1)\n"
          "               break;\n"
          "            abData2[i2++] = (byte)0x1F;\n"
          "            abData2[i2++] = abData1[i1++];\n"
          "            while (i1<iSize1 && abData1[i1]!=']')\n"
          "               i1++;\n"
          "            if (i1<iSize1)\n"
          "               i1++;\n"
          "         } else {\n"
          "            abData2[i2++] = abData1[i1++];\n"
          "         }\n"
          "      }\n"
          "      int iTextSize = i2-100;\n"
          "\n"
          "      // add sfktxt header before text\n"
          "      String sHead = \":sfktxt:v100,req\"+iClRequest+\",cs1\\n\\n\";\n"
          "      iClRequest++;\n"
          "      byte abHead[] = sHead.getBytes();\n"
          "      int iHeadLen  = abHead.length;\n"
          "      for (int i=0; i<iHeadLen; i++)\n"
          "         abData2[100-iHeadLen+i] = abHead[i];\n"
          "      int iStartOff = 100-iHeadLen;\n"
          "      int iFullSize = iHeadLen+iTextSize;\n"
          "\n"
          "      DatagramPacket packet = new DatagramPacket(abData2, iStartOff, iFullSize, clAddress, iClPort);\n"
          "      clSocket.send(packet);\n"
          "   }\n"
          "\n"
          "   public static void main(String args[]) throws Throwable\n"
          "   {\n"
          "      %s.init(\"localhost\", 21323);\n"
          "      %s.log(\"[Red]Foo[def] and [Blue]bar[def] went to the [Green]zoo[def].\");\n"
          "   }\n"
          "}\n"
          "\n"
          , pszClassName
          , pszClassName
          , pszClassName
          );
         if (!pszOutFile)
            printf("// to write .java file use:\n"
                   "// sfk samp javanetlog netlog.java\n");
         break;      
      }
      
      // sfk filt src -rep "_%_%%_" -srep "_\\_\\\\_" -srep "_\q_\\\q_" -sform "         \q$col1\\n\q" +toclip

      if (cs.outfile) {
         fclose(cs.outfile);
         cs.outfile = 0;
         if (!bLocalFile)
            printf("written: %s\n", pszOutFile);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "memerrtest"))
   {
      char *p = new char[1024];
      (void)p;
      // fall through, expect mem leak message
      bDone=1;
   }

   if (!strcmp(pszCmd, "keytest")) 
   {
      StringMap omap;
      int i=0;
      for (i=0; i<1000; i++) 
      {
         char szKey[100];
         char szVal[100];
         sprintf(szKey, "key_%03d", (int)(rand() % 1000));
         sprintf(szVal, "val_%03d", (int)(rand() % 1000));
         if (omap.put(szKey, szVal))
            return 9+perr("fail.1");
      }

      printf("%d entries in keymap\n", omap.size());

      for (i=0; i<omap.size(); i++) {
         char *pkey = 0;
         char *pval = omap.iget(i, &pkey);
         printf("%s %s\n",pkey,pval);
      }

      bDone=1;
   }

   if (!strcmp(pszCmd, "zipdump")) 
   {
      if (nparm < 1) return -1;

      cs.travelzips = 1;

      // ZipReader ozip;
      // ozip.list(argv[2]);
      // ozip.dump(argv[2], argv[3]);

      Coi ozip(argv[2], 0);
      if (!ozip.isTravelDir())
         {  perr("no directory: %s",argv[2]); return 9; }

      if (ozip.openDir())
         {  perr("cannot open"); return 9; }

      for (Coi *psub=0; (psub=ozip.nextEntry());) 
      {
         // psub is owned by caller!
         printf("entry: %s dir=%d size=%d time=%u\n", psub->name(), psub->isTravelDir(), (int)psub->getSize(), (int)psub->getTime());
         if (!psub->isTravelDir()) {
            int nrc = psub->open("rb");
            if (nrc) {
               printf("   ... open rc %d\n", nrc);
            } else {
               char abtmp[1024];
               int nread = psub->readLine(abtmp, 100);
               if (nread >= 4) {
                  execHexdump(0, (uchar*)abtmp, nread);
               } else {
                  printf("   ... nread %d\n", nread);
               }
               psub->close();
            }
         }
         delete psub;
      }

      ozip.closeDir();

      bDone = 1;
   }

   if (!strcmp(pszCmd, "match")) {
      if (argc < 4) return 9;
      char *phay = argv[2];
      char *ppat = argv[3];
      int nlen  = strlen(phay);
      memset(szAttrBuf, ' ', nlen);
      szAttrBuf[nlen] = '\0';
      int ifirst=0, ilen=0;
      if (matchstr(phay, ppat, 5, ifirst, ilen)) {
         if (ifirst+ilen < MAX_LINE_LEN)
            memset(szAttrBuf+ifirst, 'i', ilen);
         printColorText(phay, szAttrBuf);
      } else {
         printf("no hit\n");
      }
      bDone = 1;
   }

   if (!strcmp(pszCmd, "errortest"))
   {
      if (nparm < 1) {
      printx("<help>$sfk [options] errortest mask\n"
             "\n"
             "   produces test error(s), showing return codes.\n"
             "   this command implies -showrc.\n"
             "\n"
             "   $mask\n"
             "   may contain one or more characters to select\n"
             "   a test case from:\n"
             "\n"
             "      n   normal file processing (no error).\n"
             "      e   produce a syntax error.\n"
             "      w   produce a general warning.\n"
             "      f   simulate (skipped) unreadable file.\n"
             "      m   simulate out of memory.\n"
             "      l   simulate general error with low rc.\n"
             "\n"
             "   $options\n"
             "      -rcfromerr   on skipped errors, pass rc to shell.\n"
             "      -stoponerr   stop on first unreadable file.\n"
             "\n"
             "   $example\n"
             "      #sfk -rcfromerr errortest nnnfnn\n"
             "         simulates five successful and one erroneous file\n"
             "         processings, changing the shell rc on any errors.\n"
             );
      return 9;
      }

      char *pmask = str("");
      gs.showrc   = 1;

      for (; iDir<argc; iDir++) 
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unexpected: %s\n", argv[iDir]);
         }
         pmask = argv[iDir];
      }

      bool bstop = 0;
      while (!bstop && *pmask)
      {
         switch (*pmask++)
         {
            case 'n':
            {
               int nFuncRC = 0;
               printf("file processed, ");
               bstop = cs.stopTree(nFuncRC);
               printf("processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%d)\n",bstop,nFuncRC);
               break;
            }
            case 'e': lRC = 9+perr("syntax test error"); break;
            case 'w': lRC = 5+pwarn("general test warning"); break;
            case 'f':
            {
               int nFuncRC = 9+perr("file unreadable.\n");
               bstop = cs.stopTree(nFuncRC);
               printf("   processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%d)\n",bstop,nFuncRC);
               break;
            }
            case 'm':
            {
               int nFuncRC = 19+perr("out of memory.\n");
               bstop = cs.stopTree(nFuncRC);
               printf("   processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%d)\n",bstop,nFuncRC);
               break;
            }
            case 'l':
            {
               int nFuncRC = 5+perr("non-fatal fn error.\n");
               bstop = cs.stopTree(nFuncRC);
               printf("   processing %s.\n",bstop?"stopped":"continued");
               if (cs.debug) printf("%d=stopTree(%d)\n",bstop,nFuncRC);
               break;
            }
         }
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "cat")) 
   {
      if (!chain.usefiles && (nparm < 1)) {
      printx("<help>$sfk cat filename\n"
             "\n"
             "   dump content of a text file.\n"
             );
      return 9;
      }

      char *pfile = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (pfile)
            return 9+perr("unexpected: %s\n", argv[iDir]);
         pfile = argv[iDir];
      }
      if (!pfile) return 9+perr("missing filename.");

      Coi *pcoi = new Coi(pfile, 0);
      pcoi->incref("main");

      uchar *pdata = 0; // managed by COI!
      num    nsize = 0;
      if (pcoi->getContent(&pdata, nsize))
         perr("cannot get content of: %s", pcoi->name());
      else {
         // dump text content, line by line.
         char *psz1 = (char*)pdata;
         while (*psz1) {
            char *psz2 = psz1;
            while (*psz2 && *psz2 != '\n') psz2++;
            int nlen = psz2 - psz1;
            chain.print("%.*s\n", (int)nlen, psz1);
            if (*psz2) psz2++;
            psz1 = psz2;
         }
      }

      if (!pcoi->decref())
         delete pcoi; // no refs remaining, not cached

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   if (!strcmp(pszCmd, "tcping")) 
   {
      if (!chain.usefiles && (nparm < 1)) {
      printx("<help>$sfk tcping host:port [options]\n"
             "\n"
             "   check if a host accepts tcp/ip connections\n"
             "\n"
             "   $options\n"
             "      -loop     retry endlessly until connect\n"
             "      -delay=n  delay seconds between tries\n"
             "\n"
             "   $examples\n"
             "      #sfk tcping myhost:80 -loop\n"
             "         try to connect until service is available\n"
             );
      return 9;
      }

      char *phostport = 0;
      bool bloop      = 0;
      int ndelay     = 1000;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-delay", &pszParm)) {
            if (!pszParm) return 9;
            ndelay = atol(pszParm) * 1000;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-loop")) {
            bloop = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!phostport) {
            phostport = argv[iDir];
            continue;
         }
         return 9+perr("unexpected parameter: %s\n", argv[iDir]);
      }

      if (!phostport)
         return 9+perr("missing host:port\n");

      int nPort = 80;

      char szHost[200];
      strcopy(szHost, phostport);
      char *psz1 = strchr(szHost, ':');
      if (psz1) {
         *psz1++ = '\0';
         nPort = atol(psz1);
      }

      SOCKET hSock = 0;

      prepareTCP();
   
      struct hostent *pTarget;
      struct sockaddr_in sock;
      hSock = socket(AF_INET, SOCK_STREAM, 0);
      if (hSock == INVALID_SOCKET) return 9+perr("cannot create socket\n");
   
      if ((pTarget = sfkhostbyname(szHost)) == NULL)
         return 9+perr("cannot get host\n");
   
      memcpy(&sock.sin_addr.s_addr, pTarget->h_addr, pTarget->h_length);
      sock.sin_family = AF_INET;
      sock.sin_port = htons((unsigned short)nPort);

      // TODO: set shorter connection timeout

      int ncnt = 1;
      while (!userInterrupt())
      {
         if (connect(hSock, (struct sockaddr *)&sock, sizeof(sock)) != -1)
            break; // success

         if (bloop) {
            printf("not yet available, retrying (%d)   \r",ncnt++);
            fflush(stdout);
            doSleep(ndelay);
         } else {
            perr("cannot connect to %s:%u, %s\n", szHost, nPort, netErrStr());
            return 9;
         }
      }

      printf("connected.                              \n");

      closesocket(hSock);
   
      #ifdef _WIN32
      WSACleanup();
      #endif

      bDone = 1;
   }

   if (!strcmp(pszCmd, "cmptime")) 
   {
      if (nparm < 2) return 9;
      char *pszFile1 = argv[iDir+0];
      char *pszFile2 = argv[iDir+1];
      FileStat fs1; if (fs1.readFrom(pszFile1)) return 9+perr("1");
      FileStat fs2; if (fs2.readFrom(pszFile2)) return 9+perr("2");

      cs.verbose = 9;
      bool bSrcIsOlder = 0;
      int nrc = fs1.differs(fs2, 1, &bSrcIsOlder);
      printf("rc %d srcio %d\n",nrc,bSrcIsOlder);

      bDone = 1;
   }

   #ifndef _WIN32
   if (!strcmp(pszCmd, "tellnode")) 
   {
      if (nparm < 1) return 9;
      char *pszFile = argv[iDir];

      struct stat64 buf;
      if (stat64(pszFile, &buf)) return 9;
      num nnode = (num)buf.st_ino;
      printf("%s (%u) %s\n", numtohex(nnode,16),(uint)nnode,pszFile);

      bDone = 1;
   }
   #endif

   ifcmd (!strcmp(pszCmd, "script") || !strcmp(pszCmd, "fscript"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk [f]script [opts] file [-from=label] [parm1] [parm2] [...]\n"
             "\n"
             "   execute sfk command(s) from a script file, which can be\n"
             "   -  an absolute filename, e.g. C:\\scripts\\thescript.txt\n"
             "   -  a relative filename. in this case, the file is searched\n"
             "      in the current dir \".\" first, and then in the PATH.\n"
             "\n"
             "   $parameters:\n"
             "   -  if \"-from=label\" is given, the script file is searched\n"
             "      for a statement \"label mylabel\", and script execution runs\n"
             "      from this point until +end is reached.\n"
             "\n"
             "   -  all other words after -from, or instead of from, are passed\n"
             "      as parameters to the script, with one exception:\n"
             "      a word starting with a \"+\" continues the sfk command chain.\n"
             "      if you need to pass words starting with \"+\" to the script,\n"
             "      set option -literal (disallowing further chain commands).\n"
             "\n"
             "   $command chaining:\n"
             "      with ...  +script name, text data is passed to the script.\n"
             "      with ... +fscript name, filenames are passed to the script.\n"
             "\n"
             "   $script file syntax:\n"
             "      - lines having // as first text are ignored.\n"
             "      - command line parameters 1 to 9 can be addressed both\n"
             "        by expressions %%1 to %%9, or $$1 to $$9.\n"
             "      - any whitespace is skipped unless surrounded by quotes \"\n"
             "      - escaped quotes \\\" are changed into normal quotes \"\n"
             "      - line ends are ignored. in general, lines are combined\n"
             "        into one large command chain, just like typing them all\n"
             "        into one line of unlimited length.\n"
             "      - character ## at column 1 of any line is skipped, which\n"
             "        allows bash-embedded scripts to have sfk statements\n"
             "        outcommented if necessary.\n"
             "\n"
             "      $parameter name collisions:\n"
             "        if your script contains phrases like\n"
             "           #+filter -form \"$$10.10col1 ...\"\n"
             "        then \"$$1\" will be misinterpreted as an input parameter\n"
             "        into the script. to get around this problem, redefine the\n"
             "        parameter name prefix at the script's \"sfk label\" line.\n"
             "        type \"sfk label\" for more on that.\n"
             "\n"
             "   $options:\n"
             "      -verbose  tell in detail which words are used from script.\n"
             "      -literal  also pass words to the script that start with \"+\".\n"
          // "\n"
          // "   $setting global options for all commands within a script:\n"
          // "      supply them directly after \"sfk\" of the calling command:\n"
          // "      #sfk -yes script myscript.txt -from=mylabel\n"
          // "         runs myscript.txt with -yes active for every command.\n"
             "\n"
             "   $for script examples, type:\n"
             "      sfk samp sfk       - create sfk sample script\n"
             "      sfk samp sfkcmd    - sample script embedded in windows batch\n"
             "      sfk samp sfkbash   - sample script embedded in bash script\n"
             "      sfk samp           - more about the sfk sample syntax\n"
             "\n"
             "   $recommended use:\n"
             "      if you want to create an easy-to-use script on the fly,\n"
             "      1. create an embedded script in a batch file:\n"
             #ifdef _WIN32
             "         #sfk samp sfkcmd myscript.bat\n"
             #else
             "         #sfk samp sfkbash myscript.bat\n"
             #endif
             "      2. edit myscript.bat with any text editor.\n"
             "      3. run the script just by typing \"myscript.bat\".\n"
             );
      ehelp;

      char *pszScriptFile = 0;
      char *pszLabel      = 0;

      int  iChainNext =  0;
      int  iLocalParm = -1;
      int  nLocalParm =  0;
      int  nState     =  0;
      bool bliteral   =  0;

      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (nState < 2 && haveParmOption(argv, argc, iDir, "-from", &pszParm)) {
            if (!pszParm) return 9;
            pszLabel = pszParm;
            nState = 2;
            continue;
         }
         else
         if (nState < 1 && !strncmp(argv[iDir], "-", 1)) {
            // general options are interpreted only before script name,
            // i.e. as int as nState == 0.
            if (strBegins(argv[iDir], "-lit")) {
               bliteral = 1;
               continue;
            }
            else
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (!bliteral && isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszScriptFile) {
            pszScriptFile = argv[iDir];
            nState = 1;
         }
         else
         if (iLocalParm < 0) {
            iLocalParm = iDir;
            nLocalParm = 1;
            nState = 2;
         }
         else
            nLocalParm++;
      }

      if (!pszScriptFile) return 9+perr("missing script file name.");

      char *pszAbsScript = pszScriptFile;
      if (!fileExists(pszAbsScript) && !isAbsolutePath(pszAbsScript)) {
         pszAbsScript = findPathLocation(pszScriptFile, 0);
         if (!pszAbsScript) return 9+perr("%s not found in current dir or PATH.\n", pszScriptFile);
      }

      char *pScriptRaw = loadFile(pszAbsScript);
      if (!pScriptRaw)
         return 9+perr("failed to load script file: %s\n", pszAbsScript);

      // pScriptRaw is the original script data.
      // pScript will be stuffed with terminators
      // and therefore is not reusable.
      char *pScript = strdup(pScriptRaw);

      // auto delete all script data on return.
      CharAutoDel odel1(pScriptRaw);
      CharAutoDel odel2(pScript);

      // in case "call" is used inside script:
      CharAutoRestore oclear(&pGlblCurrentScript);
      pGlblCurrentScript = pScriptRaw;
      // on return, pGlbl will have its old value set.

      lRC = 0;

      // create temporary argv[] from script file
      StringTable oDynaStrings;
      char **psubargv = 0;
      int    nsubargc = 0;
      for (int npass=0; npass<2; npass++) 
      {
         char *psz1 = pScript;
         char  cold = 0; // old char before current one
         // jump to start label, if any.
         if (pszLabel) {
            sprintf(szLineBuf, "label %s", pszLabel);
            psz1 = strstr(pScript, szLineBuf);
            if (!psz1) {
               perr("label not found: %s\n", pszLabel);
               pinf("use \"sfk label %s +...\" to start with a label.\n", pszLabel);
               pinf("use \"sfk ... +label %s +...\" to insert a label.\n", pszLabel);
               lRC = 9;
               break;
            }
            // do NOT skip anything, let the chain
            // start with the "label" command.
            cold = '\0';
         }
         // main processing, until +end token.
         while (*psz1)
         {
            bool bnewline = 0;
            nextToken(&psz1, cold, bnewline);
            if (*psz1) 
            {
               // on next (non-blank) token
               char *ptok = psz1;
               if (bnewline && !strncmp(ptok, "//", 2)) {
                  // skip remark line
                  while (*ptok && *ptok != '\n') ptok++;
                  // do NOT skip lf, set newline on next cycle
                  psz1 = ptok;
                  continue;
               }

               // find end of token
               skipPastToken(&psz1, cold);
               int ntoklen = psz1 ? (psz1-ptok) : 0;

               int nrc = 0;
               if (npass && *psz1) {
                  cold = *psz1;   // e.g. lf will be overwritten
                  *psz1++ = '\0';
                  // post-process token: strip quotes, transform inner quotes,
                  // substitute parameters.
                  // uses: szLineBuf
                  nrc = postProcessToken(&ptok, oDynaStrings, argc, argv, iLocalParm, nLocalParm);
                  if (nrc >= 9) return 9+perr("unexpected format: \"%s\"\n", ptok);
                  // nrc==1 means skip EMPTY token.
               }

               // special first token "-prefix=..." ?
               // printf("tok %d: \"%s\"\n",nsubargc,ptok);
               if (!nrc && nsubargc<3 && strBegins(ptok, "-prefix=")) {
                  // give script input parameters a user-defined name
                  if (npass) { // not in prescan phase
                     strcopy(cs.paramprefix, ptok+8);
                  }
                  continue;
               }

               // count and register token
               if (!nrc) {
                  if (npass)
                     psubargv[nsubargc] = ptok;
                  nsubargc++;
               }

               // reached "+end"?
               if (ntoklen==4 && !strncmp(ptok, "+end", 4))
                  break;

            }  // endif *psz1

         }  // endwhile *psz1

         // at end of first pass, alloc token array
         if (!npass) {
            psubargv = new char*[nsubargc+10];
            nsubargc = 0;
         }
      }

      if (!lRC && (cs.verbose > 0)) {
         printf("loaded %d words from %s:\n   ", nsubargc, pszScriptFile);
         for (int i=0; i<nsubargc; i++)
            printf("%s,",psubargv[i]);
         printf("\n");
         // printf("iLocalParm %d nLocalParm %d\n",iLocalParm,nLocalParm);
      }

      if (!lRC) 
      {
         char *pszSubCmd = psubargv[0];
         int iSubDir = 1;
         // if chain starts like "sfk ...", skip "sfk":
         if (!strcmp(pszSubCmd, "sfk")) {
            pszSubCmd = psubargv[1];
            iSubDir = 2;
         }
         if (cs.verbose > 0)
            printf("  run from \"%s\" (index %d)\n", pszSubCmd, iSubDir);
         lRC = submain(nsubargc, psubargv, penv, pszSubCmd, iSubDir, bFatal);
      }

      if (psubargv) delete [] psubargv;
      oDynaStrings.resetEntries();

      // pScript is auto deleted.
      // pGlblCurrentScript is auto restored to old value,
      // in case that nested script commands are used.

      if (lRC >= 9) return lRC;

      bDone = 1;
   }

   // internal
   if (!strcmp(pszCmd, "num"))
   {
      if (nparm < 1)
         return 9+perr("missing parm");

      uint nBE = (uint)myatonum(argv[iDir]);
      uchar b0 = (uchar)((nBE >>  0) & 0xFFU);
      uchar b1 = (uchar)((nBE >>  8) & 0xFFU);
      uchar b2 = (uchar)((nBE >> 16) & 0xFFU);
      uchar b3 = (uchar)((nBE >> 24) & 0xFFU);

      uint nLE = 0;

      if (nBE < 65536U)
           nLE =     (((uint)b0) <<  8)
                  |  (((uint)b1) <<  0)
                  ;
      else
           nLE =     (((uint)b0) << 24)
                  |  (((uint)b1) << 16)
                  |  (((uint)b2) <<  8)
                  |  (((uint)b3) <<  0)
                  ;

      if (!isprint(b0)) b0 = '.';
      if (!isprint(b1)) b1 = '.';
      if (!isprint(b2)) b2 = '.';
      if (!isprint(b3)) b3 = '.';

      if (nBE < 65536U)
         printf("0x%04X=%u >%c%c< - 0x%04X=%u >%c%c<\n",
            nBE,nBE, b0,b1, nLE,nLE, b1,b0);
      else
         printf("0x%08X=%u >%c%c%c%c< - 0x%08X=%u >%c%c%c%c<\n",
            nBE,nBE, b0,b1,b2,b3, nLE,nLE, b3,b2,b1,b0);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "hex") || !strcmp(pszCmd, "dec"))
   {
      ifhelp (!chain.usedata && nparm < 1)
      printx("<help>$sfk hex value1 [value2] [...]\n"
             "$sfk dec value1 [value2] [...]\n"
             "$sfk ... +dec [+hex] -digits=n\n"
             "\n"
             "   convert numbers between decimal and hexadecimal.\n"
             "   largest convertable number is ((2 << 64) - 1).\n"
             "\n"
             "   $options:\n"
             "      -digits=n  format output numbers with n digits\n"
             "\n");
      webref(pszCmd);
      printx("   $examples:\n"
             "      #sfk hex 1048576 98765 234567\n"
             "         convert 3 decimal numbers.\n"
             "\n"
             "      #sfk filt csv.txt -ssep \"\\t\" -form \"$$col3\" +hex\n"
             "         convert 3rd column from csv.txt to hex.\n"
             );
      ehelp;

      bool btodec = !strcmp(pszCmd, "dec");

      int  iChainNext = 0;
      int  iVal       = iDir;
      int  iValMax    = iDir;
      int ndigits    = 1;

      for (; iDir<argc; iDir++)
      {
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-digits", &pszParm)) {
            if (!pszParm) return 9;
            ndigits = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               return 9+perr("unexpected option: %s\n", argv[iDir]);
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // skip number parms, maybe until a chain cmd
         iValMax = iDir;
      }

      if (chain.usedata) {
         // convert chain text
         for (int i=0; i<chain.indata->numberOfEntries(); i++) {
            szLineBuf[0]  = '\0';
            char *psz = chain.indata->getEntry(i, __LINE__);
            if (!psz) return 9+perr("int. #58282010");
            if (btodec) {
               // hex to dec
               num nval = hextonum(psz);
               numtoa(nval, ndigits, szLineBuf);
            } else {
               // dec to hex
               num nval = atonum(psz);
               numtohex(nval, ndigits, szLineBuf);
            }
            if (chain.coldata) {
               if (szLineBuf[0])
                  chain.addLine(szLineBuf, str(""));
            } else {
               printf("%s\n", szLineBuf);
            }
         }
      } else {
         // convert direct parameters
         nparm = (iValMax - iVal) + 1;
         for (; nparm > 0; nparm--) 
         {
            szLineBuf[0]  = '\0';
            char *psz = argv[iVal++];
            if (btodec) {
               // hex to dec
               num nval = hextonum(psz);
               numtoa(nval, ndigits, szLineBuf);
            } else {
               // dec to hex
               if (!isdigit(*psz))
                  return 9+perr("cannot convert to hex, not a number: %s", psz);
               num nval = atonum(psz);
               numtohex(nval, ndigits, szLineBuf);
            }
            if (chain.coldata) {
               if (nparm >= 2) strcat(szLineBuf, " ");
               chain.addToCurLine(szLineBuf, str(""));
            } else {
               printf("%s ", szLineBuf);
            }
         }
         if (!chain.coldata)
            printf("\n");
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "env"))
   {
      ifhelp (!chain.useany() && (nparm < 1))
      printx("<help>$sfk env [-all] [word] [word2] [...] +...\n"
             "\n"
             "   list contents of environment variables having\n"
             "   all supplied words in their name or content.\n"
             "\n"
             "   $options\n"
             "      -all   dump contents of all env variables. when chaining\n"
             "             output to another command, and no words are given,\n"
             "             specifying -all is optional (see example below).\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk env path\n"
             "         lists anything with PATH in name or content,\n"
             "         e.g. CLASSPATH, HOMEPATH, or PATHEXT.\n"
             "\n"
             "      #sfk env +filter -ls+path=\n"
             "         lists content of the PATH variable.\n"
             );
      ehelp;

      int iPatMin = 0;
      int iPatMax = 0;
      bool ball   = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) {
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         if (!strcmp(argv[iDir], "-all"))
            { ball = 1; continue; }
         // take all non-chaining parms as patterns
         if (!iPatMin) iPatMin = iDir;
         iPatMax = iDir;
      }

      // dump environment variables to chain text output
      if (!penv) return 9+perr("missing environment");

      memset(szAttrBuf, 0, sizeof(szAttrBuf));
      for (int i=0; penv[i] != 0; i++) 
      {
         char *psz = penv[i];

         int nlen = strlen(psz);
         memset(szAttrBuf, ' ', nlen);
         szAttrBuf[nlen] = '\0';

         bool bbail = 0;
         if (iPatMin)
         for (int ipat=iPatMin; !bbail && (ipat<=iPatMax); ipat++)
         {
            char *pszPat = argv[ipat];
            int ipos = 0;
            int ibas = 0;
            bool bhit = (bool)mystrstrip(psz+ibas, pszPat, &ipos);
            if (!bhit) { bbail=1; continue; }
            while (bhit) {
               memset(szAttrBuf+ibas+ipos, 'i', strlen(pszPat));
               ibas += ipos+strlen(pszPat);
               bhit  = (bool)mystrstrip(psz+ibas, pszPat, &ipos);
            }
         }
         if (bbail) continue;

         if (chain.coldata)
            chain.addLine(psz, szAttrBuf);
         else
            printColorText(psz, szAttrBuf);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "label"))
   {
      ifhelp (!chain.usefiles && (nparm < 1))
      printx("<help>$sfk label name [options] +...\n"
             "$sfk ... +label name +...\n"
             "\n"
             "   define a label at the beginning or within an sfk script.\n"
             "   a label is a user-defined name that can be jumped to\n"
             "   by the sfk script command.\n"
             "\n"
             "   $options\n"
             "\n"
             "      -prefix=s    set user-defined input parameter name prefix\n"
             "\n"
             "      by default, parameters passed into sfk scripts are called $$1 to $$9,\n"
             "      or %%1 to %%9. with -prefix, you can define your own parameter names,\n"
             "      e.g. if you rewrite the sfk label line like this:\n"
             "\n"
             "         sfk label begin -prefix=$$parm\n"
             "\n"
             "      then the input parameters are renamed to $$parm1, $$parm2, ...\n"
             "      accepting no other names. or simply say\n"
             "\n"
             "         sfk label begin -prefix=%%\n"
             "\n"
             "      to accept ONLY %%1 to %%9 but NOT $$1 to $$9, to get around conflicts\n"
             "      with script commands using expressions like \"$$10.10col1\".\n"
             "\n"
             "   $examples\n"
             "      #sfk samp sfkcmd mytest.bat\n"
             "         creates a windows batch file mytest.bat\n"
             "         with an embedded sfk command script.\n"
             "\n"
             "      #sfk samp sfkbash mytest\n"
             "         creates a linux batch file mytest\n"
             "         with an embedded sfk command script.\n"
             "\n"
             "   $see also\n"
             "      #sfk script<def> - how to run sfk scripts.\n"
             );
      ehelp;

      char *pszName = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         // do NOT use generic isChainStart here:
         // any "+command" is allowed after labelname to enable
         // easy starting of sfk scripts.
         char *psz = argv[iDir];
         if (psz[0] == '+') {
            if (!pszName) return 9+perr("missing labelname before %s\n",psz);
            iChainNext = iDir;
            break;
         }
         if (pszName) {
            perr("unexpected parameter: %s\n", psz);
            pinf("if %s is a command, try +%s\n", psz, psz);
            return 9;
         }
         pszName = argv[iDir];
      }

      if (cs.verbose > 1)
         pinf("[nopre] label: %s\n", pszName);

      STEP_CHAIN(iChainNext, 0);

      bDone = 1;
   }

   bool bTeeMode = 0;

   ifcmd (!strcmp(pszCmd, "tee") || !strcmp(pszCmd, "ftee"))
   {
      ifhelp (nparm < 1)
      printx("<help>$sfk ... +tee [tofile] filename.txt\n"
             "$sfk ... +tee toterm\n"
             "\n"
             "   split current command chain data into two streams.\n"
             "   stream one is passed to the next command in the chain.\n"
             "   stream two is written to file, or printed to terminal.\n"
             "\n"
             "   $see also\n"
             "      sfk tofile      for file output options\n"
             "      sfk toterm      for terminal output options\n"
             "\n"
             "   $examples\n"
             "      #sfk list testfiles .txt +tee toterm +fview\n"
             "         list selected files on terminal AND open in dview.\n"
             );
      ehelp;

      // tee tofile filename OR tee toterm
      bTeeMode = 1;
      pszCmd = argv[iDir];
      if (pszCmd[0] == '+') pszCmd++;
      if (strcmp(pszCmd, "tofile") && strcmp(pszCmd, "toterm"))
         pszCmd = str("tofile"); // expecting immediate filename
      else
         iDir++;
      // fall through
   }

   ifcmd (   !strcmp(pszCmd, "tofile") || !strcmp(pszCmd, "toterm")
          || !strcmp(pszCmd, "append") || !strcmp(pszCmd, "appendto")
         )
   {
      ifhelp (!chain.useany())
      printx("<help>$sfk ... +tofile filename\n"
             "$sfk ... +toterm\n"
             "\n"
             "   save current command chain data in a file, or print it to terminal,\n"
             "   and then clear the chain. (next command in the chain will start\n"
             "   without any chain input data).\n"
             "\n"
             "   $options\n"
             "      -append      append to output file, instead of overwriting.\n"
             "\n"
             "   $aliases\n"
             "      +append[to]  same as +tofile -append.\n"
             "\n"
             "   $see also\n"
             "      sfk tee      same as tofile, toterm but also passes chain data\n"
             "                   to the next chain command (no clearing of chain).\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk list testfiles +toterm +run \"sfk echo [[Blue]]done[[def]]\" -yes\n"
             "         list selected files on terminal, then run a completely\n"
             "         independent command which does NOT use chain input.\n"
             "\n"
             "      #sfk echo hello1 +tofile output.txt\n"
             "      #sfk echo hello2 +append output.txt\n"
             "         create a new textfile output.txt with the first command,\n"
             "         then append further output with subsequent commands.\n"
             );
      ehelp;

      bool btofile  = !strcmp(pszCmd, "tofile");
      char *pszFile = 0;
      cchar *pszMode = "w";

      if (!strcmp(pszCmd, "append") || !strcmp(pszCmd, "appendto")) {
         btofile = 1;
         pszMode = "a";
      }

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-append")) {
            pszMode = "a";
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (btofile && !pszFile)
            pszFile = argv[iDir];
         else
            return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (btofile && !pszFile) return 9+perr("+tofile: missing output filename.\n");

      if (!bTeeMode) {
         chain.coldata  = 0;
         chain.colfiles = 0;
      }

      FILE *fout = 0;

      if (pszFile)
         if (!(fout = fopen(pszFile, pszMode))) 
            return 9+perr("cannot write: %s\n", pszFile);

      if (chain.usedata) {
         for (int i=0; i<chain.indata->numberOfEntries(); i++) {
            char *pattr = str("");
            char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
            if (ptext) {
               if (fout)
                  fprintf(fout, "%s\n", ptext);
               else
                  printColorText(ptext, pattr, 1); // with lf
               if (bTeeMode)
                  chain.addLine(ptext, pattr);
            }
         }         
      }
      else
      if (chain.usefiles) {
         for (int i=0; i<chain.numberOfInFiles(); i++) {
            Coi *pcoi = chain.getFile(i);
            if (pcoi) {
               if (fout)
                  fprintf(fout, "%s\n", pcoi->name());
               else
                  oprintf("%s\n", pcoi->name());
               if (bTeeMode)
                  chain.addFile(*pcoi);
            }
         }
      }

      if (fout) fclose(fout);

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "storetext"))
   {
      ifhelp (!chain.usedata && nparm < 1)
      printx("<help>$sfk ... +storetext\n"
             "\n"
             "   store current chain text for later use by gettext.\n"
             "   see \"sfk tail\" for a script example.\n"
             "\n"
             "   $options\n"
             "     -append    do not reset previously stored text\n"
             "                but append current chain text to it.\n"
             );
      ehelp;

      bool bAppend = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (!strcmp(pszArg, "-append")) {
            bAppend = 1;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected parameter: %s\n", pszArg);
      }

      if (!bAppend)
         chain.storedata->resetEntries();

      for (int i=0; i<chain.indata->numberOfEntries(); i++) {
         char *pattr = str("");
         char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
         if (!ptext)
            break;
         chain.storedata->addEntry(ptext, pattr ? pattr : str(""));
         chain.outdata->addEntry(ptext, pattr ? pattr : str(""));
      }
 
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "gettext"))
   {
      ifhelp (!chain.usedata && nparm < 1)
      printx("<help>$sfk ... +gettext\n"
             "\n"
             "   get chain text stored by storetext.\n"
             "   see \"sfk tail\" for a script example.\n"
             );
      ehelp;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected parameter: %s\n", pszArg);
      }

      for (int i=0; i<chain.storedata->numberOfEntries(); i++) {
         char *pattr = str("");
         char *ptext = chain.storedata->getEntry(i, __LINE__, &pattr);
         if (!ptext)
            break;
         chain.outdata->addEntry(ptext, pattr ? pattr : str(""));
      }
 
      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "stop"))
   {
      ifhelp ((iDir < argc) && (!strncmp(argv[iDir], "-h", 2) || !strcmp(argv[iDir], "/?")))
      printx("<help>$sfk ... +stop [rc]\n"
             "\n"
             "   stop command chain execution.\n"
             "   returns with code 0 or given rc.\n"
             "   see \"sfk tail\" for a script example.\n"
             );
      ehelp;

      int iRC = -1;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (iRC == -1) {
            iRC = atoi(pszArg);
            continue;
         }
         return 9+perr("unexpected parameter: %s\n", pszArg);
      }

      if (iRC == -1)
         iRC = 0;

      return iRC;
   }

   // internal
   if (strBegins(pszCmd, "xmlform"))
   {
      ifhelp (bFullHelp || (chain.usedata == 0 && nparm < 1))
      printx("<help>$sfk ... +xmlform[3]\n"
             "\n"
             "   simple, line oriented XML text reformatter, just to\n"
             "   change indentation and add colors for easy reading.\n"
             "\n"
             "   not suitable for XML data with lines longer than 3900\n"
             "   characters approx. as these will be hard wrapped!\n"
             "\n"
             "   $chain-only command\n"
             "      xmlform can be used only #after another command<def>,\n"
             "      like filter, which reads the input data.\n"
             "\n"
             "   $options\n"
             "     -indent=3  or typing \"sfk xmlform3\" selects an\n"
             "                indent of 3 instead of the default 2.\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "     #sfk filter in.xml +xmlform\n"
             "       read the file in.xml and print it reformatted\n"
             "\n"
             "     #sfk filter in.xml +xmlform +view\n"
             "       the same, but view the colored output in DView\n"
             "       for easy reading and filtering.\n"
             "\n"
             "     #sfk webreq http://myserver/getxml.php +xmlform\n"
             "       call a web URL that sends an xml reply\n"
             "       and reformat output for easy reading.\n"
             );
      ehelp;

      int itabsize=2;

      char *psz = pszCmd+strlen("xmlform");
      if (isdigit(*psz))
          itabsize=atoi(psz);

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-indent", &pszParm)) {
            if (!pszParm) return 9;
            itabsize = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;

         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (!chain.usedata)
         return 9+perr("missing chain text input");

      cchar *acol = "xh";
      int icol = strlen(acol);
      
      int inest=0,inest2=0,itmpnest=0;
      int btag=0;

      char szEndTag[300];

      // prefetch: load whole chain text for analysis
      char *pInText = 0;
      int   nInSize = 0;
      char *pDstCur = 0;
      for (int ipass=0; ipass<2; ipass++) {
         if (ipass) {
            int iTol=100;
            if (!(pInText = new char[nInSize+iTol]))
               return 9+perr("out of memory");
            memset(pInText, 0, nInSize+iTol);
            pDstCur = pInText;
         }
         for (int i=0; i<chain.indata->numberOfEntries(); i++) {
            char *pattr = 0;
            char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
            int   itext = strlen(ptext);
            if (!ipass)
               nInSize += itext+1;
            else {
               memcpy(pDstCur,ptext,itext);
               pDstCur[itext] = '\n';
               pDstCur += itext+1;
            }
         }
      }
      *pDstCur = '\0'; // safety
      CharAutoDel odel(pInText);

      for (int i=0; i<chain.indata->numberOfEntries(); i++) 
      {
         char *pattr = str("");
         char *ptext = chain.indata->getEntry(i, __LINE__, &pattr);
         if (!ptext)
            continue;

         char *pSrcCur = ptext;
         char *pSrcMax = ptext+strlen(ptext);
         char *pDstCur = szLineBuf;
         char *pDstMax = szLineBuf+MAX_LINE_LEN;
         char *pAttCur = szAttrBuf;
         char *pAttMax = szAttrBuf+MAX_LINE_LEN;

         int istate=0;

         if (striBegins(ptext, "<?xml"))
         {
            strcopy(szLineBuf, ptext);
            szAttrBuf[0] = '\0';
         }
         else
         {
          while (pSrcCur<pSrcMax && pDstCur<pDstMax)
          {
            char c1 = pSrcCur[0];
            char c2 = c1 ? pSrcCur[1] : 0;
            // itmpnest=0;
            if (c1=='<' && c2!='/') {  // start tag
               // check for <footag/>
               // TODO: fails with multi line tags
               char *pszKet = strchr(pSrcCur+1, '>');
               bool bSelfClosed = (pszKet!=0 && pszKet[-1]=='/') ? 1 : 0;
               // FROM <footag any="123" ...>
               // TO   </footag> for quick lookup
               szEndTag[0] = '<';
               szEndTag[1] = '/';
               mystrcopy(szEndTag+2, pSrcCur+1, sizeof(szEndTag)-20);
               char *psz = szEndTag+2;
               while (*psz!=0 && *psz!='/' && *psz!='>' && *psz!=' ' && *psz!='\t')
                  psz++;
               if (*psz) {
                  *psz++ = '>';
                  *psz++ = '\0';
               }
               // only if such end tag(s) exist, count nesting
               if (bSelfClosed==0 && strstr(pInText, szEndTag)!=0) {
                  // printf("endtag-hit : \"%s\"\n", szEndTag);
                  inest++;
                  inest2=inest;
               } else {
                  // printf("endtag-miss: \"%s\"\n", szEndTag);
                  itmpnest=1;
               }
               btag=1;
            }
            else
            if (c1=='<' && c2=='/') {  // end tag
               // see below
               btag=1;
            }
            // else
            // if (c1=='/' && c2=='>') {  // end of tag
            //    inest--;
            // }

            if (istate==0) {
               if (isspace(c1)) {
                  pSrcCur++;
                  continue;
               }
               int itmp=inest+itmpnest;
               int indec=itmp?(itmp-1):0;
               for (int i=0; i<indec*itabsize; i++) {
                  if (pDstCur>=pDstMax)
                     break;
                  *pDstCur++=' ';
                  *pAttCur++=' ';
               }
               istate=1;
            }

            char cattr = ' ';
            if (btag)
                 cattr = acol[(inest2+itmpnest)&1];

            *pDstCur=c1;
            *pAttCur=cattr;

            if (c1=='<' && c2=='/') {  // end tag
               inest--;
            }
            else
            if (c1=='>') {
               btag=0;
               inest2=inest;
               itmpnest=0;
            }

            pSrcCur++;
            pDstCur++;
            pAttCur++;
          }
          *pDstCur='\0';
          *pAttCur='\0';
         }

         if (chain.coldata)
            chain.addLine(szLineBuf, szAttrBuf);
         else
            printColorText(szLineBuf, szAttrBuf, 1); // with lf
      }         

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "sort"))
   {
      ifhelp (!chain.usedata || (nparm >= 1 && isHelpOpt(argv[iDir])))
      printx("<help>$sfk ... +sort\n"
             "\n"
             "   sort text lines, case insensitive by default.\n"
             "   requires a previous command producing text output.\n"
             "\n"
             "   $options\n"
             "      -case        case sensitive text comparison\n"
             "      -rev[erse]   reverse sorting order\n"
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk filter csv.txt +sort\n"
             "         print sorted contents of csv.txt\n"
             #ifdef _WIN32
             "      #sfk filter csv.txt +sort +view<def>\n"
             "         shows output with the dview GUI tool\n"
             #endif
             );
      ehelp;

      if (!chain.usedata) {
         perr("missing chain text input for +sort");
         pinf("need a previous command producing text output\n");
         return 9;
      }

      bool brev = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (strBegins(argv[iDir], "-rev")) {
            brev = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (groupChainText(pszCmd, brev, 0, 0)) return 9;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }
   
   // internal
   ifcmd (!strcmp(pszCmd, "difflines"))
   {
      ifhelp (!chain.usedata || (nparm >= 1 && isHelpOpt(argv[iDir])))
      // printx("<help>$sfk ... +difflines filename\n"
      //        "\n"
      //        "   compare chain text against a text file.\n"
      //        "\n"
      //        );
      ehelp;

      if (!chain.usedata) {
         perr("missing chain text input for +difflines");
         pinf("need a previous command producing text output\n");
         return 9;
      }

      char *pszRefFile = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         if (!pszRefFile) {
            pszRefFile = argv[iDir];
            continue;
         }
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }
      if (!pszRefFile)
         return 9+perr("missing text filename.");

      if (diffChainText(pszRefFile)) return 9;

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "spell") || !strcmp(pszCmd, "nato"))
   {
      ifhelp (nparm >= 1 && isHelpOpt(argv[iDir]))
      printx("<help>$sfk spell [phrase]\n"
             "\n"
             "   show spelling table, or spell a phrase, i.e.\n"
             "   print one word per character of a word/phrase\n"
             "   for clear transmission over telephone.\n"
             "   primarily used for email addresses which must\n"
             "   be accurate by every character.\n"
             "\n"
             "   $options\n"
             "      -nato  use original Nato spelling table.\n"
             "             default is to use an optimized mix\n"
             "             of Nato/RAF.\n"
             "\n"
             "   $aliases\n"
             "      #sfk nato<def>  - same as sfk spell -nato\n"
             "\n"
             );
      ehelp;

      bool bNato = strcmp(pszCmd, "nato") ? 0 : 1;
      bool bDoneAny = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++)
      {
         if (!strcmp(argv[iDir], "-nato")) {
            bNato = 1;
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         dospell(argv[iDir], bNato);
         bDoneAny = 1;
      }

      if (!bDoneAny)
      {
         if (bNato)
            pinf("[nopre] === Standard Nato phonetic alphabet ===\n");
         else
            pinf("[nopre] === Optimized Nato/RAF alphabet. Use \"sfk nato\" for standard alphabet. ===\n");
         dospell(0, bNato);
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "count"))
   {
      ifhelp (!chain.usedata || (nparm >= 1 && isHelpOpt(argv[iDir])))
      printx("<help>$sfk ... +count [-same[lines]]\n"
             "\n"
             "   count total number of text lines, or group identical\n"
             "   text lines, counting the number of occurences per line.\n"
             "\n"
             "   $options\n"
             "      -samelines count number of occurences per line, then\n"
             "                 prefix lines by TAB separated counter.\n"
             "      -digits=n  with -samelines, change no. of counter digits\n"
             "      -case      case sensitive text comparison\n"
             "\n"
             "   $see also\n"
             "      #sfk filter<def> with -unique, to strip duplicate lines.\n"
             #ifdef _WIN32
             "      #sfk view<def>   a GUI tool that can filter text just by\n"
             "                 typing or clicking on a word, telling\n"
             "                 the number of result lines instantly.\n"
             #endif
             "\n");
      webref(pszCmd);
      printx("   $examples\n"
             "      #sfk filter words.txt +count -same -digits=10\n"
             "         tell how often each line occurs in words.txt,\n"
             "         and format the occurence counter with 10 digits.\n"
             );
      ehelp;

      if (!chain.usedata) {
         perr("missing chain text input for +count");
         pinf("need a previous command producing text output\n");
         return 9;
      }

      bool bsame = 0;
      int ndig  = 5;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         char *pszParm = 0;
         if (!strncmp(argv[iDir], "-same", 5)) {
            bsame = 1;
            continue;
         }
         else
         if (haveParmOption(argv, argc, iDir, "-digits", &pszParm)) {
            if (!pszParm) return 9;
            ndig = atol(pszParm);
            continue;
         }
         else
         if (!strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords:
         return 9+perr("unexpected: %s\n", argv[iDir]);
      }

      if (!bsame) {
         sprintf(szLineBuf, "%d", chain.indata->numberOfEntries());
         if (chain.colany())
            chain.addLine(szLineBuf, str(""));
         else
            printColorText(szLineBuf, str(""), 1); // with lf
      } else {
         if (groupChainText(pszCmd, 0, bsame, ndig)) return 9;
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }

   #ifdef _WIN32
   #ifndef VFILEMAX
   if (!strcmp(pszCmd, "donate"))
   {
      if (blockChain(pszCmd, iDir, argc, argv)) return 9; // not yet supported
      
      char *pszURL = str("http://stahlworks.com/donate/");
      
      printf("opening: %s\n", pszURL);

      ShellExecute(NULL, "open", pszURL, NULL, NULL, SW_SHOWNORMAL);

      bDone = 1;
   }
   #endif
   #endif

   if (!strcmp(pszCmd, "sfk") || !strcmp(pszCmd, "then")) // actually +sfk
   {
      int iChainNext = iDir;

      if (iChainNext >= argc)
         return 9+perr("missing command after \"sfk\"");

      chain.reset();

      STEP_CHAIN(iChainNext, 0);

      lRC = 0;
      bDone = 1;
   }

   if (!strcmp(pszCmd, "end"))
   {
      lRC = 0;
      bDone = 1;
      // fall through to exit
   }

   // do NOT use ifcmd here.
   if (!strcmp(pszCmd, "dump-console-intro"))
   {
      // this BLOCKS, waiting for a char input.
      dumpConsoleHelp(1);
      bDone = 1;
   }

   ifcmd (!strcmp(pszCmd, "dump-main-help"))
   {
      ifhelp (1)
      printx("<help>$SFK" SFK_BRANCH " - The Swiss File Knife File Tree Processor.\n");
      cchar *pfix = SFK_FIXPACK;
      sprintf(szLineBuf, "Release " SFK_VERSION " %s%s%s%s of " __DATE__ ".",
         pszGlblVerType, SFK_VERTEXT, pfix[0] ? " Revision ":"", pfix);
      printx("%s\n", szLineBuf);
      printf("this binary was compiled and provided by " SFK_PROVIDER ".\n");
      printf("original source and binary package available on sourceforge,\n");
      printf("http://swissfileknife.sourceforge.net\n");

      #ifndef NO_BSD_INFO
      printx("Distributed for free under the BSD License, without any warranty.\n");
      #endif

      #ifdef _WIN32
      if (sizeof(mytime_t) < 8) {
         // if you see this warning, sfk list -time may fail on file dates > 2038.
         // 64-bit times with unix are an sfk issue left open, so there is no warning.
         printx("\ninfo: compile with latest msvc for 64-bit time and size support.\n");
      }
      #endif

      if (bhelp)
      printx("\n$sfk main help (just type \"sfk\"):\n");
      else
      printx("\n<file>type \"sfk commandname\" for help on any of the following.<def>\n"
             "some commands require to add \"-help\" for the help text.\n"
             "\n");

/*
sfk fromclip +filt -sform "         \q$col1\\n\q" +toclip
*/

      printHelp(
         "file system\n"
         "   sfk list       - list directory tree contents.\n"
         "                    list latest, oldest or biggest files.\n"
         "                    list directory differences.\n"
         #ifdef VFILEBASE
         "                    list zip jar tar gz bz2 contents.\n"
         #else
         "                    list zip and jar contents.\n"
         #endif // VFILEBASE
         "   sfk filefind   - find files by filename\n"
         "   sfk treesize   - show directory size statistics\n"
         "   sfk copy       - copy directory trees additively\n"
         "   sfk sync       - mirror tree content with deletion\n"
         "   sfk partcopy   - copy part from a file into another one\n"
         "   sfk mkdir      - create directory tree\n"
         "   sfk delete     - delete files and folders\n"
         "   sfk deltree    - delete whole directory tree\n"
         "   sfk deblank    - remove blanks in filenames\n"
         "   sfk space [-h] - tell total and free size of volume\n"
         "   sfk filetime   - tell times of a file\n"
         "   sfk touch      - change times of a file\n"
         "   sfk index      - create index file(s) for fast lookup\n"
         "   sfk iname      - lookup file names using index files\n"
         "\n"
         );

      printHelp(
         "conversion\n"
         "   sfk lf-to-crlf - convert from LF to CRLF line endings\n"
         "   sfk crlf-to-lf - convert from CRLF to LF line endings\n"
         "   sfk detab      - convert TAB characters to spaces\n"
         "   sfk entab      - convert groups of spaces to TAB chars\n"
         "   sfk scantab    - list files containing TAB characters\n"
         "   sfk split      - split large files into smaller ones\n"
         "   sfk join       - join small files into a large one\n"
         "   sfk csvtotab   - convert .csv data to tab separated\n"
         "   sfk tabtocsv   - convert tab separated to .csv format\n"
         "   sfk hexdump    - create hexdump from a binary file\n"
         "   sfk hextobin   - convert hex data to binary\n"
         "   sfk hex        - convert decimal number(s) to hex\n"
         "   sfk dec        - convert hex number(s) to decimal\n"
         "   sfk chars      - print chars for a list of codes\n"
         "   sfk bin-to-src - convert binary to source code\n"
         "\n"
         );

      printHelp(
         "text processing\n"
         "   sfk filter     - search, filter and replace text data\n"
         "   sfk replace    - replace words in binary and text files\n"
         "   sfk run        - run command on all files of a folder\n"
         "   sfk runloop    - run a command n times in a loop\n"
         "   sfk printloop  - print some text many times\n"
         "   sfk head       - print first lines of a file\n"
         "   sfk tail       - print last lines of a file\n"
         "   sfk snapto     - join many text files into one file\n"
         "   sfk addhead    - insert string at start of text lines\n"
         "   sfk addtail    - append string at end of text lines\n"
         "   sfk joinlines  - join text lines split by email reformatting\n"
         "   sfk strings    - extract strings from a binary file\n"
         "   sfk sort       - sort text lines produced by another command\n"
         "   sfk count      - count text lines, filter identical lines\n"
         "   sfk linelen    - tell length of string(s)\n"
         "   sfk patch      - change text files through a script\n"
         #ifdef WITH_FN_INST
         "   sfk inst       - instrument c++ sourcecode with tracing calls\n"
         #endif
         "\n"
         );

      printHelp(
         "search and compare\n"
         "   sfk find       - find words in text and binary files\n"
         "   sfk ftext      - find words only in text files\n"
         "   sfk hexfind    - find words in binary files, showing hexdump\n"
         "   sfk md5gento   - create list of md5 checksums over files\n"
         "   sfk md5check   - verify list of md5 checksums over files\n"
         "   sfk md5        - calc md5 over a file, compare two files\n"
         "   sfk pathfind   - search PATH for location of a command\n"
         "   sfk reflist    - list fuzzy references between files\n"
         "   sfk deplist    - list fuzzy dependencies between files\n"
         "   sfk dupfind    - find duplicate files by content\n"
         "\n"
         );

      #ifdef WITH_TCP
      printHelp(
         "networking\n"
         "   sfk httpserv   - run an instant HTTP server.\n"
         "                    type \"sfk httpserv -help\" for help.\n"
         "   sfk ftpserv    - run an instant FTP server\n"
         "                    type \"sfk ftpserv -help\" for help.\n"
         "   sfk ftp        - instant anonymous FTP client\n"
         #ifdef VFILENET
         "   sfk wget       - download HTTP file from the web\n"
         #endif
         "   sfk webrequest - send HTTP request to a server\n"
         "   sfk tcpdump    - print TCP conversation between programs\n"
         "   sfk udpdump    - print incoming UDP requests\n"
         "   sfk udpsend    - send UDP requests\n"
         "   sfk ip         - tell own machine's IP address(es).\n"
         "                    type \"sfk ip -help\" for help.\n"
         "   sfk netlog     - send text outputs to network,\n"
         "                    and/or file, and/or terminal\n"
         "   sfk fromnet    - receive and print network text\n"
         "\n"
         );
      #endif

      printHelp(
         "scripting\n"
         "   sfk script     - run many sfk commands in a script file\n"
         "   sfk echo       - print (coloured) text to terminal\n"
         "   sfk color      - change text color of terminal\n"
         "   sfk alias      - create command from other commands\n"
         "   sfk mkcd       - create command to reenter directory\n"
         "   sfk sleep      - delay execution for milliseconds\n"
         "   sfk pause      - wait for user input\n"
         "   sfk label      - define starting point for a script\n"
         "   sfk tee        - split command output in two streams\n"
         "   sfk tofile     - save command output to a file\n"
         "   sfk toterm     - flush command output to terminal\n"
         "   sfk loop       - repeat execution of a command chain\n"
         "   sfk cd         - change directory within a script\n"
         "   sfk getcwd     - print the current working directory\n"
         "   sfk require    - compare version text\n"
         "   sfk time [-h]  - print current date and time\n"
         "\n"
         );

      printHelp(
         "development\n"
         "   sfk bin-to-src - convert binary data to source code\n"
         "   sfk make-random-file - create file with random data\n"
         "   sfk fuzz       - change file at random, for testing\n"
         "   sfk sample     - print example code for programming\n"
         "   sfk inst       - instrument c++ with tracing calls\n"
         "\n"
         );

      printHelp(
         "diverse\n"
         "   sfk media      - cut video and binary files\n"
         "   sfk view       - show results in a GUI tool\n"
         #ifdef _WIN32
         "   sfk toclip     - copy command output to clipboard\n"
         "   sfk fromclip   - read text from clipboard\n"
         #endif
         "   sfk env        - search environment variables\n"
         "   sfk version    - show version of a binary file\n"
         "   sfk ascii      - list ISO 8859-1 ASCII characters\n"
         "   sfk ascii -dos - list OEM codepage 850 characters\n"
         "   sfk spell [-h] - phonetic spelling for telephone\n"
         "   sfk cmd        - print an example command\n"
         "   sfk license    - print the SFK license text\n"
         "\n"
         );

      printHelp(
         "help by subject\n"
         "   sfk help select   - how dirs and files are selected in sfk\n"
         "   sfk help options  - general options reference\n"
         "   sfk help patterns - wildcards and text patterns within sfk\n"
         "   sfk help chain    - how to combine (chain) multiple commands\n"
         "   sfk help shell    - how to optimize the windows command prompt\n"
         "   sfk help unicode  - about unicode file reading support\n"
         "   sfk help colors   - how to change result colors\n"
         "   sfk help compile  - how to compile sfk on any linux system\n"
      // "   sfk help fileset  - how to list dir names in a text file.\n"
         #ifdef VFILEBASE
         #endif // VFILEBASE
         "\n"
         );

      printx("   $All tree walking commands support file selection this way:\n"
             "\n"
             "   1. short format with ONE directory tree and MANY file name patterns:\n"
             "      #src1dir .cpp .hpp .xml bigbar <not>footmp\n"
             "   2. short format with a list of explicite file names:\n"
             "      #letter1.txt revenues9.xls report3<sla>turnover5.ppt\n"
             "   3. long format with MANY dir trees and file masks PER dir tree:\n" 
             "      #-dir src1 src2 <not>src<sla>save -file foosys .cpp -dir bin5 -file .exe\n"
             "\n"
             "   For detailed help on file selection, type #\"sfk help select\"<def>.\n"
             "\n");
      printx("   %s and ? wildcards are supported within filenames. \"foo\" is interpreted\n"
             "   as \"%cfoo%c\", so you can leave out %s completely to search a part of a name.\n"
             "   For name start comparison, say \"%cfoo\" (finds foo.txt but not anyfoo.txt).\n"
             "\n"
             "   When you supply a directory name, by default this means \"take all files\".\n"
             ,glblWildInfoStr,glblWildChar,glblWildChar,glblWildInfoStr,glblPathChar);
      #ifndef _WIN32
      if (!bhelp) setTextColor(nGlblWarnColor);
      printx("   Use %c or \\* instead of *, and \\? instead of ?, as * and ? are eaten by the\n"
             "   command shell. You may also redefine %c through export SFK_CONFIG=wildstar:c\n"
             ,glblWildChar,glblWildChar);
      if (!bhelp) setTextColor(-1);
      #endif
      printx("\n"
             "      #sfk list mydir<def>                lists ALL  files of mydir, no * needed.\n"
             "      #sfk list mydir .cpp .hpp<def>      lists SOME files of mydir, by extension.\n"
             "      #sfk list mydir <not>.cfg<def>          lists all  files of mydir  EXCEPT .cfg\n"
             "\n"
             );
      printx("   $general options:\n"
             "      -tracesel tells in detail which files and/or directories are included\n"
             "                or excluded, and why (due to which user-supplied mask).\n"
             "      -nosub    do not process files within subdirectories.\n"
             "      -nocol    before any command switches off color output.\n"
             "      -quiet    or -nohead shows less output on some commands.\n"
             #ifdef _WIN32
             "      -hidden   includes hidden and system files and dirs.\n"
             #endif
             "      For detailed help on all options, type #\"sfk help options\".\n"
             "\n");
      #ifdef _WIN32
      printx("   $configure your windows CMD.exe properly.\n"
             "      select many display columns, 3000 lines for scrollback\n"
             "      and copy/paste of displayed text. #\"sfk help shell\"<def> for more.\n"
             "\n");
      #endif
      printx("   $beware of Shell Command Characters.\n" // main help, just reference
             "      parameters containing #spaces<def> or characters #<>|!&?*<def> must be #sur-\n"
             "      #rounded by quotes \"\"<def>. type \"#sfk filter<def>\" for details and examples.\n"
             "\n");
      printx("   WRONG COLORS? Use one of:\n"
             "      <exp> SFK_COLORS=theme:black    for DARK   backgrounds\n"
             "      <exp> SFK_COLORS=theme:white    for BRIGHT backgrounds\n"
             "      see also \"sfk help colors\"\n"
             );
      printx("\n"
             "   type #\"sfk ask word1 word2 ...\"<def>   to search ALL help text for words.\n"
             "   type #\"sfk dumphelp\"<def>              to print  ALL help text.\n"

             "\n"
             "      +-----------------------------------------------------+ \n"
             "      | Get the #three dollar e-book<def> from #stahlworks.com/pdf<def> | \n"
             #ifndef SFKPRO
             "      |-----------------------------------------------------| \n"
             "      | Search all text files of a folder in realtime with  | \n"
             "      |  Depeche View. Freeware from #www.depecheview.com<def>    | \n"
             #endif
             "      +-----------------------------------------------------+ \n"

             #ifndef _WIN32
             "\n"
             #endif
            );
      ehelp;
      // no real action here
      return 9;
   }

   ifcmd (!strcmp(argv[1], "help") || !strcmp(argv[1], "ascii"))
   {
      bool bShortAscii = strcmp(argv[1], "ascii") ? 0 : 1;

      if (!bhelp && !bShortAscii && (nparm < 1)) {
         fprintf(stderr, "please type just \"sfk\" to list the sfk main help.\n");
         return 9; 
      }

      char *pszSub = str("");

      if (bShortAscii)
         pszSub = str("ascii");
      else
         pszSub = bhelp ? (char*)"" : argv[2];

      #ifdef _WIN32
      char *pszSet = str("set");
      #else
      char *pszSet = str("export");
      #endif

      if (bhelp || !strncmp(pszSub, "color", 5))
      {
         #ifdef _WIN32
         printx("%s SFK_COLORS=off|on,err:n,warn:n,head:n,examp:n,file:n,hit:n,rep:n,pre:n\n", pszSet);
         #else
         printx("%s SFK_COLORS=off|on,def:n,err:n,warn:n,head:n,examp:n,file:n,hit:n,rep:n,pre:n\n", pszSet);
         #endif
         printx("%s SFK_COLORS=bright|dark,theme:black|theme:white\n", pszSet);
         printx("\n"
                "   color identifiers are\n"
                #ifndef _WIN32
                "      def       default color (black by default)\n"
                #endif
                "      err       error   messages\n"
                "      warn      warning messages\n"
                "      head      headlines in help text\n"
                "      examp     examples  in help text\n"
                "      file      filename listings in find\n"
                #ifndef _WIN32
                "      link      symbolic link files or directories\n"
                #endif
                "      hit       text pattern hits in find and filter\n"
                "      rep       replaced patterns in filter\n"
                "      pre       line prefix symbols in find\n"
                "      time      time or low-prio status infos\n"
                "      traceinc  with -tracesel, included names\n"
                "      traceexc  with -tracesel, excluded names\n"
                "\n"
                "   color code n is a combination of these values:\n"
                "      0 = black\n"
                "      1 = bright\n"
                "      2 = red\n"
                "      4 = green\n"
                "      8 = blue\n"
                "\n"
                "   some commands like \"sfk echo\" also accept direct color names:\n"
                "   red,green,blue,yellow,cyan,magenta,default,Red,Green,Blue...\n"
                "   sfk for windows tries to autoselect color brightness if a black\n"
                "   or white shell background is found. otherwise the spelling matters:\n"
                "   red means dark red, and Red means bright red.\n"
                "   you may also set SFK_COLORS to bright or dark, or specify options\n"
                "   -bright or -dark in your command, to force all plain text colors\n"
                "   to the same brightness, regardless of spelling.\n"
                "\n"
                "   examples for color schemes:\n"
                "\n"
                );
         printx("      neutral, compatible to black and white backgrounds:\n"
                "         <exp> SFK_COLORS=head:5,examp:11,file:11,hit:5,rep:7\n"
                "\n");
         printx("      black background optimized theme:\n"
                "         <exp> SFK_COLORS=theme:black\n"
                "\n");
         printx("      white background optimized theme:\n"
                "         <exp> SFK_COLORS=theme:white\n"
                "\n");
         printx("      switch off colored output:\n"
                "         %s SFK_COLORS=off\n\n",pszSet);
         #ifdef _WIN32
         printx("   to switch off colors per command, use general option -nocol .\n");
         #else
         printx("   by default, colors are inactive on unix, as there are some potential problems\n"
                "   depending on the background color of your shell, and if you want to post-process\n"
                "   command output. if you feel lucky, add -col in front of a command, or say\n"
                "\n"
                "      export SFK_COLORS=on,def:0      or    export SFK_COLORS=on,def:14\n"
                "      with bright shell backgrounds         with black shell backgrounds\n"
                );
         #endif

         printx("\n"
                "   to TEST current active colors, type: sfk colortest\n"
                );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp)
      {
         printx("<help>$sfk help ascii  (or just \"sfk ascii\")\n"
                "\n"
                "   print a table of ASCII characters with their codes.\n"
                "\n"
               );
      }

      if (!strcmp(pszSub, "ascii") || !strcmp(pszSub, "ASCII"))
      {
         char *pszSubSub = str("");

         int iDir = bShortAscii ? 2 : 3;

         for (; iDir<argc; iDir++) 
         {
            if (!strcmp(argv[iDir], "-ansi")) { pszSubSub=argv[iDir]; continue; }
            else
            if (!strcmp(argv[iDir], "-dos")) { pszSubSub=argv[iDir]; continue; }
            else
            if (!strncmp(argv[iDir], "-", 1)) {
               if (setGeneralOption(argv, argc, iDir))
                  continue;
               else
                  return 9+perr("unknown option: %s\n", argv[iDir]);
            }
         }
 
         #ifdef _WIN32
         bool bAnsiToOem = 0;
         bool bOemToAnsi = 0;
         if (!bGlblEnableOPrintf) {
            if (pszSubSub[0]) pwarn("-nocconv overrides -ansi or -dos. no conversions are done.\n");
            printf("Character set: ASCII from 0 to 127, codes above depending on your terminal.\n");
         }
         else
         if (bGlblHaveInteractiveConsole) {
            // dumping to interactive Windows console
            if (!strcmp(pszSubSub, "-dos")) {
               printf("Character set: ASCII from 0 to 126, codes above DOS (OEM codepage 850).\n");
            } else {
               bAnsiToOem = 1;
               printf("Character set: ASCII from 0 to 126, codes above ANSI (displayed in DOS console).\n");
            }
         } else {
            // dumping into a file
            if (!strcmp(pszSubSub, "-dos")) {
               bOemToAnsi = 1;
               printf("Character set: ASCII from 0 to 126, codes above DOS (OEM codepage 850).\n");
            } else {
               printf("Character set: ASCII from 0 to 126, codes above ANSI (1250 unconverted).\n");
            }
         }
         // printf("Character set: ASCII from 0 to 126, codes above are DOS specific. To see the Windows\n"
         //       "characters for codes >= 127, say \"sfk help ascii >x.txt\" then load x.txt in notepad.\n"
         //       );
         #else
         printf("Character set: ASCII from 0 to 127, codes above depending on your terminal.\n");
         #endif
         int nCharCols = 8;
         int nCharRows = 0x20; // (255 / nCharCols) + 1;
         for (int irow=0; irow<nCharRows; irow++) 
         {
            for (int icol=0; icol<nCharCols; icol++) 
            {
               int i = icol * nCharRows + irow;
               if (i > 255)
                  printf("        ");
               else {
                  uchar c = (uchar)i;
                  setTextColor(nGlblHitColor);
                  if (i < 10 ) putchar(' ');
                  if (i < 100) putchar(' ');
                  printf("%d ",i);
                  setTextColor(nGlblExampColor);
                  printf("%X ",i);
                  setTextColor(-1);
                  #ifdef _WIN32
                  if (c >= 0x20)
                  #else
                  if (c >= 0x20 && !(c >= 0x7F && c < 0xA0))
                  #endif
                  {
                     // setTextColor(nGlblFileColor);
                     #ifdef _WIN32
                     if (bAnsiToOem) c = ansiCharToOEM(c);
                     if (bOemToAnsi) c = oemCharToAnsi(c);
                     #endif
                     putchar(c);
                     // setTextColor(-1);
                     if (icol < nCharCols)
                        printf("  ");
                  }
                  else
                  switch (c) {
                     case 4   : printf("EOT "); break;
                     case 7   : printf("BEL "); break;
                     case 8   : printf("BS  "); break;
                     case 12  : printf("FF  "); break;
                     case 0x1A: printf("EOF");  break;
                     case 27  : printf("ESC");  break;
                     case 127 : printf("DEL");  break;
                     case '\r': printf("CR  "); break;
                     case '\n': printf("LF  "); break;
                     case '\t': printf("TAB "); break;
                     default:
                        putchar('.');
                        if (icol < nCharCols) {
                           if (c < 0x10)
                              printf("   ");
                           else
                              printf("  ");
                        }
                        break;
                  }
               }
            }
            printf("\n");
         }

         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "opt", 3))
      {
      printx("$sfk general options reference%s:\n",
             bhelp ? " (type \"sfk help options\")":"");
      printx("\n"
         "   Please note: some of these options are supported only by some commands.\n"
         );
      printx("\n"
         "   $-nosub<def>     or -norec does not include subdirectories (subfolders).\n"
         "              processing of subdirs is DEFAULT with most commands,\n"
         "              therefore you must specify -nosub to switch it off.\n"
         "   $-withsub<def>   include subdirs. is DEFAULT with most commands.\n"
         "   $-verbose<def>   print additional infos while running a command.\n"
         "              helpful if a command doesn't work as expected.\n"
         "              only some commands support -verbose. try also -verbose=2.\n"
         #if (!defined(_WIN32) && !defined(SFK_LIB5))
         "   $-nofollow<def>  or -nofo does not follow symbolic directory links.\n"
         "              this option may NOT work with older Linux versions,\n"
         "              esp. those needing the \"lib5\" binary version of sfk.\n"
         #endif
         #ifndef _WIN32
         "   $-showskip<def>  tell whenever directory contents are skipped to avoid\n"
         "              double processing caused by symbolic links.\n"
         "   $-allowdups<def> disable detection of duplicate directory contents.\n"
         "                 may cause endless recursion on links like \"X11\"->\".\"\n"
         #endif
         "   $-quiet<def>     reduce output on some commands. e.g. the find command will\n"
         "              not display the \"scan\" status info while searching files.\n"
         "   $-quiet=2<def>   reduce output even more on some commands.\n"
         #ifdef SFK_MEMTRACE
         "   $-memcheck<def>  check memory list at the end of every command\n"
         "              to detect overwrites. reduces performance.\n"
         #endif
         "   $-debug<def>     print extra program flow infos to track errors.\n"
         #ifdef SFK_MEMTRACE
         "              also activates -memcheck under Windows.\n"
         #endif
         "   $-nohead<def>    no not list header/trailer info on some commands: the run cmd\n"
         "              will not tell \"simulating\" even if it's in simulation mode.\n"
         "   $-case<def>      activate case sensitive text comparison with some commands.\n"
         "              most text processing commands are case-insensitive by default.\n"
         "              filename comparison is always case insensitive.\n"
         "   $-hidden<def>    include hidden and system files.\n"
         "   $-nohidden<def>  exclude hidden and system files.\n"
         "   $-yes<def>       fully execute the command. some commands like \"run\" are\n"
         "              running in simulation mode by default, to avoid damage to your\n"
         "              files, as long as you're unsure which files and dirs to select.\n" 
         "              as soon as you add -yes, however, everything is fully executed.\n"
      // "   $-nonames<def>   or -nofile[names] does not create :file name records when\n"
      // "              chaining text data from one command to another.\n"
         );
  printx("   $-minsize=s<def> select only files >= size, like 10b or 100k\n"
         "   $-maxsize=s<def> select only files <= size, like 10m or 4g\n"
         "              b=bytes k=kbytes m=megabytes g=gigabytes=10^9 bytes\n"
         "              K=2^10 bytes M=2^20 bytes G=2^30 bytes\n"
         "   $-textfiles<def> process only text files, no binaries. -text is the same,\n"
         "              but this may interfere with some command's local -text option.\n"
         "              text/binary detection only checks the file's first 4 kbytes.\n"
         "   $-binfiles<def>  process only binary files. -bin is the same, but this may\n"
         "              interfere with some command's local -bin option.\n"
         "   $-umlauts<def>   with binary-to-text conversion, include german characters.\n"
         "   $-nocol<def>     disable all colored output. important if your shell has\n"
         "              a background color incompatible to the default color scheme,\n"
         "              or (under linux) if the sfk output text must be processed\n"
         "              further through pipelining, and needs to be stripped from\n"
         "              the color escape sequences.\n"
         "   $-col<def>       switch on colored output. \"sfk help colors\" for more.\n"
         "   $-html<def>      dump sfk help text (color control) in html format.\n"
         "              -html must be typed directly after \"sfk\".\n"
         "   $-htmlpage<def>  the same, but include a header to view it in a browser.\n"
         "   $-sincedir<def>  or -sincedif/add/chg: compare directory tree against\n"
         "              a reference tree, process only changed or added files.\n"
         "              see \"sfk list\" for details.\n"
         "   $-tracesel<def>  give verbose infos why directories and files have been\n"
         "              selected or excluded. -tracedirs lists only directories,\n"
         "              -tracefiles lists only files.\n"
         "   $-since<def>     process only files changed on or after the supplied\n"
         "              date/timestamp. \"sfk list\" for details.\n"
         "   $-before<def>    process only files changed before that date/timestamp.\n"
         "   $-flist fn<def>  or \"-fl fn\" reads list of filenames from file fn.\n"
      // "   $-fileset<def>   use a textfile with dir- and filenames, instead of\n"
      // "              providing them as parameters. \"sfk help fileset\" for more.\n"
         "   $-spat<def>      activates interpretation of slash patterns:\n"
         "              \\t=TAB \\q=\" \\r=CR \\n=LF \\\\=\\ \\xnn=any char w/hex code nn\n"
         "              with some commands like replace, filter -form and -replace.\n"
         "   $-literal<def>   or -lit disables interpretation of wildcards * and ?\n"
         "              and slash patterns, if they were activated previously.\n"
         "   $-nospat<def>    disables only slash patterns.\n"
         );
         #ifdef _WIN32
  printx("   $-nocconv<def>   when printing output to the windows console, sfk tries\n"
         "              to convert umlaut and accent characters to display them\n"
         "              correctly with codepage 850. set -nocconv to disable this.\n"
         "              whenever output is redirected to file, no conversion is done.\n"
         "   $-cconv<def>     force codepage conversions: if command output is redirected\n"
         "              to a file, codepage conversion is disabled by default.\n"
         "              use this option to activate, e.g. when post-processing\n"
         "              sfk run output which produced filename lists.\n"
         );
         #endif
  printx("   $-noipex<def>    disable automatic IP expansion with some commands.\n");
  printx("   $-arc<def>       with sfk list, lists also archive file contents.\n");
  printx("              zip files recognized by sfk must have one of these extensions:\n"
         "              .zip .jar .ear .war .aar .xpi\n");
  printx("   $-wchar<def>     activate EXPERIMENTAL utf-16 (ucs-2, wide char) decoding,\n"
         "              allowing sfk find or filter to search text in utf-16 files.\n"
         "              should not be used when (re)writing files. get more infos\n"
         "              by typing \"sfk help unicode\".\n"
         "   $-to mask<def>   specify where to write output files with some commands.\n"
         "              mask supports <run>file, <run>path, <run>base, <run>ext and more,\n"
         "              like -to outdir<sla><run>base-modified.<run>ext\n"
         "              say \"sfk run\" for a list of possible keywords.\n"
         "   $-tofile x<def>  specify a single output filename, which is taken as is\n"
         "              and not checked for any <run> patterns.\n"
         "   $-tmpdir x<def>  set directory x as temporary file directory. default is\n"
         #ifdef _WIN32
         "              to use the path specified by TEMP or TMP env variable.\n"
         #else
         "              to use the path specified by TEMP or TMP env variable,\n"
         "              or the /tmp directory, if no such variable is defined.\n"
         #endif
         "   $-showtmp<def>   tell verbosely which temporary files are created.\n"
         "   $-keeptmp<def>   do not delete the temporary files, if possible.\n"
         "   $-nowarn<def>    and -noerr, -nonote disable warn, error and note messages.\n");
  printx("   $-memlimit=n<def> set the caching memory limit to n mbytes (default=%d).\n"
         "              used if a function needs to load whole files into memory.\n"
         ,(int)(nGlblMemLimit / 1048576));
         #ifdef VFILEBASE
  printx("              if zip etc. archive processing is very slow, it may be caused by\n"
         "              a cache overflow. try to increase the -memlimit then.\n"
         "              if you think sfk uses too much memory while processing files,\n"
         "              try to reduce -memlimit (values below 200 are not recommended).\n"
         "              you may also set SFK_CONFIG (see end of this text).\n"
         "   $-cachestat<def> tell amount of memory used by archive file cache.\n"
         "   $-nocache<def>   disable the disk cache (for network files).\n"
         );
         #endif // VFILEBASE
  printx("   $-exectime<def>  tell command execution time at program end.\n");
  printx("\n"
         "   $shell return code handling and error processing:\n"
         "\n"
         "   $-showrc<def>    print sfk return code at program end. may not print anything\n"
         "              in case of fatal errors, like wrong syntax (usually rc 9).\n"
         "   $-exterr<def>    in case of operating system related errors like file access,\n"
         "              prints extended error information, if available.\n"
         "   $-waitonerr<def> wait for user input on every error.\n"
         "   $-waitonend<def> wait for user input at program end.\n"
         "   $-stoponerr<def> stop directory tree processing on first unreadable file.\n"
         "              default is to process as many files as possible, skipping\n"
         "              unreadable files and directories.\n"
         "   $-rcfromerr<def> some commands like filter, find, hexfind tell by shell rc\n"
         "              that something was found. by default, skipped errors like\n"
         "              unreadable files do NOT change this rc. with -rcfromerr,\n"
         "              skipped errors do override the resulting shell rc.\n"
         "   $-echoonerr<def> echo whole command to stderr when an error occurs.\n"
         "              see also the SFK_CONFIG setting \"echoonstart\" below.\n"
         "\n"
         "   to experiment with the above options, try \"sfk errortest\".\n"
         "\n");

  printx("   $command local versus global scope:\n"
         "\n"
         "      within a command chain, many options have an effect only locally\n"
         "      with the command where they are specified, e.g. in\n"
         "\n"
         "         #sfk filt x.txt -case -high red FooCase +filt -high blue TheBar\n"
         "\n"
         "      the \"-case\" is valid only for the first filter command.\n"
         "      but the following options can also be used globally, if specified\n"
         "      directly after \"sfk\":\n"
         "\n"
         "         $-nohead -noinfo -nofile -case -literal -spat\n"
         "\n"
         "      for example, in\n"
         "\n"
         "         #sfk -case filt x.txt -high red FooCase +filt -high blue TheBar\n"
         "\n"
         "      the \"-case\" is valid for ALL commands in the command chain.\n"
         "\n"
         );

  printx("   $environment configuration:\n"
         "\n"
         "      $%s SFK_CONFIG=columns:n,active-file-age:n,memlimit:n,...\n"
         "        columns:\n"
         "          sfk (for windows) tries to autodetect the no. of console columns,\n"
         "          but you may also set this value through this config parm.\n",
         pszSet
         );
  printx("        active-file-age:n\n"
         "          some functions need to tell if a file is 'recently edited' or rather\n"
         "          old and inactive. by default, files > 30 days of age are considered\n"
         "          non-active. reconfigure the no. of days threshold here.\n"
         "        memlimit:\n"
         "          set memory limit to n mbytes permanently.\n"
         "        echoonstart:\n"
         "          echo the whole sfk command on start, to stderr.\n"
         "        echoonerr:\n"
         "          echo the whole sfk command on errors, to stderr.\n"
         "        tmpdir:path\n"
         "          set folder for temporary files, used by some commands.\n"
         #ifdef _WIN32
         "          e.g. set SFK_CONFIG=tmpdir:d:\\tmp,memlimit:500\n"
         #else
         "          e.g. set SFK_CONFIG=tmpdir:~/mytmp,memlimit:500\n"
         #endif
         "\n"
         );
  /*
  printx("        memtrace:\n"
         "          sfk always runs a low-overhead memory check, counting the number\n"
         "          of blocks allocated and released. should memory errors appear,\n"
         "          activate deep memory tracing by this switch for more details.\n"
         );
  */
         if (bGlblIgnore3600)
            printx("   info: files with a time difference of 1 hour AND an age > %d days\n"
                   "         are skipped by some commands, e.g. list -sincedir.\n\n", nGlblActiveFileAgeLimit);

         if (nGlblActiveFileAgeLimit != 30)
            printx("   info: active file age limit is currently set to %d days.\n", nGlblActiveFileAgeLimit);
   
         #ifndef _WIN32
         if (glblWildChar != '%') {
            if (!bhelp) setTextColor(nGlblWarnColor);
            printx("   info: wildcard star '*' is currently configured as %c\n", glblWildChar);
            if (!bhelp) setTextColor(-1);
         }
         #endif

  printx("      $%s SFK_ZIP_EXT=\".foo .bar .myext\"\n"
         "        set additional, user defined zip file extensions. in this example,\n"
         "        files ending with .foo, .bar or .myext are also treated like zip files.\n"
         "        for the list of default extensions, look above at the -arc option.\n"
         "\n"
         ,pszSet
         );
   
         if (bGlblConsColumnsSet)
            printx("   sfk currently uses %d console columns for output with some commands.\n", nGlblConsColumns);

         if (bhelp) printx("\n");
         bDone = 1;
      }

      #ifdef _WIN32
      if (bhelp) {
      printx("<help>$sfk help shell\n"
             "\n"
             "   how to configure the windows command prompt "
                "for best productivity\n"
             "\n"
            );
      }
      if (!strncmp(pszSub, "shell", strlen("shell"))) {
      printx(
         "$Configure the windows Command Prompt this way:\n"
         "\n"
         "  1. create a shell shortcut on your desktop:\n"
         "     - Start/Programs/Accessories/Command Prompt,\n"
         "       right mouse button, select Copy.\n"
         "     - go to an empty place on the desktop.\n"
         "     - select Paste.\n"
         "\n"
         "  2. on the new desktop shortcut,\n"
         "     - right mouse button, select Properties.\n"
         "\n"
         "  3. in the Command Prompt Properties, set\n"
         "     - #Options: activate QuickEdit and Insert mode\n"
         "     - #Font   : select 8 x 12\n"
         "     - #Layout : Screen buffer size: Width 160, Height 3000\n"
         "       #         Window size       : Width 160, Height   30\n"
         "\n"
         "  4. close Properties by clicking OK.\n"
         "\n"
         "  5. double-click on the Command Prompt icon to open a shell.\n"
         "\n"
         "$Now you have a well configured power shell:\n"
         "\n"
         "   - any command output is remembered #up to 3000 lines<def>.\n"
         "\n"
         "   - you may select command output anytime with left mouse button,\n"
         "     then click right button #to copy to clipboard<def>.\n"
         "     right click again to #paste clipboard as a command<def>.\n"
         "\n"
         "   - to #pause<def> a program that prints output to the screen,\n"
         "     do a #dummy-select<def> of text with the left mouse button.\n"
         "     to continue program execution, press right button, or enter.\n"
         "\n"
         "$Automatic Command Completion\n"
         "\n"
         "   Question: #how do you enter the directory VeryMuchToTypeFooBarSystem ?\n"
         "\n"
         "   Answer 1: type \"cd verymuchtotypefoobarsystem\"\n"
         "\n"
         "             this is actually what most users do, and it's a waste of time.\n"
         "\n"
         "   Answer 2: #type \"cd very\" and then press the TAB key.\n"
         "\n"
         "             since Windows XP, command completion is default.\n"
         "\n"
         "   Under Win98 and Win2k, completion it is NOT default. As a workaround,\n"
         "   you may type \"cd very*\", or run regedit and set the registry key value\n"
         "   HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\CompletionChar to 9.\n"
         );

         bDone = 1;
      }
      #endif

      if (strBegins(pszSub, "firefox")) {
      printx(
         "$Essential Mozilla Firefox (3.x and higher) tips:\n"
         "\n"
         "  $Creating a profile in a self-defined folder:\n"
         "\n"
         "    By default, Firefox creates a \"default\" profile with the Cache hidden under\n"
         "    $C:\\Documents and Settings\\USERNAME\\Local Settings\\Application Data\\...\n"
         "    and installed extensions and config files hidden under\n"
         "    $C:\\Documents and Settings\\USERNAME\\Application Data\\...\n"
         "    making it very diffcult to access those files directly.\n"
         "    On the command line, enter the Firefox application directory and type\n"
         "    #firefox -profilemanager\n"
         "    then click create/next, type a name like \"foo\", click \"choose folder\"\n"
         "    and select an easy-to-reach directory. After profile creation, type\n"
         "    #firefox -P foo -no-remote<def> to use it. Option -no-remote allows to run\n"
         "    multiple Ffox instances with different profiles.\n"
         "\n"
         "  $Basic settings for Firefox extension developers:\n"
         "\n"
         "    By default, errors in self-written extensions are not shown.\n"
         "    Therefore in the address bar, type #about:config<def> and then\n"
         "    #javascript.options.showInConsole = true\n"
         "    #extensions.logging.enabled = true\n"
         "\n"
         "  $Creating own Firefox extensions:\n"
         "\n"
         "    In the new profile directory, you find an empty directory \"extensions\".\n"
         "    The best way to start developing an extension is to search for \"firefox addons\"\n"
         "    and install an existing small, simple extensions. During the installation,\n"
         "    - an \".xpi\" file is downloaded by Firefox. this is basically a .zip file.\n"
         "    - the file is extracted, the contents are placed within \"extensions\".\n"
         "    So after installation, you find a new folder under \"extensions\",\n"
         "    containing all source code files of that extension.\n"
         "    The important starting points are #install.rdf<def> and #chrome.manifest<def> .\n"
         "    Whenever you change anything in the code, you have to restart Firefox\n"
         "    to apply those changes.\n"
         "\n"
         "    See also: \"sfk sample\", \"sfk sample firefox\".\n"
         );
         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "chain", 5))
      {
      printx("$sfk command chaining reference%s:\n",
             bhelp ? " (type \"sfk help chain\")":"");
      printx("\n"
         "   several commands can be combined in a so-called \"command chain\".\n"
         "   this is done by appending command names prefixed by \"+\", for example:\n"
         "\n"
         "   #sfk list docs .txt +ffilter -+foo\n"
         "      \"list\" produces a filename list and passes this to \"filefilter\".\n"
         "      ffilter reads the contents of these files, looking for the word \"foo\".\n"
         "\n"
         "   $chain data types\n"
         "      there are two types of data which can be passed from one command to another:\n"
         "\n"
         "         #- filename lists.\n"
         "         #- lines of plain text data.\n"
         "\n"
         "      some commands produce filename lists, other text data, some both, some none.\n"
         "\n"
         "   $chain data type conversion\n"
         "      vice versa, some commands accept filenames, or text input, or even both.\n"
         "      depending on what you want to do, it may be necessary to convert between\n"
         "      this types of data. this can be done by the keywords:\n"
         "\n"
         "         #+texttofilenames<def> or #+ttf<def>\n"
         "         #+filenamestotext<def> or #+ftt<def>\n"
         "\n"
         "      however, most sfk commands try to do such conversions automatically.\n"
         "\n"
         "   $dumping chain data between commands\n"
         "      #sfk ... +toterm<def>           dumps current chain content to terminal.\n"
         "      #sfk ... +tofile outfile<def>   dumps chain content to file outfile.\n"
         "      #sfk cmd1 ... +then cmd2<def>   does NOT pass any data to cmd2.\n"
         "      in all cases, the chain is cleared. if another command is following,\n"
         "      it will receive no input from the chain.\n"
         "\n"
         "   $scope and lifetime of options\n"
         "      most options are valid only for the command where they are specified.\n"
         "      if another command follows in the chain, the option is reset.\n"
         "      but some options may also be specified on a global scope.\n"
         "      read more on that under \"$sfk help options<def>\".\n"
         "\n"
         "   $more syntax details\n"
         "      further chain control commands are listed where they make sense.\n"
         "      for example, \"sfk tail\" shows an example on command chain looping.\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "sel", 3))
      {
  printx("$sfk file selection reference%s:\n"
         "\n"
         "   $default principles of most sfk commands:\n"
         "\n"
         "      - subdirectory (subfolder) processing is done by default.\n"
         "      - filename comparison is case insensitive.\n"
         "      - hidden and system files are not processed,\n"
         "        except for some commands like copy.\n"
         "      - symbolic links are followed.\n"
         "\n"
         "        type \"sfk help options\" on how to change that.\n"
         "\n"
         "   $how to select directories and contained filenames:\n"
         "\n"
         "   sfk provides many ways of specifying which files you want to process,\n"
         "   from very simple but unflexible to very detailed.\n"
         "\n",
         bhelp ? " (type \"sfk help select\")":""
         );
  printx("   $1. short format file selection:\n"
         "\n"
         "      $dirname [filemask1] [filemask2] [<not>fileexcludemask] [...]\n"
         "\n"
         "      this format supports ONE directory name, followed by many file masks.\n"
         "      it can be used with most commands processing directory trees.\n"
         "\n"
         "      example:\n"
         "\n"
         "      #sfk list mydir foo bar <not>-tmp .txt .zip\n"
         "         selects all files\n"
         "         - in directory mydir and all its subdirectories\n"
         "         - having foo OR bar in their filename (no * required)\n"
         "         - but not having -tmp in their filename\n"
         "         - and ending with .txt OR .zip (no *.txt required)\n"
         "\n"
         "      supported by commands:\n"
         "         list, select, stat, run, detab, scantab, hexdump and some more.\n"
         "\n"
         );
  printx("   $2. long format file selection:\n" 
         "\n"
         "      $-dir root1 [root2] [<wild>pathmask<wild>] [...] [-file mask1 [mask2] [...]]\n"
         "         $[-dir root3 root4 <not>direxcludemask -file mask3 <not>xmask4] [...]\n"
         "\n"
         "      this format supports\n"
         "\n"
         "      - several root directory sets, starting with -dir, each of them\n"
         "        containing many directories, path masks or dir exclusion masks.\n"
         "        a path mask is an expression in a directory set containing a\n"
         "        wildcard character \"<wild>\". a dir exclusion mask is started\n"
         "        by <not> and may be surrounded by <sla> to select exact dir names.\n"
         "\n"
         "      - a file mask set per root directory set, starting with -file.\n"
         "        this may also contain file exclusions starting with <not>\n"
         "\n"
         "      supported by:\n"
         "         nearly every command than can process file sets.\n"
         "\n");
  printx("      $to select all dirs of current dir except something:\n"
         "      #-dir . <not>foo       <def>-> exclude subdirs like *foo*\n"
         "      #-dir . <not>.foo      <def>-> exclude with extension .foo\n"
         "      #-dir . <not><sla>foo      <def>-> exclude starting with foo\n"
         "      #-dir . <not>foo<sla>      <def>-> exclude ending with foo\n"
         "      #-dir . <not><sla>foo<sla>     <def>-> exclude exactly foo\n"
         "      #-dir . <not><sla>foo<sla>bar<sla> <def>-> exclude subdir combi\n"
         "      #-dir . <not><wild>.foo<wild>    <def>-> exclude with .foo anywhere\n"
         "\n"
         "      $to select only sub dirs of current dir with something:\n"
         "\n"
         "      using wide sub dir expressions:\n"
         "      #-dir . -subdir foo       <def>-> include paths having *foo*\n"
         "      #-dir . -subdir <sla>foo      <def>-> include paths having *<sla>foo\n"
         "      #-dir . -subdir foo<sla>      <def>-> include paths having *foo\n"
         "      #-dir . -subdir <sla>foo<sla>     <def>-> include paths exactly foo\n"
         "      #-dir . -subdir .foo      <def>-> include with extension .foo\n"
         "      #-dir . -subdir <sla>foo<sla>bar<sla> <def>-> include subdir combi\n"
         "      instead of -subdir, you may also type just -sub\n"
         "\n"
         "      using compact sub dir expressions:\n"
         "      #-dir . <wild>foo<wild>      <def>-> include paths having *foo*\n"
         "      #-dir . <wild><sla>foo      <def>-> include paths having <sla>foo\n"
         "      #-dir . <wild>foo<sla>      <def>-> include paths having foo<sla>\n"
         "      #-dir . <wild><sla>foo<sla>     <def>-> include paths exactly foo\n"
         "      #-dir . <wild>.foo      <def>-> include with extension .foo\n"
         "      #-dir . <wild><sla>foo<sla>bar<sla> <def>-> include subdir combi\n"
         "\n"
         "      $exclusion by filename:\n"
         "      #-file <not>foo        <def>-> exclude all files like *foo*\n"
         "      #-file <not><sla>foo       <def>-> exclude starting with foo\n"
         "      #-file <not>foo<sla>       <def>-> exclude ending with foo\n"
         "      #-file <not><sla>foo<sla>      <def>-> exclude exactly foo\n"
         "      #-file <not>.foo       <def>-> exclude extension foo\n"
         "\n"
         "      $inclusion by filename:\n"
         "      #-file foo         <def>-> include all files like *foo*\n"
         "      #-file <sla>foo        <def>-> include starting with foo\n"
         "      #-file foo<sla>        <def>-> include ending with foo\n"
         "      #-file <sla>foo<sla>       <def>-> include exactly foo\n"
         "      #-file .foo .bar   <def>-> select .foo and .bar files\n"
         "\n"
         "      $examples:\n"
         "\n"
         "      #sfk scantab -dir mydir1 mydir2 <wild>include<wild> -file foo bar .hpp\n"
         "         scans all files for TAB characters\n"
         "         - in directory mydir1 and all its subdirectories\n"
         "           AND\n"
         "         - in directory mydir2 and all its subdirectories\n"
         "           IF\n"
         "           - 1. the file path contains the word \"include\",\n"
         "             e.g. mydir1\\core\\include\\foosys.hpp\n"
         "           - 2. the filename contains foo OR bar\n"
         "           - 3. or the filename ends with .hpp\n"
         "\n"
         "      #sfk scantab -dir mydir1 <not>include -file <not>.tmp <not>.save\n"
         "         scans all files for TAB characters in folder mydir1,\n"
         "         excluding all sub dirs having \"include\" in their name,\n"
         "         and excluding all .tmp and .save files.\n"
         "\n"
         "      #sfk list -dir source include -subdir save <not>.svn -file .bak\n"
         "         list .bak files from directory trees source and include,\n"
         "         within in sub directories having \"save\" in their name,\n"
         "         excluding sub directories ending with \".svn\".\n"
         "\n"
         "      #sfk list -dir source include <wild>save <not>.svn -file .bak\n"
         "         the same as above, written in compact subdir format:\n"
         "         subdir inclusion masks require a wildcard <wild> anywhere\n"
         "         to make it clear they're no root directories.\n"
         "         subdir exclusion masks can stay as they are.\n"
         "\n"
         );
  printx("   $3. single parameter file set selection:\n"
         "\n"
         "      some commands like find, filter or tail do not accept the full\n"
         "      short format, but only a single file or dir parameter, as it\n"
         "      would get too complicated mixing the short format with local\n"
         "      options. find more on that in the command's local help.\n"
         "\n"
         );
  printx("   $4. passing filename lists in command chains:\n"
         "\n"
         "      instead of selecting files in the current command, you may use\n"
         "      a filename list created by a previous command, for example:\n"
         "\n"
         "      #sfk select mydir .txt +detab=3\n"
         "         selects all .txt files from directory mydir, then passes\n"
         "         this file list to detab, where the files are detabbed.\n"
         "\n"
         "      command chaining is more intuitive, as you can play around\n"
         "      with different file sets before executing actual changes\n"
         "      on the selected files.\n"
         "\n"
         "      #sfk filter names.txt +texttofilenames +list -late\n"
         "         provided that names.txt contains a list of filenames,\n"
         "         this command chain lists the most recent of these files.\n"
         "         note that in this case, it is unclear if to pass\n"
         "         - the filename \"names.txt\" or\n"
         "         - the line contents from within names.txt\n"
         "         as filenames to \"list\", therefore we need to insert\n"
         "         +texttofilenames or +ttf to enforce a conversion.\n"
         "\n"
         "      supported by:\n"
         "         some commands. check each command's local help for more.\n"
         "\n"
         );
  printx("   $see also:\n"
         "      #sfk help options<def>  general options for most commands.\n"
         "      #sfk list<def>          for more file selection examples.\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strncmp(pszSub, "pat", 3))
      {
      printx("$sfk wildcards and text patterns%s:\n",
             bhelp ? " (type \"sfk help patterns\")":"");
      printx("\n"
         "   $available wildcards:\n"
         "      * = any number of characters.\n"
         "      ? = a single character.\n"
         "\n"
         "   $available slash patterns:\n"
         "      \\t   = TAB\n"
         "      \\q   = double quote \"\n"
         "      \\r   = carriage return\n"
         "      \\n   = linefeed\n"
         "      \\xnn = any character with hexadecimal value nn,\n"
         "             e.g. \\x09 is the same as \\t (TAB)\n"
         "      \\\\   = the backslash \\ itself\n"
         "      \\\\*   = the star '*' itself     [only with some commands]\n"
         "      \\?   = quotation mark '?'      [only with some commands]\n"
         "\n"
         "   $support by commands:\n"
         "\n"
         "      if any command supports slash patterns,\n"
         "\n"
         "      - they are not active by default, except for commands\n"
         "        starting with \"x\" that use SFK Expressions.\n"
         "\n"
         "      - to use, say -spat directly after the command name:\n"
         "        #sfk echo -spat \"three\\tlittle\\ttabs\\t.\"\n"
         "        prints: #three   little  tabs    .\n"
         "\n"
         "      - to activate slash patterns globally over multiple commands\n"
         "        of a command chain, say -spat directly after \"sfk\":\n"
         "        #sfk -spat echo \"two\\ttabs\" +filter -rep \"x\\tx_x\"\n"
         "        prints: #two_tabs\n"
         "\n"
         "      if any command supports wildcards,\n"
         "\n"
         "      - they are active by default.\n"
         "\n"
         "      - they can be deactivated by option -literal or -lit,\n"
         "        if you need to find/replace '*' or '?' characters themselves:\n"
         "        #sfk echo \"*** ok ***\" +filter -lit -rep \"_*_=_\"\n"
         "        prints: #=== ok ===\n"
         "\n"
         "      - to deactivate globally over multiple commands of a chain,\n"
         "        say -literal directly after \"sfk\":\n"
         "        #sfk -literal echo \"*** ok ???\" +filter -lit -rep \"_?_!_\"\n"
         "        prints: #*** ok !!!\n"
         "\n"
         "      - another way to find/replace '*' or '?' is to say -spat\n"
         "        and then to use \\\\* and \\? patterns:\n"
         "        #sfk echo \"*** ok ***\" +filter -spat -rep \"_\\\\*_=_\"\n"
         "        prints: #=== ok ===\n"
         "\n"
         "      further reading:\n"
         "\n"
         "         $sfk help options<def> - general options reference\n"
         "         $sfk help chain<def>   - about command chaining\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || strBegins(pszSub, "uni") || strBegins(pszSub, "utf"))
      {
      printx("$sfk unicode file read support%s:\n",
             bhelp ? " (type \"sfk help unicode\")":"");
      printx("\n"
         "   by default, sfk commands that need to read TEXT files will\n"
         "   skip utf-16 (ucs-2, wide char) files, as they look like binary,\n"
         "   containing zero bytes.\n"
         "\n"
         "   you may set option \"#-wchar<def>\" to activate utf-16 detection and decoding\n"
         "   for file READING, allowing to search for words also in unicode files.\n"
         "\n"
         "   -wchar works with text processing commands like sfk filter and sfk find.\n"
         "   (sfk hexfind will ignore the option, as it reads everything as binary)\n"
         "\n"
         "   the decoding is primitive and simply strips every 2nd byte,\n"
         "   meaning that only the lowest code points are supported.\n"
         "\n"
         "   $NOTE:<def> option \"-wchar\" is #experimental<def> and shall #not<def> be used if you want\n"
         "         to #write<def> any text file contents! (e.g. with sfk filter ... -write)\n"
         "         during write, the utf-16 format will be replaced by a primitive\n"
         "         plain ascii format (NOT a proper conversion - sfk will just\n"
         "         drop every 2nd byte from the file) which is often not desirable.\n"
         "\n"
         "   $examples\n"
         "      #sfk -wchar filter mydir -+foo\n"
         "         filter \"foo\" in all text files of mydir, including utf-16.\n"
         "      #sfk -wchar find mydir foobar\n"
         "         find \"foobar\" in all files of mydir, including utf-16.\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || strBegins(pszSub, "compile"))
      {
      printx("$sfk compile on any linux system%s:\n",
             bhelp ? " (type \"sfk help compile\")":"");
      printx("\n"
         "   To compile SFK on any linux system like 64 bit ubuntu\n"
         "   follow these steps:\n"
         "\n"
         "   $1. make sure a C++ compiler is installed:\n"
         "      sudo apt-get install g++\n"
         "\n"
         "   $2. download the sfk source code .tar.gz\n"
         "      wget http://stahlworks.com/sfk.tar.gz\n"
         "\n"
         "   $3. compile by\n"
         "      gzip -d sfk.tar.gz\n"
         "      tar xvf sfk.tar\n"
         "      cd sfk-" SFK_VERSION "\n"
         "      ./configure\n"
         "      make\n"
         "\n"
         "   $4. IF configure/make don't work for any reason\n"
         "      $try a manual compile by:\n"
         "      g++ -s sfk.cpp sfkext.cpp -o sfk\n"
         "\n"
         "   To compile SFK under Windows, download the .zip package\n"
         "   from sourceforge, then look into do-compile-win.bat\n"
         "\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      // #if def VFILEBASE
      #ifndef VFILEMAX
      if (bhelp || !strcmp(pszSub, "xe"))
      {
      printx("$about sfk xe:\n",
             bhelp ? " (type \"sfk help xe\")":"");
      printx("\n"
         "   Swiss File Knife Extended Edition (SFK XE) is the commercial\n"
         "   edition of SFK, available from StahlWorks Technologies.\n"
         );
      printx("\n"
         " $SFK XE Archive File Content Reading\n"
         "\n"
         "   Swiss File Knife Extended Edition features full content\n"
         "   reading of .zip, .jar, .ear, .war and .aar files.\n"
         "\n"
         "   sfk xe can not only read top-level contents of a zip,\n"
         "   but also contents of zips embedded within other zips,\n"
         "   e.g. jar archives within a zip package.\n"
         "\n"
         "   under xe, the following commands provide zip processing:\n"
         "\n"
         "      find, hexfind, xfind, xtext, xhexfind, extract,\n"
         "      list, filter, snapto\n"
         "\n"
         "   as usual, the output of such commands (text streams or filename lists)\n"
         "   can be processed by subsequent chain commands, just as with sfk base.\n"
         "\n"
         "   $LIMITATIONS:\n"
         "\n"
         "   -  zip file contents #must fit completely into memory<def>.\n"
         "      in general, zip files below 100 mb should be ok.\n"
         "      contents larger then the current -memlimit (default: 300mb)\n"
         "      will be skipped. if you increase the -memlimit, your machine\n"
         "      must have enough memory, or sfk may run endless or even crash.\n"
         "\n"
         "   -  the zip files must use a #normal compression format (%s%s)<def>,\n"
         "      e.g. as it is produced by the InfoZIP or WinZIP tool.\n"
         "      (most zip files in the internet use normal compression.)\n"
         "      exotic compressions and 64-bit zip files are NOT supported.\n"
         "\n"
         "   -  time or attribute informations (sfk list -time ...) of zip\n"
         "      file entries may be inaccurate or missing, all you get is\n"
         "      the actual contents (zip file entry data) for processing.\n"
         , "de", "flate"
         );

      printx("\n"
         "   $examples\n"
         "\n"
         "      #sfk list -arc -time -size -tofile lslrx .\n"
         "         list all files, all contents of zip, jar etc. archives,\n"
         "         and all files of archives contained within archives,\n"
         "         creating one large file list within file \"lslrx\".\n"
         "         type \"sfk list\" to get more infos on that example.\n"
         "\n"
         "      #sfk filt -arc \"-ls+public class\" -dir src.zip -file .java\n"
         "         find public classes in all .java files of src.zip\n"
         );

      printx("\n"
         " $SFK XE Fast Replace\n"
         "\n"
         "   Swiss File Knife Extended Edition contains a different\n"
         "   implementation of the replace command, allowing high speed\n"
         "   different-length replacements in large files. It can replace\n"
         "   directly from one file to another file, or use temporary files\n"
         "   to store the output intermediately. This means the file size\n"
         "   is not limited by the available memory, and even files with\n"
         "   many gigabytes of size can be processed.\n"
         );
      
      // #if ndef SFKOSE
      printx("\n"
         " $SFK XE Replace with Wildcards and SFK Expressions\n"
         "\n"
         "   Swiss File Knife Extended Edition contains commands\n"
         "   $xreplace, xhexfind, extract<def> and $xed<def> which support\n"
         "   wildcards * and ? as well as SFK Expressions\n"
         "   within brackets []. SFK Expressions are NOT regular\n"
         "   expressions but use a simpler, human readable syntax.\n"
         "   Type #sfk help xpat<def> for the full SFK Expression syntax.\n"
         );
      // #end if

      printx("\n"
         "   $SFK Extended Edition is available from:\n"
         "\n"
         "      http://stahlworks.com/\n"
         "\n"
         );

         if (bhelp) printx("\n");
         bDone = 1;
      }
      #endif
      // #end if // VFILEBASE

      // #if def SFKXDXE
      if (bhelp || !strcmp(pszSub, "xpat"))
      {
         printx("\n");

         printSFKMatchHelp(1, 0);

         printXRepExamples(str("xhex"), 1, 1);

         if (bhelp) printx("\n");
         bDone = 1;
      }
      // #end if // SFKXDXE

      if (bhelp || !strcmp(pszSub, "fileset"))
      {
      printx("$using filesets%s:\n",
             bhelp ? " (type \"sfk help fileset\")":"");
      printx("\n"
             "   if you want to process many directory trees and dir/file masks,\n"
             "   you may create a fileset, which is a text file containing directories\n"
             "   and file masks, as well as remark and blank lines for better readability.\n"
             "\n"
             "   $example file zz-myfiles.txt:\n"
             "\n"
             "      ## stat the fooproj folders.\n"
             "      ## this is a remark line.\n"
             "\n"
             "      -dir fooproj\\src\n"
             "             <not>\\save\\\n"
             "             <not>\\tmp\\\n"
             "           -file .hpp .cpp <not>.bak\n"
             "\n"
             "      -dir \"C:\\Docs With Blanks\"\n"
             "           -subdir <sla>current<sla>\n"
             "           -file <not>.tmp\n"
             "\n"
             "   $this can be used in a command like:\n"
             "\n"
             "      #sfk stat -fileset zz-myfiles.txt\n"
             "\n"
             "         lists size statistics of directory trees x:\\fooproj\\src\n"
             "         and x:\\foodb to z:\\ . any directory \"\\save\" or \"\\tmp\" within\n"
             "         fooproj\\src is excluded. within foodb, everything is included,\n"
             "         except .tmp files. you can also add remarks starting with \"##\"\n"
             "\n"
             "      #sfk snapto=mycache.txt -fileset zz-fileset.txt\n"
             "\n"
             "         collects all text specified by zz-fileset.txt into a large\n"
             "         snapfile \"mycache.txt\" (a snapshot of all text content).\n"
             "         this can be loaded by any text editor, or even better,\n"
             "         by the high speed text browser Depeche View which is\n"
             "         optimized for loading snapfiles (type \"sfk view\" for more).\n"
             "\n"
             "   $using flat filename lists:\n"
             "\n"
             "      as an alternative to specifying dir- and file masks,\n"
             "      option -fileset also accepts a flat filename list, like:\n"
             "\n"
             "         foo1.txt\n"
             "         foo2.txt\n"
             "         mydir1\\foo\\bar2.txt\n"
             "\n"
             "   the -fileset option is supported by most commands that accept\n"
             "   the -dir ... -file ... syntax, e.g. list, snapto, md5gento,\n"
             "   but not yet with sfk find or grep.\n"
             );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (bhelp || !strcmp(pszSub, "knx"))
      {
      printx("$knx messaging%s:\n",
             bhelp ? " (type \"sfk help knx\")":"");
      printx("\n"
             "   SFK may print KNX IP messages like:\n"
             "\n"
             "      #sfk udpdump -knx\n"
             "          print messages on the default group 224.0.23.12\n"
             "          in a minimum single line format\n"
             "\n"
             "      #sfk udpdump -knxfull 224.0.23.13\n"
             "          print full messages on an alternative IP group\n"
             "\n"
             "      #sfk knxdump -text \" 1/*/3 \" -from=100\n"
             "          print only messages having GA's starting 1 and\n"
             "          ending 3 in their knx header info text, coming from\n"
             "          an IP like 192.168.1.100 in the local network\n"
             "\n"
             "   SFK may send KNX IP messages like:\n"
             "\n"
             "      #sfk udpsend -knx \"1 2 3 1 0\"\n"
             "          send to group address 1/2/3 a 1 bit value \"0\".\n"
             "\n"
             "      #sfk knxsend \"1 2 3 8 255\"\n"
             "          send to group address 1/2/3 an 8 bit value \"255\".\n"
             "\n"
             "   $NOTE:<def> because this uses multicast I/O it may\n"
             "         or may not work, depending on many factors.\n"
             "         see \"sfk udpdump\" for details.\n"
             "\n"
             );

         if (bhelp) printx("\n");
         bDone = 1;
      }

      if (!bhelp) {
         if (!bDone) {
            fprintf(stderr, "unknown help subject: %s.\n", pszSub);
            fprintf(stderr, "type just \"sfk\" for the main help.\n");
            fprintf(stderr, "type \"sfk ask %s\" to search all help text.\n", pszSub);
         }
         return 9;
      }
   }

   ifcmd (!strcmp(pszCmd, "faq")) 
   {
      ifhelp (1)
      printx(

// 
"start of filename comparison: use \"\\pattern\". see also \"name start\"\n"
"traveling, walking subdirectories or subfolders: is default. type \"sfk help select\"\n"
"find in text files: \"sfk find\", \"sfk hexfind\", \"sfk filter\"\n"
"find text, data in binary files, binaries: \"sfk find\", \"sfk hexfind\"\n"
"find same, identical, duplicate files: \"sfk dupfind\"\n"
"compare directories, folders, differences: \"sfk list\" with -sincedir option\n"
"find different files, differences: \"sfk md5check\", \"sfk list\" with -sincedir\n"
"list, find newest, oldest, latest files of dir: \"sfk list\" with -late, -old\n"
"list, find most recent files of dir: \"sfk list\" with -late, -old\n"
"list, sort, order dir files by date, timestamp: \"sfk list\" with -late, -old\n"
"list, find largest, biggest, smallest dir files: \"sfk list\" with -big, -small\n"
"list, find files changed today, since a date: \"sfk list\" with -since\n"
"sort dir contents by date, time, size: \"sfk list\" with -late, -big\n"
"symbolic links: no option under windows. under linux (not lib5) see \"sfk help opt\"\n"
"regular expressions: not supported, but see \"sfk help patterns\"\n"
"list, show files, directory tree size, largest dirtree: see \"sfk stat\"\n"
"split text lines, column data by characters: \"sfk filter\" with -sep, -form\n"
"extract, remove text blocks between marker lines: \"sfk filter\" with -inc, -cut\n"
"create, verify md5sum, md5 checksum for dir, files: \"sfk md5gento\", \"sfk md5check\", \"sfk md5\"\n"
"convert binary to c++, cpp, java sourcecode: \"sfk bin-to-src\"\n"
"split large text or binary files: \"sfk split\"\n"
"transfer files from windows host to linux vmware: \"sfk ftpserv\", \"sfk ftp\"\n"
"find, where are classes inside, within jar files tree: \"sfk list\" with -arc\n"
"all class packages in jar dirs: \"sfk list\" with -arc\n"
"list, get all files in jars in all dirs: \"sfk list -arc . .jar\"\n"
"find, replace words in text, binary files: \"sfk replace\", \"sfk filter\"\n"
"find, replace hex pattern in binary files: \"sfk hexfind\", \"sfk replace\"\n"
"patch binary file contents: \"sfk replace\"\n"
"convert text file, dos, windows, linux crlf line endings, format: \"sfk addcr\", \"sfk remcr\"\n"
"replace, add, remove, strip, convert text file crlf line endings: \"sfk addcr\", \"sfk remcr\"\n"
"find, print, read first, last lines of text files: \"sfk head\", \"sfk tail\"\n"
"print, read head or tail of files: \"sfk head\", \"sfk tail\"\n"
"find command, cmd, bat, exe file in path: \"sfk pathfind\"\n"
"remove, replace tabs by spaces in text file lines: \"sfk detab\"\n"
"insert, remove text in files: \"sfk replace\", \"sfk filter\" with -write\n"
"find, list files in a dir sorted by size, time: \"sfk list\" with -big, -late\n"
"copy content, extract, view text of a binary file: \"sfk partcopy\", \"sfk strings\"\n"
"run user defined command, processing many files: \"sfk run\"\n"
"run a command on each file, line of file: \"sfk run\", \"sfk filter thefile.txt +run \"mycmd <run>text\"\"\n"
"replace, remove spaces in filenames, dir names: \"sfk deblank\"\n"
"join, add text, binary files: \"sfk snapto\", \"sfk join\"\n"
"adding delay, pause to command file: \"sfk sleep\", \"sfk pause\"\n"
"set, create, define alias for .cmd, .bat, command path in shell: \"sfk alias\"\n"
"delete .bak, .tmp, temporary files: \"sfk sel . .bak +del\"\n"
"convert binary file to text, source code: \"sfk hexdump\", \"sfk bin-to-src\"\n"
"hex to byte, convert hex dump, file into binary file: \"sfk hextobin\"\n"
"count files in dir tree: \"sfk list ... +count\"\n"
"create text file from dir listing: \"sfk list ... +tofile\"\n"
"create large text, binary file for tests: \"sfk make-random-file\"\n"
"delete files by extension: \"sfk del mydir .ext\"\n"
"trace, hexdump, dump TCP data, browser connection: \"sfk tcpdump\"\n"
"tcpdump of http request in plain text: \"sfk tcpdump\" with -flat\n"
"echo staying on same line, without lf: \"sfk echo\" with -noline\n"
"shell echo with colored words in red, green, blue: \"sfk echo\"\n"
"open, read text from clipboard: \"sfk fromclip\"\n"
"file copy to clipboard: \"sfk filter ... +toclip\"\n");
printx(
"find unprintable, nonprintable characters : \"sfk hexfind\" with -bin\n"
"find duplicate lines in a text file: \"sfk count\" with -samelines\n"
"find data, hex numbers in binary files: \"sfk hexfind\"\n"
"find, replace text with wildcards: \"sfk filter\"\n"
"find, get, list files matching patterns: \"sfk list\"\n"
"cut, remove, filter empty, blank lines from text files: \"sfk filter\" with -no-blank-lines\n"
"replace any, accent, umlaut characters in text files: \"sfk replace\"\n"
"check, find dependencies of binaries, executables files: \"sfk deplist\"\n"
"find, list number of files in a directory: \"sfk list mydir +count\"\n"
"add current, any dir to a file list: \"sfk list . >>myfilelist.txt\"\n"
"strip, skip text file lines by filter, markers: \"sfk filter\" with -!mypattern or -cut\n"
"cut, strip, exclude lines by words from text files: \"sfk filter\" with -!word1 -!word2\n"
"list files of dir needing no wildcard: \"sfk list mydir *foo*\" == \"sfk list mydir foo\"\n"
"write shell script with command chaining: \"sfk script\", \"sfk samp\"\n"
#ifdef _WIN32
"to create multi line commands, use ^ at the end of .bat lines, or \"sfk script\"\n"
#else
"to create multi line commands, use \"sfk script\"\n"
#endif
"if content(s) are too large to load, see -memlimit under \"sfk help opt\"\n"
"replace colors in text lines: \"sfk filter\" with -highlight\n"
"jpeg, jpg, png image processing, conversion: \"sfk samp javaimg\", \"sfk samp phpimg\""
 " or google for imagemagick.\n"
"all zip tar gz bz2 file extensions recognized by sfk: type \"sfk help opt\"\n"
"process files changed from, until a date: see option -since and -before\n"

      );
#ifdef _WIN32
      printx(
"print, get, dump clipboard contents: \"sfk fromclip\"\n"
      );
#endif
      ehelp;
      // no real action here
      return 9;
   }

   if (!strcmp(pszCmd, "syntest")) {
      lRC = runSyntaxTests(penv);
      bDone = 1;
      // fall through to exit
   }

   ifcmd (!strcmp(pszCmd, "loop"))
   {
      ifhelp (iDir == iDirStart)
      printx("<help>$sfk ... +loop\n"
             "\n"
             "   repeat (loop) the execution of a command chain.\n"
             "\n"
             "   when using +loop in an sfk script file,\n"
             "   always add +end after it (+loop +end).\n"
             "\n"
             "   $see also\n"
             "      sfk tail - a script example with looping\n"
             "\n"
             "   $examples\n"
             "      #sfk list -late mydir +sleep 5000 +loop\n"
             "         list most recent files of mydir every 5 sec.\n"
             );
      ehelp;

      if (!userInterrupt()) {
         // dump pending text data from the pipes
         // chain.flush();
         // restart command sequence
         pszCmd = pszCmdStart;
         iDir   = iDirStart;
         nparm  = argc - iDir;
         // reset all chain settings
         chain.reset();
         // rerun from start (past global prefix options)
         bChainCycle = 1;
      }
      bDone = 1;
   }

   if (!strcmp(pszCmd, "cmd"))
   {
      char *pszbook = (char*)strstr(szGlblBookSamp, szGlblHelpCmdPat);

      if (pszbook)
      {
         pszbook += strlen(szGlblHelpCmdPat);
         char *psz2 = pszbook;
         if (*pszbook==' ') {
            pszbook++;
            psz2 = strstr(pszbook, "{EOS}");
            if (!psz2)
               return 9+perr("int. error in example text\n");
         } else {
            while (*psz2!=0 && *psz2!='\r' && *psz2!='\n')
               psz2++;
         }
         int ilen=mymin(psz2-pszbook,(int)sizeof(szGlblHelpCmdText)-10);
         memcpy(szGlblHelpCmdText,pszbook,ilen);
         szGlblHelpCmdText[ilen]='\0';
      }
      else
      {
         // szGlblHelpCmdText should now contain the searched example
         bhelp = bGlblCollectHelp = 0;
   
         if (iGlblCollectCmd != 2)
         {
            iGlblCollectCmd = 0;
            return 9+perr("example command not found: %s", szGlblHelpCmdPat);
         }
         iGlblCollectCmd = 0;
      }

      int iChainNext = 0;
      bool bRun = 0;
      char *pszFile = 0;

      for (; iDir<argc; iDir++)
      {
         char *pszArg  = argv[iDir];
         char *pszParm = 0;
         if (haveParmOption(argv, argc, iDir, "-tofile", &pszParm)) {
            if (!pszParm) return 9;
            pszFile = pszParm;
            continue;
         }
         else
         if (!strcmp(pszArg, "-run")) {
            bRun = 1;
            continue;
         }
         else
         if (!strncmp(pszArg, "-", 1)) {
            if (isDirParm(pszArg))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", pszArg);
         }
         else
         if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
            break;
         // process non-option keywords: already done before
      }

      if (pszFile)
      {
         if (!cs.force && fileExists(pszFile)) {
            perr("file already exists: %s\n", pszFile);
            pinf("add -force to overwrite.\n");
            return 9;
         }
         if (!saveFile(pszFile, (uchar*)szGlblHelpCmdText, strlen(szGlblHelpCmdText)))
            printf("written: %s\n", pszFile);
      }
      else
      {
         setTextColor(nGlblHeadColor);
         printf("%s\n", szGlblHelpCmdText);
         setTextColor(-1);
         
         #ifdef _WIN32
         putClipboard(szGlblHelpCmdText);
         #endif
   
         if (bRun)
            system(szGlblHelpCmdText);
      }

      bDone = 1;
   }

   if (!strcmp(pszCmd, "dumphelp") || !strcmp(pszCmd, "ask"))
   {
      // chain data is now filled with help text
      bhelp = bGlblCollectHelp = 0;

      bool bdump = !strcmp(pszCmd, "dumphelp");

      StringTable apat;
      char *ppre1=0, *ppre2=0;
      bool bdumpmiss = 0; // internal: only tell if a miss occured
      bool bhit      = 0;
      int  iDirRaw   = iDir;
      bool bprocopt  = 0;
      int  nrawpat   = 0;

      int iChainNext = 0;
      for (; iDir<argc; iDir++) 
      {
         if (!strcmp(argv[iDir], "-dumpmiss")) {
            bdumpmiss  = 1;
            cs.quiet = 1;
            continue;
         }
         else
         if (!strcmp(argv[iDir], "-opt")) {
            bprocopt = 1;
            continue;
         }
         else
         if (bprocopt && !strncmp(argv[iDir], "-", 1)) {
            if (isDirParm(argv[iDir]))
               break; // fall through
            if (setGeneralOption(argv, argc, iDir))
               continue;
            else
               return 9+perr("unknown option: %s\n", argv[iDir]);
         }
         // else
         // if (isChainStart(pszCmd, argv, argc, iDir, &iChainNext))
         //    break;
         // process non-option keywords:
         nrawpat++;
         char *prawpat  = argv[iDir];
         char *pfiltpat = filterAskPattern(prawpat, ppre1, ppre2);
         if (pfiltpat) apat.addEntry(pfiltpat);
         ppre2 = ppre1;
         ppre1 = prawpat;
      }

      // sfk ask requires word(s)
      if (!bdump && !nrawpat) {
         perr("sfk ask requires one or more words.");
         return 9;
      }

      // did user supply a useable query phrase?
      int npat = apat.numberOfEntries();
      if (nrawpat > 0 && !npat) {
         perr("the given words are too generic, and cannot be used for search.");
         pinf("please rephrase your query with more precise words.\n");
         return 9;
      }

      // just for chaining:
      if ((lRC = processDirParms(pszCmd, argc, argv, iDir, 0, &iChainNext))) return lRC;

      // if search terms are supplied
      if (!iChainNext || (npat > 0))
      {
         // dump help contents now, optionally filtered by words
         int i=0,k=0,nlastdump=-1;

         if (!bdump && !iChainNext && !cs.quiet)
         {
            // tell short info what is really used for search
            setTextColor(nGlblTimeColor, 1);
            printf("using: ");
            for (i=0; i<npat; i++) {
               printf("%s ", apat.getEntry(i, __LINE__));
            }
            printf("\n");
            setTextColor(-1, 1);
         }

         StringPipe *phelp = chain.outdata;
         bool bfirst=1,bpostlf=0;
         for (i=0; i<phelp->numberOfEntries(); i++) 
         {
            char *pattr = 0;
            char *pline = phelp->getEntry(i, __LINE__, &pattr);

            if (pattr) strcopy(szAttrBuf, pattr);
            else { mclear(szAttrBuf); }

            int nhit=0,npos=0;
            for (k=0; k<npat; k++) {
               char *ppat = apat.getEntry(k, __LINE__);
               if (mystrstrip(pline, ppat, &npos)) {
                  nhit++;
                  if (npos + strlen(ppat) < MAX_LINE_LEN)
                     memset(szAttrBuf+npos, 'a', strlen(ppat));
               }
            }

            if (bdump)
               printColorText(pline, szAttrBuf);
            else
            if (nhit == npat) 
            {
               int nindmax = indent(pline);

               char *pcachetxt = 0;
               char *pcacheatt = 0;

               if (nindmax <= 0) {
                  if (bfirst)
                     bfirst=0;
                  else
                  if (bpostlf) {
                     if (!bdumpmiss)
                        printf("\n");
                  }
                  bpostlf = (szAttrBuf[0] == 'i');
               }
               else
               {
                  bpostlf = 1;

                  // dump context before hit line
                  char *papre=0, *plpre=0;
                  int ictx=0,ifwd=0;
   
                  // 1. walk back to zero indent
                  for (ictx=i-1; ictx>=0 && ictx>nlastdump; ictx--) 
                  {
                     plpre = phelp->getEntry(ictx, __LINE__, &papre);
                     if (plpre[0] && plpre[0] != ' ' && plpre[0] != '\t')
                        break;
                  }
                  if (ictx < 0) return 9+perr("int. #148281153");
   
                  // 2. walk forward, dump every indent change
                  if (ictx > nlastdump) 
                  {
                     if (bfirst) bfirst=0; else {
                        if (!bdumpmiss)
                           printf("\n");
                     }
                     int nindcur=0;
                     for (ifwd=ictx; ifwd<i; ifwd++) 
                     {
                        plpre = phelp->getEntry(ifwd, __LINE__, &papre);
                        int nindfwd = indent(plpre);
                        // whenever indent changes, dump previous.
                        // also dump zero indent line.
                        if (ifwd==ictx || (nindfwd >= nindcur && nindfwd < nindmax))
                        {
                           if ((nindfwd > nindcur) && pcachetxt) {
                              if (bdumpmiss) bhit=1; else
                              printColorText(pcachetxt, pcacheatt);
                           }
                           pcachetxt = plpre;
                           pcacheatt = papre;
                           nindcur = nindfwd;
                        }
                     }
                  }
               }
               // previous context remaining?
               if (pcachetxt) {
                  if (bdumpmiss) bhit=1; else
                  printColorText(pcachetxt, pcacheatt);
               }
               // dump hit line
               if (bdumpmiss) bhit=1; else
                  printColorText(pline, szAttrBuf);
               nlastdump = i;
            }
         }
         chain.reset();
      }

      if (bdumpmiss && !bhit) {
         printf("miss: sfk ask ");
         for (; iDirRaw<argc; iDirRaw++) 
            if (!strBegins(argv[iDirRaw], "-dump"))
               printf("%s ",argv[iDirRaw]);
         printf("\n");
         return 1;
      }

      STEP_CHAIN(iChainNext, 1);

      bDone = 1;
   }
 }
 while (bChainCycle);

   if (cs.memcheck) sfkmem_checklist(pszCmd);

   if (!bDone) {
      perr("unknown command: %s\n", pszCmd);
      lRC = 9;
      #ifdef SFINT
      if (paliasv && argc >= 2) {
         pwarn("this executable's name is not sfk, therefore sfk tries to run \"sfk %s\".\n", argv[1]);
         pwarn("you may set SFK_CONFIG=ignore-exec-name to disable this behaviour.\n");
         pinf("type \"sfk alias\" for more help about aliasing.\n");
      }
      #endif
   }

   return lRC;
}
#endif // USE_SFK_BASE


