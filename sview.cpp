/*
   sfk snapview by stahlworks art & technology

   known issues:
   -  not all browser instances deleted on exit
      (however cleaned up implicitely by process end)
   -  last 2 lines of help not visible on 1024x768 screen
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>
#include <assert.h>
#include <time.h>
#include <string.h>
#include <sys/timeb.h>
#include <sys/types.h>
#include <sys/stat.h>

#define VER_STR  "sfk snapview 0.1.8 alpha"
#define INFO_STR "f1:fullscr f5:hide f8:help < " VER_STR

#ifdef _WIN32
  #include <windows.h>
  #ifndef WM_MOUSEWHEEL
   #define WM_MOUSEWHEEL 0x020A
   #define WHEEL_DELTA      120
  #endif
  #include <sys/timeb.h>
  #include <time.h>
  #include <process.h>
  #define getpid() _getpid()
  #include <errno.h>
  #include <direct.h>
#else
  #include <unistd.h>
  #include <dirent.h>
  // #include <ndir.h>
  // #include <sys/ndir.h>
  // #include <sys/dir.h>
  // #define dirent direct
#endif

// #define WITH_MEM_TRACE

#ifdef _WIN32
 #ifdef WITH_MEM_TRACE
  #include "memdeb.cpp"
 #endif
#endif

#include "mtk/mtktrace.hpp"
#include "mtk/mtktrace.cpp"

#define _ mtklog("[%d]",__LINE__);

#define OWN_TOLOWER

char *pszGlblHelp =
VER_STR "\n"
"realtime text browser\n"
"stahlworks art & technology\n"
"\n"
"F1: toggle fullscreen    \n"
"F2: move focus line up   \n"
"F3: move focus line down \n"
"F4: case-sensitive search\n"
"F5: hide viewer windows  \n"
"F8: toggle help          \n"
"\n"
"Select-And-Search:  LeftMouseButton\n"
"SAS in new view  : RightMouseButton\n"
"\n"
"To go to next/previous search hit: \n"
"SHIFT+CRSR_DOWN/UP, or MouseWheel. \n"
"Type anything to edit search mask. \n"
"To reset search mask, press INSERT.\n"
"Move w/in mask: Left/Right/Home/End\n"
"Mask supports Joker *, for example:\n"
"class *bar finds \"class CAnyFooBar\"\n"
"\n"
"Screen    -> Clipboard: CTRL+INSERT\n"
"Clipboard -> Search   : SHFT+INSERT\n"
"Line      -> Clipboard: CTRL+LMOUSE\n"
"\n"
"CTRL+Home: jump to previous :file: \n"
"CTRL+SHFT+Home: jump to top of file\n"
"\n"
"To close latest view, press ESCAPE.\n"
"To close all,press ESC in 1st view.\n"
"\n"
" configure defaults via environment:\n"
"   set SFK_SNAPVIEW=tabsize:3,case:0\n"
"\n"
"  snapview best works with snapfiles\n"
"  generated by the swiss file knife.\n"
"\n"
"sfk snapto=all.txt -dir . -file .txt\n"
"                       sview all.txt\n"
;

#define IDR_MAINFRAME      128
#define IDD_XV_DIALOG      102
#define IDD_ABOUTBOX       103
#define IDS_APP_TITLE      103
#define IDM_ABOUT          104
#define IDM_EXIT           105
#define IDS_HELLO          106
#define IDI_XV             107
#define IDI_SMALL          108
#define IDC_XV             109
#define IDC_MYICON           2
#define IDC_STATIC          -1

// Next default values for new objects
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110

#define MAX_LOADSTRING 100

#define uchar unsigned char
#define ulong unsigned long
#define bool  unsigned char

// Global Variables:
HINSTANCE hInst;                       // current instance
TCHAR *szTitle = "tmp01";
TCHAR *szWindowClass = "sfkview";
HFONT glblFont = 0;
HINSTANCE glblInstance = 0;
int   glblCmdShow = 0;
long  nGlblDeskWidth  = 800; // adapted on startup
long  nGlblDeskHeight = 600;
long  nGlblBaseX      = 20;
long  nGlblBaseY      = 20;
long  nGlblFullWidth  = 760;
long  nGlblThirdWidth = 200;
long  nGlblColHeight  = 500;

#ifdef _WIN32
 typedef __int64 num;
#else
 typedef long long num;
#endif

num getCurrentTime()
{
   #ifdef _WIN32
   return (num)GetTickCount();
   #else
   return 0;
   #endif
}

#define BCOL_MAX 200
#define BROW_MAX 100
#define MAX_LINE_LEN   4096
#define MAX_SUB_MASK     10
#define MAX_SNAPPRE_LEN 100

class Browser 
{
public:
   Browser  ( );
  ~Browser  ( );
   int   create      (Browser *pLeft, ulong nid, ulong x, ulong y, ulong w, ulong h, char *apLineTable[], ulong nLines);
   void  destroy     ( );
   void  setLine     (ulong nLine, char *pszText);
   void  setAttr     (ulong nLine, char *pszMask);
   void  update      ( );
   LRESULT process   (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
   void  setMask     (char *psz);
   void  toggleWidth ( );
   void  copyConfig  (Browser *pSrc); // bool bStdSnapFile, bool bCluster, char *pszPrefix, bool bCase);
   void  config      (bool bsnap, bool bclust, char *pszPre);
   void  activate    ( );

private:
   void  detab       (char *pszIn, char *pszOut, ulong lMaxOut);
   void  copyScreenToClipboard   ( );
   void  goLocalFileStart  ( );
   void  strippedLineToClip(char *psz);
   void  calcTopAndBot     (long &lrTop, long &lrBot);
   void  goPreviousMaskHit ( );
   void  goNextMaskHit     ( );
   void  setStringToLower  (char *psz);
   void  prepareMask       (char *pszMask);
   bool  matches           (char *pszStr, int *pHitIndex=0, int *pLen=0);
   void  extendMaskByClass ( );
   void  handleTimer       ( );
   void  setMaskModified   ( );
   void  gotoFirstMaskHit  ( );
   void  updatePanel       ( );
   void  modifySearchMask  (UINT nKey);
   void  autoSelect        (char *pszLine, ulong ncol); // -> to szClSel
   void  putClipboard      (char *psz);
   long  getClipboard      ( );  // returns no. of chars retrieved, if any
   void  drawBorder        (HDC hdc, RECT rt, ulong CBrTop, ulong CBrLeft, ulong CDark1, ulong CDark2, bool bActive);
   void  closeRight        ( );
   #ifdef OWN_TOLOWER
   void  prepareToLower    ( );
   #endif

   Browser *pLeft;
   Browser *pRight;

   HWND  clWin;
   char  aText[BROW_MAX+2][BCOL_MAX+2];
   char  aAttr[BROW_MAX+2][BCOL_MAX+2];
   ulong wchar,hchar;
   char  **apClLines;
   ulong nClLines;
   ulong nClBotLines;
   ulong nClTopLine;
   ulong nClX,nClY;
   ulong nClPixWidth;
   ulong nClPixHeight;
   char  szClMask[MAX_LINE_LEN+10];
   char  szClClassBuf[MAX_LINE_LEN+10];
   char  szClMaskBuf[MAX_LINE_LEN+10];
   char  szClSel[MAX_LINE_LEN+10];
   char  szClTitleBuf[MAX_LINE_LEN+10];
   char  szClMatchBuf[MAX_LINE_LEN+10];
   char  szClClipLine[MAX_LINE_LEN+10];
   char  szClStatusLine[MAX_LINE_LEN+10];
   char  szClTextBuf[BCOL_MAX+10];
   long  nClWheel;
   ulong nCurSel;
   long  iMaskPos;      // position of input cursor in mask field
   ulong nClMaskHits;
   bool  bClSearching;  // 0, 1, 2
   num   nClSearchStart;
   num   nClSearchTime;
   bool  bClTimerSet;
   ulong nClID;
   char  szIDBuf[100];
   #ifdef OWN_TOLOWER
   char  aClLowerTab[256+10];
   #endif

   char  aClMask[MAX_SUB_MASK][1024];
   ulong nClMask;
   long  aClTopFix[3];  // possible lock positions for search cursor
   long  nClTopFixIdx;  // index into above
   long  nClTopFix;     // resulting value from index
   bool  bClStdSnapFile;   // using :file: syntax or not
   bool  bClStdCluster;
   char  szClSnapPrefix[MAX_SNAPPRE_LEN+10];
   char  *pszCurrentFile;  // i.e. :file:
   bool  bClCaseSearch;
   bool  bClShift;      // shift key pressed
   bool  bClCtrl;
   bool  bClActive;
   bool  bClShowHelp;
   ulong nClTabSize;
};

#define MAX_BROWSERS 100
Browser *apGlblBrowsers[MAX_BROWSERS];
ulong nGlblBrowsers = 0;
bool  bGlblMinimized = 0;

Browser::Browser() 
{
   clWin = 0;
   memset(aText, 0, sizeof(aText));
   memset(aAttr, 0, sizeof(aAttr));
   wchar = hchar = 0;
   apClLines = 0;
   nClLines = 0;
   nClBotLines = 3;
   nClTopLine = 0;
   nClPixWidth = 1;
   nClPixHeight = 1;
   pRight = 0;
   nClX = nClY = 0;
   memset(szClMask, 0, sizeof(szClMask));
   memset(szClClassBuf, 0, sizeof(szClClassBuf));
   memset(szClMaskBuf, 0, sizeof(szClMaskBuf));
   memset(szClSel, 0, sizeof(szClSel));
   memset(szClMatchBuf, 0, sizeof(szClMatchBuf));
   memset(szClClipLine, 0, sizeof(szClClipLine));
   memset(szClStatusLine, 0, sizeof(szClStatusLine));
   memset(szClTextBuf, 0, sizeof(szClTextBuf));
   memset(szClSnapPrefix, 0, sizeof(szClSnapPrefix));
   nClWheel = 0;
   nCurSel  = 0;
   iMaskPos = 0;
   nClMaskHits = 0;
   bClSearching = 0;
   bClTimerSet = 0;
   nClID    = 0;
   memset(szIDBuf, 0, sizeof(szIDBuf));
   memset(aClMask, 0, sizeof(aClMask));
   #ifdef OWN_TOLOWER
   memset(aClLowerTab, 0, sizeof(aClLowerTab));
   #endif
   nClMask = 0;
   aClTopFix[0] = aClTopFix[1] = aClTopFix[2] = 3;
   nClTopFixIdx = 1; // middle lock by default
   nClTopFix    = 3;
   bClStdSnapFile = 0;
   bClStdCluster  = 0;
   pszCurrentFile = 0;
   bClCaseSearch  = 0;
   bClShift = 0;
   bClCtrl  = 0;
   bClActive = 0;
   bClShowHelp = 0;
   nClSearchStart = 0;
   nClSearchTime = 0;
   #ifdef OWN_TOLOWER
   prepareToLower();
   #endif
   nClTabSize = 3;

   char *psz1 = getenv("SFK_SNAPVIEW");
   if (psz1) 
   {
      char *psz2 = strstr(psz1, "tabsize:");
      if (psz2)
         if (!(nClTabSize = atol(psz2+strlen("tabsize:"))))
            nClTabSize = 3;

      psz2 = strstr(psz1, "case:");
      if (psz2)
         bClCaseSearch = atol(psz2+strlen("case:"));
   }
}

Browser::~Browser()
{
}

void Browser::destroy()
{
   SetWindowLong(clWin, GWL_USERDATA, 0);
   DestroyWindow(clWin);
   clWin = 0;
}

void Browser::activate() {
   // SetFocus(clWin);
   SetActiveWindow(clWin);
}

void Browser::config(bool bsnap, bool bclust, char *pszPre)
{
   bClStdSnapFile = bsnap;
   bClStdCluster  = bclust;
   strncpy(szClSnapPrefix, pszPre, MAX_SNAPPRE_LEN);
   szClSnapPrefix[MAX_SNAPPRE_LEN] = '\0';
}

void Browser::copyConfig(Browser *pSrc)
{
   bClStdSnapFile = pSrc->bClStdSnapFile;
   bClStdCluster  = pSrc->bClStdCluster;
   strncpy(szClSnapPrefix, pSrc->szClSnapPrefix, MAX_SNAPPRE_LEN);
   szClSnapPrefix[MAX_SNAPPRE_LEN] = '\0';
   bClCaseSearch  = pSrc->bClCaseSearch;
   nClTabSize     = pSrc->nClTabSize;
   nClTopFixIdx   = pSrc->nClTopFixIdx;
   nClTopFix      = pSrc->nClTopFix;
}

void Browser::setMask(char *psz) 
{
   memset(szClMask, 0, sizeof(szClMask));
   strncpy(szClMask, psz, MAX_LINE_LEN);
   iMaskPos = strlen(szClMask);
   // gotoFirstMaskHit();
   setMaskModified();
}

void Browser::setLine(ulong nLine, char *pszText) {
   // mtklog("Browser %p setLine %u %s",this,nLine,pszText);
   if (nLine >= BROW_MAX) {
      mtklog("ERROR: nLine %u\n", nLine);
      return;
   }
   strncpy(&aText[nLine][0], pszText, BCOL_MAX);
   aText[nLine][BCOL_MAX] = '\0';
}

void Browser::setAttr(ulong nLine, char *pszText) {
   if (nLine >= BROW_MAX) {
      mtklog("ERROR: setAttr: nLine %u\n", nLine);
      return;
   }
   memset(&aAttr[nLine][0], 0, sizeof(aAttr[nLine]));
   strncpy(&aAttr[nLine][0], pszText, BCOL_MAX);
}

int Browser::create(Browser *pLeftIn, ulong nid, ulong x, ulong y, ulong w, ulong h, char **apLineTable, ulong nLines)
{
   pLeft = pLeftIn;
   apGlblBrowsers[nGlblBrowsers++] = this;

   nClID     = nid;
   sprintf(szClTitleBuf, "%u", (nClID+1));

   apClLines = apLineTable;
   nClLines  = nLines;
   nClX      = x;
   nClY      = y;
   nClPixWidth = w;
   nClPixHeight = h;
   sprintf(szIDBuf, "%u", nid);
   clWin = CreateWindow(
      szWindowClass, szClTitleBuf,
      WS_POPUP, // WS_VISIBLE|WS_POPUP,
      nClX,nClY,
      nClPixWidth, nClPixHeight,
      NULL, 
      NULL, glblInstance, NULL);
   if (!clWin) return 9;
   SetWindowLong(clWin, GWL_USERDATA, (long)this);
   ShowWindow(clWin, glblCmdShow);

   // consider active on start
   bClActive = 1;

   // the very first WM_PAINT will do an implicite updatePanel()
   update();

   return 0;
}

void Browser::update() {
   // mtklog("Browser %p update", this);
   InvalidateRect(clWin,0,0);
   UpdateWindow(clWin);
}

void Browser::putClipboard(char *pszStr)
{
   if (!OpenClipboard(clWin))
      { MessageBox(0, "clipboard.1", "error", MB_OK); return; }
   
   if (!EmptyClipboard())
      { MessageBox(0, "clipboard.2", "error", MB_OK); return; }

   long nStrLen = strlen(pszStr);

   HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, nStrLen+10);
   if (hMem == NULL)
      { MessageBox(0, "clipboard.3", "error", MB_OK); return; }

   LPTSTR pCopy = (char*)GlobalLock(hMem);
   if (pCopy)
   {
      memcpy(pCopy, pszStr, nStrLen);
      pCopy[nStrLen] = 0;
   }
   GlobalUnlock(hMem);

   HANDLE hData = SetClipboardData(CF_TEXT, hMem);
   if (hData == NULL)
   {
      CloseClipboard();
      MessageBox(0, "clipboard.4", "error", MB_OK);
      return;
   }

   // System is now owner of hMem.

   CloseClipboard();
}

long Browser::getClipboard( )
{
   if (!IsClipboardFormatAvailable(CF_TEXT)) 
      return 0;

   if (!OpenClipboard(clWin)) 
      return 0;
 
   HGLOBAL hglb = GetClipboardData(CF_TEXT); 
   if (hglb != NULL)
   {
      char *pMem = (char*)GlobalLock(hglb); 
      if (pMem != NULL) 
      {
         strncpy(szClClipLine, pMem, MAX_LINE_LEN);
         szClClipLine[MAX_LINE_LEN] = '\0';
      }
      GlobalUnlock(hglb);
   }

   CloseClipboard(); 

   return strlen(szClClipLine);
}

char *pszAnim = "\\|/-";
ulong iAnim   = 0;

void Browser::detab(char *pszIn, char *pszOut, ulong lMaxOut)
{
   ulong nInsert=0, iout=0;
   for (int icol=0; (pszIn[icol]!=0) && (iout<lMaxOut-1); icol++)
   {
      char c1 = pszIn[icol];
      if (c1 == '\t') 
      {
         nInsert = nClTabSize - (iout % nClTabSize);
         for (ulong i2=0; i2<nInsert; i2++)
            pszOut[iout++] = ' ';
      }
      else
         pszOut[iout++] = c1;
   }
   pszOut[iout] = '\0';
}

void Browser::updatePanel() 
{
   prepareMask(szClMask);
   ulong ymax = BROW_MAX;
   if (hchar)
      ymax = nClPixHeight/hchar;
   else
      return;

   ulong yrel = 0;
   char aAttr[BCOL_MAX+10];

   if (bClStdSnapFile) 
   {
      pszCurrentFile = 0;

      // search for previous :file:
      long i1;
      long nLen = strlen(szClSnapPrefix);
      for (i1 = nClTopLine; i1 >= 0; i1--)
         if (!strncmp(apClLines[i1], szClSnapPrefix, nLen))
            break;

      if (i1 >= 0) 
      {
         if (!bClStdCluster)
         {
            // snapfile
            i1++;
            if (i1 < nClLines) 
            {
               pszCurrentFile = apClLines[i1];
               setLine(0, pszCurrentFile);
   
               memset(aAttr, ' ', BCOL_MAX);
               aAttr[BCOL_MAX] = '\0';
               setAttr(0, aAttr);
   
               yrel = 1;
            }
         }
         else
         {
            // cluster
            pszCurrentFile = apClLines[i1]+strlen(szClSnapPrefix);

            setLine(0, pszCurrentFile);
   
            memset(aAttr, ' ', BCOL_MAX);
            aAttr[BCOL_MAX] = '\0';
            setAttr(0, aAttr);
   
            yrel = 1;
         }
      }
   }

   char szBuf[1024];
   memset(szBuf, 0, sizeof(szBuf));

   for (; yrel<ymax-3; yrel++) 
   {
      ulong iLine = nClTopLine+yrel;
      if (iLine < nClLines) 
      {
         memset(aAttr, ' ', BCOL_MAX);
         aAttr[BCOL_MAX] = '\0';

         char *pszLine = apClLines[iLine];
         detab(pszLine, szBuf, sizeof(szBuf)-10);
               pszLine = szBuf;

         bool bHit=0;
         int nMaskLen = strlen(szClMask);
         if (nMaskLen) 
         {
            int iHitIndex = 0;
            int iHitLen   = 0;
            matches(pszLine, &iHitIndex, &iHitLen);
            if (iHitLen > 0 && (iHitIndex+iHitLen) < BCOL_MAX)
            {
               memset(&aAttr[iHitIndex], 'x', iHitLen);
               bHit=1;
            }
         }

         setLine(yrel, pszLine);
         setAttr(yrel, aAttr);

         if (bHit) mtklog("HIT \"%s\"", aAttr);
      } else {
         setLine(yrel, "");
         setAttr(yrel, "");
      }
   }

   setLine(ymax-3, "------------------------------------------------------------------------------------------------------------------------------------------");

   memset(szBuf, 0, sizeof(szBuf));
   strcpy(szBuf, ">");
   strncpy(&szBuf[1], szClMask, sizeof(szBuf)-10);
   if (!nClMaskHits) {
      if (bClSearching)
         sprintf(&szBuf[strlen(szBuf)], "< - %c", (bClSearching<2)?'-':'*');
      else
         sprintf(&szBuf[strlen(szBuf)], "< - no hit, %s.",bClCaseSearch?"case":"nocase");
   } else
      sprintf(&szBuf[strlen(szBuf)], "< - %u hits, %s.",nClMaskHits,bClCaseSearch?"case":"nocase");

   // append status, if any.
   if (szClStatusLine[0]) {
      strcat(szBuf, " ");
      strncat(szBuf, szClStatusLine, sizeof(szBuf)-10-strlen(szBuf));
      szClStatusLine[0] = '\0';
   }

   char aAttrMask[BCOL_MAX+2];
   memset(aAttrMask, ' ', BCOL_MAX);

   // append statistics in grey, if in fullscreen.
   ulong iOffs = strlen(szBuf);
   if ((nClPixWidth == nGlblFullWidth) && (iOffs < sizeof(szBuf)-100)) {
      sprintf(&szBuf[strlen(szBuf)], " tab=%lu.", (ulong)nClTabSize);
      if (nClSearchTime > 0)
         sprintf(&szBuf[strlen(szBuf)], " %lu msec over", (ulong)nClSearchTime);
      sprintf(&szBuf[strlen(szBuf)], " %lu lines.", (ulong)nClLines);
      ulong nGrey = strlen(&szBuf[iOffs]);
      if (iOffs+nGrey < sizeof(szBuf)-10)
         memset(&aAttrMask[iOffs], 'g', nGrey);
   }

   long iInfo = strlen(szBuf);
   if (wchar)
   {
      long xmax = nClPixWidth/wchar;
      if (iInfo < (xmax - (long)strlen(INFO_STR) - 3))
      {
         // mtklog("iinfo %d xmax %d sl %d",iInfo,xmax,strlen(INFO_STR));
         for (long i=iInfo; (i<xmax) && (i<BCOL_MAX);i++)
            szBuf[i] = ' ';
         iInfo = xmax-strlen(INFO_STR)-3;
         strncpy(&szBuf[iInfo], INFO_STR, strlen(INFO_STR));
      }
   }
   setLine(ymax-2, szBuf);

   // mark the position of mask input cursor
   aAttrMask[BCOL_MAX] = '\0';
   aAttrMask[iMaskPos+1] = 'x';
   long nInfoLen = strlen(INFO_STR);
   for (long n=0; (n<nInfoLen) && (iInfo+n<BCOL_MAX); n++)
      aAttrMask[iInfo+n] = 'g';
   setAttr(ymax-2, aAttrMask);
}

// Forward declarations of functions included in this code module:
ATOM           MyRegisterClass(HINSTANCE hInstance);
BOOL           InitInstance(HINSTANCE, int);
LRESULT CALLBACK  WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK  About(HWND, UINT, WPARAM, LPARAM);

const char *msgAsString(long nMsg) 
{
   switch (nMsg) {
   case WM_NULL: return "WM_NULL";
   case WM_CREATE: return "WM_CREATE";
   case WM_DESTROY: return "WM_DESTROY";
   case WM_MOVE: return "WM_MOVE";
   case WM_SIZE: return "WM_SIZE";
   case WM_ACTIVATE: return "WM_ACTIVATE";
   case WM_SETFOCUS: return "WM_SETFOCUS";
   case WM_KILLFOCUS: return "WM_KILLFOCUS";
   case WM_ENABLE: return "WM_ENABLE";
   case WM_SETREDRAW: return "WM_SETREDRAW";
   case WM_SETTEXT: return "WM_SETTEXT";
   case WM_GETTEXT: return "WM_GETTEXT";
   case WM_GETTEXTLENGTH: return "WM_GETTEXTLENGTH";
   case WM_PAINT: return "WM_PAINT";
   case WM_CLOSE: return "WM_CLOSE";
   case WM_QUERYENDSESSION: return "WM_QUERYENDSESSION";
   case WM_QUIT: return "WM_QUIT";
   case WM_QUERYOPEN: return "WM_QUERYOPEN";
   case WM_ERASEBKGND: return "WM_ERASEBKGND";
   case WM_SYSCOLORCHANGE: return "WM_SYSCOLORCHANGE";
   case WM_ENDSESSION: return "WM_ENDSESSION";
   case WM_SHOWWINDOW: return "WM_SHOWWINDOW";
   case WM_WININICHANGE: return "WM_WININICHANGE";
// case WM_SETTINGCHANGE: return "WM_SETTINGCHANGE";
   case WM_DEVMODECHANGE: return "WM_DEVMODECHANGE";
   case WM_ACTIVATEAPP: return "WM_ACTIVATEAPP";
   case WM_FONTCHANGE: return "WM_FONTCHANGE";
   case WM_TIMECHANGE: return "WM_TIMECHANGE";
   case WM_CANCELMODE: return "WM_CANCELMODE";
   case WM_SETCURSOR: return "WM_SETCURSOR";
   case WM_MOUSEACTIVATE: return "WM_MOUSEACTIVATE";
   case WM_CHILDACTIVATE: return "WM_CHILDACTIVATE";
   case WM_QUEUESYNC: return "WM_QUEUESYNC";
   case WM_GETMINMAXINFO: return "WM_GETMINMAXINFO";
   case WM_PAINTICON: return "WM_PAINTICON";
   case WM_ICONERASEBKGND: return "WM_ICONERASEBKGND";
   case WM_NEXTDLGCTL: return "WM_NEXTDLGCTL";
   case WM_SPOOLERSTATUS: return "WM_SPOOLERSTATUS";
   case WM_DRAWITEM: return "WM_DRAWITEM";
   case WM_MEASUREITEM: return "WM_MEASUREITEM";
   case WM_DELETEITEM: return "WM_DELETEITEM";
   case WM_VKEYTOITEM: return "WM_VKEYTOITEM";
   case WM_CHARTOITEM: return "WM_CHARTOITEM";
   case WM_SETFONT: return "WM_SETFONT";
   case WM_GETFONT: return "WM_GETFONT";
   case WM_SETHOTKEY: return "WM_SETHOTKEY";
   case WM_GETHOTKEY: return "WM_GETHOTKEY";
   case WM_QUERYDRAGICON: return "WM_QUERYDRAGICON";
   case WM_COMPAREITEM: return "WM_COMPAREITEM";
   case WM_COMPACTING: return "WM_COMPACTING";
   case WM_COMMNOTIFY: return "WM_COMMNOTIFY";
   case WM_WINDOWPOSCHANGING: return "WM_WINDOWPOSCHANGING";
   case WM_WINDOWPOSCHANGED: return "WM_WINDOWPOSCHANGED";
   case WM_POWER: return "WM_POWER";
   case WM_COPYDATA: return "WM_COPYDATA";
   case WM_CANCELJOURNAL: return "WM_CANCELJOURNAL";
   case WM_NOTIFY: return "WM_NOTIFY";
   case WM_INPUTLANGCHANGEREQUEST: return "WM_INPUTLANGCHANGEREQUEST";
   case WM_INPUTLANGCHANGE: return "WM_INPUTLANGCHANGE";
   case WM_TCARD: return "WM_TCARD";
   case WM_HELP: return "WM_HELP";
   case WM_USERCHANGED: return "WM_USERCHANGED";
   case WM_NOTIFYFORMAT: return "WM_NOTIFYFORMAT";
   case WM_CONTEXTMENU: return "WM_CONTEXTMENU";
   case WM_STYLECHANGING: return "WM_STYLECHANGING";
   case WM_STYLECHANGED: return "WM_STYLECHANGED";
   case WM_DISPLAYCHANGE: return "WM_DISPLAYCHANGE";
   case WM_GETICON: return "WM_GETICON";
   case WM_SETICON: return "WM_SETICON";
   case WM_NCCREATE: return "WM_NCCREATE";
   case WM_NCDESTROY: return "WM_NCDESTROY";
   case WM_NCCALCSIZE: return "WM_NCCALCSIZE";
   case WM_NCHITTEST: return "WM_NCHITTEST";
   case WM_NCPAINT: return "WM_NCPAINT";
   case WM_NCACTIVATE: return "WM_NCACTIVATE";
   case WM_GETDLGCODE: return "WM_GETDLGCODE";
   case WM_NCMOUSEMOVE: return "WM_NCMOUSEMOVE";
   case WM_NCLBUTTONDOWN: return "WM_NCLBUTTONDOWN";
   case WM_NCLBUTTONUP: return "WM_NCLBUTTONUP";
   case WM_NCLBUTTONDBLCLK: return "WM_NCLBUTTONDBLCLK";
   case WM_NCRBUTTONDOWN: return "WM_NCRBUTTONDOWN";
   case WM_NCRBUTTONUP: return "WM_NCRBUTTONUP";
   case WM_NCRBUTTONDBLCLK: return "WM_NCRBUTTONDBLCLK";
   case WM_NCMBUTTONDOWN: return "WM_NCMBUTTONDOWN";
   case WM_NCMBUTTONUP: return "WM_NCMBUTTONUP";
   case WM_NCMBUTTONDBLCLK: return "WM_NCMBUTTONDBLCLK";
// case WM_KEYFIRST: return "WM_KEYFIRST";
   case WM_KEYDOWN: return "WM_KEYDOWN";
   case WM_KEYUP: return "WM_KEYUP";
   case WM_CHAR: return "WM_CHAR";
   case WM_DEADCHAR: return "WM_DEADCHAR";
   case WM_SYSKEYDOWN: return "WM_SYSKEYDOWN";
   case WM_SYSKEYUP: return "WM_SYSKEYUP";
   case WM_SYSCHAR: return "WM_SYSCHAR";
   case WM_SYSDEADCHAR: return "WM_SYSDEADCHAR";
   case WM_KEYLAST: return "WM_KEYLAST";
   case WM_IME_STARTCOMPOSITION: return "WM_IME_STARTCOMPOSITION";
   case WM_IME_ENDCOMPOSITION: return "WM_IME_ENDCOMPOSITION";
   case WM_IME_COMPOSITION: return "WM_IME_COMPOSITION";
// case WM_IME_KEYLAST: return "WM_IME_KEYLAST";
   case WM_INITDIALOG: return "WM_INITDIALOG";
   case WM_COMMAND: return "WM_COMMAND";
   case WM_SYSCOMMAND: return "WM_SYSCOMMAND";
   case WM_TIMER: return "WM_TIMER";
   case WM_HSCROLL: return "WM_HSCROLL";
   case WM_VSCROLL: return "WM_VSCROLL";
   case WM_INITMENU: return "WM_INITMENU";
   case WM_INITMENUPOPUP: return "WM_INITMENUPOPUP";
   case WM_MENUSELECT: return "WM_MENUSELECT";
   case WM_MENUCHAR: return "WM_MENUCHAR";
   case WM_ENTERIDLE: return "WM_ENTERIDLE";
   case WM_CTLCOLORMSGBOX: return "WM_CTLCOLORMSGBOX";
   case WM_CTLCOLOREDIT: return "WM_CTLCOLOREDIT";
   case WM_CTLCOLORLISTBOX: return "WM_CTLCOLORLISTBOX";
   case WM_CTLCOLORBTN: return "WM_CTLCOLORBTN";
   case WM_CTLCOLORDLG: return "WM_CTLCOLORDLG";
   case WM_CTLCOLORSCROLLBAR: return "WM_CTLCOLORSCROLLBAR";
   case WM_CTLCOLORSTATIC: return "WM_CTLCOLORSTATIC";
   case WM_MOUSEFIRST: return "WM_MOUSEFIRST";
// case WM_MOUSEMOVE: return "WM_MOUSEMOVE";
   case WM_LBUTTONDOWN: return "WM_LBUTTONDOWN";
   case WM_LBUTTONUP: return "WM_LBUTTONUP";
   case WM_LBUTTONDBLCLK: return "WM_LBUTTONDBLCLK";
   case WM_RBUTTONDOWN: return "WM_RBUTTONDOWN";
   case WM_RBUTTONUP: return "WM_RBUTTONUP";
   case WM_RBUTTONDBLCLK: return "WM_RBUTTONDBLCLK";
   case WM_MBUTTONDOWN: return "WM_MBUTTONDOWN";
   case WM_MBUTTONUP: return "WM_MBUTTONUP";
   case WM_MBUTTONDBLCLK: return "WM_MBUTTONDBLCLK";
   case WM_MOUSEWHEEL: return "WM_MOUSEWHEEL";
// case WM_MOUSELAST: return "WM_MOUSELAST";
// case WM_MOUSELAST: return "WM_MOUSELAST";
   case WM_PARENTNOTIFY: return "WM_PARENTNOTIFY";
   case WM_ENTERMENULOOP: return "WM_ENTERMENULOOP";
   case WM_EXITMENULOOP: return "WM_EXITMENULOOP";
   case WM_NEXTMENU: return "WM_NEXTMENU";
   case WM_SIZING: return "WM_SIZING";
   case WM_CAPTURECHANGED: return "WM_CAPTURECHANGED";
   case WM_MOVING: return "WM_MOVING";
   case WM_POWERBROADCAST: return "WM_POWERBROADCAST";
   case WM_DEVICECHANGE: return "WM_DEVICECHANGE";
   case WM_IME_SETCONTEXT: return "WM_IME_SETCONTEXT";
   case WM_IME_NOTIFY: return "WM_IME_NOTIFY";
   case WM_IME_CONTROL: return "WM_IME_CONTROL";
   case WM_IME_COMPOSITIONFULL: return "WM_IME_COMPOSITIONFULL";
   case WM_IME_SELECT: return "WM_IME_SELECT";
   case WM_IME_CHAR: return "WM_IME_CHAR";
   case WM_IME_KEYDOWN: return "WM_IME_KEYDOWN";
   case WM_IME_KEYUP: return "WM_IME_KEYUP";
   case WM_MDICREATE: return "WM_MDICREATE";
   case WM_MDIDESTROY: return "WM_MDIDESTROY";
   case WM_MDIACTIVATE: return "WM_MDIACTIVATE";
   case WM_MDIRESTORE: return "WM_MDIRESTORE";
   case WM_MDINEXT: return "WM_MDINEXT";
   case WM_MDIMAXIMIZE: return "WM_MDIMAXIMIZE";
   case WM_MDITILE: return "WM_MDITILE";
   case WM_MDICASCADE: return "WM_MDICASCADE";
   case WM_MDIICONARRANGE: return "WM_MDIICONARRANGE";
   case WM_MDIGETACTIVE: return "WM_MDIGETACTIVE";
   case WM_MDISETMENU: return "WM_MDISETMENU";
   case WM_ENTERSIZEMOVE: return "WM_ENTERSIZEMOVE";
   case WM_EXITSIZEMOVE: return "WM_EXITSIZEMOVE";
   case WM_DROPFILES: return "WM_DROPFILES";
   case WM_MDIREFRESHMENU: return "WM_MDIREFRESHMENU";
// case WM_MOUSEHOVER: return "WM_MOUSEHOVER";
// case WM_MOUSELEAVE: return "WM_MOUSELEAVE";
   case WM_CUT: return "WM_CUT";
   case WM_COPY: return "WM_COPY";
   case WM_PASTE: return "WM_PASTE";
   case WM_CLEAR: return "WM_CLEAR";
   case WM_UNDO: return "WM_UNDO";
   case WM_RENDERFORMAT: return "WM_RENDERFORMAT";
   case WM_RENDERALLFORMATS: return "WM_RENDERALLFORMATS";
   case WM_DESTROYCLIPBOARD: return "WM_DESTROYCLIPBOARD";
   case WM_DRAWCLIPBOARD: return "WM_DRAWCLIPBOARD";
   case WM_PAINTCLIPBOARD: return "WM_PAINTCLIPBOARD";
   case WM_VSCROLLCLIPBOARD: return "WM_VSCROLLCLIPBOARD";
   case WM_SIZECLIPBOARD: return "WM_SIZECLIPBOARD";
   case WM_ASKCBFORMATNAME: return "WM_ASKCBFORMATNAME";
   case WM_CHANGECBCHAIN: return "WM_CHANGECBCHAIN";
   case WM_HSCROLLCLIPBOARD: return "WM_HSCROLLCLIPBOARD";
   case WM_QUERYNEWPALETTE: return "WM_QUERYNEWPALETTE";
   case WM_PALETTEISCHANGING: return "WM_PALETTEISCHANGING";
   case WM_PALETTECHANGED: return "WM_PALETTECHANGED";
   case WM_HOTKEY: return "WM_HOTKEY";
   case WM_PRINT: return "WM_PRINT";
   case WM_PRINTCLIENT: return "WM_PRINTCLIENT";
   case WM_HANDHELDFIRST: return "WM_HANDHELDFIRST";
   case WM_HANDHELDLAST: return "WM_HANDHELDLAST";
   case WM_AFXFIRST: return "WM_AFXFIRST";
   case WM_AFXLAST: return "WM_AFXLAST";
   case WM_PENWINFIRST: return "WM_PENWINFIRST";
   case WM_PENWINLAST: return "WM_PENWINLAST";
   case WM_APP: return "WM_APP";
   case WM_USER: return "WM_USER";
   }
   return "?";
}

ATOM MyRegisterClass(HINSTANCE hInstance)
{
   WNDCLASSEX wcex;

   wcex.cbSize = sizeof(WNDCLASSEX); 

   wcex.style        = CS_HREDRAW | CS_VREDRAW;
   wcex.lpfnWndProc  = (WNDPROC)WndProc;
   wcex.cbClsExtra   = 0;
   wcex.cbWndExtra   = 16;
   wcex.hInstance    = hInstance;
   wcex.hIcon        = 0; // LoadIcon(hInstance, (LPCTSTR)IDI_XV);
   wcex.hCursor      = LoadCursor(NULL, IDC_ARROW);
   wcex.hbrBackground= (HBRUSH)(COLOR_WINDOW+1);
   wcex.lpszMenuName = 0;
   wcex.lpszClassName= szWindowClass;
   wcex.hIconSm      = 0; // LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

   return RegisterClassEx(&wcex);
}

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   HWND hWnd;
   hInst = hInstance; // Store instance handle in our global variable
   return TRUE;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   Browser *pBrowser = (Browser *)GetWindowLong(hWnd, GWL_USERDATA);

   // mtklog("wndproc %02x %s %p\n", message, msgAsString(message), pBrowser);
   if (pBrowser != 0)
   {
      long lRC = pBrowser->process(hWnd, message, wParam, lParam);
      return lRC;
   }
   else
      return DefWindowProc(hWnd, message, wParam, lParam);
}

static char *pszBlankBuf =
   "                                                  "
   "                                                  "
   "                                                  "
   "                                                  "
   ;

void Browser::drawBorder(HDC hdc, RECT rt, ulong CBrTop, ulong CBrLeft, ulong CDark1, ulong CDark2, bool bActive)
{
   ulong CWhite = 0xFFFFFFUL;

   ulong CBrTop2  = bActive ? CBrTop  : CWhite;
   ulong CBrLeft2 = bActive ? CBrLeft : CWhite;
   ulong CDark12  = bActive ? CDark1  : CWhite;
   ulong CDark22  = bActive ? CDark2  : CWhite;

   // ulong n1=6, n2=4;
   ulong n1=5, n2=3;

   for (long x1=0; x1<rt.right; x1++) 
   {
      for (long d=0; d<n1; d++) 
      {
         SetPixel(hdc, x1, d, (d<n2)?CBrTop:CBrTop2);
         SetPixel(hdc, x1, rt.bottom-d, (d<n2)?CDark2:CDark22);
      }
   }

   for (long y1=0; y1<rt.bottom; y1++)
   {
      for (long d=0; d<n1; d++) 
      {
         if (y1 >= d && y1 < rt.bottom-d)
            SetPixel(hdc, d, y1, (d<n2)?CBrLeft:CBrLeft2);

         if (y1 >= d && y1 < rt.bottom-d)
            SetPixel(hdc, rt.right-d, y1, (d<n2)?CDark1:CDark12);
      }
   }
}

LRESULT Browser::process(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   int wmId, wmEvent;
   PAINTSTRUCT ps;
   HDC hdc;
   TCHAR *szHello = "hellou";

   mtklog("Browser %p proc %02x %s w %x l %x act %d", this, message, msgAsString(message), (ulong)wParam, (ulong)lParam, bClActive);

   ulong nbasex  = 10;
   ulong nbasey  = 10;

   switch (message) 
   {
      case WM_COMMAND:
      {
         wmId    = LOWORD(wParam); 
         wmEvent = HIWORD(wParam); 
         // Parse the menu selections:
         switch (wmId)
         {
            case IDM_EXIT:
               DestroyWindow(hWnd);
               break;
            default:
               return DefWindowProc(hWnd, message, wParam, lParam);
         }
      }
         break;

      case WM_PAINT:
      {
_
         hdc = BeginPaint(hWnd, &ps);
         RECT rt;
         GetClientRect(hWnd, &rt);
         HFONT hfOld = (HFONT)SelectObject(hdc, glblFont);

         // DrawText(hdc, szHello, strlen(szHello), &rt, DT_CENTER);

         ulong CMiddle, CBrTop, CBrLeft, CDark1, CDark2;

/*
         if (bClActive)
         {
            CMiddle = 0xFFFFFFUL;
            CBrTop  = 0xBB9999UL;
            CBrLeft = 0xDDBBBBUL;
            CDark1  = 0x775555UL;
            CDark2  = 0x553333UL;
         }
         else 
*/
         {
            CMiddle = 0xFBFBFBUL;
            CBrTop  = 0xAAAAAAUL;
            CBrLeft = 0xCCCCCCUL;
            CDark1  = 0x666666UL;
            CDark2  = 0x444444UL;
         }

         // SetBkColor(hdc, CMiddle);

         {
            // HBRUSH hBlue = CreateSolidBrush(CMiddle);
            // FillRect(hdc, &rt, hBlue);
            // DeleteObject(hBlue);
_
            drawBorder(hdc,rt,CBrTop,CBrLeft,CDark1,CDark2,bClActive);
_
            SetBkMode(hdc, OPAQUE); // TRANSPARENT);
_
            if (!wchar)
            {
               TEXTMETRIC tm;
               GetTextMetrics(hdc, &tm);
               wchar = tm.tmAveCharWidth;
               hchar = tm.tmHeight;
               if (hchar) {
                  aClTopFix[0] = 3;
                  aClTopFix[1] = ((nClPixHeight/hchar)-2)*1/2;
                  aClTopFix[2] = ((nClPixHeight/hchar)-2)-5;
                  nClTopFix    = aClTopFix[nClTopFixIdx];
               }
               // on very first WM_PAINT, create text buffer implicitely
               if (wchar)
                  updatePanel();
            }

            // mtklog("rt top %d bot %d basey %d wc %d hc %d",rt.top,rt.bottom,nbasey,wchar,hchar);
_
            ulong nMaxCol = (rt.right-rt.left-nbasex-8)/wchar;
            ulong nMaxRow = (rt.bottom-rt.top-nbasey-8)/hchar;

            if (nMaxCol > BCOL_MAX-1) nMaxCol = BCOL_MAX-1;
            if (nMaxRow > BROW_MAX-1) nMaxRow = BROW_MAX-1;

            ulong nColText = 0x000000UL;
            if (!bClActive)
                  nColText = 0x000000UL;

            RECT rt2;

            char *pszHelp = pszGlblHelp;

            for (ulong y=0; y<nMaxRow; y++)
            for (ulong x=0; x<nMaxCol; x++)
            {
               char c = aText[y][x];
               if (c)
               {
                  rt2.left   = nbasex + x * wchar;
                  rt2.top    = nbasey + y * hchar;
                  rt2.right  = rt2.left + wchar*2;
                  rt2.bottom = rt2.top + hchar*2;
   
                  if ((y==0) && pszCurrentFile)
                     SetTextColor(hdc, 0xBB0000);
                  else
                  switch (aAttr[y][x]) {
                     case 'x': SetTextColor(hdc, 0x0000AA); break;
                     case 'g': SetTextColor(hdc, 0xAAAAAA); break;
                     default : SetTextColor(hdc, nColText); break;
                  }
   
                  DrawText(hdc,
                     &c, 1,
                     &rt2, DT_SINGLELINE|DT_TOP|DT_LEFT|DT_NOPREFIX
                     );
               }
               else
               if (x < nMaxCol)
               {
                  // draw blank rest of line, maybe including help
                  rt2.left   = nbasex + x * wchar;
                  rt2.top    = nbasey + y * hchar;
                  rt2.right  = rt.right;
                  rt2.bottom = rt2.top + hchar*2;

                  SetTextColor(hdc, 0x555555);

                  long nrlen = nMaxCol-x;
                  memset(szClTextBuf, ' ', nrlen);
                  szClTextBuf[nrlen] = '\0';

                  if (bClShowHelp && (nGlblFullWidth==nClPixWidth) && pszHelp)
                  {
                     char *psz2 = strchr(pszHelp, '\n');
                     long nhlen = 0;
                     if (psz2) { nhlen = psz2-pszHelp; psz2++; }
                         else  nhlen = strlen(pszHelp);
                     if (nhlen < nrlen) {
                        strncpy(&szClTextBuf[nrlen-nhlen], pszHelp, nhlen);
                     }
                     pszHelp = psz2; // can be NULL
                  }

                  DrawText(hdc,
                     szClTextBuf, nrlen,
                     &rt2, DT_SINGLELINE|DT_TOP|DT_LEFT|DT_NOPREFIX
                     );

                  break; // continue at next line                 
               }
               else
                  break;
            }
         }

         SelectObject(hdc, hfOld);
         EndPaint(hWnd, &ps);
      }
         break;

      case WM_DESTROY:
      {
         PostQuitMessage(0);
      }
         break;

      case WM_SETCURSOR:
      {
         UINT nHittest = LOWORD(lParam);  // hit-test code 
         UINT wMouseMsg = HIWORD(lParam); // mouse-message identifier 
         // mtklog(" nhit %x wmm %x", nHittest, wMouseMsg);
         return DefWindowProc(hWnd, message, wParam, lParam);
      }

      case WM_LBUTTONDOWN:
      {
         UINT xPos = LOWORD(lParam);  // horizontal position of cursor 
         UINT yPos = HIWORD(lParam);  // vertical position of cursor 
         UINT fwKeys = wParam;        // key flags 
         mtklog("LBUTTON %u %u %x",xPos,yPos,fwKeys);

         ulong xrel = xPos-nbasex;  // UNDERFLOW possible
         ulong yrel = yPos-nbasey;  // UNDERFLOW possible

         ulong nrow = hchar ? (yrel/hchar) : 0;
         ulong ncol = wchar ? (xrel/wchar) : 0;
         ulong ymax = BROW_MAX;
         if (hchar) ymax = nClPixHeight/hchar;
_
         if (bClCtrl)
         {
            if ((nrow==0) && (pszCurrentFile!=0) && (strlen(pszCurrentFile)>1))
               strippedLineToClip(pszCurrentFile);
            else 
            if (nrow >= 1 && nrow < ymax-2)
            {
               char *pszLine = &aText[nrow][0];
               if (strlen(pszLine) > 1)
                  strippedLineToClip(pszLine);
            }
         }
         else
         if (nrow >= 1 && nrow < ymax-2)
         {
_           autoSelect(&aText[nrow][0], ncol);
            if (strlen(szClSel) > 0) {
               setMask(szClSel);
            }
         }
_
         // return DefWindowProc(hWnd, message, wParam, lParam);
      }
         break;

      case WM_RBUTTONDOWN:
      {
         UINT xPos = LOWORD(lParam);  // horizontal position of cursor 
         UINT yPos = HIWORD(lParam);  // vertical position of cursor 
         mtklog("RBUTTON %u %u",xPos,yPos);

         ulong xrel = xPos-nbasex;
         ulong yrel = yPos-nbasey;

         ulong nrow = hchar ? (yrel/hchar) : 0;
         ulong ncol = wchar ? (xrel/wchar) : 0;

         autoSelect(aText[nrow], ncol);

         // deactivate fullscreen, if active
         if (nClPixWidth == nGlblFullWidth)
            toggleWidth();

         if (!pRight)
         {
            pRight = new Browser();
            HWND hDesk = GetDesktopWindow();
            RECT rDesk;
            GetWindowRect(hDesk, &rDesk);
            long nDeskWidth  = rDesk.right-rDesk.left;
            long nDeskHeight = rDesk.bottom-rDesk.top;
            ulong nXNew = nClX+nClPixWidth;
            ulong nYNew = nClY;
            if (nXNew > (nDeskWidth - nClPixWidth)) {
               nXNew  = nGlblBaseX;
               nYNew += 20;
            }
            if (pRight->create(this, nClID+1, nXNew, nYNew, nGlblThirdWidth, nGlblColHeight, apClLines, nClLines)) {
               mtklog("ERROR: cannot create child browser");
               delete pRight;
               pRight = 0;
            }
            pRight->copyConfig(this);
         }

         if (pRight)
         {
            // is the local selection part of an extended selection?
            // if (   (strlen(szClMask) > strlen(szClSel))
            //     && strstr(szClMask, szClSel))
            // {
            //    pRight->setMask(szClMask);
            //    pRight->activate();
            // }
            // else
            if (strlen(szClSel) > 0)
            {
               pRight->setMask(szClSel);
               pRight->activate();
            }
         }

         return DefWindowProc(hWnd, message, wParam, lParam);
      }

      case WM_KEYUP:
      {
         UINT nKey = (UINT)wParam;
         switch (nKey)
         {   
            case 0x10: bClShift = 0; break;
            case 0x11: bClCtrl  = 0; break;
         }
      }
         break;

      case WM_KEYDOWN:
      {
         UINT nKey = (UINT)wParam;
         ulong nmax = BROW_MAX;
         if (hchar) nmax = nClPixHeight/hchar;
         ulong nOldTop = nClTopLine;
         switch (nKey) 
         {
            case 0x10: bClShift = 1; break;
            case 0x11: bClCtrl  = 1; break;

            case 33: // page up
               if (nClTopLine >= nmax)
                  nClTopLine -= nmax;
               else
                  nClTopLine = 0;
               break;

            case 34: // page down
               if ((nClTopLine+nmax*2) < nClLines+nClBotLines)
                  nClTopLine += nmax;
               else
               if (nClLines+nClBotLines >= nmax)
                  nClTopLine = nClLines+nClBotLines-nmax;
               break;

            case 38: // crsr up
               if (strlen(szClMask) && bClShift)
                  goPreviousMaskHit();
               else
               if (nClTopLine > 0)
                  nClTopLine--;
               break;

            case 40: // crsr down
               if (strlen(szClMask) && bClShift)
                  goNextMaskHit();
               else
               if ((nClTopLine+nmax) < nClLines+nClBotLines)
                  nClTopLine++;
               break;

            case 36: // home, pos1
               if (bClCtrl) {
                  if (bClShift)
                     nClTopLine = 0;
                  else {
                     if (bClStdSnapFile)
                        goLocalFileStart();
                     else
                        nClTopLine = 0;
                  }
               }
               else
               if (iMaskPos > 0) {
                  iMaskPos=0;
                  updatePanel();
                  update();
               }
               break;

            case 35: // end
               if (bClCtrl) {
                  ulong ymax = BROW_MAX;
                  if (hchar) ymax = nClPixHeight/hchar;
                  if (nClLines+nClBotLines > ymax)
                     nClTopLine = nClLines+nClBotLines-ymax;
               }
               else {
                  int nLen = strlen(szClMask);  
                  if (iMaskPos < nLen) {
                     iMaskPos = nLen;
                     updatePanel();
                     update();
                  }
               }
               break;

            case VK_ESCAPE: // esc
               if (!pLeft)
                  PostQuitMessage(0);
               else
               if (!pRight)
               {
                  // call parent to close ourselves
                  pLeft->closeRight();
                  // 'this' is now INVALID!
                  return 0;
                  // NO further message processing done
               }
               break;

            case VK_LEFT:
               if (iMaskPos > 0) {
                  iMaskPos--;
                  updatePanel();
                  update();
               }
               break;

            case VK_RIGHT:
            {
               int nLen = strlen(szClMask);  
               if (iMaskPos < nLen) {
                  iMaskPos++;
                  updatePanel();
                  update();
               }
            }
               break;

            case VK_DELETE:
            {
               modifySearchMask(nKey+1000);
            }
               break;

            case VK_F1:
               toggleWidth();
               break;

            case VK_F8:
               bClShowHelp ^= 0x1;
               update();
               break;

            case VK_INSERT:
               if (bClShift) {
                  if (getClipboard() > 0)
                     setMask(szClClipLine);
               }
               else
               if (bClCtrl) {
                  copyScreenToClipboard();
               }
               else
                  setMask("");
               break;

            case VK_F2:
            {
               // move focus line up
               long nOldFocus = (long)(nClTopLine + nClTopFix);

               if (nClTopFixIdx > 0)
                  nClTopFixIdx--;
               nClTopFix = aClTopFix[nClTopFixIdx];

               long nNewFocus = (long)(nClTopLine + nClTopFix);
               long lDiff     = nNewFocus-nOldFocus;
               long lNewTop   = ((long)nClTopLine) - lDiff;
               if (lNewTop < 0)
                   nClTopLine = 0;
               else
               if (lNewTop < nClLines-5)
                   nClTopLine = lNewTop;

               updatePanel();
               update();
            }
               break;
               

            case VK_F3:
            {
               // move focus line down
               long nOldFocus = (long)(nClTopLine + nClTopFix);

               if (nClTopFixIdx < 2)
                  nClTopFixIdx++;
               nClTopFix = aClTopFix[nClTopFixIdx];

               long nNewFocus = (long)(nClTopLine + nClTopFix);
               long lDiff     = nNewFocus-nOldFocus;
               long lNewTop   = ((long)nClTopLine) - lDiff;
               if (lNewTop < 0)
                   nClTopLine = 0;
               else
               if (lNewTop < nClLines-5)
                   nClTopLine = lNewTop;

               updatePanel();
               update();
            }
               break;

            case VK_F4:
               bClCaseSearch ^= 0x1;
               setMaskModified();
               break;

            case VK_F7:
               extendMaskByClass();
               break;

            case VK_F5:
            {
               if (bGlblMinimized) {
                  for (ulong i=0; i<nGlblBrowsers; i++)
                     ShowWindow(apGlblBrowsers[i]->clWin, SW_RESTORE);
                  bGlblMinimized = 0;
               } else { 
                  for (ulong i=0; i<nGlblBrowsers; i++)
                     ShowWindow(apGlblBrowsers[i]->clWin, SW_MINIMIZE);
                  bGlblMinimized = 1;
               }
            }
               break;

            case VK_TAB:
               switch (nClTabSize) {
                  case 2: nClTabSize=3; break;
                  case 3: nClTabSize=4; break;
                  case 4: nClTabSize=8; break;
                  case 8: nClTabSize=2; break;
               }
               updatePanel();
               update();
               break;

            default:
               break;
         }
         if (nClTopLine != nOldTop) {
            mtklog("KEY: %u, new topline %u", nKey, nClTopLine);
            updatePanel();
            update();
         } else {
            mtklog("KEY: %u %x, no change", nKey, nKey);
            // return DefWindowProc(hWnd, message, wParam, lParam);
         }
      }
         break;

      case WM_CHAR:
      {
         UINT nChar = (TCHAR)wParam;
         mtklog("WM_CHAR.2 %x", nChar);
         // treat as free text, add to search mask
         if (nChar != VK_TAB)
            modifySearchMask(nChar);
      }
         break;

      case WM_MOUSEWHEEL:
      {        
         short zDelta = (short)HIWORD(wParam);
         // mtklog("WHEEL %d", zDelta);
         short nStep  = WHEEL_DELTA;
         nClWheel += zDelta;

         // calc currently displayed top and bottom lines
         long ymax = hchar ? nClPixHeight/hchar : BROW_MAX;
         long nTopLine = nClTopLine;
         long nBotLine = nClTopLine+ymax;
         if (nBotLine >= nClLines-1) nBotLine = nClLines ? nClLines-1:nClLines;

         if (nClWheel >= nStep)
         {
            nClWheel -= nStep;
            goPreviousMaskHit();
         }
         else
         if (nClWheel <= -nStep) 
         {
            nClWheel += nStep;
            goNextMaskHit();
         }
         return DefWindowProc(hWnd, message, wParam, lParam);
      }
         break;

      case WM_TIMER:
         handleTimer();
         break;

      case WM_ACTIVATE:
      {
         bool bOldActive = bClActive;
         UINT fActive = LOWORD(wParam);

         if (fActive == WA_INACTIVE)
         {
            bClActive = 0;
            if (bOldActive)
               update();
         }
         else
         {
            bClActive = 1;

            SetWindowPos(
               hWnd, HWND_TOPMOST,
               0,0,0,0,
               SWP_SHOWWINDOW|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE
               );
   
            if (bGlblMinimized) {
               bGlblMinimized = 0;
               for (ulong i=0; i<nGlblBrowsers; i++) {
                  HWND h2 = apGlblBrowsers[i]->clWin;
                  if (h2 != hWnd)
                     ShowWindow(h2, SW_RESTORE);
               }
            }

            if (!bOldActive)
               update();
         }
      }
         break;

      default:
         return DefWindowProc(hWnd, message, wParam, lParam);
   }

   return 0;
}

long fileSize(char *pszFile) {
   struct stat sinfo;
   if (stat(pszFile, &sinfo))
      return -1;
   return sinfo.st_size;
}

char *loadFile(char *pszFile, int nLine) 
{
   long lFileSize = fileSize(pszFile);
   if (lFileSize < 0)
      return 0;
   char *pOut = new char[lFileSize+10];
   // printf("loadFile %p %d\n", pOut, nLine);
   FILE *fin = fopen(pszFile, "rb");
   if (!fin) { fprintf(stderr, "error: cannot read: %s\n", pszFile); return 0; }
   long nRead = fread(pOut, 1, lFileSize, fin);
   fclose(fin);
   if (nRead != lFileSize) {
      fprintf(stderr, "error: cannot read: %s (%d %d)\n", pszFile, nRead, lFileSize);
      delete [] pOut;
      return 0;
   }
   pOut[lFileSize] = '\0';
   return pOut;
}

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
   MSG msg;
   HACCEL hAccelTable;

/*
HFONT CreateFont(
  int nHeight,             // logical height of font
  int nWidth,              // logical average character width

  int nEscapement,         // angle of escapement
  int nOrientation,        // base-line orientation angle
  int fnWeight,            // font weight

  DWORD fdwItalic,         // italic attribute flag
  DWORD fdwUnderline,      // underline attribute flag
  DWORD fdwStrikeOut,      // strikeout attribute flag
  DWORD fdwCharSet,        // character set identifier

  DWORD fdwOutputPrecision,  // output precision
  DWORD fdwClipPrecision,  // clipping precision
  DWORD fdwQuality,        // output quality
  DWORD fdwPitchAndFamily,  // pitch and family

  LPCTSTR lpszFace         // pointer to typeface name string
);
*/

   HWND hDesk = GetDesktopWindow();
   RECT rDesk;
   GetWindowRect(hDesk, &rDesk);
   nGlblDeskWidth  = rDesk.right-rDesk.left;
   nGlblDeskHeight = rDesk.bottom-rDesk.top;

   nGlblBaseX      = 20;
   nGlblBaseY      = 20;
   nGlblFullWidth  = nGlblDeskWidth-nGlblBaseX*2;
   nGlblThirdWidth = nGlblFullWidth/3;
   nGlblColHeight  = nGlblDeskHeight-140;

   glblFont = CreateFont(
      8, 0,
      0, 0, 0,
      0, 0, 0, 0, 
      0, 0, 0, 0, 
      "Fixedsys");

   // Initialize global strings
   // LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
   // LoadString(hInstance, IDC_XV, szWindowClass, MAX_LOADSTRING);

   MyRegisterClass(hInstance);

   // Perform application initialization:
   glblInstance = hInstance;
   glblCmdShow  = nCmdShow;
   if (!InitInstance (hInstance, nCmdShow)) 
   {
      MessageBox(0, "init#1", "error", MB_OK);
      return FALSE;
   }

   // load text

   if (!lpCmdLine || (strlen(lpCmdLine) < 1))
      { MessageBox(0, "supply a filename for reading:\nsview filename.txt", "error", MB_OK); return FALSE; }

   char *pszText = loadFile(lpCmdLine, __LINE__);
   if (!pszText) { MessageBox(0, "cannot load file", "error", MB_OK); return FALSE; }
   ulong nLines = 0;
   ulong i;
   for (i=0; pszText[i]; i++) {
      if (pszText[i] == '\n')
         nLines++;
   }

   char **apLineTab = new char*[nLines+10];
   memset(apLineTab, 0, sizeof(apLineTab));
   nLines = 0;
   char *psz1 = pszText;
   char *psz2 = psz1;
   while (*psz1)
   {
      if (*psz1 == '\n') {
         apLineTab[nLines++] = psz2;
         *psz1++ = '\0';
         psz2 = psz1;
      }
      else
      if (*psz1 == '\r')
         *psz1++ = ' '; // trick: allow easy search for expressions at line end
      else
         psz1++;
   }

   // check text format by header line
   // :snapfile sfk,1.0.7,lprefix=:file:
   // :cluster sfk,1.0.7,prefix=:
   bool bStdSnapFile = 0;
   bool bCluster = 0;
   char *pszHead = apLineTab[0];
   char szSnapPrefix[MAX_SNAPPRE_LEN+10];
   szSnapPrefix[0] = '\0';
   if (pszHead) 
   {
      char *pszPrefix = strstr(pszHead, ",lprefix=");
      if (pszPrefix) {
         // process snapfile prefix
         pszPrefix += strlen(",lprefix=");
         char *psz2 = pszPrefix;
         while (*psz2 && *psz2 != '\n' && *psz2 != ',')
            psz2++;
         long nLen = psz2 - pszPrefix;
         if (nLen > MAX_SNAPPRE_LEN) nLen = MAX_SNAPPRE_LEN;
         strncpy(szSnapPrefix, pszPrefix, nLen);
         szSnapPrefix[nLen] = '\0';
         bStdSnapFile = 1;
      }
      else
      if (!strncmp(pszHead, ":cluster sfk,", strlen(":cluster sfk,")))
      {
         pszPrefix = strstr(pszHead, ",prefix=");
         if (pszPrefix) {
            pszPrefix += strlen(",prefix=");
            char *psz2 = pszPrefix;
            while (*psz2 && *psz2 != '\n' && *psz2 != ',')
               psz2++;
            long nLen = psz2 - pszPrefix;
            if (nLen > MAX_SNAPPRE_LEN) nLen = MAX_SNAPPRE_LEN;
            strncpy(szSnapPrefix, pszPrefix, nLen);
            szSnapPrefix[nLen] = '\0';
            strcat(szSnapPrefix, "create ");
            bStdSnapFile = 1;
            bCluster = 1;
         }
      }
   }

   Browser b1;
   if (b1.create(0, 0, nGlblBaseX, nGlblBaseY, nGlblFullWidth, nGlblColHeight, apLineTab, nLines))
   {
      MessageBox(0, "unable to create view", "error", MB_OK);
      return FALSE;
   }
   b1.config(bStdSnapFile, bCluster, szSnapPrefix);
   b1.update();

   // hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_XV);

   // Main message loop:
   while (GetMessage(&msg, NULL, 0, 0)) 
   {
      // if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
      // {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
      // }
   }

   // cleanup
   delete [] apLineTab;
   delete [] pszText;

   #ifdef WITH_MEM_TRACE
   if (anyMemoryLeaks())
   {
      FILE *fmemlog = fopen("mem.log","w");
      long lRC = listMemoryLeaks(fmemlog);
      fclose(fmemlog);
      if (lRC) MessageBox(0, "memleak detected\nsee mem.log", "error", MB_OK|MB_TOPMOST);
   }
   #endif

   return msg.wParam;
}

void Browser::modifySearchMask(UINT nKey) 
{
   mtklog("modsm key %x", nKey);

   int nLen = strlen(szClMask);
   bool bDone = 0;

   switch (nKey) 
   {
      case VK_DELETE+1000: // messes up with "."
      {
         // remove at maskpos
         for (int i=iMaskPos; i<=nLen; i++)
            szClMask[i] = szClMask[i+1];
         bDone=1;
      }
         break;

      case VK_BACK:
      {
         // remove char at left, if any
         if (iMaskPos > 0) {
            iMaskPos--;
            for (int i=iMaskPos; i<=nLen; i++)
               szClMask[i] = szClMask[i+1];
            bDone=1;
         }
      }
         break;

      case VK_ESCAPE:
      case VK_RETURN:
         break;

      default:
      {
         if (nLen < MAX_LINE_LEN-2) 
         {
            // insert at maskpos
            for (int i=nLen; i>=iMaskPos; i--)
               szClMask[i+1] = szClMask[i];
            szClMask[iMaskPos] = (char)nKey;
            iMaskPos++;
            bDone=1;
         }
      }
         break;
   }

   if (bDone)
      setMaskModified();
}

void Browser::extendMaskByClass() 
{
   if (!strncmp(szClMask, "class ", strlen("class ")))
      return;
   sprintf(szClClassBuf, "class %s ", szClMask);
   strcpy(szClMask, szClClassBuf);
   iMaskPos = strlen("class ");
   setMaskModified();
}

void Browser::setMaskModified() 
{
   if (bClTimerSet)
      KillTimer(clWin, 1);
   SetTimer(clWin, 1, bClCaseSearch ? 600 : 800, 0);
   bClTimerSet = 1;
   // immediately show new (temporary) mask status
   nClMaskHits = 0;
   bClSearching   = 1;  // show "-" status
   nClSearchStart = getCurrentTime();
   nClSearchTime  = 0;
   updatePanel();
   update();
   // also update window title
   sprintf(szClTitleBuf, "%s", szClMask);
   SetWindowText(clWin, szClTitleBuf);
}

void Browser::handleTimer() {
   KillTimer(clWin, 1);
   bClTimerSet = 0;
   gotoFirstMaskHit();
}

void Browser::gotoFirstMaskHit()
{
   nClSearchStart = getCurrentTime();
   bClSearching   = 2;  // show animated status
   nClMaskHits = 0;
   updatePanel();
   update();

   // ulong nAnimThres = nClLines/5;

   prepareMask(szClMask);
   if (strlen(szClMask) > 0)
   for (ulong i=0; i<nClLines; i++)
   {
      if (matches(apClLines[i]))
      {
         nClMaskHits++;
         if (nClMaskHits == 1) {
            nCurSel = i;
            if (i > nClTopFix)
               nClTopLine = i-nClTopFix;
            else
            if (i > 3)
               nClTopLine = i-3;
            else
               nClTopLine = 0;
         }
         // else continue counting
      }
      // if (i > nAnimThres) {
      //    nAnimThres += nClLines/5;
      //    updatePanel();
      //    update();
      // }
   }
   bClSearching   = 0;
   nClSearchTime  = getCurrentTime()-nClSearchStart;
   nClSearchStart = 0;
   updatePanel();
   update();
}

void Browser::autoSelect(char *pszLine, ulong ncol)
{
_  szClSel[0] = '\0';
   ulong nLineLen = strlen(pszLine);
   if (ncol >= nLineLen)
      return;
 
   char *psz1 = pszLine+ncol;
   // search start and end of expression
   char *pszs = psz1;
   char *psze = psz1;
   for (; pszs > pszLine; pszs--) {
      char c = *pszs;
      if (isalnum(c) || c=='_')
         continue;
      else {
         pszs++;
         break;
      }
   }
   for (; *psze; psze++) {
      char c = *psze;
      if (isalnum(c) || c=='_')
         continue;
      else
         break;
   }
   int nLen = psze-pszs;
   if (nLen > 0) {
      if (nLen > MAX_LINE_LEN) nLen = MAX_LINE_LEN;
      strncpy(szClSel,pszs,nLen);
      szClSel[nLen] = '\0';
   }
   // doesn't change any display yet,
_  // we only set the szClSel field.
}

void Browser::toggleWidth() 
{
   if (nClPixWidth == nGlblThirdWidth) 
   {
      nClPixWidth = nGlblFullWidth;
      SetWindowPos(clWin, HWND_TOPMOST,
         nGlblBaseX,nClY,
         nClPixWidth,nClPixHeight,
         SWP_SHOWWINDOW|SWP_NOACTIVATE
         );
   }
   else 
   {
      nClPixWidth = nGlblThirdWidth;
      SetWindowPos(clWin, HWND_TOPMOST,
         nClX,nClY,
         nClPixWidth,nClPixHeight,
         SWP_SHOWWINDOW|SWP_NOACTIVATE
         );
   }
   updatePanel();
   update();
}

// uses: szClMaskBuf, also used in matches()
void Browser::prepareMask(char *pszMask)
{
   mtklog("prepareMask \"%s\"", pszMask);

   strncpy(szClMaskBuf, pszMask, MAX_LINE_LEN);
   pszMask = szClMaskBuf;

   memset(aClMask, 0, sizeof(aClMask));
   nClMask = 0;

   int nSubMaskSize = sizeof(aClMask[0])-2;
   
   // split class*FooBar*{ into 3 submasks
   char *psz1 = pszMask;
   while (*psz1) 
   {
      char *psz2 = psz1+1;
      while (*psz2 && *psz2 != '*')
         psz2++;
      if (*psz2 == '*') 
      {
         *psz2++ = '\0';
         strncpy(aClMask[nClMask], psz1, nSubMaskSize);
         if (!bClCaseSearch)
            setStringToLower(aClMask[nClMask]);
         mtklog(" submask %u \"%s\"", nClMask, aClMask[nClMask]);
         nClMask++;
      }
      else
      if (strlen(psz1))
      {
         strncpy(aClMask[nClMask], psz1, nSubMaskSize);
         if (!bClCaseSearch)
            setStringToLower(aClMask[nClMask]);
         mtklog(" submask %u \"%s\"", nClMask, aClMask[nClMask]);
         nClMask++;
      }
      psz1 = psz2;
   }
_
}

#ifdef OWN_TOLOWER
const char *pszGlblHi = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const char *pszGlblLo = "abcdefghijklmnopqrstuvwxyz";

void Browser::prepareToLower()
{
   for (ulong u1=0; u1<256; u1++)
   {
      uchar u2 = (uchar)u1;
      char *psz1 = strchr(pszGlblHi, (char)u1);
      if (psz1 != 0) {
         ulong i2 = psz1-pszGlblHi;
         if (i2 < strlen(pszGlblLo))
             u2   = pszGlblLo[i2];
      }
      aClLowerTab[u1] = (char)u2;
   }
}
#endif

void Browser::setStringToLower(char *psz)
{
   ulong nLen = strlen(psz);
   for (ulong i=0; i<nLen; i++) {
      #ifdef OWN_TOLOWER
      psz[i] = aClLowerTab[(uchar)psz[i]];
      #else
      psz[i] = tolower(psz[i]);
      #endif
   }
}

bool Browser::matches(char *pszLine, int *pIndex, int *pLen)
{
   // requires previous prepareMask run
   char *pszSubHitOld = 0;
   int nSubHitOldLen = 0;
   char *pszSubHit = 0;
   char *pszSubHitFirst = 0;
   int iHitIndex = -1;

   if (!bClCaseSearch)
   {
      // NOTE: this case-insensitive search is TEN TIMES slower
      //       then case-sensitive search. there may be much space
      //       for optimization.
      long nLen = strlen(pszLine);
      if (nLen > MAX_LINE_LEN) nLen = MAX_LINE_LEN;
      strncpy(szClMatchBuf, pszLine, nLen);
      szClMatchBuf[nLen] = '\0';
      setStringToLower(szClMatchBuf);
      pszLine = szClMatchBuf;
   }

   for (ulong i=0; i<nClMask; i++) 
   {
      char *pszSubMask = aClMask[i];

      pszSubHit = strstr(pszLine, pszSubMask);

      if (!pszSubHit)
         return false;

      if (iHitIndex == -1) {
         iHitIndex = pszSubHit-pszLine;
         pszSubHitFirst = pszSubHit;
      }

      // submasks must appear in correct sequence
      if (pszSubHitOld && (pszSubHit < pszSubHitOld))
         return false;

      pszSubHitOld = pszSubHit;
      nSubHitOldLen = strlen(pszSubMask);
   }

   int iHitLen = pszSubHitOld+nSubHitOldLen-pszSubHitFirst;

   mtklog("mask hitlen %u", iHitLen);

   if (pIndex) *pIndex = iHitIndex;
   if (pLen)   *pLen   = iHitLen;

   return true;
}

void Browser::calcTopAndBot(long &lrTop, long &lrBot)
{
   // calc currently displayed top and bottom lines
   long ymax = hchar ? nClPixHeight/hchar : BROW_MAX;
   long nTopLine = nClTopLine;
   long nBotLine = nClTopLine+ymax;
   if (nBotLine >= nClLines-1) nBotLine = nClLines ? nClLines-1:nClLines;
   lrTop = nTopLine;
   lrBot = nBotLine;
}

void Browser::goPreviousMaskHit() 
{
   long nTopLine,nBotLine;
   calcTopAndBot(nTopLine,nBotLine);

   // jump to previous mask hit
   prepareMask(szClMask);
  if (nCurSel > 0)
  {
   // is last selected line off screen?
   if (nCurSel > nBotLine)
       nCurSel = nBotLine;
   for (ulong i=nCurSel-1; i>0; i--) 
   {
      if (matches(apClLines[i])) 
      {
         nCurSel = i;
         if (i > nClTopFix)
            nClTopLine = i-nClTopFix;
         else
         if (i > 3)
            nClTopLine = i-3;
         else
            nClTopLine = 0;
         mtklog("WHEEL new topline %u sel %u msk \"%s\"", nClTopLine, nCurSel, szClMask);
         updatePanel();
         update();
         break;
      }
   }
  }
}

void Browser::goNextMaskHit() 
{
   long nTopLine,nBotLine;
   calcTopAndBot(nTopLine,nBotLine);

   // jump to next mask hit
   prepareMask(szClMask);
   // is last selected line off screen?
   if (nCurSel < nTopLine)
       nCurSel = nTopLine;
   for (ulong i=nCurSel+1; i<nClLines; i++) 
   {
      if (matches(apClLines[i])) 
      {
         nCurSel = i;
         if (i > nClTopFix)
            nClTopLine = i-nClTopFix;
         else
         if (i > 3)
            nClTopLine = i-3;
         else
            nClTopLine = 0;
         updatePanel();
         update();
         break;
      }
   }
}

void Browser::strippedLineToClip(char *psz)
{
   char szBuf[1024+10];
   strncpy(szBuf, psz, 1024);
   szBuf[1024] = '\0';
   while (szBuf[0] && szBuf[strlen(szBuf)-1]==' ')
      szBuf[strlen(szBuf)-1] = '\0'; // cut trailing blanks
   putClipboard(szBuf);
   sprintf(szClStatusLine, "clip: %.50s", szBuf);
   updatePanel();
   update();
}

void Browser::goLocalFileStart()
{
   // search local file start
   long i1;
   long nLen = strlen(szClSnapPrefix);
   for (i1 = nClTopLine; i1 >= 0; i1--)
      if (!strncmp(apClLines[i1], szClSnapPrefix, nLen))
         break;

   if (i1 >= 0)
   {
      i1++;
      if (i1 < nClLines) 
      {
         if (i1 > 2)
            nClTopLine = i1-2;
         else
            nClTopLine = i1;
      }
   }
}

void Browser::copyScreenToClipboard() 
{
   ulong ymax = BROW_MAX;
   if (hchar)
      ymax = nClPixHeight/hchar;

   // collect visible lines.
   char *pszTmp = new char[10000];
   if (!pszTmp) return;
   pszTmp[0] = '\0';
   ulong iout=0;
   for (long yrel=0; yrel<ymax; yrel++) 
   {
      ulong iLine = nClTopLine+yrel;
      if (iLine >= nClLines)
         break;
      char *psz = apClLines[iLine];
      ulong nLen = strlen(psz);
      if (iout+nLen < 10000-100) 
      {
         strcat(pszTmp, psz);
         strcat(pszTmp, "\r\n");
         iout = strlen(pszTmp);
      }
      else
         break;
   }
   putClipboard(pszTmp);
   delete [] pszTmp;

   sprintf(szClStatusLine, "clip: screen copy, %u bytes.", iout);
   updatePanel();
   update();
}

void Browser::closeRight()
{
   if (!pRight)
      return;

   if (apGlblBrowsers[nGlblBrowsers-1] == pRight)
   {
      // stop WinMsg processing
      pRight->destroy();

      // delete instance
      delete pRight;

      pRight = 0;
      apGlblBrowsers[nGlblBrowsers-1] = 0;
      nGlblBrowsers--;
   }

   activate();
}
